PROJECT SOURCE CODE LIBRARY
===========================
CONTAINS: Full Implementation Logic, Scene Trees, and Resource Data.
INSTRUCTION: This is the raw source code. Use this to answer specific implementation questions.
GENERATED: 2026-02-03T14:12:21
===========================


--------------------------------------------------
FILE: res:///KennyIsotowers.tscn
--------------------------------------------------
[gd_scene format=3 uid="uid://t8ucsyl57ta6"]

[node name="TileMapLayer" type="TileMapLayer"]


--------------------------------------------------
FILE: res:///addons/GodotAiSuite/godot_ai_suite.gd
--------------------------------------------------
# res://addons/GodotAiSuite/godot_ai_suite.gd

@tool
extends EditorPlugin

# --- UI Elements ---
var suite_container: HBoxContainer = HBoxContainer.new() # The main container for the toolbar UI
var settings_button: Button = Button.new()
var prompts_button: Button = Button.new() # Button for the prompt library
var export_button: Button = Button.new()
var settings_window: AcceptDialog = AcceptDialog.new()
var _prompt_library_instance: Window # The instance of our new scene

# --- Settings Window UI ---
var _tab_container: TabContainer
var include_system_prompt_button: CheckButton = CheckButton.new()
var include_gdd_button: CheckButton = CheckButton.new()
var include_devlog_button: CheckButton = CheckButton.new()
var include_project_settings_button: CheckButton = CheckButton.new()
var include_resources_button: CheckButton = CheckButton.new()
var include_scenes_button: CheckButton = CheckButton.new()
var include_code_button: CheckButton = CheckButton.new()
# New UI elements for exclusion trees
var _scene_exclusion_tree: Tree
var _script_exclusion_tree: Tree
var _total_tokens_label: Label

# --- Internal State for Token Counts ---
var _system_prompt_token_count: int = 0
var _gdd_token_count: int = 0
var _devlog_token_count: int = 0
var _project_settings_token_count: int = 0
var _resources_token_count: int = 0

# --- Constants ---
const PROMPT_LIBRARY_SCENE = preload("res://addons/GodotAiSuite/prompt_library/prompt_library.tscn")
const PROMPT_LIBRARY_ICON: Texture2D = preload("res://addons/GodotAiSuite/assets/prompt_library_icon.png")
const SYSTEM_PROMPT_FILE_PATH: String = "res://addons/GodotAiSuite/system_prompt.txt"
const DEVLOG_FILE_PATH: String = "res://addons/GodotAiSuite/DevLog.txt"
const GDD_FILE_PATH: String =  "res://addons/GodotAiSuite/GDD.txt"
const OUTPUT_FILE_PATH: String = "res://addons/GodotAiSuite/Masterprompt.txt"
const SETTINGS_FILE_PATH: String = "res://addons/GodotAiSuite/settings.cfg"
# Token Ratios
const TOKEN_RATIO_TEXT: float = 0.25   # For prose-like text (GDD, DevLog)
const TOKEN_RATIO_SCRIPT: float = 0.303 # For GDScript, C#, Shaders
const TOKEN_RATIO_SCENE: float = 0.4125 # For TSCN, TRES, and other structured data

# --- Add file paths here to exclude them from the export ---
const IGNORED_FILE_PATHS: Array[String] = [
	"res://addons/GodotAiSuite/godot_ai_suite.gd",
	"res://addons/GodotAiSuite/prompt_library/prompt_library.gd",
	"res://addons/GodotAiSuite/prompt_library/prompt_library.tscn"
	]
# --- Add property names here to exclude them from the scene export ---
const IGNORED_PROPERTIES: Array[String] = [
	"tile_map_data"
]


# --- EditorPlugin Overrides ---
func _enter_tree() -> void:
	# --- Create Toolbar UI ---
	var suite_label: Label = Label.new()
	suite_label.text = "Godot AI Suite:"
	suite_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER

	settings_button.icon = EditorInterface.get_editor_theme().get_icon("Tools", "EditorIcons")
	settings_button.tooltip_text = "Godot AI Suite Settings"
	settings_button.pressed.connect(_on_settings_button_pressed)

	prompts_button.icon = PROMPT_LIBRARY_ICON
	prompts_button.tooltip_text = "Prompt Library"
	prompts_button.pressed.connect(_on_prompts_button_pressed)
	
	export_button.text = "Generate Masterprompt"
	export_button.pressed.connect(_on_export_button_pressed)

	# Add all controls to the main container
	suite_container.add_child(suite_label)
	suite_container.add_child(VSeparator.new())
	suite_container.add_child(settings_button)
	suite_container.add_child(prompts_button)
	suite_container.add_child(export_button)
	
	add_control_to_container(CONTAINER_TOOLBAR, suite_container)

	_create_settings_window()
	
	# --- Instantiate Windows ---
	_prompt_library_instance = PROMPT_LIBRARY_SCENE.instantiate()
	get_editor_interface().get_base_control().add_child(_prompt_library_instance)
	
	_load_settings()


func _exit_tree() -> void:
	# Clean up the main container (which also frees its children)
	remove_control_from_container(CONTAINER_TOOLBAR, suite_container)
	suite_container.queue_free()
	
	# Clean up the windows
	if settings_window and is_instance_valid(settings_window):
		settings_window.queue_free()
	if _prompt_library_instance and is_instance_valid(_prompt_library_instance):
		_prompt_library_instance.queue_free()


# --- UI Creation ---
func _create_settings_window() -> void:
	settings_window.title = "Godot AI Suite Settings"
	settings_window.ok_button_text = "Close"
	settings_window.size = Vector2i(700, 500)
	
	var main_vbox: VBoxContainer = VBoxContainer.new()
	main_vbox.size_flags_vertical = Control.SIZE_EXPAND_FILL
	settings_window.add_child(main_vbox)

	_tab_container = TabContainer.new()
	_tab_container.size_flags_vertical = Control.SIZE_EXPAND_FILL
	main_vbox.add_child(_tab_container)
	
	# --- General Tab ---
	var general_vbox: VBoxContainer = VBoxContainer.new()
	general_vbox.add_theme_constant_override("separation", 10)
	general_vbox.set_h_size_flags(Control.SIZE_EXPAND_FILL)
	var general_margin: MarginContainer = MarginContainer.new()
	general_margin.name = "General"
	general_margin.add_theme_constant_override("margin_left", 10)
	general_margin.add_theme_constant_override("margin_top", 10)
	general_margin.add_theme_constant_override("margin_right", 10)
	general_margin.add_theme_constant_override("margin_bottom", 10)
	general_margin.add_child(general_vbox)
	_tab_container.add_child(general_margin)
	
	include_system_prompt_button.toggled.connect(_on_setting_changed)
	general_vbox.add_child(include_system_prompt_button)
	general_vbox.add_child(HSeparator.new())
	include_gdd_button.toggled.connect(_on_setting_changed)
	general_vbox.add_child(include_gdd_button)
	include_devlog_button.toggled.connect(_on_setting_changed)
	general_vbox.add_child(include_devlog_button)
	general_vbox.add_child(HSeparator.new())
	include_project_settings_button.toggled.connect(_on_setting_changed)
	general_vbox.add_child(include_project_settings_button)
	include_resources_button.toggled.connect(_on_setting_changed)
	general_vbox.add_child(include_resources_button)
	include_scenes_button.toggled.connect(_on_setting_changed)
	general_vbox.add_child(include_scenes_button)
	include_code_button.toggled.connect(_on_setting_changed)
	general_vbox.add_child(include_code_button)

	# --- Scene Exclusions Tab ---
	var scene_tab_result: Dictionary = _create_file_exclusion_tab("Scene Exclusions", ["tscn"])
	_scene_exclusion_tree = scene_tab_result.tree
	_tab_container.add_child(scene_tab_result.container)
	
	# --- Script Exclusions Tab ---
	var script_tab_result: Dictionary = _create_file_exclusion_tab("Script Exclusions", ["gd", "cs"])
	_script_exclusion_tree = script_tab_result.tree
	_tab_container.add_child(script_tab_result.container)
	
	# --- Total Tokens Label ---
	main_vbox.add_child(HSeparator.new())
	_total_tokens_label = Label.new()
	_total_tokens_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	var token_margin := MarginContainer.new()
	token_margin.add_theme_constant_override("margin_right", 10)
	token_margin.add_child(_total_tokens_label)
	main_vbox.add_child(token_margin)
	
	get_editor_interface().get_base_control().add_child(settings_window)
	
	_update_category_token_counts()


func _create_file_exclusion_tab(p_title: String, p_extensions: Array[String]) -> Dictionary:
	var vbox: VBoxContainer = VBoxContainer.new()
	
	var margin: MarginContainer = MarginContainer.new()
	margin.name = p_title
	margin.add_theme_constant_override("margin_left", 10)
	margin.add_theme_constant_override("margin_top", 10)
	margin.add_theme_constant_override("margin_right", 10)
	margin.add_theme_constant_override("margin_bottom", 10)
	margin.add_child(vbox)

	var hbox: HBoxContainer = HBoxContainer.new()
	var select_all_button: Button = Button.new()
	select_all_button.text = "Select All"
	var select_none_button: Button = Button.new()
	select_none_button.text = "Deselect All"
	hbox.add_child(select_all_button)
	hbox.add_child(select_none_button)
	vbox.add_child(hbox)
	
	var tree: Tree = Tree.new()
	tree.size_flags_vertical = Control.SIZE_EXPAND_FILL
	tree.hide_root = true
	tree.set_columns(1)
	tree.set_column_title(0, "File")
	tree.set_column_clip_content(0, true)
	vbox.add_child(tree)
	
	select_all_button.pressed.connect(_on_select_all_pressed.bind(tree))
	select_none_button.pressed.connect(_on_select_none_pressed.bind(tree))
	tree.item_edited.connect(_on_file_selection_changed)
	
	# Populate the tree with files matching the extensions
	_populate_file_tree(tree, p_extensions)

	return { "container": margin, "tree": tree }


func _populate_file_tree(p_tree: Tree, p_extensions: Array[String]) -> void:
	var root: TreeItem = p_tree.create_item()
	var files: Array = _find_files_by_extension(p_extensions)
	
	var valid_files: Array = files.filter(func(p): return not p in IGNORED_FILE_PATHS)

	for file_path in valid_files:
		var item: TreeItem = p_tree.create_item(root)
		item.set_cell_mode(0, TreeItem.CELL_MODE_CHECK)
		item.set_editable(0, true)
		item.set_checked(0, true)
		
		var file_content: String
		var ratio: float
		var extension: String = file_path.get_extension()
		
		if extension == "tscn":
			ratio = TOKEN_RATIO_SCENE
			var scene_res: Resource = load(file_path)
			if scene_res:
				var scene_node: Node = scene_res.instantiate()
				file_content = _get_node_data(scene_node, 0, scene_node)
				scene_node.free()
		else: # Script files
			ratio = TOKEN_RATIO_SCRIPT
			file_content = FileAccess.get_file_as_string(file_path)

		var token_count: int = _calculate_tokens(file_content.length(), ratio)
		
		item.set_text(0, "%s (~%d tokens)" % [file_path, token_count])
		item.set_metadata(0, { "path": file_path, "tokens": token_count })


# --- Signal Handlers ---
func _on_settings_button_pressed() -> void:
	settings_window.popup_centered()

func _on_prompts_button_pressed() -> void:
	if _prompt_library_instance:
		_prompt_library_instance.popup_library()

func _on_setting_changed(_is_toggled: bool) -> void:
	_save_settings()
	_update_ui_and_token_counts()
	
func _on_file_selection_changed() -> void:
	_save_settings()
	_update_ui_and_token_counts()

func _on_select_all_pressed(p_tree: Tree) -> void:
	_set_all_tree_items_checked(p_tree, true)

func _on_select_none_pressed(p_tree: Tree) -> void:
	_set_all_tree_items_checked(p_tree, false)
	
func _set_all_tree_items_checked(p_tree: Tree, p_checked: bool) -> void:
	var root: TreeItem = p_tree.get_root()
	if not root: return
	
	var item: TreeItem = root.get_first_child()
	while item:
		item.set_checked(0, p_checked)
		item = item.get_next()
	
	_save_settings()
	_update_ui_and_token_counts()

# --- Settings Persistence ---
func _save_settings() -> void:
	var config: ConfigFile = ConfigFile.new()
	config.set_value("General", "include_system_prompt", include_system_prompt_button.button_pressed)
	config.set_value("General", "include_gdd", include_gdd_button.button_pressed)
	config.set_value("General", "include_devlog", include_devlog_button.button_pressed)
	config.set_value("General", "include_project_settings", include_project_settings_button.button_pressed)
	config.set_value("General", "include_resources", include_resources_button.button_pressed)
	config.set_value("General", "include_scenes", include_scenes_button.button_pressed)
	config.set_value("General", "include_code", include_code_button.button_pressed)
	
	# Save exclusion lists
	config.set_value("Exclusions", "excluded_scenes", _get_excluded_files_from_tree(_scene_exclusion_tree))
	config.set_value("Exclusions", "excluded_scripts", _get_excluded_files_from_tree(_script_exclusion_tree))
	
	config.save(SETTINGS_FILE_PATH)

func _load_settings() -> void:
	var config: ConfigFile = ConfigFile.new()
	if config.load(SETTINGS_FILE_PATH) != OK:
		# If no config file, set all to default (true) and save
		include_system_prompt_button.button_pressed = true
		include_gdd_button.button_pressed = true
		include_devlog_button.button_pressed = true
		include_project_settings_button.button_pressed = true
		include_resources_button.button_pressed = true
		include_scenes_button.button_pressed = true
		include_code_button.button_pressed = true
		_save_settings()
	else:
		# Load from config file
		include_system_prompt_button.button_pressed = config.get_value("General", "include_system_prompt", true)
		include_gdd_button.button_pressed = config.get_value("General", "include_gdd", true)
		include_devlog_button.button_pressed = config.get_value("General", "include_devlog", true)
		include_project_settings_button.button_pressed = config.get_value("General", "include_project_settings", true)
		include_resources_button.button_pressed = config.get_value("General", "include_resources", true)
		include_scenes_button.button_pressed = config.get_value("General", "include_scenes", true)
		include_code_button.button_pressed = config.get_value("General", "include_code", true)

		# Load exclusion lists and apply them to the trees
		var excluded_scenes: Array[String] = config.get_value("Exclusions", "excluded_scenes", []) as Array[String]
		var excluded_scripts: Array[String] = config.get_value("Exclusions", "excluded_scripts", []) as Array[String]
		_apply_exclusions_to_tree(_scene_exclusion_tree, excluded_scenes)
		_apply_exclusions_to_tree(_script_exclusion_tree, excluded_scripts)

	_update_ui_and_token_counts()

func _apply_exclusions_to_tree(p_tree: Tree, p_exclusions: Array[String]) -> void:
	if not p_tree or p_exclusions.is_empty(): return
	var root: TreeItem = p_tree.get_root()
	if not root: return
	
	var item: TreeItem = root.get_first_child()
	while item:
		var metadata: Dictionary = item.get_metadata(0)
		if metadata.has("path") and metadata.path in p_exclusions:
			item.set_checked(0, false)
		item = item.get_next()


# --- Core Export Logic ---
func _on_export_button_pressed() -> void:
	# --- PREPARATION ---
	var heading_numbers: Dictionary = {}
	var main_heading_counter: int = 5 if include_system_prompt_button.button_pressed else 1
	var is_any_data_included: bool = (include_gdd_button.button_pressed and FileAccess.file_exists(GDD_FILE_PATH)) or \
								(include_devlog_button.button_pressed and FileAccess.file_exists(DEVLOG_FILE_PATH)) or \
								include_project_settings_button.button_pressed or \
								include_resources_button.button_pressed or \
								include_scenes_button.button_pressed or \
								include_code_button.button_pressed
	
	var excluded_files: Array[String] = _get_excluded_files_from_tree(_scene_exclusion_tree) + \
										_get_excluded_files_from_tree(_script_exclusion_tree)
	var final_ignored_paths: Array[String] = IGNORED_FILE_PATHS + excluded_files
	
	# --- PASS 1: PRE-CALCULATE ALL HEADING NUMBERS ---
	if is_any_data_included:
		heading_numbers["specification"] = str(main_heading_counter); main_heading_counter += 1

	if include_gdd_button.button_pressed and FileAccess.file_exists(GDD_FILE_PATH):
		heading_numbers["gdd"] = str(main_heading_counter); main_heading_counter += 1
	
	if include_devlog_button.button_pressed and FileAccess.file_exists(DEVLOG_FILE_PATH):
		heading_numbers["devlog"] = str(main_heading_counter); main_heading_counter += 1

	var is_project_context_included: bool = include_project_settings_button.button_pressed or \
									  include_resources_button.button_pressed or \
									  include_scenes_button.button_pressed or \
									  include_code_button.button_pressed

	if is_project_context_included:
		var project_context_number: int = main_heading_counter
		heading_numbers["project_context"] = str(project_context_number); main_heading_counter += 1
		var sub_heading_counter: int = 1
		
		if include_project_settings_button.button_pressed:
			heading_numbers["project_settings"] = "%d.%d" % [project_context_number, sub_heading_counter]; sub_heading_counter += 1
		if include_resources_button.button_pressed:
			heading_numbers["resources"] = "%d.%d" % [project_context_number, sub_heading_counter]; sub_heading_counter += 1
		if include_scenes_button.button_pressed:
			heading_numbers["scenes"] = "%d.%d" % [project_context_number, sub_heading_counter]; sub_heading_counter += 1
		if include_code_button.button_pressed:
			heading_numbers["code"] = "%d.%d" % [project_context_number, sub_heading_counter]; sub_heading_counter += 1

	if include_system_prompt_button.button_pressed:
		heading_numbers["initial_task"] = str(main_heading_counter)

	# --- PASS 2: GENERATE OUTPUT ---
	var output: String = ""
	
	if include_system_prompt_button.button_pressed:
		if not FileAccess.file_exists(SYSTEM_PROMPT_FILE_PATH):
			OS.alert("System prompt file not found! Please create a file at:\n%s" % SYSTEM_PROMPT_FILE_PATH, "Export Error"); return
		output += FileAccess.get_file_as_string(SYSTEM_PROMPT_FILE_PATH) + "\n"

	if is_any_data_included:
		var context_spec: String = "### **%s. Project Context Specification**\n\n" % heading_numbers.specification
		context_spec += "You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.\n\n"
		if heading_numbers.has("gdd"): context_spec += "*   **`%s. GDD`**: The Game Design Document.\n" % heading_numbers.gdd
		if heading_numbers.has("devlog"): context_spec += "*   **`%s. DevLog`**: A log of implemented features and changes.\n" % heading_numbers.devlog
		if heading_numbers.has("project_context"):
			context_spec += "*   **`%s. Project Context`**: The technical project dump, including:\n" % heading_numbers.project_context
			if heading_numbers.has("project_settings"): context_spec += "    *   `%s. Project Settings`\n" % heading_numbers.project_settings
			if heading_numbers.has("resources"): context_spec += "    *   `%s. Resource Files`\n" % heading_numbers.resources
			if heading_numbers.has("scenes"): context_spec += "    *   `%s. Scene Structures`\n" % heading_numbers.scenes
			if heading_numbers.has("code"): context_spec += "    *   `%s. Codebase`\n" % heading_numbers.code
		output += context_spec + "\n---\n"

	if include_gdd_button.button_pressed and heading_numbers.has("gdd"):
		output += "### **%s. GDD**\n\n" % heading_numbers.gdd
		output += FileAccess.get_file_as_string(GDD_FILE_PATH) + "\n---\n"

	if include_devlog_button.button_pressed and heading_numbers.has("devlog"):
		output += "### **%s. DevLog**\n\n" % heading_numbers.devlog
		output += FileAccess.get_file_as_string(DEVLOG_FILE_PATH) + "\n---\n"

	if is_project_context_included:
		var main_scene_path: String = ProjectSettings.get_setting("application/run/main_scene")
		if main_scene_path.is_empty(): OS.alert("No main scene configured in Project Settings.", "Export Error"); return
		
		output += "### **%s. Project Context**\n\n" % heading_numbers.project_context
		
		if include_project_settings_button.button_pressed and heading_numbers.has("project_settings"):
			output += "#### **%s. Project Settings**\n\n" % heading_numbers.project_settings
			output += "--- START OF PROJECT SETTINGS ---\n" + FileAccess.get_file_as_string("res://project.godot").rstrip(" \n") + "\n--- END OF PROJECT SETTINGS ---\n\n"
		
		if include_resources_button.button_pressed and heading_numbers.has("resources"):
			output += "#### **%s. Resource Files**\n\n" % heading_numbers.resources
			var files: Array = _find_files_by_extension(["tres", "gdshader"])
			var blocks: Array = files.filter(func(p): return not p in final_ignored_paths).map(func(p): return "--- RESOURCE: %s ---\n" % p + FileAccess.get_file_as_string(p).rstrip(" \n"))
			output += "--- START OF RESOURCE FILES ---\n" + "\n\n".join(blocks) + ("\n" if not blocks.is_empty() else "") + "--- END OF RESOURCE FILES ---\n\n"

		if include_scenes_button.button_pressed and heading_numbers.has("scenes"):
			output += "#### **%s. Scene Structures**\n\n" % heading_numbers.scenes
			var files: Array = _find_files_by_extension(["tscn"])
			var blocks: Array = []
			for file_path in files.filter(func(p): return not p in final_ignored_paths):
				var block: String = "--- SCENE: %s ---\n" % file_path
				var scene_res: Resource = load(file_path)
				if scene_res: var scene_node: Node = scene_res.instantiate(); block += _get_node_data(scene_node, 0, scene_node).rstrip(" \n"); scene_node.free()
				blocks.append(block)
			output += "--- START OF SCENE STRUCTURES ---\n" + "\n\n".join(blocks) + ("\n" if not blocks.is_empty() else "") + "--- END OF SCENE STRUCTURES ---\n\n"
			
		if include_code_button.button_pressed and heading_numbers.has("code"):
			output += "#### **%s. Codebase**\n\n" % heading_numbers.code
			var files: Array = _find_files_by_extension(["gd", "cs"])
			var blocks: Array = files.filter(func(p): return not p in final_ignored_paths).map(func(p): return "--- SCRIPT: %s ---\n" % p + FileAccess.get_file_as_string(p).rstrip(" \n"))
			output += "--- START OF CODEBASE ---\n" + "\n\n".join(blocks) + ("\n" if not blocks.is_empty() else "") + "--- END OF CODEBASE ---\n"

		if output.ends_with("\n---\n"): pass
		else: output += "\n---\n"

	if include_system_prompt_button.button_pressed and heading_numbers.has("initial_task"):
		output += "\n### **%s. Initial Task**\n" % heading_numbers.initial_task
		output += "Your first and most important task is to ingest and fully understand all project information contained in this prompt and the subsequent data dump. Once you have processed everything, confirm with a simple message that you understand the project's current state and are ready for development tasks\n"

	var file: FileAccess = FileAccess.open(OUTPUT_FILE_PATH, FileAccess.WRITE)
	if file:
		file.store_string(output.lstrip("\n"))
		file.close()
		var dialog: ConfirmationDialog = ConfirmationDialog.new(); dialog.title = "Export Successful"; dialog.dialog_text = "Project context exported to:\n%s" % OUTPUT_FILE_PATH; dialog.ok_button_text = "Open Folder"; dialog.get_cancel_button().text = "Close"
		dialog.confirmed.connect(_open_output_folder); dialog.confirmed.connect(dialog.queue_free); dialog.canceled.connect(dialog.queue_free)
		get_editor_interface().get_base_control().add_child(dialog)
		dialog.popup_centered()
	else:
		OS.alert("Failed to open file for writing at %s." % OUTPUT_FILE_PATH, "Export Error")

# --- Helper Functions ---
func _open_output_folder() -> void:
	var absolute_file_path: String = ProjectSettings.globalize_path(OUTPUT_FILE_PATH)
	OS.shell_show_in_file_manager(absolute_file_path)

func _calculate_tokens(p_content_length: int, p_ratio: float) -> int:
	return ceili(float(p_content_length) * p_ratio)

func _update_category_token_counts() -> void:
	# System Prompt
	if FileAccess.file_exists(SYSTEM_PROMPT_FILE_PATH):
		_system_prompt_token_count = _calculate_tokens(FileAccess.get_file_as_string(SYSTEM_PROMPT_FILE_PATH).length(), TOKEN_RATIO_TEXT)

	# GDD
	if FileAccess.file_exists(GDD_FILE_PATH):
		_gdd_token_count = _calculate_tokens(FileAccess.get_file_as_string(GDD_FILE_PATH).length(), TOKEN_RATIO_TEXT)
	include_gdd_button.text = "Include GDD.txt (~%d tokens)" % _gdd_token_count

	# DevLog
	if FileAccess.file_exists(DEVLOG_FILE_PATH):
		_devlog_token_count = _calculate_tokens(FileAccess.get_file_as_string(DEVLOG_FILE_PATH).length(), TOKEN_RATIO_TEXT)
	include_devlog_button.text = "Include DevLog.txt (~%d tokens)" % _devlog_token_count

	# Project Settings
	if FileAccess.file_exists("res://project.godot"):
		_project_settings_token_count = _calculate_tokens(FileAccess.get_file_as_string("res://project.godot").length(), TOKEN_RATIO_SCENE)
	include_project_settings_button.text = "Include Project Settings (~%d tokens)" % _project_settings_token_count
	
	# Resources
	_resources_token_count = 0
	var resource_files: Array = _find_files_by_extension(["tres", "gdshader"])
	for file_path in resource_files:
		var ratio: float = TOKEN_RATIO_SCRIPT if file_path.get_extension() == "gdshader" else TOKEN_RATIO_SCENE
		var content_length: int = FileAccess.get_file_as_string(file_path).length()
		_resources_token_count += _calculate_tokens(content_length, ratio)
	include_resources_button.text = "Include Resource Files (.tres, .gdshader) (~%d tokens)" % _resources_token_count
	
func _get_excluded_files_from_tree(p_tree: Tree) -> Array[String]:
	var excluded_files: Array[String] = []
	if not p_tree: return excluded_files
	
	var root: TreeItem = p_tree.get_root()
	if not root: return excluded_files

	var item: TreeItem = root.get_first_child()
	while item:
		if not item.is_checked(0):
			var metadata: Dictionary = item.get_metadata(0)
			if metadata.has("path"):
				excluded_files.append(metadata.path)
		item = item.get_next()
	return excluded_files

func _update_ui_and_token_counts() -> void:
	if not is_instance_valid(_total_tokens_label): return
		
	# Update Scene and Codebase labels on the General tab
	var selected_scene_tokens: int = _get_checked_token_sum_from_tree(_scene_exclusion_tree)
	var excluded_scene_count: int = _get_unchecked_item_count_from_tree(_scene_exclusion_tree)
	var scene_label: String = "Include Scene Structures (.tscn) (~%d tokens selected" % selected_scene_tokens
	if excluded_scene_count > 0:
		scene_label += ", %d files excluded)" % excluded_scene_count
	else:
		scene_label += ")"
	include_scenes_button.text = scene_label
	
	var selected_code_tokens: int = _get_checked_token_sum_from_tree(_script_exclusion_tree)
	var excluded_code_count: int = _get_unchecked_item_count_from_tree(_script_exclusion_tree)
	var code_label: String = "Include Codebase (.gd, .cs) (~%d tokens selected" % selected_code_tokens
	if excluded_code_count > 0:
		code_label += ", %d files excluded)" % excluded_code_count
	else:
		code_label += ")"
	include_code_button.text = code_label
	
	# Update System Prompt label
	include_system_prompt_button.text = "Include System Prompt (~%d tokens)" % _system_prompt_token_count

	# Disable/Enable tabs
	_tab_container.set_tab_disabled(1, not include_scenes_button.button_pressed) # Scene tab is at index 1
	_tab_container.set_tab_disabled(2, not include_code_button.button_pressed)   # Code tab is at index 2
	
	# Calculate grand total
	var total_tokens: int = 0
	if include_system_prompt_button.button_pressed: total_tokens += _system_prompt_token_count
	if include_gdd_button.button_pressed: total_tokens += _gdd_token_count
	if include_devlog_button.button_pressed: total_tokens += _devlog_token_count
	if include_project_settings_button.button_pressed: total_tokens += _project_settings_token_count
	if include_resources_button.button_pressed: total_tokens += _resources_token_count
	if include_scenes_button.button_pressed: total_tokens += selected_scene_tokens
	if include_code_button.button_pressed: total_tokens += selected_code_tokens
	
	_total_tokens_label.text = "Estimated Final Export Tokens: ~%d" % total_tokens

func _get_checked_token_sum_from_tree(p_tree: Tree) -> int:
	var token_sum: int = 0
	if not p_tree: return token_sum
	
	var root: TreeItem = p_tree.get_root()
	if not root: return token_sum

	var item: TreeItem = root.get_first_child()
	while item:
		if item.is_checked(0):
			var metadata: Dictionary = item.get_metadata(0)
			if metadata.has("tokens"):
				token_sum += metadata.tokens
		item = item.get_next()
	return token_sum

func _get_unchecked_item_count_from_tree(p_tree: Tree) -> int:
	var count: int = 0
	if not p_tree: return count
	
	var root: TreeItem = p_tree.get_root()
	if not root: return count

	var item: TreeItem = root.get_first_child()
	while item:
		if not item.is_checked(0):
			count += 1
		item = item.get_next()
	return count

func _find_files_by_extension(extensions: Array) -> Array:
	var files: Array = []
	var dir: DirAccess = DirAccess.open("res://")
	if dir:
		dir.list_dir_begin()
		var file_name: String = dir.get_next()
		while file_name != "":
			if dir.current_is_dir() and file_name != "." and file_name != ".." and file_name != ".godot": _recursive_find(dir.get_current_dir().path_join(file_name), extensions, files)
			elif not dir.current_is_dir():
				for ext in extensions:
					if file_name.ends_with("." + ext): files.append(dir.get_current_dir().path_join(file_name))
			file_name = dir.get_next()
	return files

func _recursive_find(path: String, extensions: Array, files: Array) -> void:
	var dir: DirAccess = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name: String = dir.get_next()
		while file_name != "":
			if dir.current_is_dir() and file_name != "." and file_name != "..": _recursive_find(path.path_join(file_name), extensions, files)
			elif not dir.current_is_dir():
				for ext in extensions:
					if file_name.ends_with("." + ext): files.append(path.path_join(file_name))
			file_name = dir.get_next()

func _value_to_string(value) -> String:
	if value is String: return '"' + value.c_escape() + '"'
	if value is Resource:
		if value.resource_path.is_empty() and not value.resource_name.is_empty():
			var scene_path: String = "res://<UNKNOWN>"
			if get_tree() and get_tree().edited_scene_root: scene_path = get_tree().edited_scene_root.scene_file_path
			return "%s::%s" % [scene_path, value.resource_name]
		return value.resource_path
	if value is Dictionary or value is Array: return JSON.stringify(value, "", false)
	return str(value)

func _get_node_data(node: Node, indent_level: int, scene_root: Node) -> String:
	var indent_str: String = ""
	if indent_level > 0: indent_str = "> " + "  ".repeat(indent_level - 1)
	var node_info: String = "%s%s (%s)\n" % [indent_str, node.name, node.get_class()]
	var details_indent: String = "> " + "  ".repeat(indent_level)
	if node.get_script() and node.get_script() is Script:
		var script_path: String = node.get_script().get_path()
		if not script_path.is_empty(): node_info += "%sscript: %s\n" % [details_indent, script_path]
	if not node.scene_file_path.is_empty(): node_info += "%sscene: %s\n" % [details_indent, node.scene_file_path]
	var groups: Array = node.get_groups()
	if not groups.is_empty(): node_info += "%sgroups = %s\n" % [details_indent, str(groups)]
	var prop_info: String = ""
	var default_node: Node = ClassDB.instantiate(node.get_class())
	if default_node:
		for prop in node.get_property_list():
			var prop_name: String = prop.name
			if not (prop.usage & PROPERTY_USAGE_STORAGE): continue
			if prop_name.begins_with("script") or prop_name.contains("/") or prop_name.begins_with("editable_children"): continue
			if prop_name in IGNORED_PROPERTIES: continue
			var current_value = node.get(prop_name)
			var default_value = default_node.get(prop_name)
			if not _are_values_equal(current_value, default_value):
				var prop_value_str: String = _value_to_string(current_value)
				prop_info += "%s> %s = %s\n" % [indent_str, prop_name, prop_value_str]
		default_node.free()
	node_info += prop_info
	for child in node.get_children(): node_info += _get_node_data(child, indent_level + 1, scene_root)
	return node_info

func _are_values_equal(a, b) -> bool:
	if typeof(a) != typeof(b):
		if (typeof(a) == TYPE_INT and typeof(b) == TYPE_FLOAT) or (typeof(a) == TYPE_FLOAT and typeof(b) == TYPE_INT):
			return is_equal_approx(float(a), float(b))
		return false
	if a is float: return is_equal_approx(a, b)
	if a is Vector2 or a is Vector3 or a is Color: return a.is_equal_approx(b)
	if a is Resource and b is Resource:
		if a.resource_path.is_empty() or b.resource_path.is_empty(): return a == b
		return a.resource_path == b.resource_path
	return a == b


--------------------------------------------------
FILE: res:///addons/GodotAiSuite/prompt_library/prompt_library.gd
--------------------------------------------------
@tool
extends Window

# --- Constants ---
const PROMPT_LIBRARY_FILE_PATH: String = "res://addons/GodotAiSuite/prompt_library/prompts.json"

# --- UI Node References ---
@onready var _search_bar: LineEdit = $MarginContainer/HSplitContainer/VBoxContainer/SearchBar
@onready var _prompt_tree: Tree = $MarginContainer/HSplitContainer/VBoxContainer/PromptTree
@onready var _title_label: Label = $MarginContainer/HSplitContainer/VBoxContainer2/TitleLabel
@onready var _description_label: Label = $MarginContainer/HSplitContainer/VBoxContainer2/DescriptionLabel
@onready var _prompt_text: TextEdit = $MarginContainer/HSplitContainer/VBoxContainer2/PromptText
@onready var _copy_button: Button = $MarginContainer/HSplitContainer/VBoxContainer2/HBoxContainer/CopyButton
@onready var _copy_feedback_label: Label = $MarginContainer/HSplitContainer/VBoxContainer2/HBoxContainer/CopyFeedbackLabel

# --- Internal State ---
var _prompts_data: Array = []
var _tree_category_items: Dictionary = {}


func _ready() -> void:
	# Connect signals via code, as per project standards
	close_requested.connect(hide)
	_search_bar.text_changed.connect(_on_search_changed)
	_prompt_tree.item_selected.connect(_on_tree_selected)
	_copy_button.pressed.connect(_on_copy_pressed)
	
	_load_and_populate_tree()


# --- Public Methods ---
func popup_library() -> void:
	# This method is called from the main plugin script to show the window.
	popup()


# --- Signal Handlers ---
func _on_search_changed(new_text: String) -> void:
	_filter_tree(new_text)


func _on_tree_selected() -> void:
	var selected_item: TreeItem = _prompt_tree.get_selected()
	if not selected_item:
		return

	# Check if the selected item is a prompt (has metadata) or a category (no metadata)
	var prompt_index = selected_item.get_metadata(0)
	if prompt_index is int:
		var prompt_data: Dictionary = _prompts_data[prompt_index]
		_title_label.text = prompt_data.get("title", "Untitled")
		_description_label.text = prompt_data.get("description", "")

		var prompt_path: String = prompt_data.get("prompt_file", "")
		if not prompt_path.is_empty() and FileAccess.file_exists(prompt_path):
			var file: FileAccess = FileAccess.open(prompt_path, FileAccess.READ)
			_prompt_text.text = file.get_as_text()
		else:
			_prompt_text.text = "Error: Prompt file not found at path:\n" + prompt_path
		
		_copy_button.disabled = false
	else:
		# It's a category, clear the view
		_title_label.text = "Select a prompt from the list"
		_description_label.text = "Select a prompt to see its description."
		_prompt_text.text = ""
		_copy_button.disabled = true


func _on_copy_pressed() -> void:
	DisplayServer.clipboard_set(_prompt_text.text)
	
	# Show "Copied!" feedback
	_copy_feedback_label.modulate.a = 1.0
	var tween: Tween = create_tween()
	tween.tween_property(_copy_feedback_label, "modulate:a", 0.0, 1.0).set_delay(1.5)


# --- Internal Logic ---
func _load_and_populate_tree() -> void:
	if not FileAccess.file_exists(PROMPT_LIBRARY_FILE_PATH):
		push_warning("Godot AI Suite: prompts.json not found.")
		return

	var file: FileAccess = FileAccess.open(PROMPT_LIBRARY_FILE_PATH, FileAccess.READ)
	var content: String = file.get_as_text()
	var json: JSON = JSON.new()
	var error: Error = json.parse(content)
	if error != OK:
		push_error("Godot AI Suite: Failed to parse prompts.json. Error %s" % json.get_error_message())
		return
	
	_prompts_data = json.data
	
	_prompt_tree.clear()
	_tree_category_items.clear()
	var root: TreeItem = _prompt_tree.create_item()

	for i in range(_prompts_data.size()):
		var prompt: Dictionary = _prompts_data[i]
		var category_name: String = prompt.get("category", "Uncategorized")
		var title: String = prompt.get("title", "Untitled Prompt")

		var category_item: TreeItem
		if not _tree_category_items.has(category_name):
			category_item = _prompt_tree.create_item(root)
			category_item.set_text(0, category_name)
			_tree_category_items[category_name] = category_item
		else:
			category_item = _tree_category_items[category_name]

		var prompt_item: TreeItem = _prompt_tree.create_item(category_item)
		prompt_item.set_text(0, title)
		prompt_item.set_metadata(0, i) # Store the index of the prompt in our data array


func _filter_tree(query: String) -> void:
	query = query.strip_edges().to_lower()
	var root: TreeItem = _prompt_tree.get_root()
	if not root:
		return
	
	var category_item: TreeItem = root.get_first_child()
	while category_item:
		var category_visible: bool = false
		var prompt_item: TreeItem = category_item.get_first_child()
		while prompt_item:
			var title: String = prompt_item.get_text(0).to_lower()
			var prompt_visible: bool = query.is_empty() or title.contains(query)
			prompt_item.set_visible(prompt_visible)
			if prompt_visible:
				category_visible = true
			prompt_item = prompt_item.get_next()
			
		category_item.set_visible(category_visible)
		category_item = category_item.get_next()


--------------------------------------------------
FILE: res:///addons/GodotAiSuite/prompt_library/prompt_library.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://c7cv3rc7708bq"]

[sub_resource type="GDScript" id="GDScript_k7vry"]
script/source = "@tool
extends Window

# --- Constants ---
const PROMPT_LIBRARY_FILE_PATH: String = \"res://addons/GodotAiSuite/prompt_library/prompts.json\"

# --- UI Node References ---
@onready var _search_bar: LineEdit = $MarginContainer/HSplitContainer/VBoxContainer/SearchBar
@onready var _prompt_tree: Tree = $MarginContainer/HSplitContainer/VBoxContainer/PromptTree
@onready var _title_label: Label = $MarginContainer/HSplitContainer/VBoxContainer2/TitleLabel
@onready var _description_label: Label = $MarginContainer/HSplitContainer/VBoxContainer2/DescriptionLabel
@onready var _prompt_text: TextEdit = $MarginContainer/HSplitContainer/VBoxContainer2/PromptText
@onready var _copy_button: Button = $MarginContainer/HSplitContainer/VBoxContainer2/HBoxContainer/CopyButton
@onready var _copy_feedback_label: Label = $MarginContainer/HSplitContainer/VBoxContainer2/HBoxContainer/CopyFeedbackLabel

# --- Internal State ---
var _prompts_data: Array = []
var _tree_category_items: Dictionary = {}


func _ready() -> void:
	# Connect signals via code, as per project standards
	close_requested.connect(hide)
	_search_bar.text_changed.connect(_on_search_changed)
	_prompt_tree.item_selected.connect(_on_tree_selected)
	_copy_button.pressed.connect(_on_copy_pressed)
	
	_load_and_populate_tree()


# --- Public Methods ---
func popup_library() -> void:
	# This method is called from the main plugin script to show the window.
	popup()


# --- Signal Handlers ---
func _on_search_changed(new_text: String) -> void:
	_filter_tree(new_text)


func _on_tree_selected() -> void:
	var selected_item: TreeItem = _prompt_tree.get_selected()
	if not selected_item:
		return

	# Check if the selected item is a prompt (has metadata) or a category (no metadata)
	var prompt_index = selected_item.get_metadata(0)
	if prompt_index is int:
		var prompt_data: Dictionary = _prompts_data[prompt_index]
		_title_label.text = prompt_data.get(\"title\", \"Untitled\")
		_description_label.text = prompt_data.get(\"description\", \"\")

		var prompt_path: String = prompt_data.get(\"prompt_file\", \"\")
		if not prompt_path.is_empty() and FileAccess.file_exists(prompt_path):
			var file: FileAccess = FileAccess.open(prompt_path, FileAccess.READ)
			_prompt_text.text = file.get_as_text()
		else:
			_prompt_text.text = \"Error: Prompt file not found at path:\\n\" + prompt_path
		
		_copy_button.disabled = false
	else:
		# It's a category, clear the view
		_title_label.text = \"Select a prompt from the list\"
		_description_label.text = \"Select a prompt to see its description.\"
		_prompt_text.text = \"\"
		_copy_button.disabled = true


func _on_copy_pressed() -> void:
	DisplayServer.clipboard_set(_prompt_text.text)
	
	# Show \"Copied!\" feedback
	_copy_feedback_label.modulate.a = 1.0
	var tween: Tween = create_tween()
	tween.tween_property(_copy_feedback_label, \"modulate:a\", 0.0, 1.0).set_delay(1.5)


# --- Internal Logic ---
func _load_and_populate_tree() -> void:
	if not FileAccess.file_exists(PROMPT_LIBRARY_FILE_PATH):
		push_warning(\"Godot AI Suite: prompts.json not found.\")
		return

	var file: FileAccess = FileAccess.open(PROMPT_LIBRARY_FILE_PATH, FileAccess.READ)
	var content: String = file.get_as_text()
	var json: JSON = JSON.new()
	var error: Error = json.parse(content)
	if error != OK:
		push_error(\"Godot AI Suite: Failed to parse prompts.json. Error %s\" % json.get_error_message())
		return
	
	_prompts_data = json.data
	
	_prompt_tree.clear()
	_tree_category_items.clear()
	var root: TreeItem = _prompt_tree.create_item()

	for i in range(_prompts_data.size()):
		var prompt: Dictionary = _prompts_data[i]
		var category_name: String = prompt.get(\"category\", \"Uncategorized\")
		var title: String = prompt.get(\"title\", \"Untitled Prompt\")

		var category_item: TreeItem
		if not _tree_category_items.has(category_name):
			category_item = _prompt_tree.create_item(root)
			category_item.set_text(0, category_name)
			_tree_category_items[category_name] = category_item
		else:
			category_item = _tree_category_items[category_name]

		var prompt_item: TreeItem = _prompt_tree.create_item(category_item)
		prompt_item.set_text(0, title)
		prompt_item.set_metadata(0, i) # Store the index of the prompt in our data array


func _filter_tree(query: String) -> void:
	query = query.strip_edges().to_lower()
	var root: TreeItem = _prompt_tree.get_root()
	if not root:
		return
	
	var category_item: TreeItem = root.get_first_child()
	while category_item:
		var category_visible: bool = false
		var prompt_item: TreeItem = category_item.get_first_child()
		while prompt_item:
			var title: String = prompt_item.get_text(0).to_lower()
			var prompt_visible: bool = query.is_empty() or title.contains(query)
			prompt_item.set_visible(prompt_visible)
			if prompt_visible:
				category_visible = true
			prompt_item = prompt_item.get_next()
			
		category_item.set_visible(category_visible)
		category_item = category_item.get_next()
"

[node name="PromptLibrary" type="Window"]
title = "Prompt Library"
initial_position = 5
size = Vector2i(800, 500)
visible = false
script = SubResource("GDScript_k7vry")

[node name="MarginContainer" type="MarginContainer" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="HSplitContainer" type="HSplitContainer" parent="MarginContainer"]
layout_mode = 2
split_offset = 300

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer/HSplitContainer"]
layout_mode = 2

[node name="SearchBar" type="LineEdit" parent="MarginContainer/HSplitContainer/VBoxContainer"]
layout_mode = 2
placeholder_text = "Seach prompts..."

[node name="PromptTree" type="Tree" parent="MarginContainer/HSplitContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="VBoxContainer2" type="VBoxContainer" parent="MarginContainer/HSplitContainer"]
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MarginContainer/HSplitContainer/VBoxContainer2"]
custom_minimum_size = Vector2(0, 10)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Select a prompt from the list"
autowrap_mode = 2

[node name="DescriptionLabel" type="Label" parent="MarginContainer/HSplitContainer/VBoxContainer2"]
custom_minimum_size = Vector2(0, 10)
layout_mode = 2
text = "Select a prompt from the list"
autowrap_mode = 3

[node name="HBoxContainer" type="HBoxContainer" parent="MarginContainer/HSplitContainer/VBoxContainer2"]
layout_mode = 2

[node name="CopyButton" type="Button" parent="MarginContainer/HSplitContainer/VBoxContainer2/HBoxContainer"]
layout_mode = 2
disabled = true
text = "Copy prompt to clipboard"

[node name="CopyFeedbackLabel" type="Label" parent="MarginContainer/HSplitContainer/VBoxContainer2/HBoxContainer"]
modulate = Color(1, 1, 1, 0)
layout_mode = 2
text = "Copied!"

[node name="PromptText" type="TextEdit" parent="MarginContainer/HSplitContainer/VBoxContainer2"]
layout_mode = 2
size_flags_vertical = 3


--------------------------------------------------
FILE: res:///addons/gut/GutScene.gd
--------------------------------------------------
extends Node2D
# ##############################################################################
# This is a wrapper around the normal and compact gui controls and serves as
# the interface between gut.gd and the gui.  The GutRunner creates an instance
# of this and then this takes care of managing the different GUI controls.
# ##############################################################################
@onready var _normal_gui = $Normal
@onready var _compact_gui = $Compact

var gut = null :
	set(val):
		gut = val
		_set_gut(val)


func _ready():
	_normal_gui.switch_modes.connect(use_compact_mode.bind(true))
	_compact_gui.switch_modes.connect(use_compact_mode.bind(false))

	_normal_gui.set_title("GUT")
	_compact_gui.set_title("GUT")

	_normal_gui.align_right()
	_compact_gui.to_bottom_right()

	use_compact_mode(false)

	if(get_parent() == get_tree().root):
		_test_running_setup()

func _test_running_setup():
	set_font_size(100)
	_normal_gui.get_textbox().text = "hello world, how are you doing?"

# ------------------------
# Private
# ------------------------
func _set_gut(val):
	if(_normal_gui.get_gut() == val):
		return
	_normal_gui.set_gut(val)
	_compact_gui.set_gut(val)

	val.start_run.connect(_on_gut_start_run)
	val.end_run.connect(_on_gut_end_run)
	val.start_pause_before_teardown.connect(_on_gut_pause)
	val.end_pause_before_teardown.connect(_on_pause_end)

func _set_both_titles(text):
	_normal_gui.set_title(text)
	_compact_gui.set_title(text)


# ------------------------
# Events
# ------------------------
func _on_gut_start_run():
	_set_both_titles('Running')

func _on_gut_end_run():
	_set_both_titles('Finished')

func _on_gut_pause():
	_set_both_titles('-- Paused --')

func _on_pause_end():
	_set_both_titles('Running')


# ------------------------
# Public
# ------------------------
func get_textbox():
	return _normal_gui.get_textbox()


func set_font_size(new_size):
	var rtl = _normal_gui.get_textbox()

	rtl.set('theme_override_font_sizes/bold_italics_font_size', new_size)
	rtl.set('theme_override_font_sizes/bold_font_size', new_size)
	rtl.set('theme_override_font_sizes/italics_font_size', new_size)
	rtl.set('theme_override_font_sizes/normal_font_size', new_size)


func set_font(font_name):
	_set_all_fonts_in_rtl(_normal_gui.get_textbox(), font_name)


func _set_font(rtl, font_name, custom_name):
	if(font_name == null):
		rtl.remove_theme_font_override(custom_name)
	else:
		var font_path = 'res://addons/gut/fonts/' + font_name + '.ttf'
		if(FileAccess.file_exists(font_path)):
			var dyn_font = FontFile.new()
			dyn_font.load_dynamic_font('res://addons/gut/fonts/' + font_name + '.ttf')
			rtl.add_theme_font_override(custom_name, dyn_font)


func _set_all_fonts_in_rtl(rtl, base_name):
	if(base_name == 'Default'):
		_set_font(rtl, null, 'normal_font')
		_set_font(rtl, null, 'bold_font')
		_set_font(rtl, null, 'italics_font')
		_set_font(rtl, null, 'bold_italics_font')
	else:
		_set_font(rtl, base_name + '-Regular', 'normal_font')
		_set_font(rtl, base_name + '-Bold', 'bold_font')
		_set_font(rtl, base_name + '-Italic', 'italics_font')
		_set_font(rtl, base_name + '-BoldItalic', 'bold_italics_font')


func set_default_font_color(color):
	_normal_gui.get_textbox().set('custom_colors/default_color', color)


func set_background_color(color):
	_normal_gui.set_bg_color(color)


func use_compact_mode(should=true):
	_compact_gui.visible = should
	_normal_gui.visible = !should


func set_opacity(val):
	_normal_gui.modulate.a = val
	_compact_gui.modulate.a = val

func set_title(text):
	_set_both_titles(text)


--------------------------------------------------
FILE: res:///addons/gut/GutScene.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://m28heqtswbuq"]

[ext_resource type="Script" uid="uid://bw7tukh738kw1" path="res://addons/gut/GutScene.gd" id="1_b4m8y"]
[ext_resource type="PackedScene" uid="uid://duxblir3vu8x7" path="res://addons/gut/gui/NormalGui.tscn" id="2_j6ywb"]
[ext_resource type="PackedScene" uid="uid://cnqqdfsn80ise" path="res://addons/gut/gui/MinGui.tscn" id="3_3glw1"]

[node name="GutScene" type="Node2D"]
script = ExtResource("1_b4m8y")

[node name="Normal" parent="." instance=ExtResource("2_j6ywb")]

[node name="Compact" parent="." instance=ExtResource("3_3glw1")]
offset_left = 5.0
offset_top = 273.0
offset_right = 265.0
offset_bottom = 403.0


--------------------------------------------------
FILE: res:///addons/gut/UserFileViewer.gd
--------------------------------------------------
extends Window

@onready var rtl = $TextDisplay/RichTextLabel

func _get_file_as_text(path):
	var to_return = null
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	else:
		to_return = str('ERROR:  Could not open file.  Error code ', FileAccess.get_open_error())
	return to_return

func _ready():
	rtl.clear()

func _on_OpenFile_pressed():
	$FileDialog.popup_centered()

func _on_FileDialog_file_selected(path):
	show_file(path)

func _on_Close_pressed():
	self.hide()

func show_file(path):
	var text = _get_file_as_text(path)
	if(text == ''):
		text = '<Empty File>'
	rtl.set_text(text)
	self.window_title = path

func show_open():
	self.popup_centered()
	$FileDialog.popup_centered()

func get_rich_text_label():
	return $TextDisplay/RichTextLabel

func _on_Home_pressed():
	rtl.scroll_to_line(0)

func _on_End_pressed():
	rtl.scroll_to_line(rtl.get_line_count() -1)

func _on_Copy_pressed():
	return
	# OS.clipboard = rtl.text

func _on_file_dialog_visibility_changed():
	if rtl.text.length() == 0 and not $FileDialog.visible:
		self.hide()


--------------------------------------------------
FILE: res:///addons/gut/UserFileViewer.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bsm7wtt1gie4v"]

[ext_resource type="Script" uid="uid://x51wilphva3d" path="res://addons/gut/UserFileViewer.gd" id="1"]

[node name="UserFileViewer" type="Window"]
exclusive = true
script = ExtResource("1")

[node name="FileDialog" type="FileDialog" parent="."]
access = 1
show_hidden_files = true
__meta__ = {
"_edit_use_anchors_": false
}

[node name="TextDisplay" type="ColorRect" parent="."]
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 8.0
offset_right = -10.0
offset_bottom = -65.0
color = Color(0.2, 0.188235, 0.188235, 1)

[node name="RichTextLabel" type="RichTextLabel" parent="TextDisplay"]
anchor_right = 1.0
anchor_bottom = 1.0
focus_mode = 2
text = "In publishing and graphic design, Lorem ipsum is a placeholder text commonly used to demonstrate the visual form of a document or a typeface without relying on meaningful content. Lorem ipsum may be used before final copy is available, but it may also be used to temporarily replace copy in a process called greeking, which allows designers to consider form without the meaning of the text influencing the design.

Lorem ipsum is typically a corrupted version of De finibus bonorum et malorum, a first-century BCE text by the Roman statesman and philosopher Cicero, with words altered, added, and removed to make it nonsensical, improper Latin.

Versions of the Lorem ipsum text have been used in typesetting at least since the 1960s, when it was popularized by advertisements for Letraset transfer sheets. Lorem ipsum was introduced to the digital world in the mid-1980s when Aldus employed it in graphic and word-processing templates for its desktop publishing program PageMaker. Other popular word processors including Pages and Microsoft Word have since adopted Lorem ipsum as well."
selection_enabled = true

[node name="OpenFile" type="Button" parent="."]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -158.0
offset_top = -50.0
offset_right = -84.0
offset_bottom = -30.0
text = "Open File"

[node name="Home" type="Button" parent="."]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -478.0
offset_top = -50.0
offset_right = -404.0
offset_bottom = -30.0
text = "Home"

[node name="Copy" type="Button" parent="."]
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = 160.0
offset_top = -50.0
offset_right = 234.0
offset_bottom = -30.0
text = "Copy"

[node name="End" type="Button" parent="."]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -318.0
offset_top = -50.0
offset_right = -244.0
offset_bottom = -30.0
text = "End"

[node name="Close" type="Button" parent="."]
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = 10.0
offset_top = -50.0
offset_right = 80.0
offset_bottom = -30.0
text = "Close"

[connection signal="file_selected" from="FileDialog" to="." method="_on_FileDialog_file_selected"]
[connection signal="visibility_changed" from="FileDialog" to="." method="_on_file_dialog_visibility_changed"]
[connection signal="pressed" from="OpenFile" to="." method="_on_OpenFile_pressed"]
[connection signal="pressed" from="Home" to="." method="_on_Home_pressed"]
[connection signal="pressed" from="Copy" to="." method="_on_Copy_pressed"]
[connection signal="pressed" from="End" to="." method="_on_End_pressed"]
[connection signal="pressed" from="Close" to="." method="_on_Close_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/autofree.gd
--------------------------------------------------
# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Class used to keep track of objects to be freed and utilities to free them.
# ##############################################################################
var _to_free = []
var _to_queue_free = []
var _ref_counted_doubles = []
var _all_instance_ids = []


func _add_instance_id(thing):
	if(thing.has_method("get_instance_id")):
		_all_instance_ids.append(thing.get_instance_id())


func add_free(thing):
	if(typeof(thing) == TYPE_OBJECT):
		_add_instance_id(thing)
		if(!thing is RefCounted):
			_to_free.append(thing)
		elif(GutUtils.is_double(thing)):
			_ref_counted_doubles.append(thing)


func add_queue_free(thing):
	if(typeof(thing) == TYPE_OBJECT):
		_add_instance_id(thing)
		_to_queue_free.append(thing)


func get_queue_free_count():
	return _to_queue_free.size()


func get_free_count():
	return _to_free.size()


func free_all():
	for node in _to_free:
		if(is_instance_valid(node)):
			if(GutUtils.is_double(node)):
				node.__gutdbl_done()
			node.free()
	_to_free.clear()

	for i in range(_to_queue_free.size()):
		if(is_instance_valid(_to_queue_free[i])):
			_to_queue_free[i].queue_free()
	_to_queue_free.clear()

	for ref_dbl in _ref_counted_doubles:
		ref_dbl.__gutdbl_done()
	_ref_counted_doubles.clear()

	_all_instance_ids.clear()


func has_instance_id(id):
	return _all_instance_ids.has(id)

--------------------------------------------------
FILE: res:///addons/gut/awaiter.gd
--------------------------------------------------
extends Node

class AwaitLogger:
	var _time_waited = 0.0
	var logger = GutUtils.get_logger()
	var waiting_on = "nothing"
	var logged_initial_message = false
	var wait_log_delay := 1.0
	var disabled = false

	func waited(x):
		_time_waited += x
		if(!logged_initial_message and _time_waited >= wait_log_delay):
			log_it()
			logged_initial_message = true


	func reset():
		_time_waited = 0.0
		logged_initial_message = false


	func log_it():
		if(!disabled):
			var msg = str("--- Awaiting ", waiting_on, " ---")
			logger.wait_msg(msg)




signal timeout
signal wait_started

var await_logger = AwaitLogger.new()
var _wait_time := 0.0
var _wait_process_frames := 0
var _wait_physics_frames := 0
var _signal_to_wait_on = null

var _predicate_method = null
var _waiting_for_predicate_to_be = null

var _predicate_time_between := 0.0
var _predicate_time_between_elpased := 0.0

var _elapsed_time := 0.0
var _elapsed_frames := 0

var _did_last_wait_timeout = false
var did_last_wait_timeout = false :
	get: return _did_last_wait_timeout
	set(val): push_error("Cannot set did_last_wait_timeout")



func _ready() -> void:
	get_tree().process_frame.connect(_on_tree_process_frame)
	get_tree().physics_frame.connect(_on_tree_physics_frame)


func _on_tree_process_frame():
	# Count frames here instead of in _process so that tree order never
	# makes a difference and the count/signaling happens outside of
	# _process being called.
	if(_wait_process_frames > 0):
		_elapsed_frames += 1
		if(_elapsed_frames > _wait_process_frames):
			_end_wait()


func _on_tree_physics_frame():
	# Count frames here instead of in _physics_process so that tree order never
	# makes a difference and the count/signaling happens outside of
	# _physics_process being called.
	if(_wait_physics_frames != 0):
		_elapsed_frames += 1
		if(_elapsed_frames > _wait_physics_frames):
			_end_wait()


func _physics_process(delta):
	if(is_waiting()):
		await_logger.waited(delta)

	if(_wait_time != 0.0):
		_elapsed_time += delta
		if(_elapsed_time >= _wait_time):
			_end_wait()

	if(_predicate_method != null):
		_predicate_time_between_elpased += delta
		if(_predicate_time_between_elpased >= _predicate_time_between):
			_predicate_time_between_elpased = 0.0
			var result = _predicate_method.call()
			if(_waiting_for_predicate_to_be == false):
				if(typeof(result) != TYPE_BOOL or result != true):
					_end_wait()
			else:
				if(typeof(result) == TYPE_BOOL and result == _waiting_for_predicate_to_be):
					_end_wait()


func _end_wait():
	await_logger.reset()
	# Check for time before checking for frames so that the extra frames added
	# when waiting on a signal do not cause a false negative for timing out.
	if(_wait_time > 0):
		_did_last_wait_timeout = _elapsed_time >= _wait_time
	elif(_wait_physics_frames > 0):
		_did_last_wait_timeout = _elapsed_frames >= _wait_physics_frames
	elif(_wait_process_frames > 0):
		_did_last_wait_timeout = _elapsed_frames >= _wait_process_frames

	if(_signal_to_wait_on != null and \
	   is_instance_valid(_signal_to_wait_on.get_object()) and \
	   _signal_to_wait_on.is_connected(_signal_callback)):
		_signal_to_wait_on.disconnect(_signal_callback)

	_wait_process_frames = 0
	_wait_time = 0.0
	_wait_physics_frames = 0
	_signal_to_wait_on = null
	_predicate_method = null
	_elapsed_time = 0.0
	_elapsed_frames = 0
	timeout.emit()


const ARG_NOT_SET = '_*_argument_*_is_*_not_set_*_'
func _signal_callback(
		_arg1=ARG_NOT_SET, _arg2=ARG_NOT_SET, _arg3=ARG_NOT_SET,
		_arg4=ARG_NOT_SET, _arg5=ARG_NOT_SET, _arg6=ARG_NOT_SET,
		_arg7=ARG_NOT_SET, _arg8=ARG_NOT_SET, _arg9=ARG_NOT_SET):

	_signal_to_wait_on.disconnect(_signal_callback)
	# DO NOT _end_wait here.  For other parts of the test to get the signal that
	# was waited on, we have to wait for another frames.  For example, the
	# signal_watcher doesn't get the signal in time if we don't do this.
	_wait_process_frames = 1


func wait_seconds(x, msg=''):
	await_logger.waiting_on = str(x, " seconds ", msg)
	_did_last_wait_timeout = false
	_wait_time = x
	wait_started.emit()


func wait_process_frames(x, msg=''):
	await_logger.waiting_on = str(x, " idle frames ", msg)
	_did_last_wait_timeout = false
	_wait_process_frames = x
	wait_started.emit()


func wait_physics_frames(x, msg=''):
	await_logger.waiting_on = str(x, " physics frames ", msg)
	_did_last_wait_timeout = false
	_wait_physics_frames = x
	wait_started.emit()


func wait_for_signal(the_signal : Signal, max_time, msg=''):
	await_logger.waiting_on = str("signal ", the_signal.get_name(), " or ", max_time, "s ", msg)
	_did_last_wait_timeout = false
	the_signal.connect(_signal_callback)
	_signal_to_wait_on = the_signal
	_wait_time = max_time
	wait_started.emit()


func wait_until(predicate_function: Callable, max_time, time_between_calls:=0.0, msg=''):
	await_logger.waiting_on = str("callable to return TRUE or ", max_time, "s.  ", msg)
	_predicate_time_between = time_between_calls
	_predicate_method = predicate_function
	_wait_time = max_time

	_waiting_for_predicate_to_be = true
	_predicate_time_between_elpased = 0.0
	_did_last_wait_timeout = false

	wait_started.emit()


func wait_while(predicate_function: Callable, max_time, time_between_calls:=0.0, msg=''):
	await_logger.waiting_on = str("callable to return FALSE or ", max_time, "s.  ", msg)
	_predicate_time_between = time_between_calls
	_predicate_method = predicate_function
	_wait_time = max_time

	_waiting_for_predicate_to_be = false
	_predicate_time_between_elpased = 0.0
	_did_last_wait_timeout = false

	wait_started.emit()


func is_waiting():
	return _wait_time != 0.0 || \
		_wait_physics_frames != 0 || \
		_wait_process_frames != 0


--------------------------------------------------
FILE: res:///addons/gut/cli/change_project_warnings.gd
--------------------------------------------------
extends SceneTree

var Optparse = load('res://addons/gut/cli/optparse.gd')
var WarningsManager = load("res://addons/gut/warnings_manager.gd")
const WARN_VALUE_PRINT_POSITION = 36

var godot_default_warnings = {
  "assert_always_false": 1,             "assert_always_true": 1,  			"confusable_identifier": 1,
  "confusable_local_declaration": 1,    "confusable_local_usage": 1,  		"constant_used_as_function": 1,
  "deprecated_keyword": 1,              "empty_file": 1,  					"enable": true,
  "exclude_addons": true, 				"function_used_as_property": 1,  	"get_node_default_without_onready": 2,
  "incompatible_ternary": 1,  			"inference_on_variant": 2,  		"inferred_declaration": 0,
  "int_as_enum_without_cast": 1,  		"int_as_enum_without_match": 1,  	"integer_division": 1,
  "narrowing_conversion": 1,  			"native_method_override": 2,  		"onready_with_export": 2,
  "property_used_as_function": 1,  		"redundant_await": 1,  				"redundant_static_unload": 1,
  "renamed_in_godot_4_hint": 1,  		"return_value_discarded": 0,  		"shadowed_global_identifier": 1,
  "shadowed_variable": 1,  				"shadowed_variable_base_class": 1,  "standalone_expression": 1,
  "standalone_ternary": 1,  			"static_called_on_instance": 1,  	"unassigned_variable": 1,
  "unassigned_variable_op_assign": 1,  	"unreachable_code": 1,  			"unreachable_pattern": 1,
  "unsafe_call_argument": 0,  			"unsafe_cast": 0,  					"unsafe_method_access": 0,
  "unsafe_property_access": 0,  		"unsafe_void_return": 1,  			"untyped_declaration": 0,
  "unused_local_constant": 1,  			"unused_parameter": 1,  			"unused_private_class_variable": 1,
  "unused_signal": 1,  					"unused_variable": 1
}

var gut_default_changes = {
  "exclude_addons": false, 				"redundant_await": 0,
}

var warning_settings = {}

func _setup_warning_settings():
	warning_settings["godot_default"] = godot_default_warnings
	warning_settings["current"] = WarningsManager.create_warnings_dictionary_from_project_settings()
	warning_settings["all_warn"] = WarningsManager.create_warn_all_warnings_dictionary()

	var gut_default = godot_default_warnings.duplicate()
	gut_default.merge(gut_default_changes, true)
	warning_settings["gut_default"] = gut_default


func _warn_value_to_s(value):
	var readable = str(value).capitalize()
	if(typeof(value) == TYPE_INT):
		readable = WarningsManager.WARNING_LOOKUP.get(value, str(readable, ' ???'))
		readable = readable.capitalize()
	return readable


func _human_readable(warnings):
	var to_return = ""
	for key in warnings:
		var readable = _warn_value_to_s(warnings[key])
		to_return += str(key.capitalize().rpad(35, ' '), readable, "\n")
	return to_return


func _dump_settings(which):
	if(warning_settings.has(which)):
		GutUtils.pretty_print(warning_settings[which])
	else:
		print("UNKNOWN print option ", which)


func _print_settings(which):
	if(warning_settings.has(which)):
		print(_human_readable(warning_settings[which]))
	else:
		print("UNKNOWN print option ", which)


func _apply_settings(which):
	if(!warning_settings.has(which)):
		print("UNKNOWN set option ", which)
		return

	var pre_settings = warning_settings["current"]
	var new_settings = warning_settings[which]

	if(new_settings == pre_settings):
		print("-- Settings are the same, no changes were made --")
		return

	WarningsManager.apply_warnings_dictionary(new_settings)
	ProjectSettings.save()
	print("-- Project Warning Settings have been updated --")
	print(_diff_changes_text(pre_settings))


func _diff_text(w1, w2, diff_col_pad=10):
	var to_return = ""
	for key in w1:
		var v1_text = _warn_value_to_s(w1[key])
		var v2_text = _warn_value_to_s(w2[key])
		var diff_text = v1_text
		var prefix = "  "

		if(v1_text != v2_text):
			var diff_prefix = " "
			if(w1[key] > w2[key]):
				diff_prefix = "-"
			else:
				diff_prefix = "+"
			prefix = "* "
			diff_text = str(v1_text.rpad(diff_col_pad, ' '), diff_prefix, v2_text)

		to_return += str(str(prefix, key.capitalize()).rpad(WARN_VALUE_PRINT_POSITION, ' '), diff_text, "\n")

	return to_return.rstrip("\n")


func _diff_changes_text(pre_settings):
	var orig_diff_text = _diff_text(
		pre_settings,
		WarningsManager.create_warnings_dictionary_from_project_settings(),
		0)
	# these next two lines are fragile and brute force...enjoy
	var diff_text = orig_diff_text.replace("-", " -> ")
	diff_text = diff_text.replace("+", " -> ")

	if(orig_diff_text == diff_text):
		diff_text += "\n-- No changes were made --"
	else:
		diff_text += "\nChanges will not be visible in Godot until it is restarted.\n"
		diff_text += "Even if it asks you to reload...Maybe.  Probably."

	return diff_text



func _diff(name_1, name_2):
	if(warning_settings.has(name_1) and warning_settings.has(name_2)):
		var c2_pad = name_1.length() + 2
		var heading = str(" ".repeat(WARN_VALUE_PRINT_POSITION), name_1.rpad(c2_pad, ' '), name_2, "\n")
		heading += str(
			" ".repeat(WARN_VALUE_PRINT_POSITION),
			"-".repeat(name_1.length()).rpad(c2_pad, " "),
			"-".repeat(name_2.length()),
			"\n")

		var text = _diff_text(warning_settings[name_1], warning_settings[name_2], c2_pad)

		print(heading)
		print(text)

		var diff_count = 0
		for line in text.split("\n"):
			if(!line.begins_with("  ")):
				diff_count += 1

		if(diff_count == 0):
			print('-- [', name_1, "] and [", name_2, "] are the same --")
		else:
			print('-- There are ', diff_count, ' differences between [', name_1, "] and [", name_2, "] --")
	else:
		print("One or more unknown Warning Level Names:, [", name_1, "] [", name_2, "]")


func _set_settings(nvps):
	var pre_settings = warning_settings["current"]
	for i in range(nvps.size()/2):
		var s_name = nvps[i * 2]
		var s_value = nvps[i * 2 + 1]
		if(godot_default_warnings.has(s_name)):
			var t = typeof(godot_default_warnings[s_name])
			if(t == TYPE_INT):
				s_value = s_value.to_int()
			elif(t == TYPE_BOOL):
				s_value = s_value.to_lower() == 'true'

			WarningsManager.set_project_setting_warning(s_name, s_value)
			ProjectSettings.save()
	print(_diff_changes_text(pre_settings))



func _setup_options():
	var opts = Optparse.new()
	opts.banner = """
	This script prints info about or sets the warning settings for the project.
	Each action requires one or more Warning Level Names.

	Warning Level Names:
	    * current        The current settings for the project.
	    * godot_default  The default settings for Godot.
	    * gut_default    The warning settings that is used when developing GUT.
	    * all_warn       Everything set to warn.
	""".dedent()

	opts.add('-h', false, 'Print this help')
	opts.add('-set', [], "Sets a single setting in the project settings and saves.\n" +
						 "Use -dump to see a list of setting names and values.\n" +
						 "Example: -set enabled,true -set unsafe_cast,2 -set unreachable_code,0")
	opts.add_heading(" Actions (require Warning Level Name)")
	opts.add('-diff', [], "Shows the difference between two Warning Level Names.\n" +
						  "Example:  -diff current,all_warn")
	opts.add('-dump', 'none', "Prints a dictionary of the warning values.")
	opts.add('-print', 'none', "Print human readable warning values.")
	opts.add('-apply', 'none', "Applys one of the Warning Level Names to the project settings.  You should restart after using this")

	return opts

func _print_help(opts):
	opts.print_help()



func _init():
	# Testing might set this flag but it should never be disabled for this tool
	# or it cannot save project settings, but says it did.  Sneakily use the
	# private property to get around this property being read-only.  Don't
	# try this at home.
	WarningsManager._disabled = false

	_setup_warning_settings()

	var opts = _setup_options()
	opts.parse()

	if(opts.unused.size() != 0):
		opts.print_help()
		print("Unknown arguments ", opts.unused)
	if(opts.values.h):
		opts.print_help()
	elif(opts.values.print != 'none'):
		_print_settings(opts.values.print)
	elif(opts.values.dump != 'none'):
		_dump_settings(opts.values.dump)
	elif(opts.values.apply != 'none'):
		_apply_settings(opts.values.apply )
	elif(opts.values.diff.size() == 2):
		_diff(opts.values.diff[0], opts.values.diff[1])
	elif(opts.values.set.size() % 2 == 0):
		_set_settings(opts.values.set)
	else:
		opts.print_help()
		print("You didn't specify any options or too many or not the right size or something invalid.  I don't know what you want to do.")

	quit()

--------------------------------------------------
FILE: res:///addons/gut/cli/gut_cli.gd
--------------------------------------------------
extends Node

var Optparse = load('res://addons/gut/cli/optparse.gd')
var Gut = load('res://addons/gut/gut.gd')
var GutRunner = load('res://addons/gut/gui/GutRunner.tscn')

# ------------------------------------------------------------------------------
# Helper class to resolve the various different places where an option can
# be set.  Using the get_value method will enforce the order of precedence of:
# 	1.  command line value
#	2.  config file value
#	3.  default value
#
# The idea is that you set the base_opts.  That will get you a copies of the
# hash with null values for the other types of values.  Lower precedented hashes
# will punch through null values of higher precedented hashes.
# ------------------------------------------------------------------------------
class OptionResolver:
	var base_opts = {}
	var cmd_opts = {}
	var config_opts = {}


	func get_value(key):
		return _nvl(cmd_opts[key], _nvl(config_opts[key], base_opts[key]))

	func set_base_opts(opts):
		base_opts = opts
		cmd_opts = _null_copy(opts)
		config_opts = _null_copy(opts)

	# creates a copy of a hash with all values null.
	func _null_copy(h):
		var new_hash = {}
		for key in h:
			new_hash[key] = null
		return new_hash

	func _nvl(a, b):
		if(a == null):
			return b
		else:
			return a

	func _string_it(h):
		var to_return = ''
		for key in h:
			to_return += str('(',key, ':', _nvl(h[key], 'NULL'), ')')
		return to_return

	func to_s():
		return str("base:\n", _string_it(base_opts), "\n", \
				"config:\n", _string_it(config_opts), "\n", \
				"cmd:\n", _string_it(cmd_opts), "\n", \
				"resolved:\n", _string_it(get_resolved_values()))

	func get_resolved_values():
		var to_return = {}
		for key in base_opts:
			to_return[key] = get_value(key)
		return to_return

	func to_s_verbose():
		var to_return = ''
		var resolved = get_resolved_values()
		for key in base_opts:
			to_return += str(key, "\n")
			to_return += str('  default: ', _nvl(base_opts[key], 'NULL'), "\n")
			to_return += str('  config:  ', _nvl(config_opts[key], ' --'), "\n")
			to_return += str('  cmd:     ', _nvl(cmd_opts[key], ' --'), "\n")
			to_return += str('  final:   ', _nvl(resolved[key], 'NULL'), "\n")

		return to_return

# ------------------------------------------------------------------------------
# Here starts the actual script that uses the Options class to kick off Gut
# and run your tests.
# ------------------------------------------------------------------------------
var _gut_config = load('res://addons/gut/gut_config.gd').new()

# array of command line options specified
var _final_opts = []


func setup_options(options, font_names):
	var opts = Optparse.new()
	opts.banner =\
"""
The GUT CLI
-----------
The default behavior for GUT is to load options from a res://.gutconfig.json if
it exists.  Any options specified on the command line will take precedence over
options specified in the gutconfig file.  You can specify a different gutconfig
file with the -gconfig option.

To generate a .gutconfig.json file you can use -gprint_gutconfig_sample
To see the effective values of a CLI command and a gutconfig use -gpo

Values for options can be supplied using:
    option=value    # no space around "="
    option value    # a space between option and value w/o =

Options whose values are lists/arrays can be specified multiple times:
	-gdir=a,b
	-gdir c,d
	-gdir e
	# results in -gdir equaling [a, b, c, d, e]

To not use an empty value instead of a default value, specifiy the option with
an immediate "=":
	-gconfig=
"""
	opts.add_heading("Test Config:")
	opts.add('-gdir', options.dirs, 'List of directories to search for test scripts in.')
	opts.add('-ginclude_subdirs', false, 'Flag to include all subdirectories specified with -gdir.')
	opts.add('-gtest', [], 'List of full paths to test scripts to run.')
	opts.add('-gprefix', options.prefix, 'Prefix used to find tests when specifying -gdir.  Default "[default]".')
	opts.add('-gsuffix', options.suffix, 'Test script suffix, including .gd extension.  Default "[default]".')
	opts.add('-gconfig', 'res://.gutconfig.json', 'The config file to load options from.  The default is [default].  Use "-gconfig=" to not use a config file.')
	opts.add('-gpre_run_script', '', 'pre-run hook script path')
	opts.add('-gpost_run_script', '', 'post-run hook script path')
	opts.add('-gerrors_do_not_cause_failure', false, 'When an internal GUT error occurs tests will fail.  With this option set, that does not happen.')
	opts.add('-gdouble_strategy', 'SCRIPT_ONLY', 'Default strategy to use when doubling.  Valid values are [INCLUDE_NATIVE, SCRIPT_ONLY].  Default "[default]"')

	opts.add_heading("Run Options:")
	opts.add('-gselect', '', 'All scripts that contain the specified string in their filename will be ran')
	opts.add('-ginner_class', '', 'Only run inner classes that contain the specified string in their name.')
	opts.add('-gunit_test_name', '', 'Any test that contains the specified text will be run, all others will be skipped.')
	opts.add('-gexit', false, 'Exit after running tests.  If not specified you have to manually close the window.')
	opts.add('-gexit_on_success', false, 'Only exit if zero tests fail.')
	opts.add('-gignore_pause', false, 'Ignores any calls to pause_before_teardown.')
	opts.add('-gno_error_tracking', false, 'Disable error tracking.')
	opts.add('-gfailure_error_types', options.failure_error_types, 'Error types that will cause tests to fail if the are encountered during the execution of a test.  Default "[default]"')

	opts.add_heading("Display Settings:")
	opts.add('-glog', options.log_level, 'Log level [0-3].  Default [default]')
	opts.add('-ghide_orphans', false, 'Display orphan counts for tests and scripts.  Default [default].')
	opts.add('-gmaximize', false, 'Maximizes test runner window to fit the viewport.')
	opts.add('-gcompact_mode', false, 'The runner will be in compact mode.  This overrides -gmaximize.')
	opts.add('-gopacity', options.opacity, 'Set opacity of test runner window. Use range 0 - 100. 0 = transparent, 100 = opaque.')
	opts.add('-gdisable_colors', false, 'Disable command line colors.')
	opts.add('-gfont_name', options.font_name, str('Valid values are:  ', font_names, '.  Default "[default]"'))
	opts.add('-gfont_size', options.font_size, 'Font size, default "[default]"')
	opts.add('-gbackground_color', options.background_color, 'Background color as an html color, default "[default]"')
	opts.add('-gfont_color',options.font_color, 'Font color as an html color, default "[default]"')
	opts.add('-gpaint_after', options.paint_after, 'Delay before GUT will add a 1 frame pause to paint the screen/GUI.  default [default]')
	opts.add('-gwait_log_delay', options.wait_log_delay, 'Delay before GUT will print a message to indicate a test is awaiting one of the wait_* methods.  Default [default]')

	opts.add_heading("Result Export:")
	opts.add('-gjunit_xml_file', options.junit_xml_file, 'Export results of run to this file in the Junit XML format.')
	opts.add('-gjunit_xml_timestamp', options.junit_xml_timestamp, 'Include a timestamp in the -gjunit_xml_file, default [default]')

	opts.add_heading("Help:")
	opts.add('-gh', false, 'Print this help.  You did this to see this, so you probably understand.')
	opts.add('-gpo', false, 'Print option values from all sources and the value used.')
	opts.add('-gprint_gutconfig_sample', false, 'Print out json that can be used to make a gutconfig file.')

	# run as in editor, for shelling out purposes through Editor.
	var o = opts.add('-graie', false, 'do not use')
	o.show_in_help = false
	return opts


# Parses options, applying them to the _tester or setting values
# in the options struct.
func extract_command_line_options(from, to):
	to.compact_mode = from.get_value_or_null('-gcompact_mode')
	to.config_file = from.get_value_or_null('-gconfig')
	to.dirs = from.get_value_or_null('-gdir')
	to.disable_colors =  from.get_value_or_null('-gdisable_colors')
	to.double_strategy = from.get_value_or_null('-gdouble_strategy')
	to.errors_do_not_cause_failure = from.get_value_or_null('-gerrors_do_not_cause_failure')
	to.hide_orphans = from.get_value_or_null('-ghide_orphans')
	to.ignore_pause = from.get_value_or_null('-gignore_pause')
	to.include_subdirs = from.get_value_or_null('-ginclude_subdirs')
	to.inner_class = from.get_value_or_null('-ginner_class')
	to.log_level = from.get_value_or_null('-glog')
	to.opacity = from.get_value_or_null('-gopacity')
	to.post_run_script = from.get_value_or_null('-gpost_run_script')
	to.pre_run_script = from.get_value_or_null('-gpre_run_script')
	to.prefix = from.get_value_or_null('-gprefix')
	to.selected = from.get_value_or_null('-gselect')
	to.should_exit = from.get_value_or_null('-gexit')
	to.should_exit_on_success = from.get_value_or_null('-gexit_on_success')
	to.should_maximize = from.get_value_or_null('-gmaximize')
	to.suffix = from.get_value_or_null('-gsuffix')
	to.tests = from.get_value_or_null('-gtest')
	to.unit_test_name = from.get_value_or_null('-gunit_test_name')
	to.wait_log_delay = from.get_value_or_null('-gwait_log_delay')

	to.background_color = from.get_value_or_null('-gbackground_color')
	to.font_color = from.get_value_or_null('-gfont_color')
	to.font_name = from.get_value_or_null('-gfont_name')
	to.font_size = from.get_value_or_null('-gfont_size')
	to.paint_after = from.get_value_or_null('-gpaint_after')

	to.junit_xml_file = from.get_value_or_null('-gjunit_xml_file')
	to.junit_xml_timestamp = from.get_value_or_null('-gjunit_xml_timestamp')

	to.failure_error_types = from.get_value_or_null('-gfailure_error_types')
	to.no_error_tracking = from.get_value_or_null('-gno_error_tracking')
	to.raie = from.get_value_or_null('-graie')



func _print_gutconfigs(values):
	var header = """Here is a sample of a full .gutconfig.json file.
You do not need to specify all values in your own file.  The values supplied in
this sample are what would be used if you ran gut w/o the -gprint_gutconfig_sample
option.   Option priority is:  command-line, .gutconfig, default)."""
	print("\n", header.replace("\n", ' '), "\n")
	var resolved = values

	# remove_at some options that don't make sense to be in config
	resolved.erase("config_file")
	resolved.erase("show_help")

	print(JSON.stringify(resolved, '  '))

	for key in resolved:
		resolved[key] = null

	print("\n\nAnd here's an empty config for you fill in what you want.")
	print(JSON.stringify(resolved, ' '))


func _run_tests(opt_resolver):
	_final_opts = opt_resolver.get_resolved_values();
	_gut_config.options = _final_opts

	var runner = GutRunner.instantiate()
	runner.set_gut_config(_gut_config)
	get_tree().root.add_child(runner)

	if(opt_resolver.cmd_opts.raie):
		runner.run_from_editor()
	else:
		runner.run_tests()


# parse options and run Gut
func main():
	var opt_resolver = OptionResolver.new()
	opt_resolver.set_base_opts(_gut_config.default_options)

	var cli_opts = setup_options(_gut_config.default_options, _gut_config.valid_fonts)

	cli_opts.parse()
	var all_options_valid = cli_opts.unused.size() == 0
	extract_command_line_options(cli_opts, opt_resolver.cmd_opts)

	var config_path = opt_resolver.get_value('config_file')
	var load_result = 1
	# Checking for an empty config path allows us to not use a config file via
	# the -gconfig_file option since using "-gconfig_file=" or -gconfig_file=''"
	# will result in an empty string.
	if(config_path != ''):
		load_result = _gut_config.load_options_no_defaults(config_path)

	# SHORTCIRCUIT
	if(!all_options_valid):
		print('Unknown arguments:  ', cli_opts.unused)
		get_tree().quit(1)
	elif(load_result == -1):
		print('Invalid gutconfig ', load_result)
		get_tree().quit(1)
	else:
		opt_resolver.config_opts = _gut_config.options

		if(cli_opts.get_value('-gh')):
			print(GutUtils.version_numbers.get_version_text())
			cli_opts.print_help()
			get_tree().quit(0)
		elif(cli_opts.get_value('-gpo')):
			print('All config options and where they are specified.  ' +
				'The "final" value shows which value will actually be used ' +
				'based on order of precedence (default < .gutconfig < cmd line).' + "\n")
			print(opt_resolver.to_s_verbose())
			get_tree().quit(0)
		elif(cli_opts.get_value('-gprint_gutconfig_sample')):
			_print_gutconfigs(opt_resolver.get_resolved_values())
			get_tree().quit(0)
		else:
			_run_tests(opt_resolver)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/cli/optparse.gd
--------------------------------------------------
## Parses command line arguments, as one might expect.
##
## Parses command line arguments with a bunch of options including generating
## text that displays all the arguments your script accepts.  This
## is included in the GUT ClassRef since it might be usable by others and is
## portable (everything it needs is in this one file).
## [br]
## This does alot, if you want to see it in action have a look at
##	[url=https://github.com/bitwes/Gut/blob/main/scratch/optparse_example.gd]scratch/optparse_example.gd[/url]
## [codeblock lang=text]
##
## Godot Argument Lists
## -------------------------
## There are two sets of command line arguments that Godot populates:
##	OS.get_cmdline_args
##	OS.get_cmdline_user_args.
##
## OS.get_cmdline_args contains any arguments that are not used by the engine
## itself.  This means options like --help and -d will never appear in this list
## since these are used by the engine.  The one exception is the -s option which
## is always included as the first entry and the script path as the second.
## Optparse ignores these values for argument processing but can be accessed
## with my_optparse.options.script_option.  This list does not contain any
## arguments that appear in OS.get_cmdline_user_args.
##
## OS.get_cmdline_user_args contains any arguments that appear on the command
## line AFTER " -- " or " ++ ".  This list CAN contain options that the engine
## would otherwise use, and are ignored completely by the engine.
##
## The parse method, by default, includes arguments from OS.get_cmdline_args and
## OS.get_cmdline_user_args.  You can optionally pass one of these to the parse
## method to limit which arguments are parsed.  You can also conjure up your own
## array of arguments and pass that to parse.
##
## See Godot's documentation for get_cmdline_args and get_cmdline_user_args for
## more information.
##
##
## Adding Options
## --------------
## Use the following to add options to be parsed.  These methods return the
## created Option instance.  See that class above for more info.  You can use
## the returned instance to get values, or use get_value/get_value_or_null.
##   add("--name", "default", "Description goes here")
##   add(["--name", "--aliases"], "default", "Description goes here")
##   add_required(["--name", "--aliases"], "default", "Description goes here")
##   add_positional("--name", "default", "Description goes here")
##   add_positional_required("--name", "default", "Description goes here")
##
## get_value will return the value of the option or the default if it was not
## set.  get_value_or_null will return the value of the option or null if it was
## not set.
##
## The Datatype for an option is determined from the default value supplied to
## the various add methods.  Supported types are
##   String
##   Int
##   Float
##   Array of strings
##   Boolean
##
##
## Value Parsing
## -------------
## optparse uses option_name_prefix to differentiate between option names and
## values.  Any argument that starts with this value will be treated as an
## argument name.  The default is "-".  Set this before calling parse if you want
## to change it.
##
## Values for options can be supplied on the command line with or without an "=":
##	option=value    # no space around "="
##	option value    # a space between option and value w/o =
## There is no way to escape "=" at this time.
##
## Array options can be specified multiple times and/or set from a comma delimited
## list.
##   -gdir=a,b
##   -gdir c,d
##   -gdir e
## Results in -gdir equaling [a, b, c, d, e].  There is no way to escape commas
## at this time.
##
## To specify an empty list via the command line follow the option with an equal
## sign
##   -gdir=
##
## Boolean options will have thier value set to !default when they are supplied
## on the command line.  Boolean options cannot have a value on the command line.
## They are either supplied or not.
##
## If a value is not an array and is specified multiple times on the command line
## then the last entry will be used as the value.
##
## Positional argument values are parsed after all named arguments are parsed.
## This means that other options can appear before, between, and after positional
## arguments.
##   --foo=bar positional_0_value --disabled --bar foo positional_1_value --a_flag
##
## Anything that is not used by named or positional arguments will appear in the
## unused property.  You can use this to detect unrecognized arguments or treat
## everything else provided as a list of things, or whatever you want.  You can
## use is_option on the elements of unused (or whatever you want really) to see
## if optparse would treat it as an option name.
##
## Use get_missing_required_options to get an array of Option with all required
## options that were not found when parsing.
##
## The parsed_args property holds the list of arguments that were parsed.
##
##
## Help Generation
## ---------------
## You can call get_help to generate help text, or you can just call print_help
## and this will print it for you.
##
## Set the banner property to any text you want to appear before the usage and
## options sections.
##
## Options are printed in the order they are added.  You can add a heading for
## different options sections with add_heading.
##   add("--asdf", 1, "This will have no heading")
##   add_heading("foo")
##   add("--foo", false, "This will have the foo heading")
##   add("--another_foo", 1.5, "This too.")
##   add_heading("This is after foo")
##   add("--bar", true, "You probably get it by now.")
##
## If you include "[default]" in the description of a option, then the help will
## substitue it with the default value.
## [/codeblock]


#-------------------------------------------------------------------------------
# Holds all the properties of a command line option
#
# value will return the default when it has not been set.
#-------------------------------------------------------------------------------
class Option:
	var _has_been_set = false
	var _value = null
	# REMEMBER that when this option is an array, you have to set the value
	# before you alter the contents of the array (append etc) or has_been_set
	# will return false and it might not be used right.  For example
	# get_value_or_null will return null when you've actually changed the value.
	var value = _value:
		get:
			return _value

		set(val):
			_has_been_set = true
			_value = val

	var option_name = ''
	var default = null
	var description = ''
	var required = false
	var aliases: Array[String] = []
	var show_in_help = true


	func _init(name,default_value,desc=''):
		option_name = name
		default = default_value
		description = desc
		_value = default


	func wrap_text(text, left_indent, max_length, wiggle_room=15):
		var line_indent = str("\n", " ".repeat(left_indent + 1))
		var wrapped = ''
		var position = 0
		var split_length = max_length
		while(position < text.length()):
			if(position > 0):
				wrapped += line_indent

			var split_by = split_length
			if(position + split_by + wiggle_room >= text.length()):
				split_by = text.length() - position
			else:
				var min_space = text.rfind(' ', position + split_length)
				var max_space = text.find(' ', position + split_length)
				if(max_space <= position + split_length + wiggle_room):
					split_by = max_space - position
				else:
					split_by = min_space - position

			wrapped += text.substr(position, split_by).lstrip(' ')

			if(position == 0):
				split_length = max_length - left_indent

			position += split_by


		return wrapped



	func to_s(min_space=0, wrap_length=100):
		var line_indent = str("\n", " ".repeat(min_space + 1))
		var subbed_desc = description
		if not aliases.is_empty():
			subbed_desc += "\naliases: " + ", ".join(aliases)
		subbed_desc = subbed_desc.replace('[default]', str(default))
		subbed_desc = subbed_desc.replace("\n", line_indent)

		var final = str(option_name.rpad(min_space), ' ', subbed_desc)
		if(wrap_length != -1):
			final = wrap_text(final, min_space, wrap_length)

		return final


	func has_been_set():
		return _has_been_set




#-------------------------------------------------------------------------------
# A struct for organizing options by a heading
#-------------------------------------------------------------------------------
class OptionHeading:
	var options = []
	var display = 'default'




#-------------------------------------------------------------------------------
# Organizes options by order, heading, position.  Also responsible for all
# help related text generation.
#-------------------------------------------------------------------------------
class Options:
	var options = []
	var positional = []
	var default_heading = OptionHeading.new()
	var script_option = Option.new('-s', '?', 'script option provided by Godot')

	var _options_by_name = {"--script": script_option, "-s": script_option}
	var _options_by_heading = [default_heading]
	var _cur_heading = default_heading


	func add_heading(display):
		var heading = OptionHeading.new()
		heading.display = display
		_cur_heading = heading
		_options_by_heading.append(heading)


	func add(option, aliases=null):
		options.append(option)
		_options_by_name[option.option_name] = option
		_cur_heading.options.append(option)

		if aliases != null:
			for a in aliases:
				_options_by_name[a] = option
			option.aliases.assign(aliases)


	func add_positional(option):
		positional.append(option)
		_options_by_name[option.option_name] = option


	func get_by_name(option_name):
		var found_param = null
		if(_options_by_name.has(option_name)):
			found_param = _options_by_name[option_name]

		return found_param


	func get_help_text():
		var longest = 0
		var text = ""
		for i in range(options.size()):
			if(options[i].option_name.length() > longest):
				longest = options[i].option_name.length()

		for heading in _options_by_heading:
			if(heading != default_heading):
				text += str("\n", heading.display, "\n")
			for option in heading.options:
				if(option.show_in_help):
					text += str('  ', option.to_s(longest + 2).replace("\n", "\n  "), "\n")

		return text


	func get_option_value_text():
		var text = ""
		var i = 0
		for option in positional:
			text += str(i, '.  ', option.option_name, ' = ', option.value)

			if(!option.has_been_set()):
				text += " (default)"
			text += "\n"
			i += 1

		for option in options:
			text += str(option.option_name, ' = ', option.value)

			if(!option.has_been_set()):
				text += " (default)"
			text += "\n"
		return text


	func print_option_values():
		print(get_option_value_text())


	func get_missing_required_options():
		var to_return = []
		for opt in options:
			if(opt.required and !opt.has_been_set()):
				to_return.append(opt)

		for opt in positional:
			if(opt.required and !opt.has_been_set()):
				to_return.append(opt)

		return to_return


	func get_usage_text():
		var pos_text = ""
		for opt in positional:
			pos_text += str("[", opt.description, "] ")

		if(pos_text != ""):
			pos_text += " [opts] "

		return "<path to godot> -s " + script_option.value + " [opts] " + pos_text




#-------------------------------------------------------------------------------
#
# optarse
#
#-------------------------------------------------------------------------------
## @ignore
var options := Options.new()
## Set the banner property to any text you want to appear before the usage and
## options sections when printing the options help.
var banner := ''
## optparse uses option_name_prefix to differentiate between option names and
## values.  Any argument that starts with this value will be treated as an
## argument name.  The default is "-".  Set this before calling parse if you want
## to change it.
var option_name_prefix := '-'
## @ignore
var unused = []
## @ignore
var parsed_args = []
## @ignore
var values: Dictionary = {}


func _populate_values_dictionary():
	for entry in options.options:
		var value_key = entry.option_name.lstrip('-')
		values[value_key] = entry.value

	for entry in options.positional:
		var value_key = entry.option_name.lstrip('-')
		values[value_key] = entry.value


func _convert_value_to_array(raw_value):
	var split = raw_value.split(',')
	# This is what an empty set looks like from the command line.  If we do
	# not do this then we will always get back [''] which is not what it
	# shoudl be.
	if(split.size() == 1 and split[0] == ''):
		split = []
	return split

# REMEMBER raw_value not used for bools.
func _set_option_value(option, raw_value):
	var t = typeof(option.default)
	# only set values that were specified at the command line so that
	# we can punch through default and config values correctly later.
	# Without this check, you can't tell the difference between the
	# defaults and what was specified, so you can't punch through
	# higher level options.
	if(t == TYPE_INT):
		option.value = int(raw_value)
	elif(t == TYPE_STRING):
		option.value = str(raw_value)
	elif(t == TYPE_ARRAY):
		var values = _convert_value_to_array(raw_value)
		if(!option.has_been_set()):
			option.value = []
		option.value.append_array(values)
	elif(t == TYPE_BOOL):
		option.value = !option.default
	elif(t == TYPE_FLOAT):
		option.value = float(raw_value)
	elif(t == TYPE_NIL):
		print(option.option_name + ' cannot be processed, it has a nil datatype')
	else:
		print(option.option_name + ' cannot be processed, it has unknown datatype:' + str(t))


func _parse_command_line_arguments(args):
	var parsed_opts = args.duplicate()
	var i = 0
	var positional_index = 0

	while i < parsed_opts.size():
		var opt  = ''
		var value = ''
		var entry = parsed_opts[i]

		if(is_option(entry)):
			if(entry.find('=') != -1):
				var parts = entry.split('=')
				opt = parts[0]
				value = parts[1]
				var the_option = options.get_by_name(opt)
				if(the_option != null):
					parsed_opts.remove_at(i)
					_set_option_value(the_option, value)
				else:
					i += 1
			else:
				var the_option = options.get_by_name(entry)
				if(the_option != null):
					parsed_opts.remove_at(i)
					if(typeof(the_option.default) == TYPE_BOOL):
						_set_option_value(the_option, null)
					elif(i < parsed_opts.size() and !is_option(parsed_opts[i])):
						value = parsed_opts[i]
						parsed_opts.remove_at(i)
						_set_option_value(the_option, value)
				else:
					i += 1
		else:
			if(positional_index < options.positional.size()):
				_set_option_value(options.positional[positional_index], entry)
				parsed_opts.remove_at(i)
				positional_index += 1
			else:
				i += 1

	# this is the leftovers that were not extracted.
	return parsed_opts


## Test if something is an existing argument. If [code]str(arg)[/code] begins
## with the [member option_name_prefix], it will considered true,
## otherwise it will be considered false.
func is_option(arg) -> bool:
	return str(arg).begins_with(option_name_prefix)


## Adds a command line option.
## If [param op_names] is a String, this is set as the argument's name.
## If [param op_names] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add(op_names, default, desc: String) -> Option:
	var op_name: String
	var aliases: Array[String] = []
	var new_op: Option = null

	if(typeof(op_names) == TYPE_STRING):
		op_name = op_names
	else:
		op_name = op_names[0]
		aliases.assign(op_names.slice(1))

	var bad_alias: int = aliases.map(
		func (a: String) -> bool: return options.get_by_name(a) != null
	).find(true)

	if(options.get_by_name(op_name) != null):
		push_error(str('Option [', op_name, '] already exists.'))
	elif bad_alias != -1:
		push_error(str('Option [', aliases[bad_alias], '] already exists.'))
	else:
		new_op = Option.new(op_name, default, desc)
		options.add(new_op, aliases)

	return new_op


## Adds a required command line option.
## Required options that have not been set may be collected after parsing
## by calling [method get_missing_required_options].
## If [param op_names] is a String, this is set as the argument's name.
## If [param op_names] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_required(op_names, default, desc: String) -> Option:
	var op := add(op_names, default, desc)
	if(op != null):
		op.required = true
	return op


## Adds a positional command line option.
## Positional options are parsed by their position in the list of arguments
## are are not assigned by name by the user.
## If [param op_name] is a String, this is set as the argument's name.
## If [param op_name] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_positional(op_name, default, desc: String) -> Option:
	var new_op = null
	if(options.get_by_name(op_name) != null):
		push_error(str('Positional option [', op_name, '] already exists.'))
	else:
		new_op = Option.new(op_name, default, desc)
		options.add_positional(new_op)
	return new_op


## Adds a required positional command line option.
## If [param op_name] is a String, this is set as the argument's name.
## Required options that have not been set may be collected after parsing
## by calling [method get_missing_required_options].
## Positional options are parsed by their position in the list of arguments
## are are not assigned by name by the user.
## If [param op_name] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_positional_required(op_name, default, desc: String) -> Option:
	var op = add_positional(op_name, default, desc)
	if(op != null):
		op.required = true
	return op


## Headings are used to separate logical groups of command line options
## when printing out options from the help menu.
## Headings are printed out between option descriptions in the order
## that [method add_heading] was called.
func add_heading(display_text: String) -> void:
	options.add_heading(display_text)


## Gets the value assigned to an option after parsing.
## [param name] can be the name of the option or an alias of it.
## [param name] specifies the option whose value you wish to query.
## If the option exists, the value assigned to it during parsing is returned.
## Otherwise, an error message is printed and [code]null[/code] is returned.
func get_value(name: String):
	var found_param: Option = options.get_by_name(name)

	if(found_param != null):
		return found_param.value
	else:
		push_error("COULD NOT FIND OPTION " + name)
		return null


## Gets the value assigned to an option after parsing,
## returning null if the option was not assigned instead of its default value.
## [param name] specifies the option whose value you wish to query.
## This can be useful when providing an order of precedence to your values.
## For example if
## [codeblock]
##     default value < config file < command line
## [/codeblock]
## then you do not want to get the default value for a command line option or
## it will overwrite the value in a config file.
func get_value_or_null(name: String):
	var found_param: Option = options.get_by_name(name)

	if(found_param != null and found_param.has_been_set()):
		return found_param.value
	else:
		return null


## Returns the help text for all defined options.
func get_help() -> String:
	var sep := '---------------------------------------------------------'

	var text := str(sep, "\n", banner, "\n\n")
	text += "Usage\n-----------\n"
	text += "  " + options.get_usage_text() + "\n\n"
	text += "\nOptions\n-----------\n"
	text += options.get_help_text()
	text += str(sep, "\n")
	return text


## Prints out the help text for all defined options.
func print_help() -> void:
	print(get_help())


## Parses a string for all options that have been set in this optparse.
## if [param cli_args] is passed as a String, then it is parsed.
## Otherwise if [param cli_args] is null,
## aruments passed to the Godot engine at startup are parsed.
## See the explanation at the top of addons/gut/cli/optparse.gd to understand
## which arguments this will have access to.
func parse(cli_args=null) -> void:
	parsed_args = cli_args

	if(parsed_args == null):
		parsed_args = OS.get_cmdline_args()
		parsed_args.append_array(OS.get_cmdline_user_args())

	unused = _parse_command_line_arguments(parsed_args)
	_populate_values_dictionary()


## Get all options that were required and were not set during parsing.
## The return value is an Array of Options.
func get_missing_required_options() -> Array:
	return options.get_missing_required_options()


# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--------------------------------------------------
FILE: res:///addons/gut/collected_script.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# This holds all the meta information for a test script.  It contains the
# name of the inner class and an array of CollectedTests.  This does not parse
# anything, it just holds the data about parsed scripts and tests.  The
# TestCollector is responsible for populating this object.
#
# This class also facilitates all the exporting and importing of tests.
# ------------------------------------------------------------------------------
var CollectedTest = GutUtils.CollectedTest

var _lgr = null

# One entry per test found in the script.  Added externally by TestCollector
var tests = []
# One entry for before_all and after_all (maybe add before_each and after_each).
# These are added by Gut when running before_all and after_all for the script.
var setup_teardown_tests = []
var inner_class_name:StringName
var path:String


# Set externally by test_collector after it can verify that the script was
# actually loaded.  This could probably be changed to just hold the GutTest
# script that was loaded, cutting down on complexity elsewhere.
var is_loaded = false

# Set by Gut when it decides that a script should be skipped.
# Right now this is whenever the script has the variable skip_script declared.
# the value of skip_script is put into skip_reason.
var was_skipped = false
var skip_reason = ''
var was_run = false


var name = '' :
	get: return path
	set(val):pass


func _init(logger=null):
	_lgr = logger


func get_new():
	var inst = load_script().new()
	inst.collected_script = self
	return inst


func load_script():
	var to_return = load(path)

	if(inner_class_name != null and inner_class_name != ''):
		# If we wanted to do inner classes in inner classses
		# then this would have to become some kind of loop or recursive
		# call to go all the way down the chain or this class would
		# have to change to hold onto the loaded class instead of
		# just path information.
		to_return = to_return.get(inner_class_name)

	return to_return

# script.gd.InnerClass
func get_filename_and_inner():
	var to_return = get_filename()
	if(inner_class_name != ''):
		to_return += '.' + String(inner_class_name)
	return to_return


# res://foo/bar.gd.FooBar
func get_full_name():
	var to_return = path
	if(inner_class_name != ''):
		to_return += '.' + String(inner_class_name)
	return to_return


func get_filename():
	return path.get_file()


func has_inner_class():
	return inner_class_name != ''


# Note:  although this no longer needs to export the inner_class names since
#        they are pulled from metadata now, it is easier to leave that in
#        so we don't have to cut the export down to unique script names.
func export_to(config_file, section):
	config_file.set_value(section, 'path', path)
	config_file.set_value(section, 'inner_class', inner_class_name)
	var names = []
	for i in range(tests.size()):
		names.append(tests[i].name)
	config_file.set_value(section, 'tests', names)


func _remap_path(source_path):
	var to_return = source_path
	if(!FileAccess.file_exists(source_path)):
		_lgr.debug('Checking for remap for:  ' + source_path)
		var remap_path = source_path.get_basename() + '.gd.remap'
		if(FileAccess.file_exists(remap_path)):
			var cf = ConfigFile.new()
			cf.load(remap_path)
			to_return = cf.get_value('remap', 'path')
		else:
			_lgr.warn('Could not find remap file ' + remap_path)
	return to_return


func import_from(config_file, section):
	path = config_file.get_value(section, 'path')
	path = _remap_path(path)
	# Null is an acceptable value, but you can't pass null as a default to
	# get_value since it thinks you didn't send a default...then it spits
	# out red text.  This works around that.
	var inner_name = config_file.get_value(section, 'inner_class', 'Placeholder')
	if(inner_name != 'Placeholder'):
		inner_class_name = inner_name
	else: # just being explicit
		inner_class_name = StringName("")


func get_test_named(test_name):
	return GutUtils.search_array(tests, 'name', test_name)


func get_ran_test_count():
	var count = 0
	for t in tests:
		if(t.was_run):
			count += 1
	return count


func get_assert_count():
	var count = 0
	for t in tests:
		count += t.pass_texts.size()
		count += t.fail_texts.size()
	for t in setup_teardown_tests:
		count += t.pass_texts.size()
		count += t.fail_texts.size()
	return count


func get_pass_count():
	var count = 0
	for t in tests:
		count += t.pass_texts.size()
	for t in setup_teardown_tests:
		count += t.pass_texts.size()
	return count


func get_fail_count():
	var count = 0
	for t in tests:
		count += t.fail_texts.size()
	for t in setup_teardown_tests:
		count += t.fail_texts.size()
	return count


func get_pending_count():
	var count = 0
	for t in tests:
		count += t.pending_texts.size()
	return count


func get_passing_test_count():
	var count = 0
	for t in tests:
		if(t.is_passing()):
			count += 1
	return count


func get_failing_test_count():
	var count = 0
	for t in tests:
		if(t.is_failing()):
			count += 1
	return count


func get_risky_count():
	var count = 0
	if(was_skipped):
		count = 1
	else:
		for t in tests:
			if(t.is_risky()):
				count += 1
	return count


func to_s():
	var to_return = path
	if(inner_class_name != null):
		to_return += str('.', inner_class_name)
	to_return += "\n"
	for i in range(tests.size()):
		to_return += str('  ', tests[i].to_s())
	return to_return


--------------------------------------------------
FILE: res:///addons/gut/collected_test.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# Used to keep track of info about each test ran.
# ------------------------------------------------------------------------------
# the name of the function
var name = ""

# flag to know if the name has been printed yet.  Used by the logger.
var has_printed_name = false

# the number of arguments the method has
var arg_count = 0

# the time it took to execute the test in seconds
var time_taken : float = 0

# The number of asserts in the test.  Converted to a property for backwards
# compatibility.  This now reflects the text sizes instead of being a value
# that can be altered externally.
var assert_count = 0 :
	get: return pass_texts.size() + fail_texts.size()
	set(val): pass

# Converted to propety for backwards compatibility.  This now cannot be set
# externally
var pending = false :
	get: return is_pending()
	set(val): pass

# the line number when the test fails
var line_number = -1

# Set internally by Gut using whatever reason Gut wants to use to set this.
# Gut will skip these marked true and the test will be listed as risky.
var should_skip = false  # -- Currently not used by GUT don't believe ^

var pass_texts = []
var fail_texts = []
var pending_texts = []
var orphans = 0

var was_run = false

var collected_script : WeakRef = null


func did_pass():
	return is_passing()


func add_fail(fail_text):
	fail_texts.append(fail_text)


func add_pending(pending_text):
	pending_texts.append(pending_text)


func add_pass(passing_text):
	pass_texts.append(passing_text)


# must have passed an assert and not have any other status to be passing
func is_passing():
	return pass_texts.size() > 0 and fail_texts.size() == 0 and pending_texts.size() == 0


# failing takes precedence over everything else, so any failures makes the
# test a failure.
func is_failing():
	return fail_texts.size() > 0


# test is only pending if pending was called and the test is not failing.
func is_pending():
	return pending_texts.size() > 0 and fail_texts.size() == 0


func is_risky():
	return should_skip or (was_run and !did_something())


func did_something():
	return is_passing() or is_failing() or is_pending()


func get_status_text():
	var to_return = GutUtils.TEST_STATUSES.NO_ASSERTS

	if(should_skip):
		to_return = GutUtils.TEST_STATUSES.SKIPPED
	elif(!was_run):
		to_return = GutUtils.TEST_STATUSES.NOT_RUN
	elif(pending_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.PENDING
	elif(fail_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.FAILED
	elif(pass_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.PASSED

	return to_return


# Deprecated
func get_status():
	return get_status_text()


func to_s():
	var pad = '     '
	var to_return = str(name, "[", get_status_text(), "]\n")

	for i in range(fail_texts.size()):
		to_return += str(pad, 'Fail:  ', fail_texts[i])
	for i in range(pending_texts.size()):
		to_return += str(pad, 'Pending:  ', pending_texts[i], "\n")
	for i in range(pass_texts.size()):
		to_return += str(pad, 'Pass:  ', pass_texts[i], "\n")
	return to_return




--------------------------------------------------
FILE: res:///addons/gut/comparator.gd
--------------------------------------------------
var _strutils = GutUtils.Strutils.new()
var _max_length = 100
var _should_compare_int_to_float = true

const MISSING = '|__missing__gut__compare__value__|'


func _cannot_compare_text(v1, v2):
	return str('Cannot compare ', _strutils.types[typeof(v1)], ' with ',
		_strutils.types[typeof(v2)], '.')


func _make_missing_string(text):
	return '<missing ' + text + '>'


func _create_missing_result(v1, v2, text):
	var to_return = null
	var v1_str = format_value(v1)
	var v2_str = format_value(v2)

	if(typeof(v1) == TYPE_STRING and v1 == MISSING):
		v1_str = _make_missing_string(text)
		to_return = GutUtils.CompareResult.new()
	elif(typeof(v2) == TYPE_STRING and v2 == MISSING):
		v2_str = _make_missing_string(text)
		to_return = GutUtils.CompareResult.new()

	if(to_return != null):
		to_return.summary = str(v1_str, ' != ', v2_str)
		to_return.are_equal = false

	return to_return


func simple(v1, v2, missing_string=''):
	var missing_result = _create_missing_result(v1, v2, missing_string)
	if(missing_result != null):
		return missing_result

	var result = GutUtils.CompareResult.new()
	var cmp_str = null
	var extra = ''

	var tv1 = typeof(v1)
	var tv2 = typeof(v2)

	# print(tv1, '::', tv2, '   ', _strutils.types[tv1], '::', _strutils.types[tv2])
	if(_should_compare_int_to_float and [TYPE_INT, TYPE_FLOAT].has(tv1) and [TYPE_INT, TYPE_FLOAT].has(tv2)):
		result.are_equal = v1 == v2
	elif([TYPE_STRING, TYPE_STRING_NAME].has(tv1) and [TYPE_STRING, TYPE_STRING_NAME].has(tv2)):
		result.are_equal = v1 == v2
	elif(GutUtils.are_datatypes_same(v1, v2)):
		result.are_equal = v1 == v2

		if(typeof(v1) == TYPE_DICTIONARY or typeof(v1) == TYPE_ARRAY):
			var sub_result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
			result.summary = sub_result.get_short_summary()
			if(!sub_result.are_equal):
				extra = ".\n" + sub_result.get_short_summary()
	else:
		cmp_str = '!='
		result.are_equal = false
		extra = str('.  ', _cannot_compare_text(v1, v2))

	cmp_str = get_compare_symbol(result.are_equal)
	result.summary = str(format_value(v1), ' ', cmp_str, ' ', format_value(v2), extra)

	return result


func shallow(v1, v2):
	var result =  null
	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
		else:
			result = simple(v1, v2)
	else:
		result = simple(v1, v2)

	return result


func deep(v1, v2):
	var result =  null

	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
		else:
			result = simple(v1, v2)
	else:
		result = simple(v1, v2)

	return result


func format_value(val, max_val_length=_max_length):
	return _strutils.truncate_string(_strutils.type2str(val), max_val_length)


func compare(v1, v2, diff_type=GutUtils.DIFF.SIMPLE):
	var result = null
	if(diff_type == GutUtils.DIFF.SIMPLE):
		result = simple(v1, v2)
	elif(diff_type ==  GutUtils.DIFF.DEEP):
		result = deep(v1, v2)

	return result


func get_should_compare_int_to_float():
	return _should_compare_int_to_float


func set_should_compare_int_to_float(should_compare_int_float):
	_should_compare_int_to_float = should_compare_int_float


func get_compare_symbol(is_equal):
	if(is_equal):
		return '=='
	else:
		return '!='


--------------------------------------------------
FILE: res:///addons/gut/compare_result.gd
--------------------------------------------------
var _are_equal = false
var are_equal = false :
	get:
		return get_are_equal()
	set(val):
		set_are_equal(val)

var _summary = null
var summary = null :
	get:
		return get_summary()
	set(val):
		set_summary(val)

var _max_differences = 30
var max_differences = 30 :
	get:
		return get_max_differences()
	set(val):
		set_max_differences(val)

var _differences = {}
var differences :
	get:
		return get_differences()
	set(val):
		set_differences(val)

func _block_set(which, val):
	push_error(str('cannot set ', which, ', value [', val, '] ignored.'))

func _to_string():
	return str(get_summary()) # could be null, gotta str it.

func get_are_equal():
	return _are_equal

func set_are_equal(r_eq):
	_are_equal = r_eq

func get_summary():
	return _summary

func set_summary(smry):
	_summary = smry

func get_total_count():
	pass

func get_different_count():
	pass

func get_short_summary():
	return summary

func get_max_differences():
	return _max_differences

func set_max_differences(max_diff):
	_max_differences = max_diff

func get_differences():
	return _differences

func set_differences(diffs):
	_block_set('differences', diffs)

func get_brackets():
	return null



--------------------------------------------------
FILE: res:///addons/gut/diff_formatter.gd
--------------------------------------------------
var _strutils = GutUtils.Strutils.new()
const INDENT = '    '
var _max_to_display = 30
const ABSOLUTE_MAX_DISPLAYED = 10000
const UNLIMITED = -1


func _single_diff(diff, depth=0):
	var to_return = ""
	var brackets = diff.get_brackets()

	if(brackets != null and !diff.are_equal):
		to_return = ''
		to_return += str(brackets.open, "\n",
			_strutils.indent_text(differences_to_s(diff.differences, depth), depth+1, INDENT), "\n",
			brackets.close)
	else:
		to_return = str(diff)

	return to_return


func make_it(diff):
	var to_return = ''
	if(diff.are_equal):
		to_return = diff.summary
	else:
		if(_max_to_display ==  ABSOLUTE_MAX_DISPLAYED):
			to_return = str(diff.get_value_1(), ' != ', diff.get_value_2())
		else:
			to_return = diff.get_short_summary()
		to_return +=  str("\n", _strutils.indent_text(_single_diff(diff, 0), 1, '  '))
	return to_return


func differences_to_s(differences, depth=0):
	var to_return = ''
	var keys = differences.keys()
	keys.sort()
	var limit = min(_max_to_display, differences.size())

	for i in range(limit):
		var key = keys[i]
		to_return += str(key, ":  ", _single_diff(differences[key], depth))

		if(i != limit -1):
			to_return += "\n"

	if(differences.size() > _max_to_display):
		to_return += str("\n\n... ", differences.size() - _max_to_display, " more.")

	return to_return


func get_max_to_display():
	return _max_to_display


func set_max_to_display(max_to_display):
	_max_to_display = max_to_display
	if(_max_to_display == UNLIMITED):
		_max_to_display = ABSOLUTE_MAX_DISPLAYED



--------------------------------------------------
FILE: res:///addons/gut/diff_tool.gd
--------------------------------------------------
extends 'res://addons/gut/compare_result.gd'
const INDENT = '    '
enum {
	DEEP,
	SIMPLE
}

var _strutils = GutUtils.Strutils.new()
var _compare = GutUtils.Comparator.new()

var _value_1 = null
var _value_2 = null
var _total_count = 0
var _diff_type = null
var _brackets = null
var _valid = true
var _desc_things = 'somethings'

# -------- comapre_result.gd "interface" ---------------------
func set_are_equal(val):
	_block_set('are_equal', val)

func get_are_equal():
	if(!_valid):
		return null
	else:
		return differences.size() == 0


func set_summary(val):
	_block_set('summary', val)

func get_summary():
	return summarize()

func get_different_count():
	return differences.size()

func  get_total_count():
	return _total_count

func get_short_summary():
	var text = str(_strutils.truncate_string(str(_value_1), 50),
		' ', _compare.get_compare_symbol(are_equal), ' ',
		_strutils.truncate_string(str(_value_2), 50))
	if(!are_equal):
		text += str('  ', get_different_count(), ' of ', get_total_count(),
			' ', _desc_things, ' do not match.')
	return text

func get_brackets():
	return _brackets
# -------- comapre_result.gd "interface" ---------------------


func _invalidate():
	_valid = false
	differences = null


func _init(v1,v2,diff_type=DEEP):
	_value_1 = v1
	_value_2 = v2
	_diff_type = diff_type
	_compare.set_should_compare_int_to_float(false)
	_find_differences(_value_1, _value_2)


func _find_differences(v1, v2):
	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) == TYPE_ARRAY):
			_brackets = {'open':'[', 'close':']'}
			_desc_things = 'indexes'
			_diff_array(v1, v2)
		elif(typeof(v2) == TYPE_DICTIONARY):
			_brackets = {'open':'{', 'close':'}'}
			_desc_things = 'keys'
			_diff_dictionary(v1, v2)
		else:
			_invalidate()
			GutUtils.get_logger().error('Only Arrays and Dictionaries are supported.')
	else:
		_invalidate()
		GutUtils.get_logger().error('Only Arrays and Dictionaries are supported.')


func _diff_array(a1, a2):
	_total_count = max(a1.size(), a2.size())
	for i in range(a1.size()):
		var result = null
		if(i < a2.size()):
			if(_diff_type == DEEP):
				result = _compare.deep(a1[i], a2[i])
			else:
				result = _compare.simple(a1[i], a2[i])
		else:
			result = _compare.simple(a1[i], _compare.MISSING, 'index')

		if(!result.are_equal):
			differences[i] = result

	if(a1.size() < a2.size()):
		for i in range(a1.size(), a2.size()):
			differences[i] = _compare.simple(_compare.MISSING, a2[i], 'index')


func _diff_dictionary(d1, d2):
	var d1_keys = d1.keys()
	var d2_keys = d2.keys()

	# Process all the keys in d1
	_total_count += d1_keys.size()
	for key in d1_keys:
		if(!d2.has(key)):
			differences[key] = _compare.simple(d1[key], _compare.MISSING, 'key')
		else:
			d2_keys.remove_at(d2_keys.find(key))

			var result = null
			if(_diff_type == DEEP):
				result = _compare.deep(d1[key], d2[key])
			else:
				result = _compare.simple(d1[key], d2[key])

			if(!result.are_equal):
				differences[key] = result

	# Process all the keys in d2 that didn't exist in d1
	_total_count += d2_keys.size()
	for i in range(d2_keys.size()):
		differences[d2_keys[i]] = _compare.simple(_compare.MISSING, d2[d2_keys[i]], 'key')


func summarize():
	var summary = ''

	if(are_equal):
		summary = get_short_summary()
	else:
		var formatter = load('res://addons/gut/diff_formatter.gd').new()
		formatter.set_max_to_display(max_differences)
		summary = formatter.make_it(self)

	return summary


func get_diff_type():
	return _diff_type


func get_value_1():
	return _value_1


func get_value_2():
	return _value_2


--------------------------------------------------
FILE: res:///addons/gut/double_tools.gd
--------------------------------------------------
var thepath = ''
var subpath = ''
var from_singleton = null
var is_partial = null

var double_ref : WeakRef = null
var stubber_ref : WeakRef = null
var spy_ref : WeakRef = null
var gut_ref : WeakRef = null

const NO_DEFAULT_VALUE = '!__gut__no__default__value__!'
func _init(double = null):
	if(double != null):
		var values = double.__gutdbl_values
		double_ref = weakref(double)
		thepath = values.thepath
		subpath = values.subpath
		stubber_ref = weakref_from_id(values.stubber)
		spy_ref = weakref_from_id(values.spy)
		gut_ref = weakref_from_id(values.gut)
		from_singleton = values.from_singleton
		is_partial = values.is_partial

		if(gut_ref.get_ref() != null):
			gut_ref.get_ref().get_autofree().add_free(double_ref.get_ref())


func _get_stubbed_method_to_call(method_name, called_with):
	var method = stubber_ref.get_ref().get_call_this(double_ref.get_ref(), method_name, called_with)
	if(method != null):
		method = method.bindv(called_with)
		return method
	return method


func weakref_from_id(inst_id):
	if(inst_id ==  -1):
		return weakref(null)
	else:
		return weakref(instance_from_id(inst_id))


func is_stubbed_to_call_super(method_name, called_with):
	if(stubber_ref.get_ref() != null):
		return stubber_ref.get_ref().should_call_super(double_ref.get_ref(), method_name, called_with)
	else:
		return false


func handle_other_stubs(method_name, called_with):
	if(stubber_ref.get_ref() == null):
		return

	var method = _get_stubbed_method_to_call(method_name, called_with)
	if(method != null):
		return await method.call()
	else:
		return stubber_ref.get_ref().get_return(double_ref.get_ref(), method_name, called_with)


func spy_on(method_name, called_with):
	if(spy_ref.get_ref() != null):
		spy_ref.get_ref().add_call(double_ref.get_ref(), method_name, called_with)


func default_val(method_name, p_index):
	if(stubber_ref.get_ref() == null):
		return null
	else:
		return stubber_ref.get_ref().get_default_value(double_ref.get_ref(), method_name, p_index)


--------------------------------------------------
FILE: res:///addons/gut/doubler.gd
--------------------------------------------------
extends RefCounted


var _base_script_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/script_template.txt')
var _script_collector = GutUtils.ScriptCollector.new()
# used by tests for debugging purposes.
var print_source = false
var inner_class_registry = GutUtils.InnerClassRegistry.new()

# ###############
# Properties
# ###############
var _stubber = GutUtils.Stubber.new()
func get_stubber():
	return _stubber
func set_stubber(stubber):
	_stubber = stubber

var _lgr = GutUtils.get_logger()
func get_logger():
	return _lgr
func set_logger(logger):
	_lgr = logger
	_method_maker.set_logger(logger)

var _spy = null
func get_spy():
	return _spy
func set_spy(spy):
	_spy = spy

var _gut = null
func get_gut():
	return _gut
func set_gut(gut):
	_gut = gut

var _strategy = null
func get_strategy():
	return _strategy
func set_strategy(strategy):
	if(GutUtils.DOUBLE_STRATEGY.values().has(strategy)):
		_strategy = strategy
	else:
		_lgr.error(str('doubler.gd:  invalid double strategy ', strategy))


var _method_maker = GutUtils.MethodMaker.new()
func get_method_maker():
	return _method_maker

var _ignored_methods = GutUtils.OneToMany.new()
func get_ignored_methods():
	return _ignored_methods

# ###############
# Private
# ###############
func _init(strategy=GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY):
	set_logger(GutUtils.get_logger())
	_strategy = strategy


func _get_indented_line(indents, text):
	var to_return = ''
	for _i in range(indents):
		to_return += "\t"
	return str(to_return, text, "\n")


func _stub_to_call_super(parsed, method_name):
	if(!parsed.get_method(method_name).is_eligible_for_doubling()):
		return

	var params = GutUtils.StubParams.new(parsed.script_path, method_name, parsed.subpath)
	params.to_call_super()
	_stubber.add_stub(params)


func _get_base_script_text(parsed, override_path, partial, included_methods):
	var path = parsed.script_path
	if(override_path != null):
		path = override_path

	var stubber_id = -1
	if(_stubber != null):
		stubber_id = _stubber.get_instance_id()

	var spy_id = -1
	if(_spy != null):
		spy_id = _spy.get_instance_id()

	var gut_id = -1
	if(_gut != null):
		gut_id = _gut.get_instance_id()

	var extends_text  = parsed.get_extends_text()

	var values = {
		# Top  sections
		"extends":extends_text,
		"constants":'',#obj_info.get_constants_text(),
		"properties":'',#obj_info.get_properties_text(),

		# metadata values
		"path":path,
		"subpath":GutUtils.nvl(parsed.subpath, ''),
		"stubber_id":stubber_id,
		"spy_id":spy_id,
		"gut_id":gut_id,
		"singleton_name":'',#GutUtils.nvl(obj_info.get_singleton_name(), ''),
		"is_partial":partial,
		"doubled_methods":included_methods,
	}

	return _base_script_text.format(values)


func _is_method_eligible_for_doubling(parsed_script, parsed_method):
	return !parsed_method.is_accessor() and \
		parsed_method.is_eligible_for_doubling() and \
		!_ignored_methods.has(parsed_script.resource, parsed_method.meta.name)


# Disable the native_method_override setting so that doubles do not generate
# errors or warnings when doubling with INCLUDE_NATIVE or when a method has
# been added because of param_count stub.
func _create_script_no_warnings(src):
	var prev_native_override_value = null
	var native_method_override = 'debug/gdscript/warnings/native_method_override'
	prev_native_override_value = ProjectSettings.get_setting(native_method_override)
	ProjectSettings.set_setting(native_method_override, 0)

	var DblClass = GutUtils.create_script_from_source(src)

	ProjectSettings.set_setting(native_method_override, prev_native_override_value)
	return DblClass


func _create_double(parsed, strategy, override_path, partial):
	var dbl_src = ""
	var included_methods = []

	for method in parsed.get_local_methods():
		if(_is_method_eligible_for_doubling(parsed, method)):
			included_methods.append(method.meta.name)
			dbl_src += _get_func_text(method.meta)

	if(strategy == GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE):
		for method in parsed.get_super_methods():
			if(_is_method_eligible_for_doubling(parsed, method)):
				included_methods.append(method.meta.name)
				_stub_to_call_super(parsed, method.meta.name)
				dbl_src += _get_func_text(method.meta)

	var base_script = _get_base_script_text(parsed, override_path, partial, included_methods)
	dbl_src = base_script + "\n\n" + dbl_src

	if(print_source):
		var to_print :String = GutUtils.add_line_numbers(dbl_src)
		to_print = to_print.rstrip("\n")
		_lgr.log(str(to_print))

	var DblClass = _create_script_no_warnings(dbl_src)
	if(_stubber != null):
		_stub_method_default_values(DblClass, parsed, strategy)

	if(print_source):
		_lgr.log(str("  path | ", DblClass.resource_path, "\n"))

	return DblClass


func _stub_method_default_values(which, parsed, strategy):
	for method in parsed.get_local_methods():
		if(method.is_eligible_for_doubling() and !_ignored_methods.has(parsed.resource, method.meta.name)):
			_stubber.stub_defaults_from_meta(parsed.script_path, method.meta)


func _double_scene_and_script(scene, strategy, partial):
	var dbl_bundle = scene._bundled.duplicate(true)
	var script_obj = GutUtils.get_scene_script_object(scene)
	# I'm not sure if the script object for the root node of a packed scene is
	# always the first entry in "variants" so this tries to find it.
	var script_index = dbl_bundle["variants"].find(script_obj)
	var script_dbl = null

	if(script_obj != null):
		if(partial):
			script_dbl = _partial_double(script_obj, strategy, scene.get_path())
		else:
			script_dbl = _double(script_obj, strategy, scene.get_path())

	if(script_index != -1):
		dbl_bundle["variants"][script_index] = script_dbl

	var doubled_scene = PackedScene.new()
	doubled_scene._set_bundled_scene(dbl_bundle)

	return doubled_scene


func _get_inst_id_ref_str(inst):
	var ref_str = 'null'
	if(inst):
		ref_str = str('instance_from_id(', inst.get_instance_id(),')')
	return ref_str


func _get_func_text(method_hash):
	return _method_maker.get_function_text(method_hash) + "\n"


func _parse_script(obj):
	var parsed = null

	if(GutUtils.is_inner_class(obj)):
		if(inner_class_registry.has(obj)):
			parsed = _script_collector.parse(inner_class_registry.get_base_resource(obj), obj)
		else:
			_lgr.error('Doubling Inner Classes requires you register them first.  Call register_inner_classes passing the script that contains the inner class.')
	else:
		parsed = _script_collector.parse(obj)

	return parsed


# Override path is used with scenes.
func _double(obj, strategy, override_path=null):
	var parsed = _parse_script(obj)
	if(parsed != null):
		return _create_double(parsed, strategy, override_path, false)


func _partial_double(obj, strategy, override_path=null):
	var parsed = _parse_script(obj)
	if(parsed != null):
		return _create_double(parsed, strategy, override_path, true)


# -------------------------
# Public
# -------------------------

# double a script/object
func double(obj, strategy=_strategy):
	return _double(obj, strategy)

func partial_double(obj, strategy=_strategy):
	return _partial_double(obj, strategy)


# double a scene
func double_scene(scene, strategy=_strategy):
	return _double_scene_and_script(scene, strategy, false)


func partial_double_scene(scene, strategy=_strategy):
	return _double_scene_and_script(scene, strategy, true)


func double_gdnative(which):
	return _double(which, GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE)


func partial_double_gdnative(which):
	return _partial_double(which, GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE)


func double_inner(parent, inner, strategy=_strategy):
	var parsed = _script_collector.parse(parent, inner)
	return _create_double(parsed, strategy, null, false)


func partial_double_inner(parent, inner, strategy=_strategy):
	var parsed = _script_collector.parse(parent, inner)
	return _create_double(parsed, strategy, null, true)


func add_ignored_method(obj, method_name):
	_ignored_methods.add(obj, method_name)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/dynamic_gdscript.gd
--------------------------------------------------
@tool
var default_script_name_no_extension = 'gut_dynamic_script'
var default_script_resource_path = 'res://addons/gut/not_a_real_file/'
var default_script_extension = "gd"

var _created_script_count = 0


# Creates a loaded script from the passed in source.  This loaded script is
# returned unless there is an error.  When an error occcurs the error number
# is returned instead.
func create_script_from_source(source, override_path=null):
	_created_script_count += 1
	var r_path = str(default_script_resource_path,
		default_script_name_no_extension, '_', _created_script_count, ".",
		default_script_extension)

	if(override_path != null):
		r_path = override_path

	var DynamicScript = GDScript.new()
	DynamicScript.source_code = source.dedent()
	# The resource_path must be unique or Godot thinks it is trying
	# to load something it has already loaded and generates an error like
	# ERROR: Another resource is loaded from path 'workaround for godot
	# issue #65263' (possible cyclic resource inclusion).
	DynamicScript.resource_path = r_path
	var result = DynamicScript.reload()
	if(result != OK):
		DynamicScript = result

	return DynamicScript



--------------------------------------------------
FILE: res:///addons/gut/editor_caret_context_notifier.gd
--------------------------------------------------
@tool
extends Node
# ##############################################################################
#
# Watches script editors and emits a signal whenever the method, inner class,
# or script changes based on cursor position and other stuff.
#
# Basically, whenever this thing's signal is emitted, then the RunAtCursor
# buttons should be updated to match the data passed to the signal.
# ##############################################################################
# In the editor, whenever a script is opened you get these new things that
# hang off of EditorInterface.get_script_editor()
# 	* ScriptEditorBase
#		* CodeEdit
# ##############################################################################


var _last_info : Dictionary = {}
var _last_line = -1
# This is the control that holds all the individual editors.
var _current_script_editor : ScriptEditor = null
# Reference to the GDScript for the last script we were notified about.
var _current_script = null
var _current_script_is_test_script = false
var _current_editor_base : ScriptEditorBase = null
var _current_editor : CodeEdit = null
# Quick lookup of editors based on the current script.
var _editors_for_scripts : Dictionary= {}


# In order to keep the data that comes back from the emitted signal way more
# usable, we have to know what GUT looks for for an inner-test-class prefix.
# If we didn't do this, then this thing would have to return all the inner
# classes and then we'd have to determine if we were in an inner-test-class
# outside of here by traversing all the classes returned.  It makes this thing
# less generic and know too much, but this is probably already too generic as
# it is.
var inner_class_prefix = "Test"
var method_prefix = "test_"
var script_prefix = "test_"
var script_suffix = ".gd"


# Based on cursor and open editors, this will be emitted.  You do what you
# want with it.
signal it_changed(change_data)


func _ready():
	# This will not change, and should not change, over the course of a session.
	_current_script_editor = EditorInterface.get_script_editor()
	_current_script_editor.editor_script_changed.connect(_on_editor_script_changed)
	_current_script_editor.script_close.connect(_on_editor_script_close)


func _handle_caret_location(which):
	var current_line = which.get_caret_line(0) + 1
	if(_last_line != current_line):
		_last_line = current_line

		if(_current_script_is_test_script):
			var new_info = _make_info(which, _current_script, _current_script_is_test_script)
			if(_last_info != new_info):
				_last_info = new_info
				it_changed.emit(_last_info.duplicate())


func _get_func_name_from_line(text):
	text = text.strip_edges()
	var left = text.split("(")[0]
	var func_name = left.split(" ")[1]
	return func_name


func _get_class_name_from_line(text):
	text = text.strip_edges()
	var right = text.split(" ")[1]
	var the_name = right.rstrip(":")
	return the_name


func _make_info(editor, script, test_script_flag):
	if(editor == null):
		return

	var info = {
		script = script,
		inner_class = null,
		method = null,
		is_test_script = test_script_flag
	}

	var start_line = editor.get_caret_line()
	var line = start_line
	var done_func = false
	var done_inner = false
	while(line > 0 and (!done_func or !done_inner)):
		if(editor.can_fold_line(line)):
			var text = editor.get_line(line)
			var strip_text = text.strip_edges(true, false) # only left

			if(!done_func and strip_text.begins_with("func ")):
				info.method = _get_func_name_from_line(text)
				done_func = true
				# If the func line is left justified then there won't be any
				# inner classes above it.
				if(editor.get_indent_level(line) == 0):
					done_inner = true

			if(!done_inner and strip_text.begins_with("class")):
				var inner_name = _get_class_name_from_line(text)
				# See note about inner_class_prefix, this knows too much, but
				# if it was to know less it would insanely more difficult
				# everywhere.
				if(inner_name.begins_with(inner_class_prefix)):
					info.inner_class = inner_name
					done_inner = true
					done_func = true
		line -= 1

	# print('parsed lines:  ', start_line - line, '(', info.inner_class, ':', info.method, ')')
	return info
# -------------
# Events
# -------------

# Fired whenever the script changes.  This does not fire if you select something
# other than a script from the tree.  So if you click a help file and then
# back to the same file, then this will fire for the same script
#
# This can fire multiple times for the same script when a script is opened.
func _on_editor_script_changed(script):
	_last_line = -1
	_current_script = script
	_current_editor_base = _current_script_editor.get_current_editor()
	if(_current_editor_base.get_base_editor() is CodeEdit):
		_current_editor = _current_editor_base.get_base_editor()
		if(!_current_editor.caret_changed.is_connected(_on_caret_changed)):
			_current_editor.caret_changed.connect(_on_caret_changed.bind(_current_editor))
	else:
		_current_editor = null
	_editors_for_scripts[script] = _current_editor
	_current_script_is_test_script = is_test_script(_current_script)

	_handle_caret_location(_current_editor)


func _on_editor_script_close(script):
	var script_editor = _editors_for_scripts.get(script, null)
	if(script_editor != null):
		if(script_editor.caret_changed.is_connected(_on_caret_changed)):
			script_editor.caret_changed.disconnect(_on_caret_changed)
			_editors_for_scripts.erase(script)


func _on_caret_changed(which):
	# Sometimes this is fired for editors that are not the current.  I could
	# make this fire by saving a file in an external editor.  I was unable to
	# get useful data out when it wasn't the current editor so I'm only doing
	# anything when it is the current editor.
	if(which == _current_editor):
		_handle_caret_location(which)


func _could_be_test_script(script):
	return 	script.resource_path.get_file().begins_with(script_prefix) and \
		script.resource_path.get_file().ends_with(script_suffix)

# -------------
# Public
# -------------
var _scripts_that_have_been_warned_about = []
var _we_have_warned_enough = false
var _max_warnings = 5
func is_test_script(script):
	var base = script.get_base_script()
	if(base == null and script.get_script_method_list().size() == 0 and _could_be_test_script(script)):
		if(OS.is_stdout_verbose() or (!_scripts_that_have_been_warned_about.has(script.resource_path) and !_we_have_warned_enough)):
			_scripts_that_have_been_warned_about.append(script.resource_path)
			push_warning(str('[GUT] Treating ', script.resource_path, " as test script:  ",
				"GUT was not able to retrieve information about this script.  If this is ",
				"a new script you can ignore this warning.  Otherwise, this may ",
				"have to do with having VSCode open.  Restarting Godot sometimes helps.  See ",
				"https://github.com/bitwes/Gut/issues/754"))
			if(!OS.is_stdout_verbose() and _scripts_that_have_been_warned_about.size() >= _max_warnings):
				print("[GUT] Disabling warning.")
				_we_have_warned_enough = true

		# We can't know if this is a test script.  It's more usable if we
		# assume this is a test script.
		return true
	else:
		while(base and base.resource_path != 'res://addons/gut/test.gd'):
			base = base.get_base_script()
		return base != null


func get_info():
	return _last_info.duplicate()


func log_values():
	print("---------------------------------------------------------------")
	print("script                   ", _current_script)
	print("script_editor            ", _current_script_editor)
	print("editor_base              ", _current_editor_base)
	print("editor                   ", _current_editor)


--------------------------------------------------
FILE: res:///addons/gut/error_tracker.gd
--------------------------------------------------
extends Logger
class_name GutErrorTracker

# ------------------------------------------------------------------------------
# Static methods wrap around add/remove logger to make disabling the logger
# easier and to help avoid misusing add/remove in tests.  If GUT needs to
# add/remove a logger then this is how it should do it.
# ------------------------------------------------------------------------------
static var registered_loggers := {}
static var register_loggers = true

static func register_logger(which):
	if(register_loggers and !registered_loggers.has(which)):
		OS.add_logger(which)
		registered_loggers[which] = get_stack()


static func deregister_logger(which):
	if(registered_loggers.has(which)):
		OS.remove_logger(which)
		registered_loggers.erase(which)




# ------------------------------------------------------------------------------
# GutErrorTracker
# ------------------------------------------------------------------------------
var _current_test_id = GutUtils.NO_TEST
var _mutex = Mutex.new()

var errors = GutUtils.OneToMany.new()

var treat_gut_errors_as : GutUtils.TREAT_AS = GutUtils.TREAT_AS.FAILURE
var treat_engine_errors_as : GutUtils.TREAT_AS = GutUtils.TREAT_AS.FAILURE
var treat_push_error_as : GutUtils.TREAT_AS = GutUtils.TREAT_AS.FAILURE
var disabled = false


# ----------------
#region Private
# ----------------

func _get_stack_data(current_test_name):
	var test_entry = {}
	var stackTrace = get_stack()

	if(stackTrace!=null):
		var index = 0
		while(index < stackTrace.size() and test_entry == {}):
			var line = stackTrace[index]
			var function = line.get("function")
			if function == current_test_name:
				test_entry = stackTrace[index]
			else:
				index += 1

		for i in range(index):
			stackTrace.remove_at(0)

	return {
		"test_entry" = test_entry,
		"full_stack" = stackTrace
	}


func _is_error_failable(error : GutTrackedError):
	var is_it = false
	if(error.handled == false):
		if(error.is_gut_error()):
			is_it = treat_gut_errors_as == GutUtils.TREAT_AS.FAILURE
		elif(error.is_push_error()):
			is_it = treat_push_error_as == GutUtils.TREAT_AS.FAILURE
		elif(error.is_engine_error()):
			is_it = treat_engine_errors_as == GutUtils.TREAT_AS.FAILURE
	return is_it

# ----------------
#endregion
#region Godot's Logger Overrides
# ----------------

# Godot's Logger virtual method for errors
func _log_error(function: String, file: String, line: int,
	code: String, rationale: String, editor_notify: bool,
	error_type: int, script_backtraces: Array[ScriptBacktrace]) -> void:

		add_error(function, file, line,
			code, rationale, editor_notify,
			error_type, script_backtraces)

# Godot's Logger virtual method for any output?
# func _log_message(message: String, error: bool) -> void:
# 	pass

# ----------------
#endregion
#region Public
# ----------------

func start_test(test_id):
	_current_test_id = test_id


func end_test():
	_current_test_id = GutUtils.NO_TEST


func did_test_error(test_id=_current_test_id):
	return errors.size(test_id) > 0


func get_current_test_errors():
	return errors.items.get(_current_test_id, [])


# This should look through all the errors for a test and see if a failure
# should happen based off of flags.
func should_test_fail_from_errors(test_id = _current_test_id):
	var to_return = false
	if(errors.items.has(test_id)):
		var errs = errors.items[test_id]
		var index = 0
		while(index < errs.size() and !to_return):
			var error = errs[index]
			to_return = _is_error_failable(error)
			index += 1
	return to_return


func get_errors_for_test(test_id=_current_test_id):
	var to_return = []
	if(errors.items.has(test_id)):
		to_return = errors.items[test_id].duplicate()

	return to_return


# Returns emtpy string or text for errors that occurred during the test that
# should cause failure based on this class' flags.
func get_fail_text_for_errors(test_id=_current_test_id) -> String:
	var error_texts = []

	if(errors.items.has(test_id)):
		for error in errors.items[test_id]:
			if(_is_error_failable(error)):
				error_texts.append(str('<', error.get_error_type_name(), '>', error.code))

	var to_return = ""
	for i in error_texts.size():
		if(to_return != ""):
			to_return += "\n"
		to_return += str("[", i + 1, "] ", error_texts[i])

	return to_return


func add_gut_error(text) -> GutTrackedError:
	if(_current_test_id != GutUtils.NO_TEST):
		var data = _get_stack_data(_current_test_id)
		if(data.test_entry != {}):
			return add_error(_current_test_id, data.test_entry.source, data.test_entry.line,
				text, '', false,
				GutUtils.GUT_ERROR_TYPE, data.full_stack)

	return add_error(_current_test_id, "unknown", -1,
		text, '', false,
		GutUtils.GUT_ERROR_TYPE, get_stack())


func add_error(function: String, file: String, line: int,
	code: String, rationale: String, editor_notify: bool,
	error_type: int, script_backtraces: Array) -> GutTrackedError:
		if(disabled):
			return

		_mutex.lock()

		var err := GutTrackedError.new()
		err.backtrace = script_backtraces
		err.code = code
		err.rationale = rationale
		err.error_type = error_type
		err.editor_notify = editor_notify
		err.file = file
		err.function = function
		err.line = line

		errors.add(_current_test_id, err)

		_mutex.unlock()

		return err


--------------------------------------------------
FILE: res:///addons/gut/get_editor_interface.gd
--------------------------------------------------
# This file is here so we can load it only when we are in the editor so that
# other places do not have to have "EditorInterface" in them, which causes a
# parser error when loaded outside of the editor.  The things we have to do in
# order to test things is annoying.
func get_it():
	return EditorInterface

--------------------------------------------------
FILE: res:///addons/gut/gui/EditorRadioButton.tres
--------------------------------------------------
[gd_resource type="Theme" load_steps=3 format=3 uid="uid://dssgvu257o1si"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_u716c"]
bg_color = Color(0.43137255, 0.8784314, 0.6156863, 0.5254902)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ht2pf"]
bg_color = Color(0, 0.44705883, 0.23921569, 1)

[resource]
Button/colors/font_hover_pressed_color = Color(1, 1, 1, 1)
Button/colors/font_pressed_color = Color(1, 1, 1, 1)
Button/styles/hover = SubResource("StyleBoxFlat_u716c")
Button/styles/pressed = SubResource("StyleBoxFlat_ht2pf")


--------------------------------------------------
FILE: res:///addons/gut/gui/GutBottomPanel.gd
--------------------------------------------------
@tool
extends Control

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var GutConfigGui = load('res://addons/gut/gui/gut_config_gui.gd')
var AboutWindow = load("res://addons/gut/gui/about.tscn")

var _interface = null;
var _is_running = false :
	set(val):
		_is_running = val
		_disable_run_buttons(_is_running)

var _gut_config = load('res://addons/gut/gut_config.gd').new()
var _gut_config_gui = null
var _gut_plugin = null
var _light_color = Color(0, 0, 0, .5) :
	set(val):
		_light_color = val
		if(is_inside_tree()):
			_ctrls.light.queue_redraw()
var _panel_button = null
var _user_prefs = null
var _shell_out_panel = null


var menu_manager = null :
	set(val):
		menu_manager = val
		if(val != null):
			_apply_shortcuts()
			menu_manager.toggle_windowed.connect(_on_toggle_windowed)
			menu_manager.about.connect(show_about)
			menu_manager.run_all.connect(_run_all)
			menu_manager.show_gut.connect(_on_show_gut)


@onready var _ctrls = {
	about = %ExtraButtons/About,
	light = %StatusIndicator,
	output_button = %ExtraButtons/OutputBtn,
	run_button = $layout/ControlBar/RunAll,
	run_externally_dialog = $ShellOutOptions,
	run_mode = %ExtraButtons/RunMode,
	run_at_cursor = $layout/ControlBar/RunAtCursor,
	run_results_button = %ExtraButtons/RunResultsBtn,
	settings = $layout/RSplit/sc/Settings,
	settings_button = %ExtraButtons/Settings,
	shortcut_dialog = $ShortcutDialog,
	shortcuts_button = %ExtraButtons/Shortcuts,

	results = {
		bar = $layout/ControlBar2,
		errors = %errors_value,
		failing = %failing_value,
		orphans = %orphans_value,
		passing = %passing_value,
		pending = %pending_value,
		warnings = %warnings_value,
	},
}

@onready var results_v_split = %VSplitResults
@onready var results_h_split = %HSplitResults
@onready var results_tree = %RunResults
@onready var results_text = %OutputText
@onready var make_floating_btn = %MakeFloating


func _ready():
	if(get_parent() is SubViewport):
		return

	GutEditorGlobals.create_temp_directory()

	_user_prefs = GutEditorGlobals.user_prefs
	_gut_config_gui = GutConfigGui.new(_ctrls.settings)

	_ctrls.results.bar.connect('draw', _on_results_bar_draw.bind(_ctrls.results.bar))
	hide_settings(!_ctrls.settings_button.button_pressed)

	_gut_config.load_options(GutEditorGlobals.editor_run_gut_config_path)
	_gut_config_gui.set_options(_gut_config.options)

	_ctrls.shortcuts_button.icon = get_theme_icon('Shortcut', 'EditorIcons')
	_ctrls.settings_button.icon = get_theme_icon('Tools', 'EditorIcons')
	_ctrls.run_results_button.icon = get_theme_icon('AnimationTrackGroup', 'EditorIcons') # Tree
	_ctrls.output_button.icon = get_theme_icon('Font', 'EditorIcons')
	make_floating_btn.icon = get_theme_icon("MakeFloating", 'EditorIcons')
	make_floating_btn.text = ''
	_ctrls.about.icon = get_theme_icon('Info', 'EditorIcons')
	_ctrls.about.text = ''
	_ctrls.run_mode.icon = get_theme_icon("ViewportSpeed", 'EditorIcons')

	results_tree.set_output_control(results_text)

	var check_import = load('res://addons/gut/images/HSplitContainer.svg')
	if(check_import == null):
		results_tree.add_centered_text("GUT got some new images that are not imported yet.  Please restart Godot.")
		print('GUT got some new images that are not imported yet.  Please restart Godot.')
	else:
		results_tree.add_centered_text("Let's run some tests!")

	_ctrls.run_externally_dialog.load_from_file()
	_apply_options_to_controls()

	results_vert_layout()


func _process(_delta):
	if(_is_running):
		if(_ctrls.run_externally_dialog.should_run_externally()):
			if(!is_instance_valid(_shell_out_panel)):
				_is_running = false
				show_me()
		elif(!_interface.is_playing_scene()):
			_is_running = false
			results_text.add_text("\ndone")
			load_result_output()
			show_me()


# ---------------
# Private
# ---------------
func _apply_options_to_controls():
	hide_settings(_user_prefs.hide_settings.value)
	hide_result_tree(_user_prefs.hide_result_tree.value)
	hide_output_text(_user_prefs.hide_output_text.value)
	results_tree.set_show_orphans(!_gut_config.options.hide_orphans)
	var shell_dialog_size = _user_prefs.run_externally_options_dialog_size.value

	if(shell_dialog_size != Vector2i(-1, -1)):
		_ctrls.run_externally_dialog.size = Vector2i(shell_dialog_size)

	if(_user_prefs.shortcuts_dialog_size.value != Vector2i(-1, -1)):
		_ctrls.shortcut_dialog.size = _user_prefs.shortcuts_dialog_size.value

	var mode_ind = 'Ed'
	if(_ctrls.run_externally_dialog.run_mode == _ctrls.run_externally_dialog.RUN_MODE_BLOCKING):
		mode_ind = 'ExB'
	elif(_ctrls.run_externally_dialog.run_mode == _ctrls.run_externally_dialog.RUN_MODE_NON_BLOCKING):
		mode_ind = 'ExN'
	_ctrls.run_mode.text = mode_ind

	_ctrls.run_at_cursor.apply_gut_config(_gut_config)



func _disable_run_buttons(should):
	_ctrls.run_button.disabled = should
	_ctrls.run_at_cursor.disabled = should


func _is_test_script(script):
	var from = script.get_base_script()
	while(from and from.resource_path != 'res://addons/gut/test.gd'):
		from = from.get_base_script()

	return from != null


func _show_errors(errs):
	results_text.clear()
	var text = "Cannot run tests, you have a configuration error:\n"
	for e in errs:
		text += str('*  ', e, "\n")
	text += "Check your settings ----->"
	results_text.add_text(text)
	hide_output_text(false)
	hide_settings(false)


func _save_user_prefs():
	_user_prefs.hide_settings.value = !_ctrls.settings_button.button_pressed
	_user_prefs.hide_result_tree.value = !_ctrls.run_results_button.button_pressed
	_user_prefs.hide_output_text.value = !_ctrls.output_button.button_pressed
	_user_prefs.shortcuts_dialog_size.value = _ctrls.shortcut_dialog.size

	_user_prefs.run_externally.value = _ctrls.run_externally_dialog.run_mode != _ctrls.run_externally_dialog.RUN_MODE_EDITOR
	_user_prefs.run_externally_options_dialog_size.value = _ctrls.run_externally_dialog.size

	_user_prefs.save_it()


func _save_config():
	_save_user_prefs()

	_gut_config.options = _gut_config_gui.get_options(_gut_config.options)
	var w_result = _gut_config.write_options(GutEditorGlobals.editor_run_gut_config_path)
	if(w_result != OK):
		push_error(str('Could not write options to ', GutEditorGlobals.editor_run_gut_config_path, ': ', w_result))
	else:
		_gut_config_gui.mark_saved()


func _run_externally():
	_shell_out_panel = GutUtils.RunExternallyScene.instantiate()
	_shell_out_panel.bottom_panel = self
	_shell_out_panel.blocking_mode = _ctrls.run_externally_dialog.run_mode
	_shell_out_panel.additional_arguments = _ctrls.run_externally_dialog.get_additional_arguments_array()

	add_child(_shell_out_panel)
	_shell_out_panel.run_tests()


func _run_tests():
	show_me()
	if(_is_running):
		push_error("GUT:  Cannot run tests, tests are already running.")
		return

	clear_results()
	GutEditorGlobals.create_temp_directory()
	_light_color = Color.BLUE

	var issues = _gut_config_gui.get_config_issues()
	if(issues.size() > 0):
		_show_errors(issues)
		return

	write_file(GutEditorGlobals.editor_run_bbcode_results_path, 'Run in progress')
	write_file(GutEditorGlobals.editor_run_json_results_path, '')
	_save_config()
	_apply_options_to_controls()

	results_text.clear()
	results_tree.clear()
	results_tree.add_centered_text('Running...')

	_is_running = true
	results_text.add_text('Running...')

	if(_ctrls.run_externally_dialog.should_run_externally()):
		_gut_plugin.make_bottom_panel_item_visible(self)
		_run_externally()
	else:
		_interface.play_custom_scene('res://addons/gut/gui/run_from_editor.tscn')


func _apply_shortcuts():
	if(menu_manager != null):
		menu_manager.apply_gut_shortcuts(_ctrls.shortcut_dialog)

	_ctrls.run_button.shortcut = \
		_ctrls.shortcut_dialog.scbtn_run_all.get_shortcut()
	_ctrls.run_at_cursor.get_script_button().shortcut = \
		_ctrls.shortcut_dialog.scbtn_run_current_script.get_shortcut()
	_ctrls.run_at_cursor.get_inner_button().shortcut = \
		_ctrls.shortcut_dialog.scbtn_run_current_inner.get_shortcut()
	_ctrls.run_at_cursor.get_test_button().shortcut = \
		_ctrls.shortcut_dialog.scbtn_run_current_test.get_shortcut()
	# Took this out because it seems to break using the shortcut when docked.
	# Though it does allow the shortcut to work when windowed.  Shortcuts
	# are weird.
	# make_floating_btn.shortcut = \
	# 	_ctrls.shortcut_dialog.scbtn_windowed.get_shortcut()


	if(_panel_button != null):
		_panel_button.shortcut = _ctrls.shortcut_dialog.scbtn_panel.get_shortcut()


func _run_all():
	_gut_config.options.selected = null
	_gut_config.options.inner_class = null
	_gut_config.options.unit_test_name = null

	_run_tests()


# ---------------
# Events
# ---------------
func _on_results_bar_draw(bar):
	bar.draw_rect(Rect2(Vector2(0, 0), bar.size), Color(0, 0, 0, .2))


func _on_Light_draw():
	var l = _ctrls.light
	l.draw_circle(Vector2(l.size.x / 2, l.size.y / 2), l.size.x / 2, _light_color)


func _on_RunAll_pressed():
	_run_all()


func _on_Shortcuts_pressed():
	_ctrls.shortcut_dialog.popup_centered()


func _on_sortcut_dialog_confirmed() -> void:
	_apply_shortcuts()
	_ctrls.shortcut_dialog.save_shortcuts()
	_save_user_prefs()


func _on_RunAtCursor_run_tests(what):
	_gut_config.options.selected = what.script
	_gut_config.options.inner_class = what.inner_class
	_gut_config.options.unit_test_name = what.method

	_run_tests()


func _on_Settings_pressed():
	hide_settings(!_ctrls.settings_button.button_pressed)
	_save_config()


func _on_OutputBtn_pressed():
	hide_output_text(!_ctrls.output_button.button_pressed)
	_save_config()


func _on_RunResultsBtn_pressed():
	hide_result_tree(! _ctrls.run_results_button.button_pressed)
	_save_config()


# Currently not used, but will be when I figure out how to put
# colors into the text results
func _on_UseColors_pressed():
	pass


func _on_shell_out_options_confirmed() -> void:
	_ctrls.run_externally_dialog.save_to_file()
	_save_user_prefs()
	_apply_options_to_controls()


func _on_run_mode_pressed() -> void:
	_ctrls.run_externally_dialog.popup_centered()


func _on_toggle_windowed():
	_gut_plugin.toggle_windowed()


func _on_to_window_pressed() -> void:
	_gut_plugin.toggle_windowed()


func _on_show_gut() -> void:
	show_hide()


func _on_about_pressed() -> void:
	show_about()

# ---------------
# Public
# ---------------
func load_shortcuts():
	_ctrls.shortcut_dialog.load_shortcuts()
	_apply_shortcuts()


func hide_result_tree(should):
	results_tree.visible = !should
	_ctrls.run_results_button.button_pressed = !should


func hide_settings(should):
	var s_scroll = _ctrls.settings.get_parent()
	s_scroll.visible = !should

	# collapse only collapses the first control, so we move
	# settings around to be the collapsed one
	if(should):
		s_scroll.get_parent().move_child(s_scroll, 0)
	else:
		s_scroll.get_parent().move_child(s_scroll, 1)

	$layout/RSplit.collapsed = should
	_ctrls.settings_button.button_pressed = !should


func hide_output_text(should):
	results_text.visible = !should
	_ctrls.output_button.button_pressed = !should


func clear_results():
	_light_color = Color(0, 0, 0, .5)

	_ctrls.results.passing.text = "0"
	_ctrls.results.passing.get_parent().visible = false

	_ctrls.results.failing.text = "0"
	_ctrls.results.failing.get_parent().visible = false

	_ctrls.results.pending.text = "0"
	_ctrls.results.pending.get_parent().visible = false

	_ctrls.results.errors.text = "0"
	_ctrls.results.errors.get_parent().visible = false

	_ctrls.results.warnings.text = "0"
	_ctrls.results.warnings.get_parent().visible = false

	_ctrls.results.orphans.text = "0"
	_ctrls.results.orphans.get_parent().visible = false


func load_result_json():
	var summary = get_file_as_text(GutEditorGlobals.editor_run_json_results_path)
	var test_json_conv = JSON.new()
	if (test_json_conv.parse(summary) != OK):
		return
	var results = test_json_conv.get_data()

	results_tree.load_json_results(results)

	var summary_json = results['test_scripts']['props']
	_ctrls.results.passing.text = str(int(summary_json.passing))
	_ctrls.results.passing.get_parent().visible = true

	_ctrls.results.failing.text = str(int(summary_json.failures))
	_ctrls.results.failing.get_parent().visible = true

	_ctrls.results.pending.text = str(int(summary_json.pending) + int(summary_json.risky))
	_ctrls.results.pending.get_parent().visible = _ctrls.results.pending.text != '0'

	_ctrls.results.errors.text = str(int(summary_json.errors))
	_ctrls.results.errors.get_parent().visible = _ctrls.results.errors.text != '0'

	_ctrls.results.warnings.text = str(int(summary_json.warnings))
	_ctrls.results.warnings.get_parent().visible = _ctrls.results.warnings.text != '0'

	_ctrls.results.orphans.text = str(int(summary_json.orphans))
	_ctrls.results.orphans.get_parent().visible = _ctrls.results.orphans.text != '0' and !_gut_config.options.hide_orphans

	if(summary_json.tests == 0):
		_light_color = Color(1, 0, 0, .75)
	elif(summary_json.failures != 0):
		_light_color = Color(1, 0, 0, .75)
	elif(summary_json.pending != 0 or summary_json.risky != 0):
		_light_color = Color(1, 1, 0, .75)
	else:
		_light_color = Color(0, 1, 0, .75)

	_ctrls.light.visible = true


func load_result_text():
	results_text.load_file(GutEditorGlobals.editor_run_bbcode_results_path)


func load_result_output():
	load_result_text()
	load_result_json()


func set_interface(value):
	_interface = value
	results_tree.set_interface(_interface)


func set_plugin(value):
	_gut_plugin = value


func set_panel_button(value):
	_panel_button = value


func write_file(path, content):
	var f = FileAccess.open(path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
	f = null;

	return FileAccess.get_open_error()


func get_file_as_text(path):
	var to_return = ''
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	f = null
	return to_return


func get_text_output_control():
	return results_text


func add_output_text(text):
	results_text.add_text(text)


func show_about():
	var about = AboutWindow.instantiate()
	add_child(about)
	about.popup_centered()
	about.confirmed.connect(about.queue_free)


func show_me():
	if(owner is Window):
		owner.grab_focus()
	else:
		_gut_plugin.make_bottom_panel_item_visible(self)


func show_hide():
	if(owner is Window):
		if(owner.has_focus()):
			var win_to_focus_on = EditorInterface.get_editor_main_screen().get_parent()
			while(win_to_focus_on != null and win_to_focus_on is not Window):
				win_to_focus_on = win_to_focus_on.get_parent()
			if(win_to_focus_on != null):
				win_to_focus_on.grab_focus()
		else:
			owner.grab_focus()
	else:
		pass
		# We don't have to do anything when we are docked because the GUT
		# bottom panel has the shortcut and it does the toggling all on its
		# own.


func get_shortcut_dialog():
	return _ctrls.shortcut_dialog


func results_vert_layout():
	if(results_tree.get_parent() != results_v_split):
		results_tree.reparent(results_v_split)
		results_text.reparent(results_v_split)
		results_v_split.visible = true
		results_h_split.visible = false


func results_horiz_layout():
	if(results_tree.get_parent() != results_h_split):
		results_tree.reparent(results_h_split)
		results_text.reparent(results_h_split)
		results_v_split.visible = false
		results_h_split.visible = true


--------------------------------------------------
FILE: res:///addons/gut/gui/GutBottomPanel.tscn
--------------------------------------------------
[gd_scene load_steps=10 format=3 uid="uid://b3bostcslstem"]

[ext_resource type="Script" uid="uid://dtvnb0xatk0my" path="res://addons/gut/gui/GutBottomPanel.gd" id="1"]
[ext_resource type="PackedScene" uid="uid://0yunjxtaa8iw" path="res://addons/gut/gui/RunAtCursor.tscn" id="3"]
[ext_resource type="Texture2D" uid="uid://cr6tvdv0ve6cv" path="res://addons/gut/gui/play.png" id="4"]
[ext_resource type="Texture2D" uid="uid://bvo0uao7deu0q" path="res://addons/gut/icon.png" id="4_xv2r3"]
[ext_resource type="PackedScene" uid="uid://4gyyn12um08h" path="res://addons/gut/gui/RunResults.tscn" id="5"]
[ext_resource type="PackedScene" uid="uid://bqmo4dj64c7yl" path="res://addons/gut/gui/OutputText.tscn" id="6"]
[ext_resource type="PackedScene" uid="uid://dj5ve0bq7xa5j" path="res://addons/gut/gui/ShortcutDialog.tscn" id="7_srqj5"]
[ext_resource type="PackedScene" uid="uid://ckv5eh8xyrwbk" path="res://addons/gut/gui/ShellOutOptions.tscn" id="7_xv2r3"]

[sub_resource type="Shortcut" id="9"]

[node name="GutBottomPanel" type="Control"]
custom_minimum_size = Vector2(250, 250)
layout_mode = 3
anchor_left = -0.0025866
anchor_top = -0.00176575
anchor_right = 0.997413
anchor_bottom = 0.998234
offset_left = 2.64868
offset_top = 1.05945
offset_right = 2.64862
offset_bottom = 1.05945
script = ExtResource("1")

[node name="layout" type="VBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="ControlBar" type="HBoxContainer" parent="layout"]
layout_mode = 2

[node name="RunAll" type="Button" parent="layout/ControlBar"]
layout_mode = 2
size_flags_vertical = 11
shortcut = SubResource("9")
text = "Run All"
icon = ExtResource("4")

[node name="Sep3" type="ColorRect" parent="layout/ControlBar"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="RunAtCursor" parent="layout/ControlBar" instance=ExtResource("3")]
custom_minimum_size = Vector2(648, 0)
layout_mode = 2

[node name="CenterContainer2" type="CenterContainer" parent="layout/ControlBar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="MakeFloating" type="Button" parent="layout/ControlBar"]
unique_name_in_owner = true
layout_mode = 2
tooltip_text = "Move the GUT panel to a window."
icon = ExtResource("4_xv2r3")
flat = true

[node name="ControlBar2" type="HBoxContainer" parent="layout"]
layout_mode = 2

[node name="Sep2" type="ColorRect" parent="layout/ControlBar2"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2
color = Color(1, 1, 1, 0)

[node name="StatusIndicator" type="Control" parent="layout/ControlBar2"]
unique_name_in_owner = true
custom_minimum_size = Vector2(30, 30)
layout_mode = 2

[node name="Passing" type="HBoxContainer" parent="layout/ControlBar2"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/ControlBar2/Passing"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/ControlBar2/Passing"]
layout_mode = 2
text = "Pass"

[node name="passing_value" type="Label" parent="layout/ControlBar2/Passing"]
unique_name_in_owner = true
layout_mode = 2
text = "---"

[node name="Failing" type="HBoxContainer" parent="layout/ControlBar2"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/ControlBar2/Failing"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/ControlBar2/Failing"]
layout_mode = 2
text = "Fail"

[node name="failing_value" type="Label" parent="layout/ControlBar2/Failing"]
unique_name_in_owner = true
layout_mode = 2
text = "---"

[node name="Pending" type="HBoxContainer" parent="layout/ControlBar2"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/ControlBar2/Pending"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/ControlBar2/Pending"]
layout_mode = 2
text = "Risky"

[node name="pending_value" type="Label" parent="layout/ControlBar2/Pending"]
unique_name_in_owner = true
layout_mode = 2
text = "---"

[node name="Orphans" type="HBoxContainer" parent="layout/ControlBar2"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/ControlBar2/Orphans"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/ControlBar2/Orphans"]
layout_mode = 2
text = "Orphans"

[node name="orphans_value" type="Label" parent="layout/ControlBar2/Orphans"]
unique_name_in_owner = true
layout_mode = 2
text = "---"

[node name="Errors" type="HBoxContainer" parent="layout/ControlBar2"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/ControlBar2/Errors"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/ControlBar2/Errors"]
layout_mode = 2
text = "Errors"

[node name="errors_value" type="Label" parent="layout/ControlBar2/Errors"]
unique_name_in_owner = true
layout_mode = 2
text = "---"

[node name="Warnings" type="HBoxContainer" parent="layout/ControlBar2"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/ControlBar2/Warnings"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/ControlBar2/Warnings"]
layout_mode = 2
text = "Warnings"

[node name="warnings_value" type="Label" parent="layout/ControlBar2/Warnings"]
unique_name_in_owner = true
layout_mode = 2
text = "---"

[node name="CenterContainer" type="CenterContainer" parent="layout/ControlBar2"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ExtraButtons" type="HBoxContainer" parent="layout/ControlBar2"]
unique_name_in_owner = true
layout_mode = 2

[node name="Sep1" type="ColorRect" parent="layout/ControlBar2/ExtraButtons"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="RunMode" type="Button" parent="layout/ControlBar2/ExtraButtons"]
layout_mode = 2
tooltip_text = "Run Mode.  Run tests through the editor or externally in a different process."
text = "ExN"
icon = ExtResource("4_xv2r3")

[node name="Sep2" type="ColorRect" parent="layout/ControlBar2/ExtraButtons"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="RunResultsBtn" type="Button" parent="layout/ControlBar2/ExtraButtons"]
layout_mode = 2
tooltip_text = "Show/Hide Result Tree"
toggle_mode = true
button_pressed = true
icon = ExtResource("4_xv2r3")

[node name="OutputBtn" type="Button" parent="layout/ControlBar2/ExtraButtons"]
layout_mode = 2
tooltip_text = "Show/Hide Text Output"
toggle_mode = true
button_pressed = true
icon = ExtResource("4_xv2r3")

[node name="Settings" type="Button" parent="layout/ControlBar2/ExtraButtons"]
layout_mode = 2
tooltip_text = "GUT Settings"
toggle_mode = true
button_pressed = true
icon = ExtResource("4_xv2r3")

[node name="Sep3" type="ColorRect" parent="layout/ControlBar2/ExtraButtons"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="Shortcuts" type="Button" parent="layout/ControlBar2/ExtraButtons"]
layout_mode = 2
size_flags_vertical = 11
tooltip_text = "GUT Shortcuts"
icon = ExtResource("4_xv2r3")

[node name="About" type="Button" parent="layout/ControlBar2/ExtraButtons"]
layout_mode = 2
tooltip_text = "About"
text = "A"

[node name="RSplit" type="HSplitContainer" parent="layout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CResults" type="VBoxContainer" parent="layout/RSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="HSplitResults" type="HSplitContainer" parent="layout/RSplit/CResults"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RunResults" parent="layout/RSplit/CResults/HSplitResults" instance=ExtResource("5")]
unique_name_in_owner = true
custom_minimum_size = Vector2(255, 255)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="OutputText" parent="layout/RSplit/CResults/HSplitResults" instance=ExtResource("6")]
unique_name_in_owner = true
layout_mode = 2

[node name="VSplitResults" type="VSplitContainer" parent="layout/RSplit/CResults"]
unique_name_in_owner = true
visible = false
layout_mode = 2
size_flags_vertical = 3

[node name="sc" type="ScrollContainer" parent="layout/RSplit"]
custom_minimum_size = Vector2(500, 2.08165e-12)
layout_mode = 2
size_flags_vertical = 3

[node name="Settings" type="VBoxContainer" parent="layout/RSplit/sc"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ShortcutDialog" parent="." instance=ExtResource("7_srqj5")]
visible = false

[node name="ShellOutOptions" parent="." instance=ExtResource("7_xv2r3")]
size = Vector2i(1300, 1336)
visible = false

[connection signal="pressed" from="layout/ControlBar/RunAll" to="." method="_on_RunAll_pressed"]
[connection signal="run_tests" from="layout/ControlBar/RunAtCursor" to="." method="_on_RunAtCursor_run_tests"]
[connection signal="pressed" from="layout/ControlBar/MakeFloating" to="." method="_on_to_window_pressed"]
[connection signal="draw" from="layout/ControlBar2/StatusIndicator" to="." method="_on_Light_draw"]
[connection signal="pressed" from="layout/ControlBar2/ExtraButtons/RunMode" to="." method="_on_run_mode_pressed"]
[connection signal="pressed" from="layout/ControlBar2/ExtraButtons/RunResultsBtn" to="." method="_on_RunResultsBtn_pressed"]
[connection signal="pressed" from="layout/ControlBar2/ExtraButtons/OutputBtn" to="." method="_on_OutputBtn_pressed"]
[connection signal="pressed" from="layout/ControlBar2/ExtraButtons/Settings" to="." method="_on_Settings_pressed"]
[connection signal="pressed" from="layout/ControlBar2/ExtraButtons/Shortcuts" to="." method="_on_Shortcuts_pressed"]
[connection signal="pressed" from="layout/ControlBar2/ExtraButtons/About" to="." method="_on_about_pressed"]
[connection signal="confirmed" from="ShortcutDialog" to="." method="_on_sortcut_dialog_confirmed"]
[connection signal="confirmed" from="ShellOutOptions" to="." method="_on_shell_out_options_confirmed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/GutControl.gd
--------------------------------------------------
@tool
extends Control

const RUNNER_JSON_PATH = 'res://.gut_editor_config.json'

var GutConfig = load('res://addons/gut/gut_config.gd')
var GutRunnerScene = load('res://addons/gut/gui/GutRunner.tscn')
var GutConfigGui = load('res://addons/gut/gui/gut_config_gui.gd')

var _config = GutConfig.new()
var _config_gui = null
var _gut_runner = null
var _tree_root : TreeItem = null

var _script_icon = load('res://addons/gut/images/Script.svg')
var _folder_icon = load('res://addons/gut/images/Folder.svg')

var _tree_scripts = {}
var _tree_directories = {}

const TREE_SCRIPT = 'Script'
const TREE_DIR = 'Directory'

@onready var _ctrls = {
	run_tests_button = $VBox/Buttons/RunTests,
	run_selected = $VBox/Buttons/RunSelected,
	test_tree = $VBox/Tabs/Tests,
	settings_vbox = $VBox/Tabs/SettingsScroll/Settings,
	tabs = $VBox/Tabs,
	bg = $Bg
}

@export var bg_color : Color = Color(.36, .36, .36) :
	get: return bg_color
	set(val):
		bg_color = val
		if(is_inside_tree()):
			$Bg.color = bg_color


func _ready():
	if Engine.is_editor_hint():
		return

	_gut_runner = GutRunnerScene.instantiate()
	$Bg.color = bg_color
	_ctrls.tabs.set_tab_title(0, 'Tests')
	_ctrls.tabs.set_tab_title(1, 'Settings')

	_config_gui = GutConfigGui.new(_ctrls.settings_vbox)

	_ctrls.test_tree.hide_root = true
	add_child(_gut_runner)

	# TODO This might not need to be called deferred after changing GutUtils to
	# an all static class.
	call_deferred('_post_ready')


func _draw():
	if Engine.is_editor_hint():
		return

	var gut = _gut_runner.get_gut()
	if(!gut.is_running()):
		var r = Rect2(Vector2(0, 0), get_rect().size)
		draw_rect(r, Color.BLACK, false, 2)


func _post_ready():
	var gut = _gut_runner.get_gut()
	gut.start_run.connect(_on_gut_run_started)
	gut.end_run.connect(_on_gut_run_ended)
	_refresh_tree_and_settings()


func _set_meta_for_script_tree_item(item, script, test=null):
	var meta = {
		type = TREE_SCRIPT,
		script = script.path,
		inner_class = script.inner_class_name,
		test = ''
	}

	if(test != null):
		meta.test = test.name

	item.set_metadata(0, meta)


func _set_meta_for_directory_tree_item(item, path, temp_item):
	var meta = {
		type = TREE_DIR,
		path = path,
		temp_item = temp_item
	}
	item.set_metadata(0, meta)


func _get_script_tree_item(script, parent_item):
	if(!_tree_scripts.has(script.path)):
		var item = _ctrls.test_tree.create_item(parent_item)
		item.set_text(0, script.path.get_file())
		item.set_icon(0, _script_icon)
		_tree_scripts[script.path] = item
		_set_meta_for_script_tree_item(item, script)

	return _tree_scripts[script.path]


func _get_directory_tree_item(path):
	var parent = _tree_root
	if(!_tree_directories.has(path)):

		var item : TreeItem = null
		if(parent != _tree_root):
			item = parent.create_child(0)
		else:
			item = parent.create_child()

		_tree_directories[path] = item
		item.collapsed = false
		item.set_text(0, path)
		item.set_icon(0, _folder_icon)
		item.set_icon_modulate(0, Color.ROYAL_BLUE)
		# temp_item is used in calls with move_before since you must use
		# move_before or move_after to reparent tree items. This ensures that
		# there is an item on all directories.  These are deleted later.
		var temp_item = item.create_child()
		temp_item.set_text(0, '<temp>')

		_set_meta_for_directory_tree_item(item, path, temp_item)

	return _tree_directories[path]


func _find_dir_item_to_move_before(path):
	var max_matching_len = 0
	var best_parent = null

	# Go through all the directory items finding the one that has the longest
	# path that contains our path.
	for key in _tree_directories.keys():
		if(path != key and path.begins_with(key) and key.length() > max_matching_len):
				max_matching_len = key.length()
				best_parent = _tree_directories[key]

	var to_return = null
	if(best_parent != null):
		to_return = best_parent.get_metadata(0).temp_item
	return to_return


func _reorder_dir_items():
	var the_keys = _tree_directories.keys()
	the_keys.sort()
	for key in _tree_directories.keys():
		var to_move = _tree_directories[key]
		to_move.collapsed = false
		var move_before = _find_dir_item_to_move_before(key)
		if(move_before != null):
			to_move.move_before(move_before)
			var new_text = key.substr(move_before.get_parent().get_metadata(0).path.length())
			to_move.set_text(0, new_text)


func _remove_dir_temp_items():
	for key in _tree_directories.keys():
		var item = _tree_directories[key].get_metadata(0).temp_item
		_tree_directories[key].remove_child(item)


func _add_dir_and_script_tree_items():
	var tree : Tree = _ctrls.test_tree
	tree.clear()
	_tree_root = _ctrls.test_tree.create_item()

	var scripts = _gut_runner.get_gut().get_test_collector().scripts
	for script in scripts:
		var dir_item = _get_directory_tree_item(script.path.get_base_dir())
		var item = _get_script_tree_item(script, dir_item)

		if(script.inner_class_name != ''):
			var inner_item = tree.create_item(item)
			inner_item.set_text(0, script.inner_class_name)
			_set_meta_for_script_tree_item(inner_item, script)
			item = inner_item

		for test in script.tests:
			var test_item = tree.create_item(item)
			test_item.set_text(0, test.name)
			_set_meta_for_script_tree_item(test_item, script, test)


func _populate_tree():
	_add_dir_and_script_tree_items()
	_tree_root.set_collapsed_recursive(true)
	_tree_root.set_collapsed(false)
	_reorder_dir_items()
	_remove_dir_temp_items()


func _refresh_tree_and_settings():
	_config.apply_options(_gut_runner.get_gut())
	_gut_runner.set_gut_config(_config)
	_populate_tree()

# ---------------------------
# Events
# ---------------------------
func _on_gut_run_started():
	_ctrls.run_tests_button.disabled = true
	_ctrls.run_selected.visible = false
	_ctrls.tabs.visible = false
	_ctrls.bg.visible = false
	_ctrls.run_tests_button.text = 'Running'
	queue_redraw()


func _on_gut_run_ended():
	_ctrls.run_tests_button.disabled = false
	_ctrls.run_selected.visible = true
	_ctrls.tabs.visible = true
	_ctrls.bg.visible = true
	_ctrls.run_tests_button.text = 'Run All'
	queue_redraw()


func _on_run_tests_pressed():
	run_all()


func _on_run_selected_pressed():
	run_selected()


func _on_tests_item_activated():
	run_selected()

# ---------------------------
# Public
# ---------------------------
func get_gut():
	return _gut_runner.get_gut()


func get_config():
	return _config


func run_all():
	_config.options.selected = ''
	_config.options.inner_class_name = ''
	_config.options.unit_test_name = ''
	run_tests()


func run_tests(options = null):
	if(options == null):
		_config.options = _config_gui.get_options(_config.options)
	else:
		_config.options = options
		
	# We ar running from within the game, so we should not exit, ever.
	_config.options.should_exit_on_success = false
	_config.options.should_exit = false

	_gut_runner.get_gut().get_test_collector().clear()
	_gut_runner.set_gut_config(_config)
	_gut_runner.run_tests()


func run_selected():
	var sel_item = _ctrls.test_tree.get_selected()
	if(sel_item == null):
		return

	var options = _config_gui.get_options(_config.options)
	var meta = sel_item.get_metadata(0)
	if(meta.type == TREE_SCRIPT):
		options.selected = meta.script.get_file()
		options.inner_class_name = meta.inner_class
		options.unit_test_name = meta.test
	elif(meta.type == TREE_DIR):
		options.dirs = [meta.path]
		options.include_subdirectories = true
		options.selected = ''
		options.inner_class_name = ''
		options.unit_test_name = ''

	run_tests(options)


func load_config_file(path):
	_config.load_options(path)
	_config.options.selected = ''
	_config.options.inner_class_name = ''
	_config.options.unit_test_name = ''
	_config_gui.load_file(path)


# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/gui/GutControl.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://4jb53yqktyfg"]

[ext_resource type="Script" uid="uid://cqlvpwidawld6" path="res://addons/gut/gui/GutControl.gd" id="1_eprql"]

[node name="GutControl" type="Control"]
layout_mode = 3
anchors_preset = 0
offset_right = 295.0
offset_bottom = 419.0
script = ExtResource("1_eprql")

[node name="Bg" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.36, 0.36, 0.36, 1)

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Tabs" type="TabContainer" parent="VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="Tests" type="Tree" parent="VBox/Tabs"]
layout_mode = 2
size_flags_vertical = 3
hide_root = true

[node name="SettingsScroll" type="ScrollContainer" parent="VBox/Tabs"]
visible = false
layout_mode = 2
size_flags_vertical = 3

[node name="Settings" type="VBoxContainer" parent="VBox/Tabs/SettingsScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Buttons" type="HBoxContainer" parent="VBox"]
layout_mode = 2

[node name="RunTests" type="Button" parent="VBox/Buttons"]
layout_mode = 2
size_flags_horizontal = 3
text = "Run All"

[node name="RunSelected" type="Button" parent="VBox/Buttons"]
layout_mode = 2
size_flags_horizontal = 3
text = "Run Selected"

[connection signal="item_activated" from="VBox/Tabs/Tests" to="." method="_on_tests_item_activated"]
[connection signal="pressed" from="VBox/Buttons/RunTests" to="." method="_on_run_tests_pressed"]
[connection signal="pressed" from="VBox/Buttons/RunSelected" to="." method="_on_run_selected_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/GutEditorWindow.gd
--------------------------------------------------
@tool
extends Window


var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

@onready var _chk_always_on_top = $Layout/WinControls/OnTop

var _bottom_panel = null
var _ready_to_go = false
var _gut_shortcuts = []

var gut_plugin = null
var interface = null


func _unhandled_key_input(event: InputEvent) -> void:
	if(event is InputEventKey):
		if(_gut_shortcuts.has(event.as_text_keycode())):
			get_tree().root.push_input(event)


func _ready() -> void:
	var pref_size = GutEditorGlobals.user_prefs.gut_window_size.value
	if(pref_size.x < 0):
		size = Vector2(800, 800)
	else:
		size = pref_size
	always_on_top = GutEditorGlobals.user_prefs.gut_window_on_top.value
	_chk_always_on_top.button_pressed = always_on_top


# --------
# Events
# --------
func _on_on_top_toggled(toggled_on: bool) -> void:
	always_on_top = toggled_on
	GutEditorGlobals.user_prefs.gut_window_on_top.value = toggled_on


func _on_size_changed() -> void:
	if(_ready_to_go):
		GutEditorGlobals.user_prefs.gut_window_size.value = size


func _on_close_requested() -> void:
	gut_plugin.toggle_windowed()



func _on_vert_layout_pressed() -> void:
	_bottom_panel.results_vert_layout()


func _on_horiz_layout_pressed() -> void:
	_bottom_panel.results_horiz_layout()


# --------
# Public
# --------
func add_gut_panel(panel : Control):
	$Layout.add_child(panel)
	panel.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	panel.size_flags_vertical = Control.SIZE_EXPAND_FILL
	panel.visible = true
	_bottom_panel = panel
	_ready_to_go = true

	panel.owner = self

	# This stunk to figure out.
	theme = interface.get_editor_theme()
	var settings = interface.get_editor_settings()
	$ColorRect.color = settings.get_setting("interface/theme/base_color")

	set_gut_shortcuts(_bottom_panel._ctrls.shortcut_dialog)


func remove_panel():
	$Layout.remove_child(_bottom_panel)
	_bottom_panel.owner = null


func set_gut_shortcuts(shortcuts_dialog):
	_gut_shortcuts.clear()
	for btn in shortcuts_dialog.all_buttons:
		_gut_shortcuts.append(btn.get_input_event().as_text_keycode())


--------------------------------------------------
FILE: res:///addons/gut/gui/GutEditorWindow.tscn
--------------------------------------------------
[gd_scene load_steps=10 format=3 uid="uid://dnnvwlplf1km7"]

[ext_resource type="Script" uid="uid://crp2af6k4nmf5" path="res://addons/gut/gui/GutEditorWindow.gd" id="1_qevl3"]
[ext_resource type="Texture2D" uid="uid://ljc2viafngwd" path="res://addons/gut/images/HSplitContainer.svg" id="2_xw0o2"]
[ext_resource type="Texture2D" uid="uid://bhew20crsywxr" path="res://addons/gut/images/VSplitContainer.svg" id="3_fqfwy"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_qevl3"]
content_margin_left = 8.0
content_margin_top = 8.0
content_margin_right = 8.0
content_margin_bottom = 8.0
bg_color = Color(0.115499996, 0.132, 0.15949999, 1)
corner_detail = 1
anti_aliasing = false

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_af010"]
content_margin_left = 8.0
content_margin_top = 12.0
content_margin_right = 8.0
content_margin_bottom = 8.0
bg_color = Color(0.21, 0.24, 0.29, 1)
border_color = Color(0.08399999, 0.095999986, 0.116, 1)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6
corner_detail = 5
anti_aliasing = false

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_xw0o2"]
content_margin_left = 0.0
content_margin_top = 8.0
content_margin_right = 0.0
content_margin_bottom = 0.0
bg_color = Color(0.21, 0.24, 0.29, 1)
border_color = Color(0.08399999, 0.095999986, 0.116, 1)
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6
corner_detail = 5
anti_aliasing = false

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_fqfwy"]
content_margin_left = 12.0
content_margin_top = 8.0
content_margin_right = 12.0
content_margin_bottom = 8.0
bg_color = Color(0.14699998, 0.16799998, 0.203, 1)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6
corner_detail = 5
anti_aliasing = false

[sub_resource type="Theme" id="Theme_fqfwy"]
Editor/colors/accent_color = Color(0.44, 0.73, 0.98, 1)
Editor/colors/background = Color(0.115499996, 0.132, 0.15949999, 1)
Editor/colors/base_color = Color(0.21, 0.24, 0.29, 1)
EditorStyles/styles/Background = SubResource("StyleBoxFlat_qevl3")
EditorStyles/styles/BottomPanel = SubResource("StyleBoxFlat_af010")
EditorStyles/styles/Content = SubResource("StyleBoxFlat_xw0o2")
Panel/styles/panel = SubResource("StyleBoxFlat_fqfwy")

[sub_resource type="ButtonGroup" id="ButtonGroup_qevl3"]

[node name="GutEditorWindow" type="Window"]
oversampling_override = 1.0
title = "GUT"
position = Vector2i(0, 36)
size = Vector2i(1408, 1728)
min_size = Vector2i(800, 600)
script = ExtResource("1_qevl3")

[node name="ColorRect" type="ColorRect" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = SubResource("Theme_fqfwy")
color = Color(0.18717614, 0.18717614, 0.18717614, 1)

[node name="Layout" type="VBoxContainer" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="WinControls" type="HBoxContainer" parent="Layout"]
layout_mode = 2

[node name="MenuBar" type="MenuBar" parent="Layout/WinControls"]
custom_minimum_size = Vector2(300, 0)
layout_mode = 2
size_flags_horizontal = 3
flat = true
prefer_global_menu = false

[node name="CenterContainer" type="CenterContainer" parent="Layout/WinControls"]
layout_mode = 2
size_flags_horizontal = 3

[node name="OnTop" type="CheckButton" parent="Layout/WinControls"]
layout_mode = 2
text = "Always on Top"

[node name="HorizLayout" type="Button" parent="Layout/WinControls"]
texture_filter = 1
layout_mode = 2
toggle_mode = true
button_pressed = true
button_group = SubResource("ButtonGroup_qevl3")
icon = ExtResource("2_xw0o2")
icon_alignment = 1

[node name="VertLayout" type="Button" parent="Layout/WinControls"]
layout_mode = 2
toggle_mode = true
button_group = SubResource("ButtonGroup_qevl3")
icon = ExtResource("3_fqfwy")

[connection signal="close_requested" from="." to="." method="_on_close_requested"]
[connection signal="size_changed" from="." to="." method="_on_size_changed"]
[connection signal="toggled" from="Layout/WinControls/OnTop" to="." method="_on_on_top_toggled"]
[connection signal="pressed" from="Layout/WinControls/HorizLayout" to="." method="_on_horiz_layout_pressed"]
[connection signal="pressed" from="Layout/WinControls/VertLayout" to="." method="_on_vert_layout_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/GutLogo.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://bjkn8mhx2fmt1"]

[ext_resource type="Script" uid="uid://b8lvgepb64m8t" path="res://addons/gut/gui/gut_logo.gd" id="1_ba6lh"]
[ext_resource type="Texture2D" uid="uid://dyxbmyvpkkcvs" path="res://addons/gut/images/GutIconV2_base.png" id="2_ba6lh"]
[ext_resource type="Texture2D" uid="uid://dx0yxxn5q7doc" path="res://addons/gut/images/eyey.png" id="3_rc8fb"]

[node name="Logo" type="Node2D"]
script = ExtResource("1_ba6lh")

[node name="BaseLogo" type="Sprite2D" parent="."]
scale = Vector2(0.5, 0.5)
texture = ExtResource("2_ba6lh")

[node name="LeftEye" type="Sprite2D" parent="BaseLogo"]
visible = false
position = Vector2(-238, 16)
texture = ExtResource("3_rc8fb")

[node name="RightEye" type="Sprite2D" parent="BaseLogo"]
visible = false
position = Vector2(239, 16)
texture = ExtResource("3_rc8fb")

[node name="ResetTimer" type="Timer" parent="."]
wait_time = 5.0
one_shot = true

[node name="FaceButton" type="Button" parent="."]
modulate = Color(1, 1, 1, 0)
offset_left = -141.0
offset_top = -113.0
offset_right = 140.0
offset_bottom = 175.0

[connection signal="timeout" from="ResetTimer" to="." method="_on_reset_timer_timeout"]
[connection signal="pressed" from="FaceButton" to="." method="_on_face_button_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/GutRunner.gd
--------------------------------------------------
# ##############################################################################
# This class joins together GUT, GUT Gui, GutConfig and is THE way to kick off a
# run of a test suite.
#
# This creates its own instance of gut.gd that it manages.  You can set the
# gut.gd instance if you need to for testing.
#
# Set gut_config to an instance of a configured gut_config.gd instance prior to
# running tests.
#
# This will create a GUI and wire it up and apply gut_config.gd options.
#
# Running tests:  Call run_tests
# ##############################################################################
extends Node2D

const EXIT_OK = 0
const EXIT_ERROR = 1

var Gut = load('res://addons/gut/gut.gd')
var ResultExporter = load('res://addons/gut/result_exporter.gd')
var GutConfig = load('res://addons/gut/gut_config.gd')

var runner_json_path = null
var result_bbcode_path = null
var result_json_path = null

var lgr = GutUtils.get_logger()
var gut_config = null

var error_tracker = GutUtils.get_error_tracker()

var _hid_gut = null;
# Lazy loaded gut instance.  Settable for testing purposes.
var gut = _hid_gut :
	get:
		if(_hid_gut == null):
			_hid_gut = Gut.new(lgr)
			_hid_gut.error_tracker = error_tracker
		return _hid_gut
	set(val):
		_hid_gut = val

var _wrote_results = false
var _ran_from_editor = false

@onready var _gut_layer = $GutLayer
@onready var _gui = $GutLayer/GutScene


func _ready():
	GutUtils.WarningsManager.apply_warnings_dictionary(
		GutUtils.warnings_at_start)


func _exit_tree():
	if(!_wrote_results and _ran_from_editor):
		_write_results_for_gut_panel()


func _setup_gui(show_gui):
	if(show_gui):
		_gui.gut = gut
		var printer = gut.logger.get_printer('gui')
		printer.set_textbox(_gui.get_textbox())
	else:
		gut.logger.disable_printer('gui', true)
		_gui.visible = false

	var opts = gut_config.options
	_gui.set_font_size(opts.font_size)
	_gui.set_font(opts.font_name)
	if(opts.font_color != null and opts.font_color.is_valid_html_color()):
		_gui.set_default_font_color(Color(opts.font_color))
	if(opts.background_color != null and opts.background_color.is_valid_html_color()):
		_gui.set_background_color(Color(opts.background_color))

	_gui.set_opacity(min(1.0, float(opts.opacity) / 100))
	_gui.use_compact_mode(opts.compact_mode)


func _write_results_for_gut_panel():
	var content = _gui.get_textbox().get_parsed_text() #_gut.logger.get_gui_bbcode()
	var f = FileAccess.open(result_bbcode_path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
		f = null # closes file
	else:
		push_error('Could not save bbcode, result = ', FileAccess.get_open_error())

	var exporter = ResultExporter.new()
	# TODO this should be checked and _wrote_results should maybe not be set, or
	# maybe we do not care.  Whichever, it should be clear.
	var _f_result = exporter.write_json_file(gut, result_json_path)
	_wrote_results = true


func _handle_quit(should_exit, should_exit_on_success, override_exit_code=EXIT_OK):
	var quitting_time = should_exit or \
		(should_exit_on_success and gut.get_fail_count() == 0)

	if(!quitting_time):
		if(should_exit_on_success):
			lgr.log("There are failing tests, exit manually.")
		_gui.use_compact_mode(false)
		return

	# For some reason, tests fail asserting that quit was called with 0 if we
	# do not do this, but everything is defaulted so I don't know why it gets
	# null.
	var exit_code = GutUtils.nvl(override_exit_code, EXIT_OK)

	if(gut.get_fail_count() > 0):
		exit_code = EXIT_ERROR

	# Overwrite the exit code with the post_script's exit code if it is set
	var post_hook_inst = gut.get_post_run_script_instance()
	if(post_hook_inst != null and post_hook_inst.get_exit_code() != null):
		exit_code = post_hook_inst.get_exit_code()

	quit(exit_code)


func _end_run(override_exit_code=EXIT_OK):
	if(_ran_from_editor):
		_write_results_for_gut_panel()

	GutErrorTracker.deregister_logger(error_tracker)

	_handle_quit(gut_config.options.should_exit,
		gut_config.options.should_exit_on_success,
		override_exit_code)


# -------------
# Events
# -------------
func _on_tests_finished():
	_end_run()


# -------------
# Public
# -------------
# For internal use only, but still public.  Consider it "protected" and you
# don't have my permission to call this, unless "you" is "me".
func run_from_editor():
	_ran_from_editor = true
	var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
	runner_json_path = GutUtils.nvl(runner_json_path, GutEditorGlobals.editor_run_gut_config_path)
	result_bbcode_path = GutUtils.nvl(result_bbcode_path, GutEditorGlobals.editor_run_bbcode_results_path)
	result_json_path = GutUtils.nvl(result_json_path, GutEditorGlobals.editor_run_json_results_path)

	if(gut_config == null):
		gut_config = GutConfig.new()
		gut_config.load_options(runner_json_path)

	call_deferred('run_tests')


func run_tests(show_gui=true):
	_setup_gui(show_gui)

	if(gut_config.options.dirs.size() + gut_config.options.tests.size() == 0):
		var err_text = "You do not have any directories configured, so GUT " + \
			"doesn't know where to find the tests.  Tell GUT where to find the " + \
			"tests and GUT shall run the tests."
		lgr.error(err_text)
		push_error(err_text)
		_end_run(EXIT_ERROR)
		return

	var install_check_text = GutUtils.make_install_check_text()
	if(install_check_text != GutUtils.INSTALL_OK_TEXT):
		print("\n\n", GutUtils.version_numbers.get_version_text())
		lgr.error(install_check_text)
		push_error(install_check_text)
		_end_run(EXIT_ERROR)
		return

	gut.add_children_to = self
	if(gut.get_parent() == null):
		if(gut_config.options.gut_on_top):
			_gut_layer.add_child(gut)
		else:
			add_child(gut)
	
	if(!gut.end_run.is_connected(_on_tests_finished)):
		gut.end_run.connect(_on_tests_finished)

	gut_config.apply_options(gut)
	var run_rest_of_scripts = gut_config.options.unit_test_name == ''
	GutErrorTracker.register_logger(error_tracker)
	gut.test_scripts(run_rest_of_scripts)


func set_gut_config(which):
	gut_config = which


# for backwards compatibility
func get_gut():
	return gut


func quit(exit_code):
	# Sometimes quitting takes a few seconds.  This gives some indicator
	# of what is going on.
	_gui.set_title("Exiting")

	await get_tree().process_frame

	lgr.info(str('Exiting with code ', exit_code))
	get_tree().quit(exit_code)




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/gui/GutRunner.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://bqy3ikt6vu4b5"]

[ext_resource type="Script" uid="uid://eg8k46gd42a4" path="res://addons/gut/gui/GutRunner.gd" id="1"]
[ext_resource type="PackedScene" uid="uid://m28heqtswbuq" path="res://addons/gut/GutScene.tscn" id="2_6ruxb"]

[node name="GutRunner" type="Node2D"]
script = ExtResource("1")

[node name="GutLayer" type="CanvasLayer" parent="."]
layer = 128

[node name="GutScene" parent="GutLayer" instance=ExtResource("2_6ruxb")]


--------------------------------------------------
FILE: res:///addons/gut/gui/GutSceneTheme.tres
--------------------------------------------------
[gd_resource type="Theme" load_steps=2 format=3 uid="uid://cstkhwkpajvqu"]

[ext_resource type="FontFile" uid="uid://c6c7gnx36opr0" path="res://addons/gut/fonts/AnonymousPro-Regular.ttf" id="1_df57p"]

[resource]
default_font = ExtResource("1_df57p")
Label/colors/font_color = Color(1, 1, 1, 1)
Label/colors/font_outline_color = Color(0, 0, 0, 1)
Label/colors/font_shadow_color = Color(0, 0, 0, 0)
Label/constants/line_spacing = 3
Label/constants/outline_size = 0
Label/constants/shadow_offset_x = 1
Label/constants/shadow_offset_y = 1
Label/constants/shadow_outline_size = 1
Label/font_sizes/font_size = 16
Label/fonts/font = ExtResource("1_df57p")


--------------------------------------------------
FILE: res:///addons/gut/gui/MinGui.tscn
--------------------------------------------------
[gd_scene load_steps=5 format=3 uid="uid://cnqqdfsn80ise"]

[ext_resource type="Theme" uid="uid://cstkhwkpajvqu" path="res://addons/gut/gui/GutSceneTheme.tres" id="1_farmq"]
[ext_resource type="FontFile" uid="uid://bnh0lslf4yh87" path="res://addons/gut/fonts/CourierPrime-Regular.ttf" id="2_a2e2l"]
[ext_resource type="Script" uid="uid://blvhsbnsvfyow" path="res://addons/gut/gui/gut_gui.gd" id="2_eokrf"]
[ext_resource type="PackedScene" uid="uid://bvrqqgjpyouse" path="res://addons/gut/gui/ResizeHandle.tscn" id="4_xrhva"]

[node name="Min" type="Panel"]
clip_contents = true
custom_minimum_size = Vector2(280, 145)
offset_right = 280.0
offset_bottom = 145.0
theme = ExtResource("1_farmq")
script = ExtResource("2_eokrf")

[node name="MainBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="TitleBar" type="Panel" parent="MainBox"]
custom_minimum_size = Vector2(0, 25)
layout_mode = 2

[node name="TitleBox" type="HBoxContainer" parent="MainBox/TitleBar"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = 2.0
offset_bottom = 3.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="Spacer1" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
text = "Title"

[node name="Spacer2" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="TimeLabel" type="Label" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
text = "0.000s"

[node name="Body" type="HBoxContainer" parent="MainBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="LeftMargin" type="CenterContainer" parent="MainBox/Body"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="BodyRows" type="VBoxContainer" parent="MainBox/Body"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ProgressBars" type="HBoxContainer" parent="MainBox/Body/BodyRows"]
layout_mode = 2
size_flags_horizontal = 3

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/Body/BodyRows/ProgressBars"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label" type="Label" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer"]
layout_mode = 2
text = "T:"

[node name="ProgressTest" type="ProgressBar" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
size_flags_horizontal = 3
value = 25.0

[node name="HBoxContainer2" type="HBoxContainer" parent="MainBox/Body/BodyRows/ProgressBars"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label" type="Label" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer2"]
layout_mode = 2
text = "S:"

[node name="ProgressScript" type="ProgressBar" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer2"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
size_flags_horizontal = 3
value = 75.0

[node name="PathDisplay" type="VBoxContainer" parent="MainBox/Body/BodyRows"]
clip_contents = true
layout_mode = 2
size_flags_vertical = 3

[node name="Path" type="Label" parent="MainBox/Body/BodyRows/PathDisplay"]
layout_mode = 2
theme_override_fonts/font = ExtResource("2_a2e2l")
theme_override_font_sizes/font_size = 14
text = "res://test/integration/whatever"
clip_text = true
text_overrun_behavior = 3

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/Body/BodyRows/PathDisplay"]
clip_contents = true
layout_mode = 2

[node name="S3" type="CenterContainer" parent="MainBox/Body/BodyRows/PathDisplay/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="File" type="Label" parent="MainBox/Body/BodyRows/PathDisplay/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = ExtResource("2_a2e2l")
theme_override_font_sizes/font_size = 14
text = "test_this_thing.gd"
text_overrun_behavior = 3

[node name="Footer" type="HBoxContainer" parent="MainBox/Body/BodyRows"]
layout_mode = 2

[node name="HandleLeft" parent="MainBox/Body/BodyRows/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_xrhva")]
layout_mode = 2
orientation = 0
resize_control = NodePath("../../../../..")
vertical_resize = false

[node name="SwitchModes" type="Button" parent="MainBox/Body/BodyRows/Footer"]
layout_mode = 2
text = "Expand"

[node name="CenterContainer" type="CenterContainer" parent="MainBox/Body/BodyRows/Footer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Continue" type="Button" parent="MainBox/Body/BodyRows/Footer"]
layout_mode = 2
text = "Continue
"

[node name="HandleRight" parent="MainBox/Body/BodyRows/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_xrhva")]
layout_mode = 2
resize_control = NodePath("../../../../..")
vertical_resize = false

[node name="RightMargin" type="CenterContainer" parent="MainBox/Body"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="CenterContainer" type="CenterContainer" parent="MainBox"]
custom_minimum_size = Vector2(2.08165e-12, 2)
layout_mode = 2


--------------------------------------------------
FILE: res:///addons/gut/gui/NormalGui.tscn
--------------------------------------------------
[gd_scene load_steps=5 format=3 uid="uid://duxblir3vu8x7"]

[ext_resource type="Theme" uid="uid://cstkhwkpajvqu" path="res://addons/gut/gui/GutSceneTheme.tres" id="1_5hlsm"]
[ext_resource type="Script" uid="uid://blvhsbnsvfyow" path="res://addons/gut/gui/gut_gui.gd" id="2_fue6q"]
[ext_resource type="FontFile" uid="uid://bnh0lslf4yh87" path="res://addons/gut/fonts/CourierPrime-Regular.ttf" id="2_u5uc1"]
[ext_resource type="PackedScene" uid="uid://bvrqqgjpyouse" path="res://addons/gut/gui/ResizeHandle.tscn" id="4_2r8a8"]

[node name="Large" type="Panel"]
custom_minimum_size = Vector2(500, 150)
offset_right = 632.0
offset_bottom = 260.0
theme = ExtResource("1_5hlsm")
script = ExtResource("2_fue6q")

[node name="MainBox" type="VBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="TitleBar" type="Panel" parent="MainBox"]
custom_minimum_size = Vector2(0, 25)
layout_mode = 2

[node name="TitleBox" type="HBoxContainer" parent="MainBox/TitleBar"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = 2.0
offset_bottom = 3.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="Spacer1" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
text = "Title"

[node name="Spacer2" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="TimeLabel" type="Label" parent="MainBox/TitleBar/TitleBox"]
custom_minimum_size = Vector2(90, 0)
layout_mode = 2
text = "999.999s"

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="VBoxContainer" type="VBoxContainer" parent="MainBox/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="OutputBG" type="ColorRect" parent="MainBox/HBoxContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
color = Color(0.0745098, 0.0705882, 0.0784314, 1)
metadata/_edit_layout_mode = 1

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="S2" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="TestOutput" type="RichTextLabel" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
focus_mode = 2
bbcode_enabled = true
scroll_following = true
autowrap_mode = 0
selection_enabled = true

[node name="S1" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="ControlBox" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer"]
layout_mode = 2

[node name="S1" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="ProgressBars" type="VBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
custom_minimum_size = Vector2(2.08165e-12, 2.08165e-12)
layout_mode = 2

[node name="TestBox" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars"]
layout_mode = 2

[node name="Label" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/TestBox"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
size_flags_horizontal = 3
text = "Tests"

[node name="ProgressTest" type="ProgressBar" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/TestBox"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
value = 25.0

[node name="ScriptBox" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars"]
layout_mode = 2

[node name="Label" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/ScriptBox"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
size_flags_horizontal = 3
text = "Scripts"

[node name="ProgressScript" type="ProgressBar" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/ScriptBox"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
value = 75.0

[node name="PathDisplay" type="VBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Path" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay"]
layout_mode = 2
size_flags_vertical = 6
theme_override_fonts/font = ExtResource("2_u5uc1")
theme_override_font_sizes/font_size = 14
text = "res://test/integration/whatever"
text_overrun_behavior = 3

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay"]
layout_mode = 2
size_flags_vertical = 3

[node name="S3" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="File" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = ExtResource("2_u5uc1")
theme_override_font_sizes/font_size = 14
text = "test_this_thing.gd"
text_overrun_behavior = 3

[node name="Buttons" type="VBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
layout_mode = 2

[node name="Continue" type="Button" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/Buttons"]
layout_mode = 2
size_flags_vertical = 4
text = "Continue
"

[node name="WordWrap" type="CheckButton" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/Buttons"]
layout_mode = 2
text = "Word Wrap"

[node name="S3" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="BottomPad" type="CenterContainer" parent="MainBox"]
custom_minimum_size = Vector2(0, 5)
layout_mode = 2

[node name="Footer" type="HBoxContainer" parent="MainBox"]
layout_mode = 2

[node name="SidePad1" type="CenterContainer" parent="MainBox/Footer"]
custom_minimum_size = Vector2(2, 2.08165e-12)
layout_mode = 2

[node name="ResizeHandle3" parent="MainBox/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_2r8a8")]
custom_minimum_size = Vector2(25, 25)
layout_mode = 2
orientation = 0
resize_control = NodePath("../../..")

[node name="SwitchModes" type="Button" parent="MainBox/Footer"]
layout_mode = 2
text = "Compact
"

[node name="CenterContainer" type="CenterContainer" parent="MainBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ResizeHandle2" parent="MainBox/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_2r8a8")]
custom_minimum_size = Vector2(25, 25)
layout_mode = 2
resize_control = NodePath("../../..")

[node name="SidePad2" type="CenterContainer" parent="MainBox/Footer"]
custom_minimum_size = Vector2(2, 2.08165e-12)
layout_mode = 2

[node name="BottomPad2" type="CenterContainer" parent="MainBox"]
custom_minimum_size = Vector2(2.08165e-12, 2)
layout_mode = 2


--------------------------------------------------
FILE: res:///addons/gut/gui/OutputText.gd
--------------------------------------------------
@tool
extends VBoxContainer

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var PanelControls = load('res://addons/gut/gui/panel_controls.gd')

# ##############################################################################
# Keeps search results from the TextEdit
# ##############################################################################
class TextEditSearcher:
	var te : TextEdit
	var _last_term = ''
	var _last_pos = Vector2(-1, -1)
	var _ignore_caret_change = false

	func set_text_edit(which):
		te = which
		te.caret_changed.connect(_on_caret_changed)


	func _on_caret_changed():
		if(_ignore_caret_change):
			_ignore_caret_change = false
		else:
			_last_pos = _get_caret();


	func _get_caret():
		return Vector2(te.get_caret_column(), te.get_caret_line())


	func _set_caret_and_sel(pos, len):
		te.set_caret_line(pos.y)
		te.set_caret_column(pos.x)
		if(len > 0):
			te.select(pos.y, pos.x, pos.y, pos.x + len)


	func _find(term, search_flags):
		var pos = _get_caret()
		if(term == _last_term):
			if(search_flags == 0):
				pos = _last_pos
				pos.x += 1
			else:
				pos = _last_pos
				pos.x -= 1

		var result = te.search(term, search_flags, pos.y, pos.x)
#		print('searching from ', pos, ' for "', term, '" = ', result)
		if(result.y != -1):
			_ignore_caret_change = true
			_set_caret_and_sel(result, term.length())
			_last_pos = result

		_last_term = term

	func find_next(term):
		_find(term, 0)

	func find_prev(term):
		_find(term, te.SEARCH_BACKWARDS)


# ##############################################################################
# Start OutputText control code
# ##############################################################################
@onready var _ctrls = {
	output = $Output,
	settings_bar = $Settings,
	use_colors = $Settings/UseColors,
	word_wrap = $Settings/WordWrap,

	copy_button = $Toolbar/CopyButton,
	clear_button = $Toolbar/ClearButton,
	show_search = $Toolbar/ShowSearch,
	caret_position = $Toolbar/LblPosition,

	search_bar = {
		bar = $Search,
		search_term = $Search/SearchTerm,
	}
}

var _sr = TextEditSearcher.new()
var _highlighter : CodeHighlighter
var _font_name = null
var _user_prefs = GutEditorGlobals.user_prefs
var _font_name_pctrl = null
var _font_size_pctrl = null

var keywords = [
	['Failed', Color.RED],
	['Passed', Color.GREEN],
	['Pending', Color.YELLOW],
	['Risky', Color.YELLOW],
	['Orphans', Color.YELLOW],
	['WARNING', Color.YELLOW],
	['ERROR', Color.RED],
	['ExpectedError', Color.LIGHT_BLUE],
]


# Automatically used when running the OutputText scene from the editor.  Changes
# to this method only affect test-running the control through the editor.
func _test_running_setup():
	_ctrls.use_colors.text = 'use colors'
	_ctrls.show_search.text = 'search'
	_ctrls.word_wrap.text = 'ww'

	set_all_fonts("CourierPrime")
	set_font_size(30)

	_ctrls.output.queue_redraw()
	load_file('user://.gut_editor.bbcode')
	await get_tree().process_frame

	show_search(true)
	_ctrls.output.set_caret_line(0)
	_ctrls.output.scroll_vertical = 0
	_ctrls.output.caret_changed.connect(_on_caret_changed)


func _ready():
	if(get_parent() is SubViewport):
		return

	_sr.set_text_edit(_ctrls.output)
	_ctrls.use_colors.icon = get_theme_icon('RichTextEffect', 'EditorIcons')
	_ctrls.show_search.icon = get_theme_icon('Search', 'EditorIcons')
	_ctrls.word_wrap.icon = get_theme_icon('Loop', 'EditorIcons')

	_setup_colors()
	_ctrls.use_colors.button_pressed = true
	_use_highlighting(true)

	if(get_parent() == get_tree().root):
		_test_running_setup()

	_ctrls.settings_bar.visible = false
	_add_other_ctrls()


func _add_other_ctrls():
	var fname = GutUtils.gut_fonts.DEFAULT_CUSTOM_FONT_NAME
	if(_user_prefs != null):
		fname = _user_prefs.output_font_name.value
	_font_name_pctrl = PanelControls.SelectControl.new('Font', fname, GutUtils.avail_fonts,
		"The font, you know, for the text below.  Change it, see what it does.")
	_font_name_pctrl.changed.connect(_on_font_name_changed)
	_font_name_pctrl.label.size_flags_horizontal = SIZE_SHRINK_BEGIN
	_ctrls.settings_bar.add_child(_font_name_pctrl)
	set_all_fonts(fname)

	var fsize = 30
	if(_user_prefs != null):
		fsize = _user_prefs.output_font_size.value
	_font_size_pctrl = PanelControls.NumberControl.new('Font Size', fsize , 5, 100,
		"The size of 'The Font'.")
	_font_size_pctrl.changed.connect(_on_font_size_changed)
	_font_size_pctrl.label.size_flags_horizontal = SIZE_SHRINK_BEGIN
	_ctrls.settings_bar.add_child(_font_size_pctrl)
	set_font_size(fsize)


# ------------------
# Private
# ------------------

# Call this after changes in colors and the like to get them to apply.  reloads
# the text of the output control.
func _refresh_output():
	var orig_pos = _ctrls.output.scroll_vertical
	var text = _ctrls.output.text

	_ctrls.output.text = text
	_ctrls.output.scroll_vertical = orig_pos


func _create_highlighter(default_color=Color(1, 1, 1, 1)):
	var to_return = CodeHighlighter.new()

	to_return.function_color = default_color
	to_return.number_color = default_color
	to_return.symbol_color = default_color
	to_return.member_variable_color = default_color

	for keyword in keywords:
		to_return.add_keyword_color(keyword[0], keyword[1])

	return to_return


func _setup_colors():
	_ctrls.output.clear()
	_highlighter = _create_highlighter()
	_ctrls.output.queue_redraw()



func _use_highlighting(should):
	if(should):
		_ctrls.output.syntax_highlighter = _highlighter
	else:
		_ctrls.output.syntax_highlighter = null
	_refresh_output()

# ------------------
# Events
# ------------------
func _on_caret_changed():
	var txt = str("line:",_ctrls.output.get_caret_line(), ' col:', _ctrls.output.get_caret_column())
	_ctrls.caret_position.text = str(txt)

func _on_font_size_changed():
	set_font_size(_font_size_pctrl.value)
	if(_user_prefs != null):
		_user_prefs.output_font_size.value = _font_size_pctrl.value
		_user_prefs.output_font_size.save_it()

func _on_font_name_changed():
	set_all_fonts(_font_name_pctrl.text)
	if(_user_prefs != null):
		_user_prefs.output_font_name.value = _font_name_pctrl.text
		_user_prefs.output_font_name.save_it()

func _on_CopyButton_pressed():
	copy_to_clipboard()

func _on_UseColors_pressed():
	_use_highlighting(_ctrls.use_colors.button_pressed)

func _on_ClearButton_pressed():
	clear()

func _on_ShowSearch_pressed():
	show_search(_ctrls.show_search.button_pressed)

func _on_SearchTerm_focus_entered():
	_ctrls.search_bar.search_term.call_deferred('select_all')

func _on_SearchNext_pressed():
	_sr.find_next(_ctrls.search_bar.search_term.text)

func _on_SearchPrev_pressed():
	_sr.find_prev(_ctrls.search_bar.search_term.text)

func _on_SearchTerm_text_changed(new_text):
	if(new_text == ''):
		_ctrls.output.deselect()
	else:
		_sr.find_next(new_text)

func _on_SearchTerm_text_entered(new_text):
	if(Input.is_physical_key_pressed(KEY_SHIFT)):
		_sr.find_prev(new_text)
	else:
		_sr.find_next(new_text)

func _on_SearchTerm_gui_input(event):
	if(event is InputEventKey and !event.pressed and event.keycode == KEY_ESCAPE):
		show_search(false)

func _on_WordWrap_pressed():
	if(_ctrls.word_wrap.button_pressed):
		_ctrls.output.wrap_mode = TextEdit.LINE_WRAPPING_BOUNDARY
	else:
		_ctrls.output.wrap_mode = TextEdit.LINE_WRAPPING_NONE

	_ctrls.output.queue_redraw()

func _on_settings_pressed():
	_ctrls.settings_bar.visible = $Toolbar/ShowSettings.button_pressed

# ------------------
# Public
# ------------------
func show_search(should):
	_ctrls.search_bar.bar.visible = should
	if(should):
		_ctrls.search_bar.search_term.grab_focus()
		_ctrls.search_bar.search_term.select_all()
	_ctrls.show_search.button_pressed = should


func search(text, start_pos, highlight=true):
	return _sr.find_next(text)


func copy_to_clipboard():
	var selected = _ctrls.output.get_selected_text()
	if(selected != ''):
		DisplayServer.clipboard_set(selected)
	else:
		DisplayServer.clipboard_set(_ctrls.output.text)


func clear():
	_ctrls.output.text = ''


func _set_font(custom_name, theme_font_name):
	var font = GutUtils.gut_fonts.get_font_for_theme_font_name(theme_font_name, custom_name)
	_ctrls.output.add_theme_font_override(theme_font_name, font)


func set_all_fonts(base_name):
	_font_name = GutUtils.nvl(base_name, 'Default')

	_set_font(base_name, 'font')
	_set_font(base_name, 'normal_font')
	_set_font(base_name, 'bold_font')
	_set_font(base_name, 'italics_font')
	_set_font(base_name, 'bold_italics_font')


func set_font_size(new_size):
	_ctrls.output.set("theme_override_font_sizes/font_size", new_size)


func set_use_colors(value):
	pass


func get_use_colors():
	return false;


func get_rich_text_edit():
	return _ctrls.output


func load_file(path):
	var f = FileAccess.open(path, FileAccess.READ)
	if(f == null):
		return

	var t = f.get_as_text()
	f = null # closes file
	_ctrls.output.text = t
	_ctrls.output.scroll_vertical = _ctrls.output.get_line_count()
	_ctrls.output.set_deferred('scroll_vertical', _ctrls.output.get_line_count())


func add_text(text):
	if(is_inside_tree()):
		_ctrls.output.text += text


func scroll_to_line(line):
	_ctrls.output.scroll_vertical = line
	_ctrls.output.set_caret_line(line)


--------------------------------------------------
FILE: res:///addons/gut/gui/OutputText.tscn
--------------------------------------------------
[gd_scene load_steps=5 format=3 uid="uid://bqmo4dj64c7yl"]

[ext_resource type="Script" uid="uid://cax5phqs8acmu" path="res://addons/gut/gui/OutputText.gd" id="1"]
[ext_resource type="Texture2D" uid="uid://bvo0uao7deu0q" path="res://addons/gut/icon.png" id="2_b4xqv"]

[sub_resource type="DPITexture" id="DPITexture_lygvu"]
_source = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\"><path fill=\"#ff5d5d\" d=\"M2 1v8.586l1.293-1.293a1 1 0 0 1 1.414 0L7 10.587l2.293-2.293a1 1 0 0 1 1.414 0L13 10.586l1-1V6H9V1H2zm8 0v4h4zm-6 9.414-2 2V15h12v-2.586l-.293.293a1 1 0 0 1-1.414 0L10 10.414l-2.293 2.293a1 1 0 0 1-1.414 0L4 10.414z\"/></svg>
"

[sub_resource type="CodeHighlighter" id="CodeHighlighter_8ynmy"]
number_color = Color(1, 1, 1, 1)
symbol_color = Color(1, 1, 1, 1)
function_color = Color(1, 1, 1, 1)
member_variable_color = Color(1, 1, 1, 1)
keyword_colors = {
"ERROR": Color(1, 0, 0, 1),
"ExpectedError": Color(0.6784314, 0.84705883, 0.9019608, 1),
"Failed": Color(1, 0, 0, 1),
"Orphans": Color(1, 1, 0, 1),
"Passed": Color(0, 1, 0, 1),
"Pending": Color(1, 1, 0, 1),
"Risky": Color(1, 1, 0, 1),
"WARNING": Color(1, 1, 0, 1)
}

[node name="OutputText" type="VBoxContainer"]
offset_right = 862.0
offset_bottom = 523.0
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1")

[node name="Toolbar" type="HBoxContainer" parent="."]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShowSearch" type="Button" parent="Toolbar"]
layout_mode = 2
tooltip_text = "Search"
toggle_mode = true
icon = ExtResource("2_b4xqv")

[node name="ShowSettings" type="Button" parent="Toolbar"]
layout_mode = 2
tooltip_text = "Settings"
toggle_mode = true
text = "..."

[node name="CenterContainer" type="CenterContainer" parent="Toolbar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LblPosition" type="Label" parent="Toolbar"]
layout_mode = 2

[node name="CopyButton" type="Button" parent="Toolbar"]
layout_mode = 2
text = " Copy "

[node name="ClearButton" type="Button" parent="Toolbar"]
layout_mode = 2
text = "  Clear  "

[node name="Settings" type="HBoxContainer" parent="."]
visible = false
layout_mode = 2

[node name="WordWrap" type="Button" parent="Settings"]
layout_mode = 2
tooltip_text = "Word Wrap"
toggle_mode = true
icon = SubResource("DPITexture_lygvu")

[node name="UseColors" type="Button" parent="Settings"]
layout_mode = 2
tooltip_text = "Colorized Text"
toggle_mode = true
button_pressed = true
icon = SubResource("DPITexture_lygvu")

[node name="Output" type="TextEdit" parent="."]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_font_sizes/font_size = 30
deselect_on_focus_loss_enabled = false
virtual_keyboard_enabled = false
middle_mouse_paste_enabled = false
scroll_smooth = true
syntax_highlighter = SubResource("CodeHighlighter_8ynmy")
highlight_all_occurrences = true
highlight_current_line = true

[node name="Search" type="HBoxContainer" parent="."]
visible = false
layout_mode = 2

[node name="SearchTerm" type="LineEdit" parent="Search"]
layout_mode = 2
size_flags_horizontal = 3

[node name="SearchNext" type="Button" parent="Search"]
layout_mode = 2
text = "Next"

[node name="SearchPrev" type="Button" parent="Search"]
layout_mode = 2
text = "Prev"

[connection signal="pressed" from="Toolbar/ShowSearch" to="." method="_on_ShowSearch_pressed"]
[connection signal="pressed" from="Toolbar/ShowSettings" to="." method="_on_settings_pressed"]
[connection signal="pressed" from="Toolbar/CopyButton" to="." method="_on_CopyButton_pressed"]
[connection signal="pressed" from="Toolbar/ClearButton" to="." method="_on_ClearButton_pressed"]
[connection signal="pressed" from="Settings/WordWrap" to="." method="_on_WordWrap_pressed"]
[connection signal="pressed" from="Settings/UseColors" to="." method="_on_UseColors_pressed"]
[connection signal="focus_entered" from="Search/SearchTerm" to="." method="_on_SearchTerm_focus_entered"]
[connection signal="gui_input" from="Search/SearchTerm" to="." method="_on_SearchTerm_gui_input"]
[connection signal="text_changed" from="Search/SearchTerm" to="." method="_on_SearchTerm_text_changed"]
[connection signal="text_submitted" from="Search/SearchTerm" to="." method="_on_SearchTerm_text_entered"]
[connection signal="pressed" from="Search/SearchNext" to="." method="_on_SearchNext_pressed"]
[connection signal="pressed" from="Search/SearchPrev" to="." method="_on_SearchPrev_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/ResizeHandle.gd
--------------------------------------------------
@tool
extends ColorRect
# #############################################################################
# Resize Handle control.  Place onto a control.  Set the orientation, then
# set the control that this should resize.  Then you can resize the control
# by dragging this thing around.  It's pretty neat.
# #############################################################################
enum ORIENTATION {
	LEFT,
	RIGHT
}

@export var orientation := ORIENTATION.RIGHT :
	get: return orientation
	set(val):
		orientation = val
		queue_redraw()
@export var resize_control : Control = null
@export var vertical_resize := true

var _line_width = .5
var _line_color = Color(.4, .4, .4)
var _active_line_color = Color(.3, .3, .3)
var _invalid_line_color = Color(1, 0, 0)

var _line_space = 3
var _num_lines = 8

var _mouse_down = false
# Called when the node enters the scene tree for the first time.


func _draw():
	var c = _line_color
	if(resize_control == null):
		c = _invalid_line_color
	elif(_mouse_down):
		c = _active_line_color

	if(orientation == ORIENTATION.LEFT):
		_draw_resize_handle_left(c)
	else:
		_draw_resize_handle_right(c)


func _gui_input(event):
	if(resize_control == null):
		return

	if(orientation == ORIENTATION.LEFT):
		_handle_left_input(event)
	else:
		_handle_right_input(event)


# Draw the lines in the corner to show where you can
# drag to resize the dialog
func _draw_resize_handle_right(draw_color):
	var br = size

	for i in range(_num_lines):
		var start = br - Vector2(i * _line_space, 0)
		var end = br - Vector2(0, i * _line_space)
		draw_line(start, end, draw_color, _line_width, true)


func _draw_resize_handle_left(draw_color):
	var bl = Vector2(0, size.y)

	for i in range(_num_lines):
		var start = bl + Vector2(i * _line_space, 0)
		var end = bl -  Vector2(0, i * _line_space)
		draw_line(start, end, draw_color, _line_width, true)


func _handle_right_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_mouse_down and
			event.global_position.x > 0 and
			event.global_position.y < DisplayServer.window_get_size().y):

			if(vertical_resize):
				resize_control.size.y += event.relative.y
			resize_control.size.x += event.relative.x
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_mouse_down = event.pressed
			queue_redraw()


func _handle_left_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_mouse_down and
			event.global_position.x > 0 and
			event.global_position.y < DisplayServer.window_get_size().y):

			var start_size = resize_control.size
			resize_control.size.x -= event.relative.x
			if(resize_control.size.x != start_size.x):
				resize_control.global_position.x += event.relative.x

			if(vertical_resize):
				resize_control.size.y += event.relative.y
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_mouse_down = event.pressed
			queue_redraw()


--------------------------------------------------
FILE: res:///addons/gut/gui/ResizeHandle.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bvrqqgjpyouse"]

[ext_resource type="Script" uid="uid://duf6rfdqr6yoc" path="res://addons/gut/gui/ResizeHandle.gd" id="1_oi5ed"]

[node name="ResizeHandle" type="ColorRect"]
custom_minimum_size = Vector2(20, 20)
color = Color(1, 1, 1, 0)
script = ExtResource("1_oi5ed")


--------------------------------------------------
FILE: res:///addons/gut/gui/ResultsTree.gd
--------------------------------------------------
@tool
extends Tree

var _show_orphans = true
var show_orphans = true :
	get: return _show_orphans
	set(val): _show_orphans = val


var _hide_passing = true
var hide_passing = true :
	get: return _hide_passing
	set(val): _hide_passing = val


var _icons = {
	red = load('res://addons/gut/images/red.png'),
	green = load('res://addons/gut/images/green.png'),
	yellow = load('res://addons/gut/images/yellow.png'),
}

@export var script_entry_color : Color = Color(0, 0, 0, .2) :
	set(val):
		if(val != null):
			script_entry_color = val
@export var column_0_color : Color = Color(1, 1, 1, 0) :
	set(val):
		if(val != null):
			column_0_color = val
@export var column_1_color : Color = Color(0, 0, 0, .2):
	set(val):
		if(val != null):
			column_1_color = val



var _max_icon_width = 10
var _root : TreeItem


@onready var lbl_overlay = $TextOverlay


signal selected(script_path, inner_class, test_name, line_number)

func _debug_ready():
	hide_passing = false
	load_json_file('user://gut_temp_directory/gut_editor.json')


func _ready():
	_root = create_item()
	set_hide_root(true)
	columns = 2
	set_column_expand(0, true)
	set_column_expand_ratio(0, 5)

	set_column_expand_ratio(1, 1)
	set_column_expand(1, true)

	item_selected.connect(_on_tree_item_selected)

	if(get_parent() == get_tree().root):
		_debug_ready()


# -------------------
# Private
# -------------------
func _get_line_number_from_assert_msg(msg):
	var line = -1
	if(msg.find('at line') > 0):
		line = msg.split("at line")[-1].split(" ")[-1].to_int()
	return line


func _get_path_and_inner_class_name_from_test_path(path):
	var to_return = {
		path = '',
		inner_class = ''
	}

	to_return.path = path
	if !path.ends_with('.gd'):
		var loc = path.find('.gd')
		to_return.inner_class = path.split('.')[-1]
		to_return.path = path.substr(0, loc + 3)
	return to_return


func _find_script_item_with_path(path):
	var items = _root.get_children()
	var to_return = null

	var idx = 0
	while(idx < items.size() and to_return == null):
		var item = items[idx]
		if(item.get_metadata(0).path == path):
			to_return = item
		else:
			idx += 1

	return to_return


func _add_script_tree_item(script_path, script_json):
	var path_info = _get_path_and_inner_class_name_from_test_path(script_path)
	var item_text = script_path
	var parent = _root

	if(path_info.inner_class != ''):
		parent = _find_script_item_with_path(path_info.path)
		item_text = path_info.inner_class
		if(parent == null):
			parent = _add_script_tree_item(path_info.path, {})

	var item = create_item(parent)
	item.set_text(0, item_text)
	var meta = {
		"type":"script",
		"path":path_info.path,
		"inner_class":path_info.inner_class,
		"json":script_json,
		"inner_passing":0,
		"inner_tests":0
	}
	item.set_metadata(0, meta)
	item.set_custom_bg_color(0, script_entry_color)
	item.set_custom_bg_color(1, script_entry_color)

	return item


func _add_assert_item(text, icon, parent_item):
	# print('        * adding assert')
	var assert_item = create_item(parent_item)
	assert_item.set_icon_max_width(0, _max_icon_width)
	assert_item.set_text(0, text)
	assert_item.set_metadata(0, {"type":"assert"})
	assert_item.set_icon(0, icon)
	assert_item.set_custom_bg_color(0, column_0_color)
	assert_item.set_custom_bg_color(1, column_1_color)

	return assert_item


func _add_test_tree_item(test_name, test_json, script_item):
	# print('    * adding test ', test_name)
	var no_orphans_to_show = !_show_orphans or (_show_orphans and test_json.orphan_count == 0)
	if(_hide_passing and test_json['status'] == 'pass' and no_orphans_to_show):
		return

	var item = create_item(script_item)
	var status = test_json['status']
	var meta = {"type":"test", "json":test_json}

	item.set_text(0, test_name)
	item.set_text(1, status)
	item.set_text_alignment(1, HORIZONTAL_ALIGNMENT_RIGHT)
	item.set_custom_bg_color(1, column_1_color)

	item.set_metadata(0, meta)
	item.set_icon_max_width(0, _max_icon_width)
	item.set_custom_bg_color(0, column_0_color)

	if(status == 'pass' and no_orphans_to_show):
		item.set_icon(0, _icons.green)
	elif(status == 'fail'):
		item.set_icon(0, _icons.red)
	else:
		item.set_icon(0, _icons.yellow)

	if(!_hide_passing):
		for passing in test_json.passing:
			_add_assert_item('pass: ' + passing, _icons.green, item)

	for failure in test_json.failing:
		_add_assert_item("fail:  " + failure.replace("\n", ''), _icons.red, item)

	for pending in test_json.pending:
		_add_assert_item("pending:  " + pending.replace("\n", ''), _icons.yellow, item)

	var orphan_text = 'orphans'
	if(test_json.orphan_count == 1):
		orphan_text = 'orphan'
	orphan_text = str(int(test_json.orphan_count), ' ', orphan_text)

	if(!no_orphans_to_show):
		var orphan_item = _add_assert_item(orphan_text, _icons.yellow, item)
		for o in test_json.orphans:
			var orphan_entry = create_item(orphan_item)
			orphan_entry.set_text(0, o)
			orphan_entry.set_custom_bg_color(0, column_0_color)
			orphan_entry.set_custom_bg_color(1, column_1_color)

	return item


func _add_script_to_tree(key, script_json):
	var tests = script_json['tests']
	var test_keys = tests.keys()
	var s_item = _add_script_tree_item(key, script_json)
	var bad_count = 0

	for test_key in test_keys:
		var t_item = _add_test_tree_item(test_key, tests[test_key], s_item)
		if(tests[test_key].status != 'pass'):
			bad_count += 1
		elif(t_item != null):
			t_item.collapsed = true

	if(s_item.get_children().size() == 0):
		if(script_json.props.skipped):
			_add_assert_item("Skipped", _icons.yellow, s_item)
			s_item.set_text(1, "Skipped")
		else:
			s_item.free()
	else:
		var total_text = str('All ', test_keys.size(), ' passed')
		if(bad_count == 0):
			s_item.collapsed = true
		else:
			total_text = str(int(test_keys.size() - bad_count), '/', int(test_keys.size()), ' passed')
		s_item.set_text(1, total_text)


func _free_childless_scripts():
	var items = _root.get_children()
	for item in items:
		var next_item = item.get_next()
		if(item.get_children().size() == 0):
			item.free()
		item = next_item


func _show_all_passed():
	if(_root.get_children().size() == 0):
		add_centered_text('Everything passed!')


func _load_result_tree(j):
	var scripts = j['test_scripts']['scripts']
	var script_keys = scripts.keys()
	# if we made it here, the json is valid and we did something, otherwise the
	# 'nothing to see here' should be visible.
	clear_centered_text()

	var add_count = 0
	for key in script_keys:
		add_count += 1
		_add_script_to_tree(key, scripts[key])

	_free_childless_scripts()
	if(add_count == 0):
		add_centered_text('Nothing was run')
	else:
		_show_all_passed()
# -------------------
# Events
# -------------------
func _on_tree_item_selected():
	var item = get_selected()
	var item_meta = item.get_metadata(0)
	var item_type = null

	# Only select the left side of the tree item, cause I like that better.
	# you can still click the right, but only the left gets highlighted.
	if(item.is_selected(1)):
		item.deselect(1)
		item.select(0)

	if(item_meta == null):
		return
	else:
		item_type = item_meta.type

	var script_path = '';
	var line = -1;
	var test_name = ''
	var inner_class = ''

	if(item_type == 'test'):
		var s_item = item.get_parent()
		script_path = s_item.get_metadata(0)['path']
		inner_class = s_item.get_metadata(0)['inner_class']
		line = -1
		test_name = item.get_text(0)
	elif(item_type == 'assert'):
		var s_item = item.get_parent().get_parent()
		script_path = s_item.get_metadata(0)['path']
		inner_class = s_item.get_metadata(0)['inner_class']
		line = _get_line_number_from_assert_msg(item.get_text(0))
		test_name = item.get_parent().get_text(0)
	elif(item_type == 'script'):
		script_path = item.get_metadata(0)['path']
		if(item.get_parent() != _root):
			inner_class = item.get_text(0)
		line = -1
		test_name = ''
	else:
		return

	selected.emit(script_path, inner_class, test_name, line)


# -------------------
# Public
# -------------------
func load_json_file(path):
	var file = FileAccess.open(path, FileAccess.READ)
	var text = ''
	if(file != null):
		text = file.get_as_text()

	if(text != ''):
		var test_json_conv = JSON.new()
		var result = test_json_conv.parse(text)
		if(result != OK):
			add_centered_text(str(path, " has invalid json in it \n",
				'Error ', result, "@", test_json_conv.get_error_line(), "\n",
				test_json_conv.get_error_message()))
			return

		var data = test_json_conv.get_data()
		load_json_results(data)
	else:
		add_centered_text(str(path, ' was empty or does not exist.'))


func load_json_results(j):
	clear()
	if(_root == null):
		_root = create_item()

	_load_result_tree(j)


#func clear():
	#clear()
	#_root = create_item()


func set_summary_min_width(width):
	set_column_custom_minimum_width(1, width)


func add_centered_text(t):
	lbl_overlay.visible = true
	lbl_overlay.text = t


func clear_centered_text():
	lbl_overlay.visible = false
	lbl_overlay.text = ''


func collapse_all():
	set_collapsed_on_all(_root, true)


func expand_all():
	set_collapsed_on_all(_root, false)


func set_collapsed_on_all(item, value):
	item.set_collapsed_recursive(value)
	if(item == _root and value):
		item.set_collapsed(false)


--------------------------------------------------
FILE: res:///addons/gut/gui/ResultsTree.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://dls5r5f6157nq"]

[ext_resource type="Script" uid="uid://dehdhn78qv5tr" path="res://addons/gut/gui/ResultsTree.gd" id="1_b4uub"]

[node name="ResultsTree" type="Tree"]
offset_right = 1082.0
offset_bottom = 544.0
size_flags_horizontal = 3
size_flags_vertical = 3
columns = 2
hide_root = true
script = ExtResource("1_b4uub")

[node name="TextOverlay" type="Label" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ResultsTree" type="VBoxContainer" parent="."]
custom_minimum_size = Vector2(10, 10)
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = -70.0
offset_bottom = -104.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3


--------------------------------------------------
FILE: res:///addons/gut/gui/RunAtCursor.gd
--------------------------------------------------
@tool
extends Control

var EditorCaretContextNotifier = load('res://addons/gut/editor_caret_context_notifier.gd')

@onready var _ctrls = {
	btn_script = $HBox/BtnRunScript,
	btn_inner = $HBox/BtnRunInnerClass,
	btn_method = $HBox/BtnRunMethod,
	lbl_none = $HBox/LblNoneSelected,
	arrow_1 = $HBox/Arrow1,
	arrow_2 = $HBox/Arrow2
}

var _caret_notifier = null

var _last_info = {
	script = null,
	inner_class = null,
	method = null
}

var disabled = false :
	set(val):
		disabled = val
		if(is_inside_tree()):
			_ctrls.btn_script.disabled = val
			_ctrls.btn_inner.disabled = val
			_ctrls.btn_method.disabled = val
var method_prefix = 'test_'
var inner_class_prefix = 'Test'
var menu_manager = null :
	set(val):
		menu_manager = val
		menu_manager.run_script.connect(_on_BtnRunScript_pressed)
		menu_manager.run_at_cursor.connect(run_at_cursor)
		menu_manager.rerun.connect(rerun)
		menu_manager.run_inner_class.connect(_on_BtnRunInnerClass_pressed)
		menu_manager.run_test.connect(_on_BtnRunMethod_pressed)
		_update_buttons(_last_info)


signal run_tests(what)


func _ready():
	_ctrls.lbl_none.visible = true
	_ctrls.btn_script.visible = false
	_ctrls.btn_inner.visible = false
	_ctrls.btn_method.visible = false
	_ctrls.arrow_1.visible = false
	_ctrls.arrow_2.visible = false

	_caret_notifier = EditorCaretContextNotifier.new()
	add_child(_caret_notifier)
	_caret_notifier.it_changed.connect(_on_caret_notifer_changed)

	disabled = disabled


func _on_caret_notifer_changed(data):
	if(data.is_test_script):
		_last_info = data
		_update_buttons(_last_info)


# ----------------
# Private
# ----------------

func _update_buttons(info):
	_ctrls.lbl_none.visible = false
	_ctrls.btn_script.visible = info.script != null

	if(info.script != null and info.is_test_script):
		_ctrls.btn_script.text = info.script.resource_path.get_file()

	_ctrls.btn_inner.visible = info.inner_class != null
	_ctrls.arrow_1.visible = info.inner_class != null
	_ctrls.btn_inner.text = str(info.inner_class)
	_ctrls.btn_inner.tooltip_text = str("Run all tests in Inner-Test-Class ", info.inner_class)

	var is_test_method = info.method != null and info.method.begins_with(method_prefix)
	_ctrls.btn_method.visible = is_test_method
	_ctrls.arrow_2.visible = is_test_method
	if(is_test_method):
		_ctrls.btn_method.text = str(info.method)
		_ctrls.btn_method.tooltip_text = str("Run test ", info.method)

	if(menu_manager != null):
		menu_manager.disable_menu("run_script", info.script == null)
		menu_manager.disable_menu("run_inner_class", info.inner_class == null)
		menu_manager.disable_menu("run_at_cursor", info.script == null)
		menu_manager.disable_menu("run_test", is_test_method)
		menu_manager.disable_menu("rerun", _last_run_info == {})
	# The button's new size won't take effect until the next frame.
	# This appears to be what was causing the button to not be clickable the
	# first time.
	_update_size.call_deferred()


func _update_size():
	custom_minimum_size.x = _ctrls.btn_method.size.x + _ctrls.btn_method.position.x

var _last_run_info = {}
func _emit_run_tests(info):
	_last_run_info = info.duplicate()
	run_tests.emit(info)

# ----------------
# Events
# ----------------
func _on_BtnRunScript_pressed():
	var info = _last_info.duplicate()
	info.script = info.script.resource_path.get_file()
	info.inner_class = null
	info.method = null
	_emit_run_tests(info)


func _on_BtnRunInnerClass_pressed():
	var info = _last_info.duplicate()
	info.script = info.script.resource_path.get_file()
	info.method = null
	_emit_run_tests(info)


func _on_BtnRunMethod_pressed():
	var info = _last_info.duplicate()
	info.script = info.script.resource_path.get_file()
	_emit_run_tests(info)


# ----------------
# Public
# ----------------
func rerun():
	if(_last_run_info != {}):
		_emit_run_tests(_last_run_info)


func run_at_cursor():
	if(_ctrls.btn_method.visible):
		_on_BtnRunMethod_pressed()
	elif(_ctrls.btn_inner.visible):
		_on_BtnRunInnerClass_pressed()
	elif(_ctrls.btn_script.visible):
		_on_BtnRunScript_pressed()
	else:
		print("nothing selected")


func get_script_button():
	return _ctrls.btn_script


func get_inner_button():
	return _ctrls.btn_inner


func get_test_button():
	return _ctrls.btn_method


func set_inner_class_prefix(value):
	_caret_notifier.inner_class_prefix = value


func apply_gut_config(gut_config):
	_caret_notifier.script_prefix = gut_config.options.prefix
	_caret_notifier.script_suffix = gut_config.options.suffix


--------------------------------------------------
FILE: res:///addons/gut/gui/RunAtCursor.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://0yunjxtaa8iw"]

[ext_resource type="Script" uid="uid://c4gmgdl1xwflw" path="res://addons/gut/gui/RunAtCursor.gd" id="1"]
[ext_resource type="Texture2D" uid="uid://6wra5rxmfsrl" path="res://addons/gut/gui/arrow.png" id="3"]

[node name="RunAtCursor" type="Control"]
custom_minimum_size = Vector2(510, 0)
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = 1.0
offset_bottom = -527.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1")

[node name="HBox" type="HBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LblNoneSelected" type="Label" parent="HBox"]
visible = false
layout_mode = 2
text = "<None>"

[node name="BtnRunScript" type="Button" parent="HBox"]
layout_mode = 2
text = "test_test.gd"

[node name="Arrow1" type="TextureButton" parent="HBox"]
custom_minimum_size = Vector2(24, 0)
layout_mode = 2
texture_normal = ExtResource("3")
stretch_mode = 3

[node name="BtnRunInnerClass" type="Button" parent="HBox"]
layout_mode = 2
tooltip_text = "Run all tests in Inner-Test-Class TestAssertNe"
text = "TestAssertNe"

[node name="Arrow2" type="TextureButton" parent="HBox"]
custom_minimum_size = Vector2(24, 0)
layout_mode = 2
texture_normal = ExtResource("3")
stretch_mode = 3

[node name="BtnRunMethod" type="Button" parent="HBox"]
layout_mode = 2
tooltip_text = "Run test test_fails_with_integers_equal"
text = "test_fails_with_integers_equal"

[connection signal="pressed" from="HBox/BtnRunScript" to="." method="_on_BtnRunScript_pressed"]
[connection signal="pressed" from="HBox/BtnRunInnerClass" to="." method="_on_BtnRunInnerClass_pressed"]
[connection signal="pressed" from="HBox/BtnRunMethod" to="." method="_on_BtnRunMethod_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/RunExternally.gd
--------------------------------------------------
@tool
extends Control

# I'm probably going to put this back in later and I don't want to create it
# again.  Yeah, yeah, yeah.
# class DotsAnimator:
# 	var text = ''
# 	var dot = '.'
# 	var max_dots = 3
# 	var dot_delay = .5

# 	var _anim_text = ''
# 	var _elapsed_time = 0.0
# 	var _cur_dots = 0

# 	func get_animated_text():
# 		return _anim_text

# 	func add_time(delta):
# 		_elapsed_time += delta
# 		if(_elapsed_time > dot_delay):
# 			_elapsed_time = 0
# 			_cur_dots += 1
# 			if(_cur_dots > max_dots):
# 				_cur_dots = 0

# 			_anim_text = text.rpad(text.length() + _cur_dots, dot)


var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

@onready var btn_kill_it = $BgControl/VBox/Kill
@onready var bg_control = $BgControl

var _pipe_results = {}
var _debug_mode = false
var _std_thread : Thread
var _escape_regex : RegEx = RegEx.new()
var _text_buffer = ''

var bottom_panel = null :
	set(val):
		bottom_panel = val
		bottom_panel.resized.connect(_on_bottom_panel_resized)
var blocking_mode = "Blocking"
var additional_arguments = []
var remove_escape_characters = true
@export var bg_color = Color.WHITE:
	set(val):
		bg_color = val
		if(is_inside_tree()):
			bg_control.get("theme_override_styles/panel").bg_color = bg_color


func _debug_ready():
	_debug_mode = true
	additional_arguments = ['-gselect', 'test_awaiter.gd', '-gconfig', 'res://.gutconfig.json'] # '-gunit_test_name', 'test_can_clear_spies'
	blocking_mode = "NonBlocking"
	run_tests()


func _ready():
	_escape_regex.compile("\\x1b\\[[0-9;]*m")
	btn_kill_it.visible = false

	if(get_parent() == get_tree().root):
		_debug_ready.call_deferred()
	bg_color = bg_color


func _process(_delta: float) -> void:
	if(_pipe_results != {}):
		if(!OS.is_process_running(_pipe_results.pid)):
			_end_non_blocking()


# ----------
# Private
# ----------
func _center_me():
	position = get_parent().size / 2.0 - size / 2.0


func _output_text(text, should_scroll = true):
	if(_debug_mode):
		print(text)
	else:
		if(remove_escape_characters):
			text = _escape_regex.sub(text, '', true)

		if(bottom_panel != null):
			bottom_panel.add_output_text(text)
			if(should_scroll):
				_scroll_output_pane(-1)
		else:
			_text_buffer += text


func _scroll_output_pane(line):
	if(!_debug_mode and bottom_panel != null):
		var txt_ctrl = bottom_panel.get_text_output_control().get_rich_text_edit()
		if(line == -1):
			line = txt_ctrl.get_line_count()
		txt_ctrl.scroll_vertical = line


func _add_arguments_to_output():
	if(additional_arguments.size() != 0):
		_output_text(
			str("Run Mode arguments: ", ' '.join(additional_arguments), "\n\n")
		)


func _load_json():
	if(_debug_mode):
		pass # could load file and print it if we want.
	elif(bottom_panel != null):
		bottom_panel.load_result_json()


func _run_blocking(options):
	btn_kill_it.visible = false
	var output = []
	await get_tree().create_timer(.1).timeout

	OS.execute(OS.get_executable_path(), options, output, true)

	_output_text(output[0])
	_add_arguments_to_output()
	_scroll_output_pane(-1)

	_load_json()
	queue_free()


func _read_non_blocking_stdio():
	while(OS.is_process_running(_pipe_results.pid)):
		while(_pipe_results.stderr.get_length() > 0):
			_output_text(_pipe_results.stderr.get_line() + "\n")

		while(_pipe_results.stdio.get_length() > 0):
			_output_text(_pipe_results.stdio.get_line() + "\n")

		# without this, things start to lock up.
		await get_tree().process_frame


func _run_non_blocking(options):
	_pipe_results = OS.execute_with_pipe(OS.get_executable_path(), options, false)
	_std_thread = Thread.new()
	_std_thread.start(_read_non_blocking_stdio)
	btn_kill_it.visible = true


func _end_non_blocking():
	_add_arguments_to_output()
	_scroll_output_pane(-1)

	_load_json()

	_pipe_results = {}
	_std_thread.wait_to_finish()
	_std_thread = null
	queue_free()
	if(_debug_mode):
		get_tree().quit()



# ----------------
# Events
# ----------------
func _on_kill_pressed() -> void:
	if(_pipe_results != {} and OS.is_process_running(_pipe_results.pid)):
		OS.kill(_pipe_results.pid)
		btn_kill_it.visible = false


func _on_color_rect_gui_input(event: InputEvent) -> void:
	if(event is InputEventMouseMotion):
		if(event.button_mask == MOUSE_BUTTON_MASK_LEFT):
			position += event.relative


func _on_bottom_panel_resized():
	_center_me()


# ----------------
# Public
# ----------------
func run_tests():
	_center_me()

	var options = ["-s", "res://addons/gut/gut_cmdln.gd", "-graie", "-gdisable_colors",
		"-gconfig", GutEditorGlobals.editor_run_gut_config_path]
	options.append_array(additional_arguments)

	if(blocking_mode == 'Blocking'):
		_run_blocking(options)
	else:
		_run_non_blocking(options)


func get_godot_help():
	_text_buffer = ''
	var options = ["--help", "--headless"]
	await _run_blocking(options)
	return _text_buffer


func get_gut_help():
	_text_buffer = ''
	var options = ["-s", "res://addons/gut/gut_cmdln.gd", "-gh", "--headless"]
	await _run_blocking(options)
	return _text_buffer


--------------------------------------------------
FILE: res:///addons/gut/gui/RunExternally.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://cftcb0e6g7tu1"]

[ext_resource type="Script" uid="uid://bi8pg352un4om" path="res://addons/gut/gui/RunExternally.gd" id="1_lrqqi"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_haowt"]
bg_color = Color(0.025935074, 0.17817128, 0.30283752, 1)
corner_radius_top_left = 20
corner_radius_top_right = 20
corner_radius_bottom_right = 20
corner_radius_bottom_left = 20
shadow_size = 5
shadow_offset = Vector2(7, 7)

[node name="DoShellOut" type="Control"]
layout_mode = 3
anchors_preset = 0
offset_right = 774.0
offset_bottom = 260.0
script = ExtResource("1_lrqqi")
bg_color = Color(0.025935074, 0.17817128, 0.30283752, 1)

[node name="BgControl" type="Panel" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_haowt")

[node name="VBox" type="VBoxContainer" parent="BgControl"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Spacer" type="CenterContainer" parent="BgControl/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="Title" type="Label" parent="BgControl/VBox"]
layout_mode = 2
text = "Running Tests"
horizontal_alignment = 1

[node name="Spacer2" type="CenterContainer" parent="BgControl/VBox"]
visible = false
layout_mode = 2
size_flags_vertical = 3

[node name="Kill" type="Button" parent="BgControl/VBox"]
visible = false
custom_minimum_size = Vector2(200, 50)
layout_mode = 2
size_flags_horizontal = 4
text = "Stop"

[node name="Spacer3" type="CenterContainer" parent="BgControl/VBox"]
layout_mode = 2
size_flags_vertical = 3

[connection signal="gui_input" from="BgControl" to="." method="_on_color_rect_gui_input"]
[connection signal="pressed" from="BgControl/VBox/Kill" to="." method="_on_kill_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/RunResults.gd
--------------------------------------------------
@tool
extends Control

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

var _interface = null
var _output_control = null

@onready var _ctrls = {
	tree = $VBox/Output/Scroll/Tree,
	toolbar = {
		toolbar = $VBox/Toolbar,
		collapse = $VBox/Toolbar/Collapse,
		collapse_all = $VBox/Toolbar/CollapseAll,
		expand = $VBox/Toolbar/Expand,
		expand_all = $VBox/Toolbar/ExpandAll,
		hide_passing = $VBox/Toolbar/HidePassing,
		show_script = $VBox/Toolbar/ShowScript,
		scroll_output = $VBox/Toolbar/ScrollOutput
	}
}

func _ready():
	if(get_parent() is SubViewport):
		return

	var f = null
	if ($FontSampler.get_label_settings() == null) :
		f = get_theme_default_font()
	else :
		f = $FontSampler.get_label_settings().font
	var s_size = f.get_string_size("000 of 000 passed")
	_ctrls.tree.set_summary_min_width(s_size.x)

	_set_toolbutton_icon(_ctrls.toolbar.collapse, 'CollapseTree', 'c')
	_set_toolbutton_icon(_ctrls.toolbar.collapse_all, 'CollapseTree', 'c')
	_set_toolbutton_icon(_ctrls.toolbar.expand, 'ExpandTree', 'e')
	_set_toolbutton_icon(_ctrls.toolbar.expand_all, 'ExpandTree', 'e')
	_set_toolbutton_icon(_ctrls.toolbar.show_script, 'Script', 'ss')
	_set_toolbutton_icon(_ctrls.toolbar.scroll_output, 'Font', 'so')

	_ctrls.tree.hide_passing = true
	_ctrls.toolbar.hide_passing.button_pressed = false
	_ctrls.tree.show_orphans = true
	_ctrls.tree.selected.connect(_on_item_selected)

	if(get_parent() == get_tree().root):
		_test_running_setup()

	call_deferred('_update_min_width')


func _test_running_setup():
	_ctrls.tree.hide_passing = true
	_ctrls.tree.show_orphans = true

	_ctrls.toolbar.hide_passing.text = '[hp]'
	_ctrls.tree.load_json_file(GutEditorGlobals.editor_run_json_results_path)


func _set_toolbutton_icon(btn, icon_name, text):
	if(Engine.is_editor_hint()):
		btn.icon = get_theme_icon(icon_name, 'EditorIcons')
	else:
		btn.text = str('[', text, ']')


func _update_min_width():
	custom_minimum_size.x = _ctrls.toolbar.toolbar.size.x


func _open_script_in_editor(path, line_number):
	if(_interface == null):
		print('Too soon, wait a bit and try again.')
		return

	var r = load(path)
	if(line_number != null and line_number != -1):
		_interface.edit_script(r, line_number)
	else:
		_interface.edit_script(r)

	if(_ctrls.toolbar.show_script.pressed):
		_interface.set_main_screen_editor('Script')


# starts at beginning of text edit and searches for each search term, moving
# through the text as it goes; ensuring that, when done, it found the first
# occurance of the last srting that happend after the first occurance of
# each string before it.  (Generic way of searching for a method name in an
# inner class that may have be a duplicate of a method name in a different
# inner class)
func _get_line_number_for_seq_search(search_strings, te):
	if(te == null):
		print("No Text editor to get line number for")
		return 0;

	var result = null
	var line = Vector2i(0, 0)
	var s_flags = 0

	var i = 0
	var string_found = true
	while(i < search_strings.size() and string_found):
		result = te.search(search_strings[i], s_flags, line.y, line.x)
		if(result.x != -1):
			line = result
		else:
			string_found = false
		i += 1

	return line.y


func _goto_code(path, line, method_name='', inner_class =''):
	if(_interface == null):
		print('going to ', [path, line, method_name, inner_class])
		return

	_open_script_in_editor(path, line)
	if(line == -1):
		var search_strings = []
		if(inner_class != ''):
			search_strings.append(inner_class)

		if(method_name != ''):
			search_strings.append(method_name)

		await get_tree().process_frame
		line = _get_line_number_for_seq_search(search_strings,
			_interface.get_script_editor().get_current_editor().get_base_editor())
		if(line != null and line != -1):
			_interface.get_script_editor().goto_line(line)


func _goto_output(path, method_name, inner_class):
	if(_output_control == null):
		return

	var search_strings = [path]

	if(inner_class != ''):
		search_strings.append(inner_class)

	if(method_name != ''):
		search_strings.append(method_name)

	var line = _get_line_number_for_seq_search(search_strings, _output_control.get_rich_text_edit())
	if(line != null and line != -1):
		_output_control.scroll_to_line(line)




# --------------
# Events
# --------------
func _on_Collapse_pressed():
	collapse_selected()


func _on_Expand_pressed():
	expand_selected()


func _on_CollapseAll_pressed():
	collapse_all()


func _on_ExpandAll_pressed():
	expand_all()


func _on_Hide_Passing_pressed():
	_ctrls.tree.hide_passing = !_ctrls.toolbar.hide_passing.button_pressed
	_ctrls.tree.load_json_file(GutEditorGlobals.editor_run_json_results_path)


func _on_item_selected(script_path, inner_class, test_name, line):
	if(_ctrls.toolbar.show_script.button_pressed):
		_goto_code(script_path, line, test_name, inner_class)
	if(_ctrls.toolbar.scroll_output.button_pressed):
		_goto_output(script_path, test_name, inner_class)




# --------------
# Public
# --------------
func add_centered_text(t):
	_ctrls.tree.add_centered_text(t)


func clear_centered_text():
	_ctrls.tree.clear_centered_text()


func clear():
	_ctrls.tree.clear()
	clear_centered_text()


func set_interface(which):
	_interface = which


func collapse_all():
	_ctrls.tree.collapse_all()


func expand_all():
	_ctrls.tree.expand_all()


func collapse_selected():
	var item = _ctrls.tree.get_selected()
	if(item != null):
		_ctrls.tree.set_collapsed_on_all(item, true)


func expand_selected():
	var item = _ctrls.tree.get_selected()
	if(item != null):
		_ctrls.tree.set_collapsed_on_all(item, false)


func set_show_orphans(should):
	_ctrls.tree.show_orphans = should


func set_font(font_name, size):
	pass
#	var dyn_font = FontFile.new()
#	var font_data = FontFile.new()
#	font_data.font_path = 'res://addons/gut/fonts/' + font_name + '-Regular.ttf'
#	font_data.antialiased = true
#	dyn_font.font_data = font_data
#
#	_font = dyn_font
#	_font.size = size
#	_font_size = size


func set_output_control(value):
	_output_control = value


func load_json_results(j):
	_ctrls.tree.load_json_results(j)


--------------------------------------------------
FILE: res:///addons/gut/gui/RunResults.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://4gyyn12um08h"]

[ext_resource type="Script" uid="uid://chnko3073tkcv" path="res://addons/gut/gui/RunResults.gd" id="1"]
[ext_resource type="Texture2D" uid="uid://bvo0uao7deu0q" path="res://addons/gut/icon.png" id="2_1k8e0"]
[ext_resource type="PackedScene" uid="uid://dls5r5f6157nq" path="res://addons/gut/gui/ResultsTree.tscn" id="2_o808v"]

[node name="RunResults" type="Control"]
custom_minimum_size = Vector2(345, 0)
layout_mode = 3
anchors_preset = 0
offset_right = 709.0
offset_bottom = 321.0
script = ExtResource("1")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="Toolbar" type="HBoxContainer" parent="VBox"]
layout_mode = 2
size_flags_horizontal = 0

[node name="Expand" type="Button" parent="VBox/Toolbar"]
visible = false
layout_mode = 2
icon = ExtResource("2_1k8e0")

[node name="Collapse" type="Button" parent="VBox/Toolbar"]
visible = false
layout_mode = 2
icon = ExtResource("2_1k8e0")

[node name="Sep" type="ColorRect" parent="VBox/Toolbar"]
visible = false
custom_minimum_size = Vector2(2, 0)
layout_mode = 2

[node name="LblAll" type="Label" parent="VBox/Toolbar"]
visible = false
layout_mode = 2
text = "All:"

[node name="ExpandAll" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
icon = ExtResource("2_1k8e0")

[node name="CollapseAll" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
icon = ExtResource("2_1k8e0")

[node name="Sep2" type="ColorRect" parent="VBox/Toolbar"]
custom_minimum_size = Vector2(2, 0)
layout_mode = 2

[node name="HidePassing" type="CheckBox" parent="VBox/Toolbar"]
layout_mode = 2
size_flags_horizontal = 4
text = "Passing"

[node name="Sep3" type="ColorRect" parent="VBox/Toolbar"]
custom_minimum_size = Vector2(2, 0)
layout_mode = 2

[node name="LblSync" type="Label" parent="VBox/Toolbar"]
layout_mode = 2
text = "Sync:"

[node name="ShowScript" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
toggle_mode = true
button_pressed = true
icon = ExtResource("2_1k8e0")

[node name="ScrollOutput" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
toggle_mode = true
button_pressed = true
icon = ExtResource("2_1k8e0")

[node name="Output" type="Panel" parent="VBox"]
self_modulate = Color(1, 1, 1, 0.541176)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Scroll" type="ScrollContainer" parent="VBox/Output"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Tree" parent="VBox/Output/Scroll" instance=ExtResource("2_o808v")]
layout_mode = 2

[node name="FontSampler" type="Label" parent="."]
visible = false
layout_mode = 0
offset_right = 40.0
offset_bottom = 14.0
text = "000 of 000 passed"

[connection signal="pressed" from="VBox/Toolbar/Expand" to="." method="_on_Expand_pressed"]
[connection signal="pressed" from="VBox/Toolbar/Collapse" to="." method="_on_Collapse_pressed"]
[connection signal="pressed" from="VBox/Toolbar/ExpandAll" to="." method="_on_ExpandAll_pressed"]
[connection signal="pressed" from="VBox/Toolbar/CollapseAll" to="." method="_on_CollapseAll_pressed"]
[connection signal="pressed" from="VBox/Toolbar/HidePassing" to="." method="_on_Hide_Passing_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/Settings.tscn
--------------------------------------------------
[gd_scene format=3 uid="uid://cvvvtsah38l0e"]

[node name="Settings" type="VBoxContainer"]
offset_right = 388.0
offset_bottom = 586.0
size_flags_horizontal = 3
size_flags_vertical = 3


--------------------------------------------------
FILE: res:///addons/gut/gui/ShellOutOptions.gd
--------------------------------------------------
@tool
extends ConfirmationDialog

const RUN_MODE_EDITOR = 'Editor'
const RUN_MODE_BLOCKING = 'Blocking'
const RUN_MODE_NON_BLOCKING = 'NonBlocking'

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

@onready var _bad_arg_dialog = $AcceptDialog
@onready var _main_container = $ScrollContainer/VBoxContainer

var _blurb_style_box = StyleBoxEmpty.new()
var _opt_maker_setup = false
var _arg_vbox : VBoxContainer = null
var _my_ok_button : Button = null

# Run mode button stuff
var _run_mode_theme = load('res://addons/gut/gui/EditorRadioButton.tres')
var _button_group = ButtonGroup.new()
var _btn_in_editor : Button = null
var _btn_blocking : Button = null
var _btn_non_blocking : Button = null
var _txt_additional_arguments = null
var _btn_godot_help = null
var _btn_gut_help = null


var opt_maker = null
var default_path = GutEditorGlobals.run_externally_options_path
# I like this.  It holds values loaded/saved which makes for an easy
# reset mechanism.  Hit OK; values get written to this object (not the file
# system).  Hit Cancel; values are reloaded from this object.  Call the
# save/load methods to interact with the file system.
#
# Downside:  If the keys/sections in the config file change, this ends up
#            preserving old data.  So you gotta find a way to clean it out
#            somehow.
# Downside solved:  Clear the config file at the start of the save method.
var _config_file = ConfigFile.new()

var _run_mode = RUN_MODE_EDITOR
var run_mode = _run_mode:
	set(val):
		_run_mode = val
		if(is_inside_tree()):
			_btn_in_editor.button_pressed = _run_mode == RUN_MODE_EDITOR
			if(_btn_in_editor.button_pressed):
				_btn_in_editor.pressed.emit()
			_btn_blocking.button_pressed = _run_mode == RUN_MODE_BLOCKING
			if(_btn_blocking.button_pressed):
				_btn_blocking.pressed.emit()
			_btn_non_blocking.button_pressed = _run_mode == RUN_MODE_NON_BLOCKING
			if(_btn_non_blocking.button_pressed):
				_btn_non_blocking.pressed.emit()
	get():
		return _run_mode


var additional_arguments = '' :
	get():
		if(_opt_maker_setup):
			return opt_maker.controls.additional_arguments.value
		else:
			return additional_arguments


func _debug_ready():
	popup_centered()
	default_path = GutEditorGlobals.temp_directory.path_join('test_external_run_options.cfg')
	exclusive = false

	var save_btn = Button.new()
	save_btn.text = 'save'
	save_btn.pressed.connect(func():
		save_to_file()
		print(_config_file.encode_to_text()))
	save_btn.position = Vector2(100, 20)
	save_btn.size = Vector2(100, 100)
	get_tree().root.add_child(save_btn)

	var load_btn = Button.new()
	load_btn.text = 'load'
	load_btn.pressed.connect(func():
		load_from_file()
		print(_config_file.encode_to_text()))
	load_btn.position = Vector2(100, 130)
	load_btn.size = Vector2(100, 100)
	get_tree().root.add_child(load_btn)

	var show_btn = Button.new()
	show_btn.text = 'Show'
	show_btn.pressed.connect(popup_centered)
	show_btn.position = Vector2(100, 250)
	show_btn.size = Vector2(100, 100)
	get_tree().root.add_child(show_btn)


func _ready():
	opt_maker = GutUtils.OptionMaker.new(_main_container)
	_add_controls()

	if(get_parent() == get_tree().root):
		_debug_ready.call_deferred()

	_my_ok_button = Button.new()
	_my_ok_button.text = 'OK'
	_my_ok_button.pressed.connect(_validate_and_confirm)
	get_ok_button().add_sibling(_my_ok_button)
	get_ok_button().modulate.a = 0.0
	get_ok_button().text = ''
	get_ok_button().disabled = true

	canceled.connect(reset)
	_button_group.pressed.connect(_on_mode_button_pressed)
	run_mode = run_mode


func _validate_and_confirm():
	if(validate_arguments()):
		_save_to_config_file(_config_file)
		confirmed.emit()
		hide()
	else:
		var dlg_text = str("Invalid arguments.  The following cannot be used:\n",
			' '.join(_invalid_args))

		if(run_mode == RUN_MODE_BLOCKING):
			dlg_text += str("\nThese cannot be used with blocking mode:\n",
				' '.join(_invalid_blocking_args))

		_bad_arg_dialog.dialog_text = dlg_text
		_bad_arg_dialog.popup_centered()


func _on_mode_button_pressed(which):
	if(which == _btn_in_editor):
		_arg_vbox.modulate.a = .3
	else:
		_arg_vbox.modulate.a = 1.0

	_txt_additional_arguments.value_ctrl.editable = which != _btn_in_editor
	if(which == _btn_in_editor):
		_run_mode = RUN_MODE_EDITOR
	elif(which == _btn_blocking):
		_run_mode = RUN_MODE_BLOCKING
	elif(which == _btn_non_blocking):
		_run_mode = RUN_MODE_NON_BLOCKING


func _add_run_mode_button(text, desc_label, description):
	var btn = Button.new()
	btn.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	btn.toggle_mode = true
	btn.text = text
	btn.button_group = _button_group
	btn.theme = _run_mode_theme
	btn.pressed.connect(func():  desc_label.text = str('[b]', text, "[/b]\n", description))

	return btn


func _add_blurb(text):
	var ctrl = opt_maker.add_blurb(text)
	ctrl.set("theme_override_styles/normal", _blurb_style_box)
	return ctrl


func _add_title(text):
	var ctrl = opt_maker.add_title(text)
	ctrl.get_child(0).horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	return ctrl


func _add_controls():
	_add_title("Run Modes")
	_add_blurb(
		"Choose how GUT will launch tests.  Normally you just run them through the editor, but now " +
		"you can run them externally.  This is an experimental feature.  It has been tested on Mac " +
		"and Windows.  Your results may vary.  Feedback welcome at [url]https://github.com/bitwes/Gut/issues[/url].\n ")

	var button_desc_box = HBoxContainer.new()
	var button_box = VBoxContainer.new()
	var button_desc = RichTextLabel.new()
	button_desc.fit_content = true
	button_desc.bbcode_enabled = true
	button_desc.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	button_desc.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	_main_container.add_child(button_desc_box)
	button_desc_box.add_child(button_box)
	button_desc_box.add_child(button_desc)

	_btn_in_editor = _add_run_mode_button("In Editor (default)", button_desc,
		"This is the default.  Runs through the editor.  When an error occurs " +
		"the debugger is invoked.  [b]print[/b] output " +
		"appears in the Output panel and errors show up in the Debugger panel.")
	button_box.add_child(_btn_in_editor)
	_btn_blocking = _add_run_mode_button("Externally - Blocking", button_desc,
		"Debugger is not enabled, and cannot be enabled.  All output (print, errors, warnings, etc) " +
		"appears in the GUT panel, and [b]not[/b] the Output or Debugger panels.  \n" +
		"The Editor cannot be used while tests are running.  If you are trying to test for errors, this " +
		"mode provides the best output.")
	button_box.add_child(_btn_blocking)
	_btn_non_blocking = _add_run_mode_button("Externally - NonBlocking", button_desc,
		"Debugger is not enabled, and cannot be enabled.  All output (print, errors, warnings, etc) " +
		"appears in the GUT panel, and [b]not[/b] the Output or Debugger panels.  \n" +
		"Test output is streamed to the GUT panel.  The editor is not blocked, but can be less " +
		"responsive when there is a lot of output.  This is the only mode that supports the --headless argument." )
	button_box.add_child(_btn_non_blocking)

	_add_title("Command Line Arguments")
	_arg_vbox = VBoxContainer.new()
	_main_container.add_child(_arg_vbox)
	opt_maker.base_container = _arg_vbox
	_txt_additional_arguments = opt_maker.add_value("additional_arguments", additional_arguments, '', '')
	_txt_additional_arguments.value_ctrl.placeholder_text = "Put your arguments here.  Ex:  --verbose -glog 0"
	_txt_additional_arguments.value_ctrl.select_all_on_focus = false
	_add_blurb(
		"Supply any command line options for GUT and/or Godot when running externally.  You cannot use " +
		"spaces in values.  See the Godot and GUT documentation for valid arguments.  GUT arguments " + 
		"specified here take precedence over your config.")
	_add_blurb("[b]Be Careful[/b]  There are plenty of argument combinations that may make this " +
		"act wrong/odd/bad/horrible.  Some arguments you might [i]want[/i] " +
		"to use but [b]shouldn't[/b] are checked for, but not that many.  Choose your arguments carefully (generally good advice).")

	opt_maker.base_container = _main_container
	_add_title("Display CLI Help")
	_add_blurb("You can use these buttons to get a list of valid GUT and Godot options.  They print the CLI help text for each to the [b]Output Panel[/b].")
	_btn_godot_help = Button.new()
	_btn_godot_help.text = "Print Godot CLI Help"
	_main_container.add_child(_btn_godot_help)
	_btn_godot_help.pressed.connect(func():
		await _show_help("get_godot_help"))

	_btn_gut_help = Button.new()
	_btn_gut_help.text = "Print GUT CLI Help"
	_main_container.add_child(_btn_gut_help)
	_btn_gut_help.pressed.connect(func():
		await _show_help("get_gut_help"))

	_opt_maker_setup = true


func _show_help(help_method_name):
	_btn_godot_help.disabled = true
	_btn_gut_help.disabled = true
	var re = GutUtils.RunExternallyScene.instantiate()
	add_child(re)
	re.visible = false
	var text = await re.call(help_method_name)
	print(text)
	re.queue_free()
	_btn_godot_help.disabled = false
	_btn_gut_help.disabled = false
	if(GutEditorGlobals.gut_plugin != null):
		GutEditorGlobals.gut_plugin.show_output_panel()


func _save_to_config_file(f : ConfigFile):
	f.clear()
	f.set_value('main', 'run_mode', run_mode)
	f.set_value('main', 'additional_arguments', opt_maker.controls.additional_arguments.value)


func save_to_file(path = default_path):
	_save_to_config_file(_config_file)
	_config_file.save(path)


func _load_from_config_file(f):
	run_mode = f.get_value('main', 'run_mode', RUN_MODE_EDITOR)
	opt_maker.controls.additional_arguments.value = \
		f.get_value('main', 'additional_arguments', '')


func load_from_file(path = default_path):
	_config_file.load(path)
	_load_from_config_file(_config_file)


func reset():
	_load_from_config_file(_config_file)


func get_additional_arguments_array():
	return additional_arguments.split(" ", false)


func should_run_externally():
	return run_mode != RUN_MODE_EDITOR


var _invalid_args = [
	'-d', '--debug',
	'-s', '--script',
	'-e', '--editor'
]
var _invalid_blocking_args = [
	'--headless'
]
func validate_arguments():
	var arg_array = get_additional_arguments_array()
	var i = 0
	var invalid_found = false
	while i < _invalid_args.size() and !invalid_found:
		if(arg_array.has(_invalid_args[i])):
			invalid_found = true
		i += 1

	if(run_mode == RUN_MODE_BLOCKING):
		i = 0
		while i < _invalid_blocking_args.size() and !invalid_found:
			if(arg_array.has(_invalid_blocking_args[i])):
				invalid_found = true
			i += 1

	return !invalid_found


func get_godot_help():
	return ''


--------------------------------------------------
FILE: res:///addons/gut/gui/ShellOutOptions.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://ckv5eh8xyrwbk"]

[ext_resource type="Script" uid="uid://c64u22kybimgi" path="res://addons/gut/gui/ShellOutOptions.gd" id="1_ht2pf"]

[node name="ShellOutOptions" type="ConfirmationDialog"]
oversampling_override = 1.0
title = "GUT Run Mode (Experimental)"
position = Vector2i(0, 36)
size = Vector2i(516, 557)
visible = true
script = ExtResource("1_ht2pf")

[node name="ScrollContainer" type="ScrollContainer" parent="."]
custom_minimum_size = Vector2(500, 500)
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 8.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = -49.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="AcceptDialog" type="AcceptDialog" parent="."]
oversampling_override = 1.0
size = Vector2i(399, 106)
dialog_text = "Invalid arguments.  The following cannot be used:
-d --debug -s --script"


--------------------------------------------------
FILE: res:///addons/gut/gui/ShortcutButton.gd
--------------------------------------------------
@tool
extends Control


@onready var _ctrls = {
	shortcut_label = $Layout/lblShortcut,
	set_button = $Layout/SetButton,
	save_button = $Layout/SaveButton,
	cancel_button = $Layout/CancelButton,
	clear_button = $Layout/ClearButton
}

signal changed
signal start_edit
signal end_edit

const NO_SHORTCUT = '<None>'

var _source_event = InputEventKey.new()
var _pre_edit_event = null
var _key_disp = NO_SHORTCUT
var _editing = false

var _modifier_keys = [KEY_ALT, KEY_CTRL, KEY_META, KEY_SHIFT]

# Called when the node enters the scene tree for the first time.
func _ready():
	set_process_unhandled_key_input(false)


func _display_shortcut():
	if(_key_disp == ''):
		_key_disp = NO_SHORTCUT
	_ctrls.shortcut_label.text = _key_disp


func _is_shift_only_modifier():
	return _source_event.shift_pressed and \
		!(_source_event.alt_pressed or \
			_source_event.ctrl_pressed or \
			_source_event.meta_pressed) \
		and !_is_modifier(_source_event.keycode)


func _has_modifier(event):
	return event.alt_pressed or event.ctrl_pressed or \
		event.meta_pressed or event.shift_pressed


func _is_modifier(keycode):
	return _modifier_keys.has(keycode)


func _edit_mode(should):
	_editing = should
	set_process_unhandled_key_input(should)
	_ctrls.set_button.visible = !should
	_ctrls.save_button.visible = should
	_ctrls.save_button.disabled = should
	_ctrls.cancel_button.visible = should
	_ctrls.clear_button.visible = !should

	if(should and to_s() == ''):
		_ctrls.shortcut_label.text = 'press buttons'
	else:
		_ctrls.shortcut_label.text = to_s()

	if(should):
		emit_signal("start_edit")
	else:
		emit_signal("end_edit")

# ---------------
# Events
# ---------------
func _unhandled_key_input(event):
	if(event is InputEventKey):
		if(event.pressed):
			if(_has_modifier(event) and !_is_modifier(event.get_keycode_with_modifiers())):
				_source_event = event
				_key_disp = OS.get_keycode_string(event.get_keycode_with_modifiers())
			else:
				_source_event = InputEventKey.new()
				_key_disp = NO_SHORTCUT
			_display_shortcut()
			_ctrls.save_button.disabled = !is_valid()


func _on_SetButton_pressed():
	_pre_edit_event = _source_event.duplicate(true)
	_edit_mode(true)


func _on_SaveButton_pressed():
	_edit_mode(false)
	_pre_edit_event = null
	emit_signal('changed')


func _on_CancelButton_pressed():
	cancel()


func _on_ClearButton_pressed():
	clear_shortcut()

# ---------------
# Public
# ---------------
func to_s():
	return OS.get_keycode_string(_source_event.get_keycode_with_modifiers())


func is_valid():
	return _has_modifier(_source_event) and !_is_shift_only_modifier()


func get_shortcut():
	var to_return = Shortcut.new()
	to_return.events.append(_source_event)
	return to_return

func get_input_event():
	return _source_event

func set_shortcut(sc):
	if(sc == null or sc.events == null || sc.events.size() <= 0):
		clear_shortcut()
	else:
		_source_event = sc.events[0]
		_key_disp = to_s()
		_display_shortcut()


func clear_shortcut():
	_source_event = InputEventKey.new()
	_key_disp = NO_SHORTCUT
	_display_shortcut()


func disable_set(should):
	_ctrls.set_button.disabled = should


func disable_clear(should):
	_ctrls.clear_button.disabled = should
	
	
func cancel():
	if(_editing):
		_edit_mode(false)
		_source_event = _pre_edit_event
		_key_disp = to_s()
		_display_shortcut()


--------------------------------------------------
FILE: res:///addons/gut/gui/ShortcutButton.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://sfb1fw8j6ufu"]

[ext_resource type="Script" uid="uid://k6hvvpekp0xw" path="res://addons/gut/gui/ShortcutButton.gd" id="1"]

[node name="ShortcutButton" type="Control"]
custom_minimum_size = Vector2(210, 30)
layout_mode = 3
anchor_right = 0.123
anchor_bottom = 0.04
offset_right = 68.304
offset_bottom = 6.08
script = ExtResource("1")

[node name="Layout" type="HBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="lblShortcut" type="Label" parent="Layout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 7
text = "<None>"
horizontal_alignment = 2

[node name="CenterContainer" type="CenterContainer" parent="Layout"]
custom_minimum_size = Vector2(10, 0)
layout_mode = 2

[node name="SetButton" type="Button" parent="Layout"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Set"

[node name="SaveButton" type="Button" parent="Layout"]
visible = false
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Save"

[node name="CancelButton" type="Button" parent="Layout"]
visible = false
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Cancel"

[node name="ClearButton" type="Button" parent="Layout"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Clear"

[connection signal="pressed" from="Layout/SetButton" to="." method="_on_SetButton_pressed"]
[connection signal="pressed" from="Layout/SaveButton" to="." method="_on_SaveButton_pressed"]
[connection signal="pressed" from="Layout/CancelButton" to="." method="_on_CancelButton_pressed"]
[connection signal="pressed" from="Layout/ClearButton" to="." method="_on_ClearButton_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/ShortcutDialog.gd
--------------------------------------------------
@tool
extends ConfirmationDialog

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var default_path = GutEditorGlobals.editor_shortcuts_path


@onready var scbtn_run_all = $Scroll/Layout/CRunAll/ShortcutButton
@onready var scbtn_run_current_script = $Scroll/Layout/CRunCurrentScript/ShortcutButton
@onready var scbtn_run_current_inner = $Scroll/Layout/CRunCurrentInner/ShortcutButton
@onready var scbtn_run_current_test = $Scroll/Layout/CRunCurrentTest/ShortcutButton
@onready var scbtn_run_at_cursor = $Scroll/Layout/CRunAtCursor/ShortcutButton
@onready var scbtn_rerun = $Scroll/Layout/CRerun/ShortcutButton
@onready var scbtn_panel = $Scroll/Layout/CPanelButton/ShortcutButton
@onready var scbtn_windowed = $Scroll/Layout/CToggleWindowed/ShortcutButton


@onready var all_buttons = [
	scbtn_run_all, scbtn_run_current_script, scbtn_run_current_inner,
	scbtn_run_current_test, scbtn_run_at_cursor, scbtn_rerun,
	scbtn_panel, scbtn_windowed
]


func _debug_ready():
	popup_centered()

	var btn = Button.new()
	btn.text = "show"
	get_tree().root.add_child(btn)
	btn.pressed.connect(popup)
	btn.position = Vector2(100, 100)
	btn.size = Vector2(100, 100)

	size_changed.connect(func(): title = str(size))


func _ready():
	for scbtn in all_buttons:
		scbtn.connect('start_edit', _on_edit_start.bind(scbtn))
		scbtn.connect('end_edit', _on_edit_end)

	canceled.connect(_on_cancel)

	# Sizing this window on different monitors, especially compared to what it
	# looks like if you just run this project is annoying.  This is what I came
	# up with after getting annoyed.  You probably won't be looking at this
	# very often so it's fine...until it isn't.
	size = Vector2(DisplayServer.screen_get_size()) * Vector2(.5, .8)

	if(get_parent() == get_tree().root):
		_debug_ready.call_deferred()



func _cancel_all():
	for scbtn in all_buttons:
		scbtn.cancel()


# ------------
# Events
# ------------
func _on_cancel():
	_cancel_all()
	load_shortcuts()


func _on_edit_start(which):
	for scbtn in all_buttons:
		if(scbtn != which):
			scbtn.disable_set(true)
			scbtn.disable_clear(true)


func _on_edit_end():
	for scbtn in all_buttons:
		scbtn.disable_set(false)
		scbtn.disable_clear(false)


# ------------
# Public
# ------------
func save_shortcuts():
	save_shortcuts_to_file(default_path)


func save_shortcuts_to_file(path):
	var f = ConfigFile.new()
	f.set_value('main', 'panel_button', scbtn_panel.get_shortcut())
	f.set_value('main', 'rerun', scbtn_rerun.get_shortcut())
	f.set_value('main', 'run_all', scbtn_run_all.get_shortcut())
	f.set_value('main', 'run_at_cursor', scbtn_run_at_cursor.get_shortcut())
	f.set_value('main', 'run_current_inner', scbtn_run_current_inner.get_shortcut())
	f.set_value('main', 'run_current_script', scbtn_run_current_script.get_shortcut())
	f.set_value('main', 'run_current_test', scbtn_run_current_test.get_shortcut())
	f.set_value('main', 'toggle_windowed', scbtn_windowed.get_shortcut())
	f.save(path)


func load_shortcuts():
	load_shortcuts_from_file(default_path)


func load_shortcuts_from_file(path):
	var f = ConfigFile.new()
	# as long as this shortcut is never modified, this is fine, otherwise
	# each thing should get its own default instead.
	var empty = Shortcut.new()

	f.load(path)
	scbtn_panel.set_shortcut(f.get_value('main', 'panel_button', empty))
	scbtn_rerun.set_shortcut(f.get_value('main', 'rerun', empty))
	scbtn_run_all.set_shortcut(f.get_value('main', 'run_all', empty))
	scbtn_run_at_cursor.set_shortcut(f.get_value('main', 'run_at_cursor', empty))
	scbtn_run_current_inner.set_shortcut(f.get_value('main', 'run_current_inner', empty))
	scbtn_run_current_script.set_shortcut(f.get_value('main', 'run_current_script', empty))
	scbtn_run_current_test.set_shortcut(f.get_value('main', 'run_current_test', empty))
	scbtn_windowed.set_shortcut(f.get_value('main', 'toggle_windowed', empty))


--------------------------------------------------
FILE: res:///addons/gut/gui/ShortcutDialog.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://dj5ve0bq7xa5j"]

[ext_resource type="Script" uid="uid://dc5jgemxslgvl" path="res://addons/gut/gui/ShortcutDialog.gd" id="1_qq8qn"]
[ext_resource type="PackedScene" uid="uid://sfb1fw8j6ufu" path="res://addons/gut/gui/ShortcutButton.tscn" id="2_i3wie"]

[node name="ShortcutDialog" type="ConfirmationDialog"]
oversampling_override = 1.0
title = "GUT Shortcuts"
position = Vector2i(0, 36)
size = Vector2i(1920, 1728)
visible = true
script = ExtResource("1_qq8qn")

[node name="Scroll" type="ScrollContainer" parent="."]
offset_left = 8.0
offset_top = 8.0
offset_right = 1912.0
offset_bottom = 1679.0

[node name="Layout" type="VBoxContainer" parent="Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ShortcutDescription" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "Shortcuts for:
	- Buttons in Panel
	- Project->Tools->GUT menu items
Shortcuts that only apply to menus are labeled."
fit_content = true
scroll_active = false

[node name="TopPad" type="CenterContainer" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 5)
layout_mode = 2

[node name="CPanelButton" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CPanelButton"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Show/Hide GUT"

[node name="ShortcutButton" parent="Scroll/Layout/CPanelButton" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription2" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Show/hide the gut panel or move focus to/away from the GUT window.
[/i]"
fit_content = true
scroll_active = false

[node name="CRunAll" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CRunAll"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run All"

[node name="ShortcutButton" parent="Scroll/Layout/CRunAll" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription3" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Run the entire test suite.[/i]"
fit_content = true
scroll_active = false

[node name="CRunCurrentScript" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CRunCurrentScript"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run Current Script"

[node name="ShortcutButton" parent="Scroll/Layout/CRunCurrentScript" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription4" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Run all tests in the currently selected script.[/i]"
fit_content = true
scroll_active = false

[node name="CRunCurrentInner" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CRunCurrentInner"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run Current Inner Class"

[node name="ShortcutButton" parent="Scroll/Layout/CRunCurrentInner" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription5" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Run only the currently selected inner test class if one is selected.[/i]"
fit_content = true
scroll_active = false

[node name="CRunCurrentTest" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CRunCurrentTest"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run Current Test"

[node name="ShortcutButton" parent="Scroll/Layout/CRunCurrentTest" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription6" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Run only the currently selected test, if one is selected[/i]"
fit_content = true
scroll_active = false

[node name="CRunAtCursor" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CRunAtCursor"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run At Cursor (menu only)"

[node name="ShortcutButton" parent="Scroll/Layout/CRunAtCursor" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription7" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Run the most specific test/inner class/script based on where the cursor is.[/i]"
fit_content = true
scroll_active = false

[node name="CRerun" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CRerun"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Rerun (menu only)"

[node name="ShortcutButton" parent="Scroll/Layout/CRerun" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription8" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Rerun the test(s) that were last run."
fit_content = true
scroll_active = false

[node name="CToggleWindowed" type="HBoxContainer" parent="Scroll/Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Scroll/Layout/CToggleWindowed"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Toggle Windowed"

[node name="ShortcutButton" parent="Scroll/Layout/CToggleWindowed" instance=ExtResource("2_i3wie")]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShortcutDescription9" type="RichTextLabel" parent="Scroll/Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
bbcode_enabled = true
text = "[i]Toggle GUT in the bottom panel or a separate window.[/i]"
fit_content = true
scroll_active = false


--------------------------------------------------
FILE: res:///addons/gut/gui/about.gd
--------------------------------------------------
@tool
extends AcceptDialog

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

var _bbcode = \
"""
[center]GUT {gut_version}[/center]

[center][b]GUT Links[/b]
{gut_link_table}[/center]

[center][b]VSCode Extension Links[/b]
{vscode_link_table}[/center]

[center]You can support GUT development at
{donate_link}

Thanks for using GUT!
[/center]
"""

var _gut_links = [
	[&"Documentation", &"https://gut.readthedocs.io"],
	[&"What's New", &"https://github.com/bitwes/Gut/releases/tag/v{gut_version}"],
	[&"Repo", &"https://github.com/bitwes/gut"],
	[&"Report Bugs", &"https://github.com/bitwes/gut/issues"]
]

var _vscode_links = [
	["Repo", "https://github.com/bitwes/gut-extension"],
	["Market Place", "https://marketplace.visualstudio.com/items?itemName=bitwes.gut-extension"]
]

var _donate_link = "https://buymeacoffee.com/bitwes"

@onready var _logo = $Logo


func _ready():
	if(get_parent() is SubViewport):
		return

	_vert_center_logo()
	$Logo.disabled = true
	$HBox/Scroll/RichTextLabel.text = _make_text()


func _color_link(link_text):
	return str("[color=ROYAL_BLUE]", link_text, "[/color]")


func _link_table(entries):
	var text = ''
	for entry in entries:
		text += str("[cell][right]", entry[0], "[/right][/cell]")
		var link = str("[url]", entry[1], "[/url]")
		if(entry[1].length() > 60):
			link = str("[url=", entry[1], "]", entry[1].substr(0, 50), "...[/url]")

		text += str("[cell][left]", _color_link(link), "[/left][/cell]\n")
	return str('[table=2]', text, '[/table]')


func _make_text():
	var gut_link_table = _link_table(_gut_links)
	var vscode_link_table = _link_table(_vscode_links)

	var text = _bbcode.format({
		"gut_link_table":gut_link_table,
		"vscode_link_table":vscode_link_table,
		"donate_link":_color_link(str('[url]', _donate_link, '[/url]')),
		"gut_version":GutUtils.version_numbers.gut_version,
	})
	return text


func _vert_center_logo():
	_logo.position.y = size.y / 2.0


# -----------
# Events
# -----------
func _on_rich_text_label_meta_clicked(meta: Variant) -> void:
	OS.shell_open(str(meta))


func _on_mouse_entered() -> void:
	pass#_logo.active = true


func _on_mouse_exited() -> void:
	pass#_logo.active = false


var _odd_ball_eyes_l = 1.1
var _odd_ball_eyes_r = .7
func _on_rich_text_label_meta_hover_started(meta: Variant) -> void:
	if(meta == _gut_links[0][1]):
		_logo.set_eye_color(Color.RED)
	elif(meta.find("releases/tag/") > 0):
		_logo.set_eye_color(Color.GREEN)
	elif(meta == _gut_links[2][1]):
		_logo.set_eye_color(Color.PURPLE)
	elif(meta == _gut_links[3][1]):
		_logo.set_eye_scale(1.2)
	elif(meta == _vscode_links[0][1]):
		_logo.set_eye_scale(.5, .5)
	elif(meta == _vscode_links[1][1]):
		_logo.set_eye_scale(_odd_ball_eyes_l, _odd_ball_eyes_r)
		var temp = _odd_ball_eyes_l
		_odd_ball_eyes_l = _odd_ball_eyes_r
		_odd_ball_eyes_r = temp
	elif(meta == _donate_link):
		_logo.active = false


func _on_rich_text_label_meta_hover_ended(meta: Variant) -> void:
	if(meta == _donate_link):
		_logo.active = true


func _on_logo_pressed() -> void:
	_logo.disabled = !_logo.disabled


--------------------------------------------------
FILE: res:///addons/gut/gui/about.tscn
--------------------------------------------------
[gd_scene load_steps=5 format=3 uid="uid://dqbkylpsatcqm"]

[ext_resource type="Script" uid="uid://g7qu8ihdt3pd" path="res://addons/gut/gui/about.gd" id="1_bg86c"]
[ext_resource type="PackedScene" uid="uid://bjkn8mhx2fmt1" path="res://addons/gut/gui/GutLogo.tscn" id="3_kpic4"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_q8rky"]
bg_color = Color(0, 0, 0, 0.49803922)

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_kpic4"]

[node name="About" type="AcceptDialog"]
oversampling_override = 1.0
title = "About GUT"
position = Vector2i(0, 36)
size = Vector2i(1500, 800)
visible = true
min_size = Vector2i(800, 800)
script = ExtResource("1_bg86c")

[node name="HBox" type="HBoxContainer" parent="."]
offset_left = 8.0
offset_top = 8.0
offset_right = 1492.0
offset_bottom = 751.0
alignment = 1

[node name="MakeRoomForLogo" type="CenterContainer" parent="HBox"]
custom_minimum_size = Vector2(200, 0)
layout_mode = 2

[node name="Scroll" type="ScrollContainer" parent="HBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="RichTextLabel" type="RichTextLabel" parent="HBox/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_styles/normal = SubResource("StyleBoxFlat_q8rky")
theme_override_styles/focus = SubResource("StyleBoxEmpty_kpic4")
bbcode_enabled = true
fit_content = true

[node name="Logo" parent="." instance=ExtResource("3_kpic4")]
modulate = Color(0.74509805, 0.74509805, 0.74509805, 1)
position = Vector2(151, 265)
scale = Vector2(0.8, 0.8)
active = true
disabled = true

[connection signal="mouse_entered" from="." to="." method="_on_mouse_entered"]
[connection signal="mouse_exited" from="." to="." method="_on_mouse_exited"]
[connection signal="meta_clicked" from="HBox/Scroll/RichTextLabel" to="." method="_on_rich_text_label_meta_clicked"]
[connection signal="meta_hover_ended" from="HBox/Scroll/RichTextLabel" to="." method="_on_rich_text_label_meta_hover_ended"]
[connection signal="meta_hover_started" from="HBox/Scroll/RichTextLabel" to="." method="_on_rich_text_label_meta_hover_started"]
[connection signal="pressed" from="Logo" to="." method="_on_logo_pressed"]


--------------------------------------------------
FILE: res:///addons/gut/gui/editor_globals.gd
--------------------------------------------------
@tool

static var GutUserPreferences = load("res://addons/gut/gui/gut_user_preferences.gd")
static var temp_directory = 'user://gut_temp_directory'

static var editor_run_gut_config_path = 'gut_editor_config.json':
	# This avoids having to use path_join wherever we want to reference this
	# path.  The value is not supposed to change.  Could it be a constant
	# instead?  Probably, but I didn't like repeating the directory part.
	# Do I like that this is a bit witty.  Absolutely.
	get: return temp_directory.path_join(editor_run_gut_config_path)
	# Should this print a message or something instead?  Probably, but then I'd
	# be repeating even more code than if this was just a constant.  So I didn't,
	# even though I wanted to make the message a easter eggish fun message.
	# I didn't, so this dumb comment will have to serve as the easter eggish fun.
	set(v):
		print("Be sure to document your code.  Never trust comments.")


static var editor_run_bbcode_results_path = 'gut_editor.bbcode':
	get: return temp_directory.path_join(editor_run_bbcode_results_path)
	set(v): pass


static var editor_run_json_results_path = 'gut_editor.json':
	get: return temp_directory.path_join(editor_run_json_results_path)
	set(v): pass


static var editor_shortcuts_path = 'gut_editor_shortcuts.cfg' :
	get: return temp_directory.path_join(editor_shortcuts_path)
	set(v): pass

static var run_externally_options_path = 'gut_editor_run_externally.cfg' :
	get: return temp_directory.path_join(run_externally_options_path)
	set(v): pass

static var _user_prefs = null
static var user_prefs = _user_prefs :
	# workaround not being able to reference EditorInterface when not in
	# the editor.  This shouldn't be referenced by anything not in the
	# editor.
	get:
		if(_user_prefs == null and Engine.is_editor_hint()):
			# This is sometimes used when not in the editor.  Avoid parser error
			# for EditorInterface.
			_user_prefs = GutUserPreferences.new(GutUtils.get_editor_interface().get_editor_settings())
		return _user_prefs
static var gut_plugin = null

static func create_temp_directory():
	DirAccess.make_dir_recursive_absolute(temp_directory)


static func is_being_edited_in_editor(which):
	if(!Engine.is_editor_hint()):
		return false

	var trav = which
	var is_scene_root = false
	var editor_root = which.get_tree().edited_scene_root
	while(trav != null and !is_scene_root):
		is_scene_root = editor_root == trav
		if(!is_scene_root):
			trav = trav.get_parent()
	return is_scene_root




--------------------------------------------------
FILE: res:///addons/gut/gui/gut_config_gui.gd
--------------------------------------------------
var PanelControls = load("res://addons/gut/gui/panel_controls.gd")
var GutConfig = load('res://addons/gut/gut_config.gd')

const DIRS_TO_LIST = 6

# specific titles that we need to do stuff with
var _titles = {
	dirs = null
}

var _cfg_ctrls = {}
var opt_maker = null

func _init(cont):
	opt_maker = GutUtils.OptionMaker.new(cont)
	_cfg_ctrls = opt_maker.controls
	# _base_container = cont


func _add_save_load():
	var ctrl = PanelControls.SaveLoadControl.new('Config', '', '')

	ctrl.save_path_chosen.connect(_on_save_path_chosen)
	ctrl.load_path_chosen.connect(_on_load_path_chosen)

	#_cfg_ctrls['save_load'] = ctrl
	opt_maker.add_ctrl('save_load', ctrl)
	return ctrl

# ------------------
# Events
# ------------------
func _on_save_path_chosen(path):
	save_file(path)


func _on_load_path_chosen(path):
	load_file.bind(path).call_deferred()

# ------------------
# Public
# ------------------
func get_config_issues():
	var to_return = []
	var has_directory = false

	for i in range(DIRS_TO_LIST):
		var key = str('directory_', i)
		var path = _cfg_ctrls[key].value
		if(path != null and path != ''):
			has_directory = true
			if(!DirAccess.dir_exists_absolute(path)):
				_cfg_ctrls[key].mark_invalid(true)
				to_return.append(str('Test directory ', path, ' does not exist.'))
			else:
				_cfg_ctrls[key].mark_invalid(false)
		else:
			_cfg_ctrls[key].mark_invalid(false)

	if(!has_directory):
		to_return.append('You do not have any directories set.')
		_titles.dirs.mark_invalid(true)
	else:
		_titles.dirs.mark_invalid(false)

	if(!_cfg_ctrls.suffix.value.ends_with('.gd')):
		_cfg_ctrls.suffix.mark_invalid(true)
		to_return.append("Script suffix must end in '.gd'")
	else:
		_cfg_ctrls.suffix.mark_invalid(false)

	return to_return


func clear():
	opt_maker.clear()


func save_file(path):
	var gcfg = GutConfig.new()
	gcfg.options = get_options({})
	gcfg.save_file(path)



func load_file(path):
	var gcfg = GutConfig.new()
	gcfg.load_options(path)
	clear()
	set_options(gcfg.options)


# --------------
# SUPER dumb but VERY fun hack to hide settings.  The various _add methods will
# return what they add.  If you want to hide it, just assign the result to this.
# YES, I could have just put .visible at the end, but I didn't think of that
# until just now, and this was fun, non-permanent and the .visible at the end
# isn't as obvious as hide_this =
#
# Also, we can't just skip adding the controls because other things are looking
# for them and things start to blow up if you don't add them.
var hide_this = null :
	set(val):
		val.visible = false

# --------------

func set_options(opts):
	var options = opts.duplicate()

	# _add_title('Save/Load')
	_add_save_load()

	opt_maker.add_title("Settings")
	opt_maker.add_number("log_level", options.log_level, "Log Level", 0, 3,
		"Detail level for log messages.\n" + \
		"\t0: Errors and failures only.\n" + \
		"\t1: Adds all test names + warnings + info\n" + \
		"\t2: Shows all asserts\n" + \
		"\t3: Adds more stuff probably, maybe not.")
	opt_maker.add_float("wait_log_delay", options.wait_log_delay, "Wait Log Delay", 0.1, 0.0, 999.1,
		"How long to wait before displaying 'Awaiting' messages.")
	opt_maker.add_boolean('ignore_pause', options.ignore_pause, 'Ignore Pause',
		"Ignore calls to pause_before_teardown")
	opt_maker.add_boolean('hide_orphans', options.hide_orphans, 'Hide Orphans',
		'Do not display orphan counts in output.')
	opt_maker.add_boolean('should_exit', options.should_exit, 'Exit on Finish',
		"Exit when tests finished.")
	opt_maker.add_boolean('should_exit_on_success', options.should_exit_on_success, 'Exit on Success',
		"Exit if there are no failures.  Does nothing if 'Exit on Finish' is enabled.")
	opt_maker.add_select('double_strategy', 'Script Only', ['Include Native', 'Script Only'], 'Double Strategy',
		'"Include Native" will include native methods in Doubles.  "Script Only" will not.  ' + "\n" + \
		'The native method override warning is disabled when creating Doubles.' + "\n" + \
		'This is the default, you can override this at the script level or when creating doubles.')
	_cfg_ctrls.double_strategy.value = GutUtils.get_enum_value(
		options.double_strategy, GutUtils.DOUBLE_STRATEGY, GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY)


	opt_maker.add_title("Fail Error Types")
	opt_maker.add_boolean("error_tracking", !options.no_error_tracking, 'Track Errors',
		"Enable/Disable GUT's ability to detect engine and push errors.")
	opt_maker.add_boolean('engine_errors_cause_failure', options.failure_error_types.has(GutConfig.FAIL_ERROR_TYPE_ENGINE),
		'Engine', 'Any script/engine error that occurs during a test will cause the test to fail.')
	opt_maker.add_boolean('push_error_errors_cause_failure', options.failure_error_types.has(GutConfig.FAIL_ERROR_TYPE_PUSH_ERROR),
		'Push', 'Any error generated by a call to push_error that occurs during a test will cause the test to fail.')
	opt_maker.add_boolean('gut_errors_cause_failure', options.failure_error_types.has(GutConfig.FAIL_ERROR_TYPE_GUT),
		'GUT', 'Any internal GUT error that occurs while a test is running will cause it to fail..')


	opt_maker.add_title('Runner Appearance')
	hide_this = opt_maker.add_boolean("gut_on_top", options.gut_on_top, "On Top",
		"The GUT Runner appears above children added during tests.")
	opt_maker.add_number('opacity', options.opacity, 'Opacity', 0, 100,
		"The opacity of GUT when tests are running.")
	hide_this = opt_maker.add_boolean('should_maximize', options.should_maximize, 'Maximize',
		"Maximize GUT when tests are being run.")
	opt_maker.add_boolean('compact_mode', options.compact_mode, 'Compact Mode',
		'The runner will be in compact mode.  This overrides Maximize.')
	opt_maker.add_select('font_name', options.font_name, GutUtils.avail_fonts, 'Font',
		"The font to use for text output in the Gut Runner.")
	opt_maker.add_number('font_size', options.font_size, 'Font Size', 5, 100,
		"The font size for text output in the Gut Runner.")
	hide_this = opt_maker.add_color('font_color', options.font_color, 'Font Color',
		"The font color for text output in the Gut Runner.")
	opt_maker.add_color('background_color', options.background_color, 'Background Color',
		"The background color for text output in the Gut Runner.")
	opt_maker.add_boolean('disable_colors', options.disable_colors, 'Disable Formatting',
		'Disable formatting and colors used in the Runner.  Does not affect panel output.')


	_titles.dirs = opt_maker.add_title('Test Directories')
	opt_maker.add_boolean('include_subdirs', options.include_subdirs, 'Include Subdirs',
		"Include subdirectories of the directories configured below.")

	var dirs_to_load = options.configured_dirs
	if(options.dirs.size() > dirs_to_load.size()):
		dirs_to_load = options.dirs

	for i in range(DIRS_TO_LIST):
		var value = ''
		if(dirs_to_load.size() > i):
			value = dirs_to_load[i]

		var test_dir = opt_maker.add_directory(str('directory_', i), value, str(i))
		test_dir.enabled_button.visible = true
		test_dir.enabled_button.button_pressed = options.dirs.has(value)


	opt_maker.add_title("XML Output")
	opt_maker.add_save_file_anywhere("junit_xml_file", options.junit_xml_file, "Output Path",
		"Path and filename where GUT should create a JUnit compliant XML file.  " +
		"This file will contain the results of the last test run.  To avoid " +
		"overriding the file use Include Timestamp.")
	opt_maker.add_boolean("junit_xml_timestamp", options.junit_xml_timestamp, "Include Timestamp",
		"Include a timestamp in the filename so that each run gets its own xml file.")


	opt_maker.add_title('Hooks')
	opt_maker.add_file('pre_run_script', options.pre_run_script, 'Pre-Run Hook',
		'This script will be run by GUT before any tests are run.')
	opt_maker.add_file('post_run_script', options.post_run_script, 'Post-Run Hook',
		'This script will be run by GUT after all tests are run.')


	opt_maker.add_title('Misc')
	opt_maker.add_value('prefix', options.prefix, 'Script Prefix',
		"The filename prefix for all test scripts.")
	opt_maker.add_value('suffix', options.suffix, 'Script Suffix',
		"Script suffix, including .gd extension.  For example '_foo.gd'.")
	opt_maker.add_float('paint_after', options.paint_after, 'Paint After', .05, 0.0, 1.0,
		"How long GUT will wait before pausing for 1 frame to paint the screen.  0 is never.")



func get_options(base_opts):
	var to_return = base_opts.duplicate()

	# Settings
	to_return.log_level = _cfg_ctrls.log_level.value
	to_return.wait_log_delay = _cfg_ctrls.wait_log_delay.value
	to_return.ignore_pause = _cfg_ctrls.ignore_pause.value
	to_return.hide_orphans = _cfg_ctrls.hide_orphans.value
	to_return.should_exit = _cfg_ctrls.should_exit.value
	to_return.should_exit_on_success = _cfg_ctrls.should_exit_on_success.value
	to_return.double_strategy = _cfg_ctrls.double_strategy.value

	# Runner Appearance
	to_return.font_name = _cfg_ctrls.font_name.text
	to_return.font_size = _cfg_ctrls.font_size.value
	to_return.should_maximize = _cfg_ctrls.should_maximize.value
	to_return.compact_mode = _cfg_ctrls.compact_mode.value
	to_return.opacity = _cfg_ctrls.opacity.value
	to_return.background_color = _cfg_ctrls.background_color.value.to_html()
	to_return.font_color = _cfg_ctrls.font_color.value.to_html()
	to_return.disable_colors = _cfg_ctrls.disable_colors.value
	to_return.gut_on_top = _cfg_ctrls.gut_on_top.value
	to_return.paint_after = _cfg_ctrls.paint_after.value

	# Fail Error Types
	to_return.no_error_tracking = !_cfg_ctrls.error_tracking

	var fail_error_types = []
	if(_cfg_ctrls.engine_errors_cause_failure.value):
		fail_error_types.append(GutConfig.FAIL_ERROR_TYPE_ENGINE)
	if(_cfg_ctrls.push_error_errors_cause_failure.value):
		fail_error_types.append(GutConfig.FAIL_ERROR_TYPE_PUSH_ERROR)
	if(_cfg_ctrls.gut_errors_cause_failure.value):
		fail_error_types.append(GutConfig.FAIL_ERROR_TYPE_GUT)
	to_return.failure_error_types = fail_error_types

	# Directories
	to_return.include_subdirs = _cfg_ctrls.include_subdirs.value
	var dirs = []
	var configured_dirs = []
	for i in range(DIRS_TO_LIST):
		var key = str('directory_', i)
		var ctrl = _cfg_ctrls[key]
		if(ctrl.value != '' and ctrl.value != null):
			configured_dirs.append(ctrl.value)
			if(ctrl.enabled_button.button_pressed):
				dirs.append(ctrl.value)
	to_return.dirs = dirs
	to_return.configured_dirs = configured_dirs

	# XML Output
	to_return.junit_xml_file = _cfg_ctrls.junit_xml_file.value
	to_return.junit_xml_timestamp = _cfg_ctrls.junit_xml_timestamp.value

	# Hooks
	to_return.pre_run_script = _cfg_ctrls.pre_run_script.value
	to_return.post_run_script = _cfg_ctrls.post_run_script.value

	# Misc
	to_return.prefix = _cfg_ctrls.prefix.value
	to_return.suffix = _cfg_ctrls.suffix.value

	return to_return


func mark_saved():
	for key in _cfg_ctrls:
		_cfg_ctrls[key].mark_unsaved(false)


--------------------------------------------------
FILE: res:///addons/gut/gui/gut_gui.gd
--------------------------------------------------
extends Control
# ##############################################################################
# This is the decoupled GUI for gut.gd
#
# This is a "generic" interface between a GUI and gut.gd.  It assumes there are
# certain controls with specific names.  It will then interact with those
# controls based on signals emitted from gut.gd in order to give the user
# feedback about the progress of the test run and the results.
#
# Optional controls are marked as such in the _ctrls dictionary.  The names
# of the controls can be found in _populate_ctrls.
# ##############################################################################
var _gut = null

var _ctrls = {
	btn_continue = null,
	path_dir = null,
	path_file = null,
	prog_script = null,
	prog_test = null,
	rtl = null,                 # optional
	rtl_bg = null,              # required if rtl exists
	switch_modes = null,
	time_label = null,
	title = null,
	title_bar = null,
	tgl_word_wrap = null,		# optional
}

var _title_mouse = {
	down = false
}


signal switch_modes()

var _max_position = Vector2(100, 100)

func _ready():
	_populate_ctrls()

	_ctrls.btn_continue.visible = false
	_ctrls.btn_continue.pressed.connect(_on_continue_pressed)
	_ctrls.switch_modes.pressed.connect(_on_switch_modes_pressed)
	_ctrls.title_bar.gui_input.connect(_on_title_bar_input)
	if(_ctrls.tgl_word_wrap != null):
		_ctrls.tgl_word_wrap.toggled.connect(_on_word_wrap_toggled)

	_ctrls.prog_script.value = 0
	_ctrls.prog_test.value = 0
	_ctrls.path_dir.text = ''
	_ctrls.path_file.text = ''
	_ctrls.time_label.text = ''

	_max_position = get_display_size() - Vector2(30, _ctrls.title_bar.size.y)


func _process(_delta):
	if(_gut != null and _gut.is_running()):
		set_elapsed_time(_gut.get_elapsed_time())


# ------------------
# Private
# ------------------
func get_display_size():
	return get_viewport().get_visible_rect().size


func _populate_ctrls():
	# Brute force, but flexible.  This allows for all the controls to exist
	# anywhere, and as long as they all have the right name, they will be
	# found.
	_ctrls.btn_continue = _get_first_child_named('Continue', self)
	_ctrls.path_dir = _get_first_child_named('Path', self)
	_ctrls.path_file = _get_first_child_named('File', self)
	_ctrls.prog_script = _get_first_child_named('ProgressScript', self)
	_ctrls.prog_test = _get_first_child_named('ProgressTest', self)
	_ctrls.rtl = _get_first_child_named('TestOutput', self)
	_ctrls.rtl_bg = _get_first_child_named('OutputBG', self)
	_ctrls.switch_modes = _get_first_child_named("SwitchModes", self)
	_ctrls.time_label = _get_first_child_named('TimeLabel', self)
	_ctrls.title = _get_first_child_named("Title", self)
	_ctrls.title_bar = _get_first_child_named("TitleBar", self)
	_ctrls.tgl_word_wrap = _get_first_child_named("WordWrap", self)


func _get_first_child_named(obj_name, parent_obj):
	if(parent_obj == null):
		return null

	var kids = parent_obj.get_children()
	var index = 0
	var to_return = null

	while(index < kids.size() and to_return == null):
		if(str(kids[index]).find(str(obj_name, ':')) != -1):
			to_return = kids[index]
		else:
			to_return = _get_first_child_named(obj_name, kids[index])
			if(to_return == null):
				index += 1
	
	return to_return



# ------------------
# Events
# ------------------
func _on_title_bar_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_title_mouse.down):
			position += event.relative
			position.x = clamp(position.x, 0, _max_position.x)
			position.y = clamp(position.y, 0, _max_position.y)
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_title_mouse.down = event.pressed


func _on_continue_pressed():
	_gut.end_teardown_pause()


func _on_gut_start_run():
	if(_ctrls.rtl != null):
		_ctrls.rtl.clear()
	set_num_scripts(_gut.get_test_collector().scripts.size())


func _on_gut_end_run():
	_ctrls.prog_test.value = _ctrls.prog_test.max_value
	_ctrls.prog_script.value = _ctrls.prog_script.max_value


func _on_gut_start_script(script_obj):
	next_script(script_obj.get_full_name(), script_obj.tests.size())


func _on_gut_end_script():
	pass


func _on_gut_start_test(test_name):
	next_test(test_name)


func _on_gut_end_test():
	pass


func _on_gut_start_pause():
	pause_before_teardown()


func _on_gut_end_pause():
	_ctrls.btn_continue.visible = false


func _on_switch_modes_pressed():
	switch_modes.emit()


func _on_word_wrap_toggled(toggled):
	_ctrls.rtl.autowrap_mode = toggled
# ------------------
# Public
# ------------------
func set_num_scripts(val):
	_ctrls.prog_script.value = 0
	_ctrls.prog_script.max_value = val


func next_script(path, num_tests):
	_ctrls.prog_script.value += 1
	_ctrls.prog_test.value = 0
	_ctrls.prog_test.max_value = num_tests

	_ctrls.path_dir.text = path.get_base_dir()
	_ctrls.path_file.text = path.get_file()


func next_test(__test_name):
	_ctrls.prog_test.value += 1


func pause_before_teardown():
	_ctrls.btn_continue.visible = true


func set_gut(g):
	if(_gut == g):
		return
	_gut = g
	g.start_run.connect(_on_gut_start_run)
	g.end_run.connect(_on_gut_end_run)

	g.start_script.connect(_on_gut_start_script)
	g.end_script.connect(_on_gut_end_script)

	g.start_test.connect(_on_gut_start_test)
	g.end_test.connect(_on_gut_end_test)

	g.start_pause_before_teardown.connect(_on_gut_start_pause)
	g.end_pause_before_teardown.connect(_on_gut_end_pause)

func get_gut():
	return _gut

func get_textbox():
	return _ctrls.rtl

func set_elapsed_time(t):
	_ctrls.time_label.text = str("%6.1f" % t, 's')


func set_bg_color(c):
	_ctrls.rtl_bg.color = c


func set_title(text):
	_ctrls.title.text = text


func to_top_left():
	self.position = Vector2(5, 5)


func to_bottom_right():
	var win_size = get_display_size()
	self.position = win_size - Vector2(self.size) - Vector2(5, 5)


func align_right():
	var win_size = get_display_size()
	self.position.x = win_size.x - self.size.x -5
	self.position.y = 5
	self.size.y = win_size.y - 10


--------------------------------------------------
FILE: res:///addons/gut/gui/gut_logo.gd
--------------------------------------------------
@tool
extends Node2D

class Eyeball:
	extends Node2D

	var _should_draw_laser = false
	var _laser_end_pos = Vector2.ZERO
	var _laser_timer : Timer = null
	var _color_tween : Tween
	var _size_tween : Tween

	var sprite : Sprite2D = null
	var default_position = Vector2(0, 0)
	var move_radius = 25
	var move_center = Vector2(0, 0)
	var default_color = Color(0.31, 0.31, 0.31)
	var _color = default_color :
		set(val):
			_color = val
			queue_redraw()
	var color = _color :
		set(val):
			_start_color_tween(_color, val)
		get(): return _color
	var default_size = 70
	var _size = default_size :
		set(val):
			_size = val
			queue_redraw()
	var size = _size :
		set(val):
			_start_size_tween(_size, val)
		get(): return _size


	func _init(node):
		sprite = node
		default_position = sprite.position
		move_center = sprite.position
		# hijack the original sprite, because I want to draw it here but keep
		# the original in the scene for layout.
		position = sprite.position
		sprite.get_parent().add_child(self)
		sprite.visible = false


	func _ready():
		_laser_timer = Timer.new()
		_laser_timer.wait_time = .1
		_laser_timer.one_shot = true
		add_child(_laser_timer)
		_laser_timer.timeout.connect(func():  _should_draw_laser = false)


	func _process(_delta):
		if(_should_draw_laser):
			queue_redraw()


	func _start_color_tween(old_color, new_color):
		if(_color_tween != null and _color_tween.is_running()):
			_color_tween.kill()
		_color_tween = create_tween()
		_color_tween.tween_property(self, '_color', new_color, .3).from(old_color)
		_color_tween.play()


	func _start_size_tween(old_size, new_size):
		if(_size_tween != null and _size_tween.is_running()):
			_size_tween.kill()
		_size_tween = create_tween()
		_size_tween.tween_property(self, '_size', new_size, .3).from(old_size)
		_size_tween.play()


	var _laser_size = 20.0
	func _draw() -> void:
		draw_circle(Vector2.ZERO, size, color, true, -1, true)
		if(_should_draw_laser):
			var end_pos = (_laser_end_pos - global_position) * 2
			var laser_size = _laser_size * (float(size)/float(default_size))
			draw_line(Vector2.ZERO, end_pos, color, laser_size)
			draw_line(Vector2.ZERO, end_pos, Color(1, 1, 1, .5), laser_size * .8)


	# There's a bug in here where the eye shakes like crazy.  It's a feature
	# now.  Don't fix it.
	func look_at_local_position(local_pos):
		var dir = position.direction_to(local_pos)
		var dist = position.distance_to(local_pos)
		position = move_center + (dir * min(dist, move_radius))
		position.x = clamp(position.x, move_center.x - move_radius, move_center.x + move_radius)
		position.y = clamp(position.y, move_center.y - move_radius, move_center.y + move_radius)


	func reset():
		color = default_color
		size = default_size


	func eye_laser(global_pos):
		_should_draw_laser = true
		_laser_end_pos = global_pos
		_laser_timer.start()


	func _stop_laser():
		_should_draw_laser = false



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
# Active means it's actively doing stuff.  When this is not active the eyes
# won't follow, but you can still make the sizes change by calling methods on
# this.
@export var active = false :
	set(val):
		active = val
		if(!active and is_inside_tree()):
			left_eye.position = left_eye.default_position
			right_eye.position = right_eye.default_position
# When disabled, this will reset to default and you can't make it do anything.
@export var disabled = false :
	set(val):
		disabled = val
		if(disabled and is_inside_tree()):
			left_eye.position = left_eye.default_position
			right_eye.position = right_eye.default_position
			left_eye.reset()
			right_eye.reset()
			modulate = Color.GRAY
			$BaseLogo.texture = _no_shine
		else:
			$BaseLogo.texture = _normal
			modulate = Color.WHITE

@onready var _reset_timer = $ResetTimer
@onready var _face_button = $FaceButton
@onready var left_eye : Eyeball = Eyeball.new($BaseLogo/LeftEye)
@onready var right_eye : Eyeball = Eyeball.new($BaseLogo/RightEye)

var _no_shine = load("res://addons/gut/images/GutIconV2_no_shine.png")
var _normal = load("res://addons/gut/images/GutIconV2_base.png")
var _is_in_edited_scene = false

signal pressed

func _debug_ready():
	position = Vector2(500, 500)
	active = true


func _ready():
	_is_in_edited_scene = GutEditorGlobals.is_being_edited_in_editor(self)

	if(get_parent() == get_tree().root):
		_debug_ready()

	disabled = disabled
	active = active
	left_eye.move_center.x -= 20
	right_eye.move_center.x += 10
	_face_button.modulate.a = 0.0


func _process(_delta):
	if(active and !disabled and !_is_in_edited_scene):
		left_eye.look_at_local_position(get_local_mouse_position())
		right_eye.look_at_local_position(get_local_mouse_position())


# ----------------
# Events
# ----------------
func _on_reset_timer_timeout() -> void:
	left_eye.reset()
	right_eye.reset()


func _on_face_button_pressed() -> void:
	pressed.emit()


# ----------------
# Public
# ----------------
func set_eye_scale(left, right=left):
	if(disabled or _is_in_edited_scene):
		return
	left_eye.size = left_eye.default_size * left
	right_eye.size = right_eye.default_size * right
	_reset_timer.start()


func reset_eye_size():
	if(disabled or _is_in_edited_scene):
		return
	left_eye.size = left_eye.default_size
	right_eye.size = right_eye.default_size


func set_eye_color(left, right=left):
	if(disabled or _is_in_edited_scene):
		return
	left_eye.color = left
	right_eye.color = right
	_reset_timer.start()


func reset_eye_color():
	if(disabled or _is_in_edited_scene):
		return
	left_eye.color = left_eye.default_color
	right_eye.color = right_eye.default_color


# I removed the eye lasers because they aren't ready yet.  I've already spent
# too much time on this logo.  It's great, I love it...but it's been long
# enough.  This gives me, or someone else, something to do later.
#func eye_lasers(global_pos):
	#left_eye.eye_laser(global_pos)
	#right_eye.eye_laser(global_pos)


--------------------------------------------------
FILE: res:///addons/gut/gui/gut_user_preferences.gd
--------------------------------------------------
class GutEditorPref:
	var gut_pref_prefix = 'gut/'
	var pname = '__not_set__'
	var default = null
	var value = '__not_set__'
	var _settings = null

	func _init(n, d, s):
		pname = n
		default = d
		_settings = s
		load_it()

	func _prefstr():
		var to_return = str(gut_pref_prefix, pname)
		return to_return

	func save_it():
		_settings.set_setting(_prefstr(), value)

	func load_it():
		if(_settings.has_setting(_prefstr())):
			value = _settings.get_setting(_prefstr())
		else:
			value = default

	func erase():
		_settings.erase(_prefstr())


const EMPTY = '-- NOT_SET --'

# -- Editor ONLY Settings --
var output_font_name = null
var output_font_size = null
var hide_result_tree = null
var hide_output_text = null
var hide_settings = null
var use_colors = null	# ? might be output panel
var run_externally = null
var run_externally_options_dialog_size = null
var shortcuts_dialog_size = null
var gut_window_size = null
var gut_window_on_top = null


func _init(editor_settings):
	output_font_name = GutEditorPref.new('output_font_name', 'CourierPrime', editor_settings)
	output_font_size = GutEditorPref.new('output_font_size', 30, editor_settings)
	hide_result_tree = GutEditorPref.new('hide_result_tree', false, editor_settings)
	hide_output_text = GutEditorPref.new('hide_output_text', false, editor_settings)
	hide_settings = GutEditorPref.new('hide_settings', false, editor_settings)
	use_colors = GutEditorPref.new('use_colors', true, editor_settings)
	run_externally = GutEditorPref.new('run_externally', false, editor_settings)
	run_externally_options_dialog_size = GutEditorPref.new('run_externally_options_dialog_size', Vector2i(-1, -1), editor_settings)
	shortcuts_dialog_size = GutEditorPref.new('shortcuts_dialog_size', Vector2i(-1, -1), editor_settings)
	gut_window_size = GutEditorPref.new('editor_window_size', Vector2i(-1, -1), editor_settings)
	gut_window_on_top = GutEditorPref.new('editor_window_on_top', false, editor_settings)


func save_it():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.save_it()


func load_it():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.load_it()


func erase_all():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.erase()


--------------------------------------------------
FILE: res:///addons/gut/gui/option_maker.gd
--------------------------------------------------
var PanelControls = load("res://addons/gut/gui/panel_controls.gd")

# All titles so we can free them when we want.
var _all_titles = []


var base_container = null
# All the various PanelControls indexed by thier keys.
var controls = {}


func _init(cont):
	base_container = cont


func add_title(text):
	var row = PanelControls.BaseGutPanelControl.new(text, text)
	base_container.add_child(row)
	row.connect('draw', _on_title_cell_draw.bind(row))
	_all_titles.append(row)
	return row


func add_ctrl(key, ctrl):
	controls[key] = ctrl
	base_container.add_child(ctrl)


func add_number(key, value, disp_text, v_min, v_max, hint=''):
	var ctrl = PanelControls.NumberControl.new(disp_text, value, v_min, v_max, hint)
	add_ctrl(key, ctrl)
	return ctrl


func add_float(key, value, disp_text, step, v_min, v_max, hint=''):
	var ctrl = PanelControls.FloatControl.new(disp_text, value, step, v_min, v_max, hint)
	add_ctrl(key, ctrl)
	return ctrl


func add_select(key, value, values, disp_text, hint=''):
	var ctrl = PanelControls.SelectControl.new(disp_text, value, values, hint)
	add_ctrl(key, ctrl)
	return ctrl


func add_value(key, value, disp_text, hint=''):
	var ctrl = PanelControls.StringControl.new(disp_text, value, hint)
	add_ctrl(key, ctrl)
	return ctrl

func add_multiline_text(key, value, disp_text, hint=''):
	var ctrl = PanelControls.MultiLineStringControl.new(disp_text, value, hint)
	add_ctrl(key, ctrl)
	return ctrl

func add_boolean(key, value, disp_text, hint=''):
	var ctrl = PanelControls.BooleanControl.new(disp_text, value, hint)
	add_ctrl(key, ctrl)
	return ctrl


func add_directory(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	add_ctrl(key, ctrl)
	ctrl.dialog.title = disp_text
	return ctrl


func add_file(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	add_ctrl(key, ctrl)
	ctrl.dialog.file_mode = ctrl.dialog.FILE_MODE_OPEN_FILE
	ctrl.dialog.title = disp_text
	return ctrl


func add_save_file_anywhere(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	add_ctrl(key, ctrl)
	ctrl.dialog.file_mode = ctrl.dialog.FILE_MODE_SAVE_FILE
	ctrl.dialog.access = ctrl.dialog.ACCESS_FILESYSTEM
	ctrl.dialog.title = disp_text
	return ctrl


func add_color(key, value, disp_text, hint=''):
	var ctrl = PanelControls.ColorControl.new(disp_text, value, hint)
	add_ctrl(key, ctrl)
	return ctrl


var _blurbs = 0
func add_blurb(text):
	var ctrl = RichTextLabel.new()
	ctrl.fit_content = true
	ctrl.bbcode_enabled = true
	ctrl.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	ctrl.text = text
	add_ctrl(str("blurb_", _blurbs), ctrl)
	return ctrl


# ------------------
# Events
# ------------------
func _on_title_cell_draw(which):
	which.draw_rect(Rect2(Vector2(0, 0), which.size), Color(0, 0, 0, .15))


# ------------------
# Public
# ------------------

func clear():
	for key in controls:
		controls[key].free()

	controls.clear()

	for entry in _all_titles:
		entry.free()

	_all_titles.clear()


--------------------------------------------------
FILE: res:///addons/gut/gui/panel_controls.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class BaseGutPanelControl:
	extends HBoxContainer
	var label = Label.new()
	var _lbl_unsaved = Label.new()
	var _lbl_invalid = Label.new()

	var value = null:
		get: return get_value()
		set(val): set_value(val)

	signal changed

	func _init(title, val, hint=""):
		size_flags_horizontal = SIZE_EXPAND_FILL
		mouse_filter = MOUSE_FILTER_PASS

		label.size_flags_horizontal = label.SIZE_EXPAND_FILL
		label.mouse_filter = label.MOUSE_FILTER_STOP
		add_child(label)

		_lbl_unsaved.text = '*'
		_lbl_unsaved.visible = false
		add_child(_lbl_unsaved)

		_lbl_invalid.text = '!'
		_lbl_invalid.visible = false
		add_child(_lbl_invalid)

		label.text = title
		label.tooltip_text = hint


	func mark_unsaved(is_it=true):
		_lbl_unsaved.visible = is_it


	func mark_invalid(is_it):
		_lbl_invalid.visible = is_it

	# -- Virtual --
	#
	# value_ctrl (all should declare the value_ctrl)
	#
	func set_value(value):
		pass

	func get_value():
		pass


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class NumberControl:
	extends BaseGutPanelControl

	var value_ctrl = SpinBox.new()

	func _init(title, val, v_min, v_max, hint=""):
		super._init(title, val, hint)

		value_ctrl.value = val
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.min_value = v_min
		value_ctrl.max_value = v_max
		value_ctrl.value_changed.connect(_on_value_changed)
		value_ctrl.select_all_on_focus = true
		add_child(value_ctrl)

	func _on_value_changed(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.value

	func set_value(val):
		value_ctrl.value = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class FloatControl:
	extends NumberControl

	func _init(title, val, step, v_min, v_max, hint=""):
		super._init(title, val, v_min, v_max, hint)
		value_ctrl.step = step
		value_ctrl.value = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class StringControl:
	extends BaseGutPanelControl

	var value_ctrl = LineEdit.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.text = val
		value_ctrl.text_changed.connect(_on_text_changed)
		value_ctrl.select_all_on_focus = true
		add_child(value_ctrl)
		if(title == ''):
			label.visible = false

	func _on_text_changed(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.text

	func set_value(val):
		value_ctrl.text = val



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class MultiLineStringControl:
	extends BaseGutPanelControl

	var value_ctrl = TextEdit.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)
		var vbox = VBoxContainer.new()
		vbox.size_flags_horizontal = SIZE_EXPAND_FILL
		add_child(vbox)
		label.reparent(vbox)
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.text = val
		value_ctrl.text_changed.connect(_on_text_changed)
		value_ctrl.scroll_fit_content_height = true
		vbox.add_child(value_ctrl)

	func _on_text_changed(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.text

	func set_value(val):
		value_ctrl.text = val



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class BooleanControl:
	extends BaseGutPanelControl

	var value_ctrl = CheckBox.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		value_ctrl.button_pressed = val
		value_ctrl.toggled.connect(_on_button_toggled)
		add_child(value_ctrl)

	func _on_button_toggled(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.button_pressed

	func set_value(val):
		value_ctrl.button_pressed = val


# ------------------------------------------------------------------------------
# value is "selected" and is gettable and settable
# text is the text value of the selected item, it is gettable only
# ------------------------------------------------------------------------------
class SelectControl:
	extends BaseGutPanelControl

	var value_ctrl = OptionButton.new()

	var text = '' :
		get: return value_ctrl.get_item_text(value_ctrl.selected)
		set(val): pass

	func _init(title, val, choices, hint=""):
		super._init(title, val, hint)

		var select_idx = 0
		for i in range(choices.size()):
			value_ctrl.add_item(choices[i])
			if(val == choices[i]):
				select_idx = i
		value_ctrl.selected = select_idx
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.item_selected.connect(_on_item_selected)
		add_child(value_ctrl)

	func _on_item_selected(idx):
		changed.emit()

	func get_value():
		return value_ctrl.selected

	func set_value(val):
		value_ctrl.selected = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class ColorControl:
	extends BaseGutPanelControl

	var value_ctrl = ColorPickerButton.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.color = val
		add_child(value_ctrl)

	func get_value():
		return value_ctrl.color

	func set_value(val):
		value_ctrl.color = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class DirectoryControl:
	extends BaseGutPanelControl

	var value_ctrl := LineEdit.new()
	var dialog := FileDialog.new()
	var enabled_button = CheckButton.new()

	var _btn_dir := Button.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		label.size_flags_horizontal = Control.SIZE_SHRINK_BEGIN

		_btn_dir.text = '...'
		_btn_dir.pressed.connect(_on_dir_button_pressed)

		value_ctrl.text = val
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.select_all_on_focus = true
		value_ctrl.text_changed.connect(_on_value_changed)

		dialog.file_mode = dialog.FILE_MODE_OPEN_DIR
		dialog.unresizable = false
		dialog.dir_selected.connect(_on_selected)
		dialog.file_selected.connect(_on_selected)

		enabled_button.button_pressed = true
		enabled_button.visible = false

		add_child(enabled_button)
		add_child(value_ctrl)
		add_child(_btn_dir)
		add_child(dialog)

	func _update_display():
		var is_empty = value_ctrl.text == ''
		enabled_button.button_pressed = !is_empty
		enabled_button.disabled = is_empty


	func _ready():
		if(Engine.is_editor_hint()):
			dialog.size = Vector2(1000, 700)
		else:
			dialog.size = Vector2(500, 350)
		_update_display()

	func _on_value_changed(new_text):
		_update_display()

	func _on_selected(path):
		value_ctrl.text = path
		_update_display()

	func _on_dir_button_pressed():
		dialog.current_dir = value_ctrl.text
		dialog.popup_centered()

	func get_value():
		return value_ctrl.text

	func set_value(val):
		value_ctrl.text = val


# ------------------------------------------------------------------------------
# Features:
# 	Buttons to pick res://, user://, or anywhere on the OS.
# ------------------------------------------------------------------------------
class FileDialogSuperPlus:
	extends FileDialog

	var show_diretory_types = true :
		set(val) :
			show_diretory_types = val
			_update_display()

	var show_res = true :
		set(val) :
			show_res = val
			_update_display()

	var show_user = true :
		set(val) :
			show_user = val
			_update_display()

	var show_os = true :
		set(val) :
			show_os = val
			_update_display()

	var _dir_type_hbox = null
	var _btn_res = null
	var _btn_user = null
	var _btn_os = null

	func _ready():
		_init_controls()
		_update_display()


	func _init_controls():
		_dir_type_hbox = HBoxContainer.new()

		_btn_res = Button.new()
		_btn_user = Button.new()
		_btn_os = Button.new()
		var spacer1 = CenterContainer.new()
		spacer1.size_flags_horizontal = spacer1.SIZE_EXPAND_FILL
		var spacer2 = spacer1.duplicate()

		_dir_type_hbox.add_child(spacer1)
		_dir_type_hbox.add_child(_btn_res)
		_dir_type_hbox.add_child(_btn_user)
		_dir_type_hbox.add_child(_btn_os)
		_dir_type_hbox.add_child(spacer2)

		_btn_res.text = 'res://'
		_btn_user.text = 'user://'
		_btn_os.text = '  OS  '

		get_vbox().add_child(_dir_type_hbox)
		get_vbox().move_child(_dir_type_hbox, 0)

		_btn_res.pressed.connect(func(): access = ACCESS_RESOURCES)
		_btn_user.pressed.connect(func(): access = ACCESS_USERDATA)
		_btn_os.pressed.connect(func(): access = ACCESS_FILESYSTEM)


	func _update_display():
		if(is_inside_tree()):
			_dir_type_hbox.visible = show_diretory_types
			_btn_res.visible = show_res
			_btn_user.visible = show_user
			_btn_os.visible = show_os


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class SaveLoadControl:
	extends BaseGutPanelControl

	var btn_load = Button.new()
	var btn_save = Button.new()

	var dlg_load := FileDialogSuperPlus.new()
	var dlg_save := FileDialogSuperPlus.new()

	signal save_path_chosen(path)
	signal load_path_chosen(path)

	func _init(title, val, hint):
		super._init(title, val, hint)

		btn_load.text = "Load"
		btn_load.custom_minimum_size.x = 100
		btn_load.pressed.connect(_on_load_pressed)
		add_child(btn_load)

		btn_save.text = "Save As"
		btn_save.custom_minimum_size.x = 100
		btn_save.pressed.connect(_on_save_pressed)
		add_child(btn_save)

		dlg_load.file_mode = dlg_load.FILE_MODE_OPEN_FILE
		dlg_load.unresizable = false
		dlg_load.dir_selected.connect(_on_load_selected)
		dlg_load.file_selected.connect(_on_load_selected)
		add_child(dlg_load)

		dlg_save.file_mode = dlg_save.FILE_MODE_SAVE_FILE
		dlg_save.unresizable = false
		dlg_save.dir_selected.connect(_on_save_selected)
		dlg_save.file_selected.connect(_on_save_selected)
		add_child(dlg_save)


	func _ready():
		if(Engine.is_editor_hint()):
			dlg_load.size = Vector2(1000, 700)
			dlg_save.size = Vector2(1000, 700)
		else:
			dlg_load.size = Vector2(500, 350)
			dlg_save.size = Vector2(500, 350)

	func _on_load_selected(path):
		load_path_chosen.emit(path)

	func _on_save_selected(path):
		save_path_chosen.emit(path)

	func _on_load_pressed():
		dlg_load.popup_centered()

	func _on_save_pressed():
		dlg_save.popup_centered()

# ------------------------------------------------------------------------------
# This one was never used in gut_config_gui...but I put some work into it and
# I'm a sucker for that kinda thing.  Delete this when you get tired of looking
# at it.
# ------------------------------------------------------------------------------
# class Vector2Ctrl:
# 	extends VBoxContainer

# 	var value = Vector2(-1, -1) :
# 		get:
# 			return get_value()
# 		set(val):
# 			set_value(val)
# 	var disabled = false :
# 		get:
# 			return get_disabled()
# 		set(val):
# 			set_disabled(val)
# 	var x_spin = SpinBox.new()
# 	var y_spin = SpinBox.new()

# 	func _init():
# 		add_child(_make_one('x:  ', x_spin))
# 		add_child(_make_one('y:  ', y_spin))

# 	func _make_one(txt, spinner):
# 		var hbox = HBoxContainer.new()
# 		var lbl = Label.new()
# 		lbl.text = txt
# 		hbox.add_child(lbl)
# 		hbox.add_child(spinner)
# 		spinner.min_value = -1
# 		spinner.max_value = 10000
# 		spinner.size_flags_horizontal = spinner.SIZE_EXPAND_FILL
# 		return hbox

# 	func set_value(v):
# 		if(v != null):
# 			x_spin.value = v[0]
# 			y_spin.value = v[1]

# 	# Returns array instead of vector2 b/c that is what is stored in
# 	# in the dictionary and what is expected everywhere else.
# 	func get_value():
# 		return [x_spin.value, y_spin.value]

# 	func set_disabled(should):
# 		get_parent().visible = !should
# 		x_spin.visible = !should
# 		y_spin.visible = !should

# 	func get_disabled():
# 		pass


--------------------------------------------------
FILE: res:///addons/gut/gui/run_from_editor.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# This is the entry point when running tests from the editor.
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
extends Node2D

var GutLoader : Object

func _init() -> void:
	GutLoader = load("res://addons/gut/gut_loader.gd")


@warning_ignore("unsafe_method_access")
func _ready() -> void:
	var runner : Node = load("res://addons/gut/gui/GutRunner.tscn").instantiate()
	add_child(runner)
	runner.run_from_editor()
	GutLoader.restore_ignore_addons()


--------------------------------------------------
FILE: res:///addons/gut/gui/run_from_editor.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bgj3fm5d8yvjw"]

[ext_resource type="Script" uid="uid://bwf2iuidqfkpl" path="res://addons/gut/gui/run_from_editor.gd" id="1_53pap"]

[node name="RunFromEditor" type="Node2D"]
script = ExtResource("1_53pap")


--------------------------------------------------
FILE: res:///addons/gut/gut.gd
--------------------------------------------------
extends 'res://addons/gut/gut_to_move.gd'
class_name GutMain
## The GUT brains.
##
## Most of this class is for internal use only.  Features that can be used are
## have descriptions and can be accessed through the [member GutTest.gut] variable
## in your test scripts (extends [GutTest]).
## The wiki page for this class contains only the usable features.
## [br][br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br]
## @ignore-uncommented


# ---------------------------
# Constants
# ---------------------------
const LOG_LEVEL_FAIL_ONLY = 0
const LOG_LEVEL_TEST_AND_FAILURES = 1
const LOG_LEVEL_ALL_ASSERTS = 2
const WAITING_MESSAGE = '/# waiting #/'
const PAUSE_MESSAGE = '/# Pausing.  Press continue button...#/'
const COMPLETED = 'completed'

# ---------------------------
# Signals
# ---------------------------
signal start_pause_before_teardown
signal end_pause_before_teardown

signal start_run
signal end_run
signal start_script(test_script_obj)
signal end_script
signal start_test(test_name)
signal end_test


# ---------------------------
# Settings
#
# These are properties that are usually set before a run is started through
# gutconfig.
# ---------------------------

var _inner_class_name = ''
# When set, GUT will only run Inner-Test-Classes that contain this string.
var inner_class_name = _inner_class_name :
	get: return _inner_class_name
	set(val): _inner_class_name = val

var _ignore_pause_before_teardown = false
# For batch processing purposes, you may want to ignore any calls to
# pause_before_teardown that you forgot to remove_at.
var ignore_pause_before_teardown = _ignore_pause_before_teardown :
	get: return _ignore_pause_before_teardown
	set(val): _ignore_pause_before_teardown = val

var _log_level = 1
## The log detail level.  Valid values are 0 - 2.  Larger values do not matter.
var log_level = _log_level:
	get: return _log_level
	set(val): _set_log_level(val)

## The amount of time that must elapse before an "Awaiting" message is printed.
var wait_log_delay = 0.5

# TODO 4.0
# This appears to not be used anymore.  Going to wait for more tests to be
# ported before removing.
var _disable_strict_datatype_checks = false
var disable_strict_datatype_checks = false :
	get: return _disable_strict_datatype_checks
	set(val): _disable_strict_datatype_checks = val

var _export_path = ''
# Path to file that GUT will create which holds a list of all test scripts so
# that GUT can run tests when a project is exported.
var export_path = '' :
	get: return _export_path
	set(val): _export_path = val

var _include_subdirectories = false
# Setting this to true will make GUT search all subdirectories of any directory
# you have configured GUT to search for tests in.
var include_subdirectories = _include_subdirectories :
	get: return _include_subdirectories
	set(val): _include_subdirectories = val


var _double_strategy = GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY
# TODO rework what this is and then document it here.
var double_strategy = _double_strategy  :
	get: return _double_strategy
	set(val):
		if(GutUtils.DOUBLE_STRATEGY.values().has(val)):
			_double_strategy = val
			_doubler.set_strategy(double_strategy)
		else:
			_lgr.error(str("gut.gd:  invalid double_strategy ", val))

var _pre_run_script = ''
# Path to the script that will be run before all tests are run.  This script
# must extend GutHookScript
var pre_run_script = _pre_run_script :
	get: return _pre_run_script
	set(val): _pre_run_script = val

var _post_run_script = ''
# Path to the script that will run after all tests have run.  The script
# must extend GutHookScript
var post_run_script = _post_run_script :
	get: return _post_run_script
	set(val): _post_run_script = val

var _color_output = false
# Flag to color output at the command line and in the GUT GUI.
var color_output = false :
	get: return _color_output
	set(val):
		_color_output = val
		_lgr.disable_formatting(!_color_output)

var _junit_xml_file = ''
# The full path to where GUT should write a JUnit compliant XML file to which
# contains the results of all tests run.
var junit_xml_file = '' :
	get: return _junit_xml_file
	set(val): _junit_xml_file = val

var _junit_xml_timestamp = false
# When true and junit_xml_file is set, the file name will include a
# timestamp so that previous files are not overwritten.
var junit_xml_timestamp = false :
	get: return _junit_xml_timestamp
	set(val): _junit_xml_timestamp = val

# The minimum amout of time GUT will wait before pausing for 1 frame to allow
# the screen to paint.  GUT checkes after each test to see if enough time has
# passed.
var paint_after = .1:
	get: return paint_after
	set(val): paint_after = val

var _unit_test_name = ''
# When set GUT will only run tests that contain this string.
var unit_test_name = _unit_test_name :
	get: return _unit_test_name
	set(val): _unit_test_name = val

var _parameter_handler = null
# This is populated by test.gd each time a paramterized test is encountered
# for the first time.
# FOR INTERNAL USE ONLY
var parameter_handler = _parameter_handler :
	get: return _parameter_handler
	set(val):
		_parameter_handler = val
		_parameter_handler.set_logger(_lgr)

var _lgr = GutUtils.get_logger()
# Local reference for the common logger.
var logger = _lgr :
	get: return _lgr
	set(val):
		_lgr = val
		_lgr.set_gut(self)

var error_tracker = GutUtils.get_error_tracker()

var _add_children_to = self
# Sets the object that GUT will add test objects to as it creates them.  The
# default is self, but can be set to other objects so that GUT is not obscured
# by the objects added during tests.
var add_children_to = self :
	get: return _add_children_to
	set(val): _add_children_to = val


# ------------
# Read only
# ------------
var _test_collector = GutUtils.TestCollector.new()
func get_test_collector():
	return _test_collector

# var version = null :
func get_version():
	return GutUtils.version_numbers.gut_version

var _orphan_counter =  GutUtils.OrphanCounter.new()
func get_orphan_counter():
	return _orphan_counter

# var _autofree = GutUtils.AutoFree.new()
func get_autofree():
	return _orphan_counter.autofree

var _stubber = GutUtils.Stubber.new()
func get_stubber():
	return _stubber

var _doubler = GutUtils.Doubler.new()
func get_doubler():
	return _doubler

var _spy = GutUtils.Spy.new()
func get_spy():
	return _spy

var _is_running = false
func is_running():
	return _is_running


# ---------------------------
# Private
# ---------------------------
var  _should_print_versions = true # used to cut down on output in tests.
var _should_print_summary = true

var _file_prefix = 'test_'
var _inner_class_prefix = 'Test'

var _select_script = ''
var _last_paint_time = 0.0
var _strutils = GutUtils.Strutils.new()

# The instance that is created from _pre_run_script.  Accessible from
# get_pre_run_script_instance.  These are created at the start of the run
# and then referenced at the appropriate time.  This allows us to validate the
# scripts prior to running.
var _pre_run_script_instance = null
var _post_run_script_instance = null

var _script_name = null

# The instanced scripts.  This is populated as the scripts are run.
var _test_script_objects = []

var _waiting = false

# msecs ticks when run was started
var _start_time = 0.0

# Collected Test instance for the current test being run.
var _current_test = null
var _pause_before_teardown = false


# Used to cancel importing scripts if an error has occurred in the setup.  This
# prevents tests from being run if they were exported and ensures that the
# error displayed is seen since importing generates a lot of text.
#
# TODO this appears to only be checked and never set anywhere.  Verify that this
# was not broken somewhere and remove if no longer used.
var _cancel_import = false

# this is how long Gut will wait when there are items that must be queued free
# when a test completes (due to calls to add_child_autoqfree)
var _auto_queue_free_delay = .1

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _init(override_logger=null):
	if(override_logger != null):
		logger = override_logger
	else:
		logger = logger # force setter logic

	_doubler.set_stubber(_stubber)
	_doubler.set_spy(_spy)
	_doubler.set_gut(self)

	update_loggers()

# Public for tests that set the logger.  This makes it much easier to propigate
# test loggers.
func update_loggers():
	_doubler.set_logger(_lgr)
	_spy.set_logger(_lgr)
	_stubber.set_logger(_lgr)
	_test_collector.set_logger(_lgr)


# ------------------------------------------------------------------------------
# Initialize controls
# ------------------------------------------------------------------------------
func _ready():
	if(_should_print_versions):
		_lgr.log('---  GUT  ---')
		_lgr.info(str('using [', OS.get_user_data_dir(), '] for temporary output.'))

	if(_select_script != null):
		select_script(_select_script)

	_print_versions()

# ------------------------------------------------------------------------------
# Runs right before free is called.  Can't override `free`.
# ------------------------------------------------------------------------------
func _notification(what):
	if(what == NOTIFICATION_PREDELETE):
		for ts in _test_script_objects:
			if(is_instance_valid(ts)):
				ts.free()

		_test_script_objects = []


func _print_versions(send_all = true):
	if(!_should_print_versions):
		return

	var info = GutUtils.version_numbers.get_version_text()

	if(send_all):
		p(info)
	else:
		_lgr.get_printer('gui').send(info + "\n")




# ---------------------------
#
# Accessor code
#
# ---------------------------


# ------------------------------------------------------------------------------
# Set the log level.  Use one of the various LOG_LEVEL_* constants.
# ------------------------------------------------------------------------------
func _set_log_level(level):
	_log_level = max(level, 0)

	# Level 0 settings
	_lgr.set_less_test_names(level == 0)
	# Explicitly always enabled
	_lgr.set_type_enabled(_lgr.types.normal, true)
	_lgr.set_type_enabled(_lgr.types.error, true)
	_lgr.set_type_enabled(_lgr.types.pending, true)

	# Level 1 types
	_lgr.set_type_enabled(_lgr.types.warn, level > 0)
	_lgr.set_type_enabled(_lgr.types.deprecated, level > 0)

	# Level 2 types
	_lgr.set_type_enabled(_lgr.types.passed, level > 1)
	_lgr.set_type_enabled(_lgr.types.info, level > 1)
	_lgr.set_type_enabled(_lgr.types.debug, level > 1)

# ---------------------------
#
# Events
#
# ---------------------------
func end_teardown_pause():
	_pause_before_teardown = false
	_waiting = false
	end_pause_before_teardown.emit()

# ---------------------------
#
# Private
#
# ---------------------------
func _log_test_children_warning(test_script):
	if(!_lgr.is_type_enabled(_lgr.types.orphan)):
		return

	var kids = test_script.get_children()
	if(kids.size() > 1):
		var msg = ''
		if(_log_level == 2):
			msg = "Test script still has children when all tests finisehd.\n"
			for i in range(kids.size()):
				msg += str("  ", _strutils.type2str(kids[i]), "\n")
			msg += "You can use autofree, autoqfree, add_child_autofree, or add_child_autoqfree to automatically free objects."
		else:
			msg = str("Test script has ", kids.size(), " unfreed children.  Increase log level for more details.")

		_lgr.warn(msg)


func _log_end_run():
	var summary = GutUtils.Summary.new(self)
	if(_should_print_summary):
		_orphan_counter.record_orphans("end_run")
		if(_lgr.is_type_enabled("orphan") and _orphan_counter.get_count() > 0):
			_lgr.log("\n\n\n")
			_lgr.orphan("==============================================")
			_lgr.orphan(str('= ', _orphan_counter.get_count(), ' Orphans'))
			_lgr.orphan("==============================================")
			_orphan_counter.log_all()
			_lgr.log("\n")
		else:
			_lgr.log("\n\n\n")

		summary.log_end_run()


func _validate_hook_script(path):
	var result = {
		valid = true,
		instance = null
	}

	# empty path is valid but will have a null instance
	if(path == ''):
		return result

	if(FileAccess.file_exists(path)):
		var inst = load(path).new()
		if(inst and inst is GutHookScript):
			result.instance = inst
			result.valid = true
		else:
			result.valid = false
			_lgr.error('The hook script [' + path + '] does not extend GutHookScript')
	else:
		result.valid = false
		_lgr.error('The hook script [' + path + '] does not exist.')

	return result


# ------------------------------------------------------------------------------
# Runs a hook script.  Script must exist, and must extend
# GutHookScript or addons/gut/hook_script.gd
# ------------------------------------------------------------------------------
func _run_hook_script(inst):
	if(inst != null):
		inst.gut = self
		await inst.run()
	return inst


# ------------------------------------------------------------------------------
# Initialize variables for each run of a single test script.
# ------------------------------------------------------------------------------
func _init_run():
	var valid = true
	_test_collector.set_test_class_prefix(_inner_class_prefix)
	_test_script_objects = []
	_current_test = null
	_is_running = true

	var pre_hook_result = _validate_hook_script(_pre_run_script)
	_pre_run_script_instance = pre_hook_result.instance
	var post_hook_result = _validate_hook_script(_post_run_script)
	_post_run_script_instance  = post_hook_result.instance

	valid = pre_hook_result.valid and  post_hook_result.valid

	return valid


# ------------------------------------------------------------------------------
# Print out run information and close out the run.
# ------------------------------------------------------------------------------
func _end_run():
	await _run_hook_script(get_post_run_script_instance())

	_orphan_counter.record_orphans("end_run")
	_orphan_counter.orphanage.clean()
	_log_end_run()
	_is_running = false

	_export_results()
	end_run.emit()


# ------------------------------------------------------------------------------
# Add additional export types here.
# ------------------------------------------------------------------------------
func _export_results():
	if(_junit_xml_file != ''):
		_export_junit_xml()


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _export_junit_xml():
	var exporter = GutUtils.JunitXmlExport.new()
	var output_file = _junit_xml_file

	if(_junit_xml_timestamp):
		var ext = "." + output_file.get_extension()
		output_file = output_file.replace(ext, str("_", Time.get_unix_time_from_system(), ext))

	var f_result = exporter.write_file(self, output_file)
	if(f_result == OK):
		p(str("Results saved to ", output_file))


# ------------------------------------------------------------------------------
# Print out the heading for a new script
# ------------------------------------------------------------------------------
func _print_script_heading(coll_script):
	if(_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
		_lgr.log(str("\n\n", coll_script.get_full_name()), _lgr.fmts.underline)


# ------------------------------------------------------------------------------
# Yes if the class name is null or the script's class name includes class_name
# ------------------------------------------------------------------------------
func _does_class_name_match(the_class_name, script_class_name):
	return (the_class_name == null or the_class_name == '') or \
		(script_class_name != null and str(script_class_name).findn(the_class_name) != -1)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _create_script_instance(collected_script):
	var test_script = collected_script.get_new()

	test_script.gut = self
	test_script.set_logger(_lgr)
	_add_children_to.add_child(test_script)
	_test_script_objects.append(test_script)
	test_script.wait_log_delay = wait_log_delay

	if(!test_script._was_ready_called):
		test_script._do_ready_stuff()
		_lgr.warn(str("!!! YOU HAVE UPSET YOUR GUT !!!\n",
			"You have overridden _ready in [", collected_script.get_filename_and_inner(), "] ",
			"but it does not call super._ready().  New additions (or maybe old ",
			"by the time you see this) require that super._ready() is called.",
			"\n\n",
			"GUT is working around this infraction, but may not be able to in ",
			"the future.  GUT also reserves the right to decide it does not want ",
			"to work around it in the future.  ",
			"You should probably use before_all instead of _ready.  I can think ",
			"of a few reasons why you would want to use _ready but I won't list ",
			"them here because I think they are bad ideas.  I know they are bad ",
			"ideas because I did them.  Hence the warning.  This message is ",
			"intentially long so that it bothers you and you change your ways.\n\n",
			"Thank you for using GUT."))
	return test_script


# ------------------------------------------------------------------------------
# returns self so it can be integrated into the yield call.
# ------------------------------------------------------------------------------
func _wait_for_continue_button():
	p(PAUSE_MESSAGE, 0)
	_waiting = true
	return self


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_indexes_matching_script_name(script_name):
	var indexes = [] # empty runs all
	for i in range(_test_collector.scripts.size()):
		if(_test_collector.scripts[i].get_filename().find(script_name) != -1):
			indexes.append(i)
	return indexes


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_indexes_matching_path(path):
	var indexes = []
	for i in range(_test_collector.scripts.size()):
		if(_test_collector.scripts[i].path == path):
			indexes.append(i)
	return indexes


# ------------------------------------------------------------------------------
# Execute all calls of a parameterized test.
# ------------------------------------------------------------------------------
func _run_parameterized_test(test_script, test_name):
	await _run_test(test_script, test_name, 0)

	if(_current_test.assert_count == 0 and !_current_test.pending):
		_lgr.risky('Test did not assert')

	if(_parameter_handler == null):
		_lgr.error(str('Parameterized test ', _current_test.name, ' did not call use_parameters for the default value of the parameter.'))
		_fail(str('Parameterized test ', _current_test.name, ' did not call use_parameters for the default value of the parameter.'))
	else:
		var index = 1
		while(!_parameter_handler.is_done()):
			var cur_assert_count = _current_test.assert_count
			await _run_test(test_script, test_name, index)
			if(_current_test.assert_count == cur_assert_count and !_current_test.pending):
				_lgr.risky('Test did not assert')
			index += 1

	_parameter_handler = null


# ------------------------------------------------------------------------------
# Runs a single test given a test.gd instance and the name of the test to run.
# ------------------------------------------------------------------------------
func _run_test(script_inst, test_name, param_index = -1):
	_lgr.log_test_name()
	_lgr.set_indent_level(1)

	await script_inst.before_each()

	start_test.emit(test_name)
	var test_id = str(script_inst.collected_script.get_filename_and_inner(), ':', test_name)
	if(param_index != -1):
		test_id += str('[', param_index, ']')
	error_tracker.start_test(test_id)

	await script_inst.call(test_name)

	if(error_tracker.should_test_fail_from_errors(test_id)):
		script_inst._fail(str("Unexpected Errors:\n", error_tracker.get_fail_text_for_errors(test_id)))

	error_tracker.end_test()
	# if the test called pause_before_teardown then await until
	# the continue button is pressed.
	if(_pause_before_teardown and !_ignore_pause_before_teardown):
		start_pause_before_teardown.emit()
		await _wait_for_continue_button().end_pause_before_teardown

	script_inst.clear_signal_watcher()

	await script_inst.after_each()

	# Free up everything in the _autofree.  Yield for a bit if we
	# have anything with a queue_free so that they have time to
	# free and are not found by the orphan counter.
	var aqf_count = _orphan_counter.autofree.get_queue_free_count()
	_orphan_counter.autofree.free_all()
	if(aqf_count > 0):
		await get_tree().create_timer(_auto_queue_free_delay).timeout

	_orphan_counter.end_test(
		script_inst.collected_script.get_filename_and_inner(), test_name,
		_log_level > 0)

	_doubler.get_ignored_methods().clear()


func get_current_test_orphans():
	var sname = get_current_test_object().collected_script.get_ref().get_filename_and_inner()
	var tname = get_current_test_object().name
	_orphan_counter.record_orphans(sname, tname)
	return _orphan_counter.get_orphan_ids(sname, tname)


# ------------------------------------------------------------------------------
# Calls before_all on the passed in test script and takes care of settings so all
# logger output appears indented and with a proper heading
#
# Calls both pre-all-tests methods until prerun_setup is removed
# ------------------------------------------------------------------------------
func _call_before_all(test_script, collected_script):
	var before_all_test_obj = GutUtils.CollectedTest.new()
	before_all_test_obj.has_printed_name = false
	before_all_test_obj.name = 'before_all'

	collected_script.setup_teardown_tests.append(before_all_test_obj)
	_current_test = before_all_test_obj

	_lgr.inc_indent()
	await test_script.before_all()
	# before all does not need to assert anything so only mark it as run if
	# some assert was done.
	before_all_test_obj.was_run = before_all_test_obj.did_something()

	_lgr.dec_indent()

	_current_test = null


# ------------------------------------------------------------------------------
# Calls after_all on the passed in test script and takes care of settings so all
# logger output appears indented and with a proper heading
#
# Calls both post-all-tests methods until postrun_teardown is removed.
# ------------------------------------------------------------------------------
func _call_after_all(test_script, collected_script):
	var after_all_test_obj = GutUtils.CollectedTest.new()
	after_all_test_obj.has_printed_name = false
	after_all_test_obj.name = 'after_all'

	collected_script.setup_teardown_tests.append(after_all_test_obj)
	_current_test = after_all_test_obj

	_lgr.inc_indent()
	await test_script.after_all()
	# after all does not need to assert anything so only mark it as run if
	# some assert was done.
	after_all_test_obj.was_run = after_all_test_obj.did_something()
	_lgr.dec_indent()

	_current_test = null


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _should_skip_script(test_script, collected_script):
	var skip_message = 'not skipped'
	var skip_value = test_script.get('skip_script')
	var should_skip = false

	if(skip_value == null):
		skip_value = await test_script.should_skip_script()
	else:
		_lgr.deprecated('Using the skip_script var has been deprecated.  Implement the new should_skip_script() method in your test instead.')

	if(skip_value != null):
		if(typeof(skip_value) == TYPE_BOOL):
			should_skip = skip_value
			if(skip_value):
				skip_message = 'script marked to skip'
		elif(typeof(skip_value) == TYPE_STRING):
			should_skip = true
			skip_message = skip_value

	if(should_skip):
		var msg = str('- [Script skipped]:  ', skip_message)
		_lgr.inc_indent()
		_lgr.log(msg, _lgr.fmts.yellow)
		_lgr.dec_indent()
		collected_script.skip_reason = skip_message
		collected_script.was_skipped = true

	return should_skip


# ------------------------------------------------------------------------------
# Run all tests in a script.  This is the core logic for running tests.
# ------------------------------------------------------------------------------
func _test_the_scripts(indexes=[]):

	_print_versions(false)
	var is_valid = _init_run()
	if(!is_valid):
		_lgr.error('Something went wrong and the run was aborted.')
		return

	await _run_hook_script(get_pre_run_script_instance())
	if(_pre_run_script_instance!= null and _pre_run_script_instance.should_abort()):
		_lgr.error('pre-run abort')
		end_run.emit()
		return

	start_run.emit()
	_start_time = Time.get_ticks_msec()
	_last_paint_time = _start_time

	var indexes_to_run = []
	if(indexes.size()==0):
		for i in range(_test_collector.scripts.size()):
			indexes_to_run.append(i)
	else:
		indexes_to_run = indexes


	# loop through scripts
	for test_indexes in range(indexes_to_run.size()):
		var coll_script = _test_collector.scripts[indexes_to_run[test_indexes]]

		if(coll_script.tests.size() > 0):
			_lgr.set_indent_level(0)
			_print_script_heading(coll_script)

		if(!coll_script.is_loaded):
			break

		start_script.emit(coll_script)

		var test_script = _create_script_instance(coll_script)
		_doubler.set_strategy(_double_strategy)

		# ----
		# SHORTCIRCUIT
		# skip_script logic
		if(await _should_skip_script(test_script, coll_script)):
			_orphan_counter.record_orphans(coll_script.get_full_name())
			continue
		# ----

		# !!!
		# Hack so there isn't another indent to this monster of a method.  if
		# inner class is set and we do not have a match then empty the tests
		# for the current test.
		# !!!
		if(!_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
			coll_script.tests = []
		else:
			coll_script.was_run = true
			await _call_before_all(test_script, coll_script)

		_orphan_counter.record_orphans(coll_script.get_full_name())
		# Each test in the script
		for i in range(coll_script.tests.size()):
			_stubber.clear()
			_spy.clear()
			_current_test = coll_script.tests[i]

			if((_unit_test_name != '' and _current_test.name.find(_unit_test_name) > -1) or
				(_unit_test_name == '')):

				var ticks_before := Time.get_ticks_usec()

				if(_current_test.arg_count > 1):
					_lgr.error(str('Parameterized test ', _current_test.name,
						' has too many parameters:  ', _current_test.arg_count, '.'))
				elif(_current_test.arg_count == 1):
					_current_test.was_run = true
					await _run_parameterized_test(test_script, _current_test.name)
				else:
					_current_test.was_run = true
					await _run_test(test_script, _current_test.name)

				if(!_current_test.did_something()):
					_lgr.risky(str(_current_test.name, ' did not assert'))

				_current_test.has_printed_name = false

				_current_test.time_taken = (Time.get_ticks_usec() - ticks_before) / 1000000.0

				end_test.emit()

				# After each test, check to see if we shoudl wait a frame to
				# paint based on how much time has elapsed since we last 'painted'
				if(paint_after > 0.0):
					var now = Time.get_ticks_msec()
					var time_since = (now - _last_paint_time) / 1000.0
					if(time_since > paint_after):
						_last_paint_time = now
						await get_tree().process_frame

		_current_test = null
		_lgr.dec_indent()

		if(_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
			await _call_after_all(test_script, coll_script)

		_orphan_counter.end_script(
			coll_script.get_filename_and_inner(),
			_log_level > 0)

		_log_test_children_warning(test_script)
		# This might end up being very resource intensive if the scripts
		# don't clean up after themselves.  Might have to consolidate output
		# into some other structure and kill the script objects with
		# test_script.free() instead of remove_at child.
		_add_children_to.remove_child(test_script)

		_lgr.set_indent_level(0)
		if(test_script.get_assert_count() > 0):
			var script_sum = str(coll_script.get_passing_test_count(), '/', coll_script.get_ran_test_count(), ' passed.')
			_lgr.log(script_sum, _lgr.fmts.bold)

		test_script.queue_free()
		end_script.emit()
		# END TEST SCRIPT LOOP

	_lgr.set_indent_level(0)
	# Give anything that is queued to be freed time to be freed before we count
	# the orphans.  Without this, the last test's awaiter won't be freed
	# yet, which messes with the orphans total.  There could also be objects
	# the user has queued to be freed as well.
	# Bump number from .1 to .5 when inner classes that were not run were still
	# appearing as orphans.  Maybe this could loop through the orpahns looking
	# for entries that were not freed but are queued to be freed and wait unitl
	# they are all gone.  ".5" is a lot easier.
	await get_tree().create_timer(.5).timeout
	_end_run()


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _pass(text=''):
	if(_current_test):
		_current_test.add_pass(text)


# ------------------------------------------------------------------------------
# Returns an empty string or "(call #x) " if the current test being run has
# parameters.  The
# ------------------------------------------------------------------------------
func get_call_count_text():
	var to_return = ''
	if(_parameter_handler != null):
		# This uses get_call_count -1 because test.gd's use_parameters method
		# should have been called before we get to any calls for this method
		# just due to how use_parameters works.  There isn't a way to know
		# whether we are before or after that call.
		to_return = str('params[', _parameter_handler.get_call_count() -1, '] ')
	return to_return


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _fail(text=''):
	if(_current_test != null):
		var line_number = _extract_line_number(_current_test)
		var line_text = '  at line ' + str(line_number)
		p(line_text, LOG_LEVEL_FAIL_ONLY)
		# format for summary
		line_text =  "\n    " + line_text
		var call_count_text = get_call_count_text()
		_current_test.line_number = line_number
		_current_test.add_fail(call_count_text + text + line_text)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _pending(text=''):
	if(_current_test):
		_current_test.add_pending(text)


# ------------------------------------------------------------------------------
# Extracts the line number from curren stacktrace by matching the test case name
# ------------------------------------------------------------------------------
func _extract_line_number(current_test):
	var line_number = -1
	# if stack trace available than extraxt the test case line number
	var stackTrace = get_stack()
	if(stackTrace!=null):
		for index in stackTrace.size():
			var line = stackTrace[index]
			var function = line.get("function")
			if function == current_test.name:
				line_number = line.get("line")
	return line_number


# ------------------------------------------------------------------------------
# Gets all the files in a directory and all subdirectories if include_subdirectories
# is true.  The files returned are all sorted by name.
# ------------------------------------------------------------------------------
func _get_files(path, prefix, suffix):
	var files = []
	var directories = []
	# ignore addons/gut per issue 294
	if(path == 'res://addons/gut'):
		return [];

	var d = DirAccess.open(path)
	d.include_hidden = false
	d.include_navigational = false

	# Traversing a directory is kinda odd.  You have to start the process of
	# listing the contents of a directory with list_dir_begin then use get_next
	# until it returns an empty string.  Then I guess you should end it.
	d.list_dir_begin()
	var fs_item = d.get_next()
	var full_path = ''
	while(fs_item != ''):
		full_path = path.path_join(fs_item)

		# MUST use FileAccess since d.file_exists returns false for exported
		# projects
		if(FileAccess.file_exists(full_path)):
			if(fs_item.begins_with(prefix) and fs_item.ends_with(suffix)):
				files.append(full_path)
		# MUST use DirAccess, d.dir_exists is false for exported projects.
		elif(include_subdirectories and DirAccess.dir_exists_absolute(full_path)):
			directories.append(full_path)

		fs_item = d.get_next()
	d.list_dir_end()

	for dir in range(directories.size()):
		var dir_files = _get_files(directories[dir], prefix, suffix)
		for i in range(dir_files.size()):
			files.append(dir_files[i])

	files.sort()
	return files


# ---------------------------
#
# public
#
# ---------------------------

func get_elapsed_time() -> float:
	var to_return = 0.0
	if(_start_time != 0.0):
		to_return = Time.get_ticks_msec() - _start_time
	to_return = to_return / 1000.0

	return to_return

# ------------------------------------------------------------------------------
# Conditionally prints the text to the console/results variable based on the
# current log level and what level is passed in.  Whenever currently in a test,
# the text will be indented under the test.  It can be further indented if
# desired.
#
# The first time output is generated when in a test, the test name will be
# printed.
# ------------------------------------------------------------------------------
func p(text, level=0):
	var str_text = str(text)

	if(level <= GutUtils.nvl(_log_level, 0)):
		_lgr.log(str_text)

# ---------------------------
#
# RUN TESTS/ADD SCRIPTS
#
# ---------------------------

# ------------------------------------------------------------------------------
# Runs all the scripts that were added using add_script
# ------------------------------------------------------------------------------
func test_scripts(_run_rest=false):
	if(_script_name != null and _script_name != ''):
		var indexes = _get_indexes_matching_script_name(_script_name)
		if(indexes == []):
			_lgr.error(str(
				"Could not find script matching '", _script_name, "'.\n",
				"Check your directory settings and Script Prefix/Suffix settings."))
			end_run.emit()
		else:
			_test_the_scripts(indexes)
	else:
		_test_the_scripts([])

# alias
func run_tests(run_rest=false):
	test_scripts(run_rest)


# ------------------------------------------------------------------------------
# Runs a single script passed in.
# ------------------------------------------------------------------------------
# func run_test_script(script):
# 	_test_collector.set_test_class_prefix(_inner_class_prefix)
# 	_test_collector.clear()
# 	_test_collector.add_script(script)
# 	_test_the_scripts()


# ------------------------------------------------------------------------------
# Adds a script to be run when test_scripts called.
# ------------------------------------------------------------------------------
func add_script(script):
	# if(!Engine.is_editor_hint()):
	_test_collector.set_test_class_prefix(_inner_class_prefix)
	_test_collector.add_script(script)


# ------------------------------------------------------------------------------
# Add all scripts in the specified directory that start with the prefix and end
# with the suffix.  Does not look in sub directories.  Can be called multiple
# times.
# ------------------------------------------------------------------------------
func add_directory(path, prefix=_file_prefix, suffix=".gd"):
	# check for '' b/c the calls to addin the exported directories 1-6 will pass
	# '' if the field has not been populated.  This will cause res:// to be
	# processed which will include all files if include_subdirectories is true.
	if(path == '' or path == null):
		return

	var dir = DirAccess.open(path)
	if(dir == null):
		_lgr.error(str('The path [', path, '] does not exist.'))
	else:
		var files = _get_files(path, prefix, suffix)
		for i in range(files.size()):
			if(_script_name == null or _script_name == '' or \
					(_script_name != null and files[i].findn(_script_name) != -1)):
				add_script(files[i])


# ------------------------------------------------------------------------------
# This will try to find a script in the list of scripts to test that contains
# the specified script name.  It does not have to be a full match.  It will
# select the first matching occurrence so that this script will run when run_tests
# is called.  Works the same as the select_this_one option of add_script.
#
# returns whether it found a match or not
# ------------------------------------------------------------------------------
func select_script(script_name):
	_script_name = script_name
	_select_script = script_name


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func export_tests(path=_export_path):
	if(path == null):
		_lgr.error('You must pass a path or set the export_path before calling export_tests')
	else:
		var result = _test_collector.export_tests(path)
		if(result):
			_lgr.info(_test_collector.to_s())
			_lgr.info("Exported to " + path)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func import_tests(path=_export_path):
	if(!FileAccess.file_exists(path)):
		_lgr.error(str('Cannot import tests:  the path [', path, '] does not exist.'))
	else:
		_test_collector.clear()
		var result = _test_collector.import_tests(path)
		if(result):
			_lgr.info("\n" + _test_collector.to_s())
			_lgr.info("Imported from " + path)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func import_tests_if_none_found():
	if(!_cancel_import and _test_collector.scripts.size() == 0):
		import_tests()


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func export_if_tests_found():
	if(_test_collector.scripts.size() > 0):
		export_tests()

# ---------------------------
#
# MISC
#
# ---------------------------


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func maximize():
	_lgr.deprecated('gut.maximize')


# ------------------------------------------------------------------------------
# Clears the text of the text box.  This resets all counters.
# ------------------------------------------------------------------------------
func clear_text():
	_lgr.deprecated('gut.clear_text')


# ------------------------------------------------------------------------------
# Get the number of tests that were ran
# ------------------------------------------------------------------------------
func get_test_count():
	return _test_collector.get_ran_test_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that were made
func get_assert_count():
	return _test_collector.get_assert_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that passed
func get_pass_count():
	return _test_collector.get_pass_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that failed
func get_fail_count():
	return _test_collector.get_fail_count()

# ------------------------------------------------------------------------------
## Get the number of tests flagged as pending
func get_pending_count():
	return _test_collector.get_pending_count()


# ------------------------------------------------------------------------------
# Call this method to make the test pause before teardown so that you can inspect
# anything that you have rendered to the screen.
# ------------------------------------------------------------------------------
func pause_before_teardown():
	_pause_before_teardown = true;


# ------------------------------------------------------------------------------
# Returns the script object instance that is currently being run.
# ------------------------------------------------------------------------------
func get_current_script_object():
	var to_return = null
	if(_test_script_objects.size() > 0):
		to_return = _test_script_objects[-1]
	return to_return


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_current_test_object():
	return _current_test


## Returns a summary.gd object that contains all the information about
## the run results.
func get_summary():
	return GutUtils.Summary.new(self)

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_pre_run_script_instance():
	return _pre_run_script_instance

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_post_run_script_instance():
	return _post_run_script_instance

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func show_orphans(should):
	_lgr.set_type_enabled(_lgr.types.orphan, should)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_logger():
	return _lgr


# ------------------------------------------------------------------------------
## Returns the number of test scripts.  Inner Test classes each count as a
## script.
func get_test_script_count():
	return _test_script_objects.size()




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/gut_cmdln.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# Description
# -----------
# Entry point for the command line interface.  The actual logic for GUT's CLI
# is in addons/gut/cli/gut_cli.gd.
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
extends SceneTree

var VersionConversion = load("res://addons/gut/version_conversion.gd")

@warning_ignore("unsafe_method_access")
@warning_ignore("inferred_declaration")
func _init() -> void:
	if(VersionConversion.error_if_not_all_classes_imported()):
		quit(0)
		return

	var max_iter := 20
	var iter := 0

	var Loader : Object = load("res://addons/gut/gut_loader.gd")

	# Not seen this wait more than 1.
	while(Engine.get_main_loop() == null and iter < max_iter):
		await create_timer(.01).timeout
		iter += 1

	if(Engine.get_main_loop() == null):
		push_error('Main loop did not start in time.')
		quit(0)
		return

	var cli : Node = load('res://addons/gut/cli/gut_cli.gd').new()
	get_root().add_child(cli)

	Loader.restore_ignore_addons()
	cli.main()




# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/gut_config.gd
--------------------------------------------------
# ##############################################################################
#
# This holds all the configuratoin values for GUT.  It can load and save values
# to a json file.  It is also responsible for applying these settings to GUT.
#
# ##############################################################################
const FAIL_ERROR_TYPE_ENGINE = &'engine'
const FAIL_ERROR_TYPE_PUSH_ERROR = &'push_error'
const FAIL_ERROR_TYPE_GUT = &'gut'



var valid_fonts = GutUtils.gut_fonts.get_font_names()
var _deprecated_values = {
	"errors_do_not_cause_failure": "Use failure_error_types instead."
}

var default_options = {
	background_color = Color(.15, .15, .15, 1).to_html(),
	config_file = 'res://.gutconfig.json',
	# used by editor to handle enabled/disabled dirs.  All dirs configured go
	# here and only the enabled dirs go into dirs
	configured_dirs = [],
	dirs = [],
	disable_colors = false,
	# double strategy can be the name of the enum value, the enum value or
	# lowercase name with spaces:  0/SCRIPT_ONLY/script only
	# The GUI gut config expects the value to be the enum value and not a string
	# when saved.
	double_strategy = 'SCRIPT_ONLY',
	font_color = Color(.8, .8, .8, 1).to_html(),
	font_name = GutUtils.gut_fonts.DEFAULT_CUSTOM_FONT_NAME,
	font_size = 16,
	hide_orphans = false,
	ignore_pause = false,
	include_subdirs = false,
	inner_class = '',
	junit_xml_file = '',
	junit_xml_timestamp = false,
	log_level = 1,
	opacity = 100,
	paint_after = .1,
	post_run_script = '',
	pre_run_script = '',
	prefix = 'test_',
	selected = '',
	should_exit_on_success = false,
	should_exit = false,
	should_maximize = false,
	compact_mode = false,
	show_help = false,
	suffix = '.gd',
	tests = [],
	unit_test_name = '',

	no_error_tracking = false,
	failure_error_types = ["engine", "gut", "push_error"],
	wait_log_delay = .5,

	gut_on_top = true,
}


var options = default_options.duplicate()
var logger = GutUtils.get_logger()

func _null_copy(h):
	var new_hash = {}
	for key in h:
		new_hash[key] = null
	return new_hash


func _load_options_from_config_file(file_path, into):
	if(!FileAccess.file_exists(file_path)):
		# Default files are ok to be missing.  Maybe this is too deep a place
		# to implement this, but here it is.
		if(file_path != 'res://.gutconfig.json' and file_path != GutUtils.EditorGlobals.editor_run_gut_config_path):
			logger.error(str('Config File "', file_path, '" does not exist.'))
			return -1
		else:
			return 1

	var f = FileAccess.open(file_path, FileAccess.READ)
	if(f == null):
		var result = FileAccess.get_open_error()
		logger.error(str("Could not load data ", file_path, ' ', result))
		return result

	var json = f.get_as_text()
	f = null # close file

	var test_json_conv = JSON.new()
	test_json_conv.parse(json)
	var results = test_json_conv.get_data()
	# SHORTCIRCUIT
	if(results == null):
		logger.error(str("Could not parse file:  ", file_path))
		return -1

	# Get all the options out of the config file using the option name.  The
	# options hash is now the default source of truth for the name of an option.
	_load_dict_into(results, into)

	return 1


func _load_dict_into(source, dest):
	for key in dest:
		if(source.has(key)):
			if(source[key] != null):
				if(typeof(source[key]) == TYPE_DICTIONARY):
					_load_dict_into(source[key], dest[key])
				else:
					dest[key] = source[key]


# Apply all the options specified to tester.  This is where the rubber meets
# the road.
func _apply_options(opts, gut):
	for entry in _deprecated_values.keys():
		if(opts.has(entry)):
			# Use gut.logger instead of our own for testing purposes.
			logger.deprecated(str('Config value "', entry, '" is deprecated.  ', _deprecated_values[entry]))

	gut.include_subdirectories = opts.include_subdirs

	if(opts.inner_class != ''):
		gut.inner_class_name = opts.inner_class
	gut.log_level = opts.log_level
	gut.ignore_pause_before_teardown = opts.ignore_pause

	gut.select_script(opts.selected)

	for i in range(opts.dirs.size()):
		gut.add_directory(opts.dirs[i], opts.prefix, opts.suffix)

	for i in range(opts.tests.size()):
		gut.add_script(opts.tests[i])

	# Sometimes it is the index, sometimes it's a string.  This sets it regardless
	gut.double_strategy = GutUtils.get_enum_value(
		opts.double_strategy, GutUtils.DOUBLE_STRATEGY,
		GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY)

	gut.unit_test_name = opts.unit_test_name
	gut.pre_run_script = opts.pre_run_script
	gut.post_run_script = opts.post_run_script
	gut.color_output = !opts.disable_colors
	gut.show_orphans(!opts.hide_orphans)
	gut.junit_xml_file = opts.junit_xml_file
	gut.junit_xml_timestamp = opts.junit_xml_timestamp
	gut.paint_after = str(opts.paint_after).to_float()
	gut.wait_log_delay = opts.wait_log_delay

	# These error_tracker options default to true.  Don't trust this comment.
	if(!opts.failure_error_types.has(FAIL_ERROR_TYPE_ENGINE)):
		gut.error_tracker.treat_engine_errors_as = GutUtils.TREAT_AS.NOTHING

	if(!opts.failure_error_types.has(FAIL_ERROR_TYPE_PUSH_ERROR)):
		gut.error_tracker.treat_push_error_as = GutUtils.TREAT_AS.NOTHING

	if(!opts.failure_error_types.has(FAIL_ERROR_TYPE_GUT)):
		gut.error_tracker.treat_gut_errors_as = GutUtils.TREAT_AS.NOTHING

	gut.error_tracker.register_loggers = !opts.no_error_tracking

	return gut


# --------------------------
# Public
# --------------------------
func write_options(path):
	var content = JSON.stringify(options, ' ')

	var f = FileAccess.open(path, FileAccess.WRITE)
	var result = FileAccess.get_open_error()
	if(f != null):
		f.store_string(content)
		f = null # closes file
	else:
		logger.error(str("Could not open file ", path, ' ', result))
	return result


# consistent name
func save_file(path):
	write_options(path)


func load_options(path):
	return _load_options_from_config_file(path, options)


# consistent name
func load_file(path):
	return load_options(path)


func load_options_no_defaults(path):
	options = _null_copy(default_options)
	return _load_options_from_config_file(path, options)


func apply_options(gut):
	_apply_options(options, gut)




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/gut_fonts.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# There was an error that someone found in Godot 4.4.1, but ended up being a
# different error in Godot 4.5.  The fix was to hold a reference to the font
# so that TextEdit control did not lose the font when switching.  This is
# the solution I came up with.  Just hold a reference to all fonts we use,
# but only when we use them.  Basically a lazy loader with some semantics for
# font names and location.
#
# https://github.com/bitwes/Gut/issues/749
#
# An instance of this could be used to allow users to specify their own fonts.
# It's not perect for that yet, but it is feasible.
# ------------------------------------------------------------------------------
const DEFAULT_CUSTOM_FONT_NAME = 'CourierPrime'
const THEME_FONT_TO_FONT_TYPES_MAP = {
	'font':FONT_TYPES.REGULAR,
	'normal_font': FONT_TYPES.REGULAR,
	'bold_font': FONT_TYPES.BOLD,
	'italics_font':FONT_TYPES.ITALIC,
	'bold_italics_font':FONT_TYPES.BOLD_ITALIC
}


# Values for FONT_TYPES are based on Google font file suffix (not extension).
# A font file will be a key from fonts + - + FONT_TYPE value + .ttf.
const FONT_TYPES = {
	REGULAR = 'Regular',
	BOLD = 'Bold',
	ITALIC = 'Italic',
	BOLD_ITALIC = 'BoldItalic'
}


var fonts = {
	'AnonymousPro':{},
	'CourierPrime':{},
	'LobsterTwo':{},
	'Default':{}
}


var custom_font_path = 'res://addons/gut/fonts/'


func _init():
	_populate_default_fonts()


func _populate_default_fonts():
	var ctrl = TextEdit.new()
	var f = ctrl.get_theme_font('font')
	for key in FONT_TYPES:
		fonts['Default'][FONT_TYPES[key]] = f
	ctrl.free()


func _load_font(font_name, font_type, font_path):
	var dynamic_font = FontFile.new()
	dynamic_font.load_dynamic_font(font_path)
	fonts[font_name][font_type] = dynamic_font


func get_font(font_name, font_type='Regular'):
	if(!fonts.has(font_name)):
		push_error(str("Invalid font name '", font_name, "'"))
		return fonts['Default'][FONT_TYPES.REGULAR]

	if(!FONT_TYPES.values().has(font_type)):
		push_error(str("Invalid font type '", font_type, "'"))
		return fonts['Default'][FONT_TYPES.REGULAR]

	if(!fonts[font_name].has(font_type)):
		var filename = custom_font_path.path_join(str(font_name, '-', font_type, '.ttf'))
		if(FileAccess.file_exists(filename)):
			_load_font(font_name, font_type, filename)
		else:
			push_error(str("Missing custom font ", filename))
			return fonts['Default'][FONT_TYPES.REGULAR]

	return fonts.get(font_name, {}).get(font_type, null)


func get_font_names():
	return fonts.keys()


# Maps the various theme font names (font, normal_font, italics_font etc) to
# a FONT_TYPE.
func get_font_for_theme_font_name(theme_font_name, custom_font_name):
	if(!THEME_FONT_TO_FONT_TYPES_MAP.has(theme_font_name)):
		push_error(str("Unknown theme font name ", theme_font_name))
		return get_font(custom_font_name)
	return get_font(custom_font_name, THEME_FONT_TO_FONT_TYPES_MAP[theme_font_name])



--------------------------------------------------
FILE: res:///addons/gut/gut_loader.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# This script should be loaded as soon as possible when running tests.  This
# will disable warnings and then load all scripts that are registered with the
# LazyLoader.
#
# Once you are ready to run tests, restore_ignore_addons should be called so
# that it has the expected value.  This should be done after whatever loaded
# this is done loading and doing setup stuff.
#
# This was created after a first attempt to suppress all GUT warnings did not
# work for the strictest warning settings.  This has turned the LazyLoader into
# just a Loader...so maybe all that should be reworked or renamed.  A problem
# for a time when we are absolutely sure that all warnings are being correctly
# suppressed I suppose.
#
# You can use the cli script test/resources/change_project_warnings.gd to
# quickly alter project warning levels for testing purposes.
# 	gdscript test/resources/change_project_warnings.gd --headless ++ -h
#
# You can set project warning settings from the command line with:
#	godot -s addons/gut/cli/change_project_warnings.gd ++ -h
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
const WARNING_PATH : String = 'debug/gdscript/warnings/'


static var were_addons_disabled : bool = true


@warning_ignore("unsafe_method_access")
@warning_ignore("unsafe_property_access")
@warning_ignore("untyped_declaration")
static func _static_init() -> void:
	were_addons_disabled = ProjectSettings.get(str(WARNING_PATH, 'exclude_addons'))
	ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), true)

	var WarningsManager = load('res://addons/gut/warnings_manager.gd')

	# Turn everything back on (if it originally was on) if the warnings manager
	# is disabled.  This makes sure we see all the warnings for all the scripts
	# in the LazyLoader (except WarningsManager, but that's not a big deal).
	#
	# With the warnings manager disabled and all_warn warnings:
	#	test_warnings_manager.gd 	-> 5471 errors
	#	full run 				 	-> 131,742 errors
	#
	# With the warnings manager disabled and gut_default warnings:
	#	test_warnings_manager.gd 	-> 46 errors
	#	full run 					-> 165 errors.
	if(WarningsManager.disabled):
		ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), were_addons_disabled)

	# Force a reference to utils.gd by path.  Using the class_name would cause
	# utils.gd to load when this script loads, before we could turn off the
	# warnings.
	var _utils : Object = load('res://addons/gut/utils.gd')

	# Since load_all exists on the LazyLoader, it should be done now so nothing
	# sneaks in later...This essentially defeats the "lazy" part of the
	# LazyLoader, but not the "loader" part of LazyLoader.
	_utils.LazyLoader.load_all()

	# Make sure that the values set in WarningsManager's static_init actually
	# reflect the project settings and not whatever we do here to make things
	# not warn.
	WarningsManager._project_warnings.exclude_addons = were_addons_disabled


# this can be called before tests are run to reinstate whatever exclude_addons
# was set to before this script disabled it.
static func restore_ignore_addons() -> void:
	ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), were_addons_disabled)




# ##############################################################################
# (G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/gut_loader_the_scene.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://jt6wsefn0x54"]

[sub_resource type="Resource" id="Resource_cayac"]
metadata/__load_path__ = "res://addons/gut/gut_loader_the_scene.gd"

[node name="Node" type="Node2D"]
script = SubResource("Resource_cayac")


--------------------------------------------------
FILE: res:///addons/gut/gut_menu.gd
--------------------------------------------------
var sub_menu : PopupMenu = null

var _menus = {
	# name : {
	# 	index,
	# 	id,
	# 	callback
	# }
}

signal about
signal rerun
signal run_all
signal run_at_cursor
signal run_inner_class
signal run_script
signal run_test
signal show_gut
signal toggle_windowed


func _init():
	sub_menu = PopupMenu.new()
	sub_menu.index_pressed.connect(_on_sub_menu_index_pressed)
	make_menu()


func _invalid_index():
	print("bad menu index")


func _on_sub_menu_index_pressed(index):
	var to_call : Callable = _invalid_index
	for key in _menus:
		if(_menus[key].index == index):
			to_call = _menus[key].callback

	to_call.call()


func add_menu(display_text, sig_to_emit, tooltip=''):
	var index = sub_menu.item_count
	_menus[sig_to_emit.get_name()] = {
		index = index,
		id = index,
		callback = sig_to_emit.emit
	}
	sub_menu.add_item(display_text, index)
	sub_menu.set_item_tooltip(index, tooltip)
	return index



func make_menu():
	add_menu("Toggle Windowed", toggle_windowed, 
		'Toggle GUT in the dock or a floating window')
	add_menu("Show/Hide GUT", show_gut, '')

	sub_menu.add_separator('Run')
	add_menu("Run All", run_all,
		"Run all tests")
	add_menu("Run Script", run_script,
		"Run the currently selected script")
	add_menu("Run Inner Class", run_inner_class,
		"Run the currently selected inner test class")
	add_menu("Run Test", run_test,
		"Run the currently selected test")
	add_menu("Run At Cursor", run_at_cursor,
		"Run the most specific of script/inner class/test based on cursor position")
	add_menu("Rerun", rerun, "Rerun the last test(s) ran", )

	sub_menu.add_separator()
	add_menu("About", about, 'All about GUT')


func set_shortcut(menu_name, accel_or_input_key):
	if(typeof(accel_or_input_key) == TYPE_INT):
		sub_menu.set_item_accelerator(_menus[menu_name].index, accel_or_input_key)
	elif(typeof(accel_or_input_key) == TYPE_OBJECT and accel_or_input_key is InputEventKey):
		sub_menu.set_item_accelerator(_menus[menu_name].index, accel_or_input_key.get_keycode_with_modifiers())


func disable_menu(menu_name, disabled):
	sub_menu.set_item_disabled(_menus[menu_name].index, disabled)


func apply_gut_shortcuts(shortcut_dialog):
	set_shortcut("show_gut",
		shortcut_dialog.scbtn_panel.get_input_event())
	set_shortcut("run_all",
		shortcut_dialog.scbtn_run_all.get_input_event())
	set_shortcut("run_script",
		shortcut_dialog.scbtn_run_current_script.get_input_event())
	set_shortcut("run_inner_class",
		shortcut_dialog.scbtn_run_current_inner.get_input_event())
	set_shortcut("run_test",
		shortcut_dialog.scbtn_run_current_test.get_input_event())
	set_shortcut("run_at_cursor",
		shortcut_dialog.scbtn_run_at_cursor.get_input_event())
	set_shortcut("rerun",
		shortcut_dialog.scbtn_rerun.get_input_event())
	set_shortcut("toggle_windowed",
		shortcut_dialog.scbtn_windowed.get_input_event())


--------------------------------------------------
FILE: res:///addons/gut/gut_plugin.gd
--------------------------------------------------
@tool
extends EditorPlugin

var VersionConversion = load("res://addons/gut/version_conversion.gd")
var MenuManager = load("res://addons/gut/gut_menu.gd")
var GutWindow = load("res://addons/gut/gui/GutEditorWindow.tscn")
var BottomPanelScene = preload('res://addons/gut/gui/GutBottomPanel.tscn')
var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

var _bottom_panel : Control = null
var _menu_mgr = null
var _gut_button = null
var _gut_window = null
var _dock_mode = 'none'


func _init():
	if(VersionConversion.error_if_not_all_classes_imported()):
		return


func _enter_tree():
	if(!_version_conversion()):
		return

	_bottom_panel = BottomPanelScene.instantiate()
	gut_as_panel()

	# ---------
	# I removed this delay because it was causing issues with the shortcut button.
	# The shortcut button wouldn't work right until load_shortcuts is called., but
	# the delay gave you 3 seconds to click it before they were loaded.  This
	# await came with the conversion to 4 and probably isn't needed anymore.
	# I'm leaving it here becuase I don't know why it showed up to begin with
	# and if it's needed, it will be pretty hard to debug without seeing this.
	#
	# This should be deleted after the next release or two if not needed.
	#
	# I added it back in when doing the window stuff.  Starting in a window
	# made it angry (don't remember how) until I added it back in.
	await get_tree().create_timer(1).timeout
	# ---

	_bottom_panel.set_interface(get_editor_interface())
	_bottom_panel.set_plugin(self)
	_bottom_panel.load_shortcuts()

	_menu_mgr = MenuManager.new()
	_bottom_panel._ctrls.run_at_cursor.menu_manager = _menu_mgr
	_bottom_panel.menu_manager = _menu_mgr
	add_tool_submenu_item("GUT", _menu_mgr.sub_menu)

	GutEditorGlobals.gut_plugin = self



func _version_conversion():
	var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")
	EditorGlobals.create_temp_directory()

	if(VersionConversion.error_if_not_all_classes_imported()):
		return false

	VersionConversion.convert()
	return true


func gut_as_window():
	if(_gut_window == null):
		_gut_window = GutWindow.instantiate()
		_gut_window.gut_plugin = self
		add_child(_gut_window)
		_gut_window.theme = get_tree().root.theme
		_gut_window.interface = get_editor_interface()

	_gut_window.add_gut_panel(_bottom_panel)
	_bottom_panel.make_floating_btn.visible = false
	_gut_button = null
	_dock_mode = 'window'


func gut_as_panel():
	_gut_button = add_control_to_bottom_panel(_bottom_panel, 'GUT')
	_bottom_panel.set_panel_button(_gut_button)
	_gut_button.shortcut_in_tooltip = true
	_dock_mode = 'panel'
	_bottom_panel._apply_shortcuts()
	_bottom_panel.results_horiz_layout()
	_bottom_panel.make_floating_btn.visible = true

	if(_gut_window != null):
		_gut_window.queue_free()
		_gut_window = null


func toggle_windowed():
	_deparent_bottom_panel()
	if(_dock_mode == 'window' or _dock_mode == 'none'):
		gut_as_panel()
	elif(_dock_mode == 'panel'):
		gut_as_window()
	_bottom_panel.show_me()


func _deparent_bottom_panel():
	if(_dock_mode == 'window'):
		_gut_window.remove_panel()
	elif(_dock_mode == 'panel'):
		remove_control_from_bottom_panel(_bottom_panel)



func _exit_tree():
	remove_tool_menu_item("GUT")
	_menu_mgr = null
	GutEditorGlobals.user_prefs.save_it()
	# Clean-up of the plugin goes here
	# Always remember to remove_at it from the engine when deactivated
	_deparent_bottom_panel()
	if(_gut_window != null):
		_gut_window.queue_free()

	_bottom_panel.menu_manager = null
	_bottom_panel.queue_free()

	remove_tool_menu_item("GUT") # made by _menu_mgr


func show_output_panel():
	if(_bottom_panel == null):
		return

	var panel = null
	var kids = _bottom_panel.get_parent().get_children()
	var idx = 0

	while(idx < kids.size() and panel == null):
		if(str(kids[idx]).contains("<EditorLog#")):
			panel = kids[idx]
		idx += 1

	if(panel != null):
		make_bottom_panel_item_visible(panel)

--------------------------------------------------
FILE: res:///addons/gut/gut_to_move.gd
--------------------------------------------------
# Temporary base script for gut.gd to hold the things to be remvoed and added
# to some utility somewhere.
extends Node

# ------------------------------------------------------------------------------
# deletes all files in a given directory
# ------------------------------------------------------------------------------
func directory_delete_files(path):
	var d = DirAccess.open(path)

	# SHORTCIRCUIT
	if(d == null):
		return

	# Traversing a directory is kinda odd.  You have to start the process of listing
	# the contents of a directory with list_dir_begin then use get_next until it
	# returns an empty string.  Then I guess you should end it.
	d.list_dir_begin() # TODOGODOT4 fill missing arguments https://github.com/godotengine/godot/pull/40547
	var thing = d.get_next() # could be a dir or a file or something else maybe?
	var full_path = ''
	while(thing != ''):
		full_path = path + "/" + thing
		# file_exists returns fasle for directories
		if(d.file_exists(full_path)):
			d.remove(full_path)
		thing = d.get_next()

	d.list_dir_end()

# ------------------------------------------------------------------------------
# deletes the file at the specified path
# ------------------------------------------------------------------------------
func file_delete(path):
	var d = DirAccess.open(path.get_base_dir())
	if(d != null):
		d.remove(path)

# ------------------------------------------------------------------------------
# Checks to see if the passed in file has any data in it.
# ------------------------------------------------------------------------------
func is_file_empty(path):
	var f = FileAccess.open(path, FileAccess.READ)
	var result = FileAccess.get_open_error()
	var empty = true
	if(result == OK):
		empty = f.get_length() == 0
	f = null
	return empty

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_file_as_text(path):
	return GutUtils.get_file_as_text(path)

# ------------------------------------------------------------------------------
# Creates an empty file at the specified path
# ------------------------------------------------------------------------------
func file_touch(path):
	FileAccess.open(path, FileAccess.WRITE)

# ------------------------------------------------------------------------------
# Simulate a number of frames by calling '_process' and '_physics_process' (if
# the methods exist) on an object and all of its descendents. The specified frame
# time, 'delta', will be passed to each simulated call.
#
# NOTE: Objects can disable their processing methods using 'set_process(false)' and
# 'set_physics_process(false)'. This is reflected in the 'Object' methods
# 'is_processing()' and 'is_physics_processing()', respectively. To make 'simulate'
# respect this status, for example if you are testing an object which toggles
# processing, pass 'check_is_processing' as 'true'.
# ------------------------------------------------------------------------------
func simulate(obj, times, delta, check_is_processing: bool = false):
	for _i in range(times):
		if (
			obj.has_method("_process")
			and (
				not check_is_processing
				or obj.is_processing()
			)
		):
			obj._process(delta)
		if(
			obj.has_method("_physics_process")
			and (
				not check_is_processing
				or obj.is_physics_processing()
			)
		):
			obj._physics_process(delta)

		for kid in obj.get_children():
			simulate(kid, 1, delta, check_is_processing)


--------------------------------------------------
FILE: res:///addons/gut/gut_tracked_error.gd
--------------------------------------------------
class_name GutTrackedError
## This contains all the information provided by Godot about an error.
## This is also used to represent a GUT error.  See [Logger] for
## additional information about properties.  Some properties are not populated
## for GUT errors.

## This will be an [code]Array[ScriptBacktrace][/code] for engine/push errors.
## This will the result of [code]get_stack[/code] for GUT errors.
var backtrace = []
## Usually the description
var code = GutUtils.NO_TEST
var rationale = GutUtils.NO_TEST
## [enum Logger.ErrorType] value or, for GUT errors, this will be [code skip-lint]GutUtils.GUT_ERROR_TYPE[/code].
var error_type = -1
var editor_notify = false

## The full path to the file where the error occurred.
var file = GutUtils.NO_TEST
## The function name in [member file] where the error occurred.
var function = GutUtils.NO_TEST
## The line number in [member file]
var line = -1

## Used by GUT to flag errors as being handled.  This is set by various asserts
## or can be set in a test.  When set to [code]true[/code] GUT will ignore it
## when determining if an unexpected error occurred during the execution of the
## test.  Setting this value prior to performing any of the error related
## asserts may have unexpected results.  It is recommended you either set this
## manually or use the error asserts.
var handled = false


## _to_string that is not _to_string.
func to_s() -> String:
	return str("CODE:", code, " TYPE:", error_type, " RATIONALE:", rationale, "\n",
		file, '->', function, '@', line, "\n",
		backtrace, "\n")


## Returns [code]true[/code] if the error is a push_error.
func is_push_error():
	return error_type != GutUtils.GUT_ERROR_TYPE and function == "push_error"


## Returns [code]true[/code] if the error is an engine error.  This includes
## all errors that pass through the [Logger] that do not originate from the
## [code]push_error[/code] function.
func is_engine_error():
	return error_type != GutUtils.GUT_ERROR_TYPE and !is_push_error()


## Returns [code]true[/code] if the error is a GUT error.  Some fields may not
## be populated for GUT errors.
func is_gut_error():
	return error_type == GutUtils.GUT_ERROR_TYPE


func contains_text(text):
	return code.to_lower().find(text.to_lower()) != -1 or \
		rationale.to_lower().find(text.to_lower()) != -1


## For display purposes only, the actual value returned may change over time.
## This returns a name for the error_type as far as this class is concerned.
## Use the various [code]is_[/code] methods to check if an error is a certain
## type.
func get_error_type_name():
	var to_return = "Unknown"

	if(is_gut_error()):
		to_return =  "GUT"
	elif(is_push_error()):
		to_return = "push_error"
	elif(is_engine_error()):
		to_return = str("engine-", error_type)

	return to_return


# this might not work in other languages, and feels falkey, but might be
# useful at some point.
# func is_assert():
# 	return error_type == Logger.ERROR_TYPE_SCRIPT and \
# 		(code.find("Assertion failed.") == 0 or \
# 			code.find("Assertion failed:") == 0)

--------------------------------------------------
FILE: res:///addons/gut/gut_vscode_debugger.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# Entry point for using the debugger through VSCode.  The gut-extension for
# VSCode launches this instead of gut_cmdln.gd when running tests through the
# debugger.
#
# This could become more complex overtime, but right now all we have to do is
# to make sure the console printer is enabled or you do not get any output.
# ------------------------------------------------------------------------------
extends 'res://addons/gut/gut_cmdln.gd'

func run_tests(runner):
	runner.get_gut().get_logger().disable_printer('console', false)
	runner.run_tests()


# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/hook_script.gd
--------------------------------------------------
class_name GutHookScript
## This script is the base for custom scripts to be used in pre and post
## run hooks.
##
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br][br]
## Creating a hook script requires that you:[br]
##  - Inherit [code skip-lint]GutHookScript[/code][br]
##  - Implement a [code skip-lint]run()[/code] method[br]
##  - Configure the path in GUT (gutconfig and/or editor) as the approparite hook (pre or post).[br]
##
## See [wiki]Hooks[/wiki]


## Class responsible for generating xml.  You could use this to generate XML
## yourself instead of using the built in GUT xml generation options.  See
## [addons/gut/junit_xml_export.gd]
var JunitXmlExport = load('res://addons/gut/junit_xml_export.gd')

## This is the instance of [GutMain] that is running the tests.  You can get
## information about the run from this object.  This is set by GUT when the
## script is instantiated.
var gut  = null

# the exit code to be used by gut_cmdln.  See set method.
var _exit_code = null

var _should_abort =  false

## Virtual method that will be called by GUT after instantiating this script.
## This is where you put all of your logic.
func run():
	gut.logger.error("Run method not overloaded.  Create a 'run()' method in your hook script to run your code.")


## Set the exit code when running from the command line.  If not set then the
## default exit code will be returned (0 when no tests fail, 1 when any tests
## fail).
func set_exit_code(code : int):
	_exit_code  = code

## Returns the exit code set with [code skip-lint]set_exit_code[/code]
func get_exit_code():
	return _exit_code

## Usable by pre-run script to cause the run to end AFTER the run() method
## finishes.  GUT will quit and post-run script will not be ran.
func abort():
	_should_abort = true

## Returns if [code skip-lint]abort[/code] was called.
func should_abort():
	return _should_abort


--------------------------------------------------
FILE: res:///addons/gut/inner_class_registry.gd
--------------------------------------------------
var _registry = {}


func _create_reg_entry(base_path, subpath):
	var to_return = {
		"base_path":base_path,
		"subpath":subpath,
		"base_resource":load(base_path),
		"full_path":str("'", base_path, "'", subpath)
	}
	return to_return

func _register_inners(base_path, obj, prev_inner = ''):
	var const_map = obj.get_script_constant_map()
	var consts = const_map.keys()
	var const_idx = 0

	while(const_idx < consts.size()):
		var key = consts[const_idx]
		var thing = const_map[key]

		if(typeof(thing) == TYPE_OBJECT and thing.resource_path == ''):
			var cur_inner = str(prev_inner, ".", key)
			_registry[thing] = _create_reg_entry(base_path, cur_inner)
			_register_inners(base_path, thing, cur_inner)

		const_idx += 1


func register(base_script):
	var base_path = base_script.resource_path
	_register_inners(base_path, base_script)


func get_extends_path(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].full_path
	else:
		return null

# returns the subpath for the inner class.  This includes the leading "." in
# the path.
func get_subpath(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].subpath
	else:
		return ''

func get_base_path(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].base_path


func has(inner_class):
	return _registry.has(inner_class)


func get_base_resource(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].base_resource


func to_s():
	var text = ""
	for key in _registry:
		text += str(key, ": ", _registry[key], "\n")
	return text


--------------------------------------------------
FILE: res:///addons/gut/input_factory.gd
--------------------------------------------------
class_name GutInputFactory
## Static class full of helper methods to make InputEvent instances.
##
## This thing makes InputEvents.  Enjoy.

# Implemented InputEvent* convenience methods
# 	InputEventAction
# 	InputEventKey
# 	InputEventMouseButton
# 	InputEventMouseMotion

# Yet to implement InputEvents
# 	InputEventJoypadButton
# 	InputEventJoypadMotion
# 	InputEventMagnifyGesture
# 	InputEventMIDI
# 	InputEventPanGesture
# 	InputEventScreenDrag
# 	InputEventScreenTouch


static func _to_scancode(which):
	var key_code = which
	if(typeof(key_code) == TYPE_STRING):
		key_code = key_code.to_upper().to_ascii_buffer()[0]
	return key_code


## Creates a new button with the given propoerties.
static func new_mouse_button_event(position, global_position, pressed, button_index) -> InputEventMouseButton:
	var event = InputEventMouseButton.new()
	event.position = position
	if(global_position != null):
		event.global_position = global_position
	event.pressed = pressed
	event.button_index = button_index

	return event


## Returns an [InputEventKey] event with [code]pressed = false[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
static func key_up(which) -> InputEventKey:
	var event = InputEventKey.new()
	event.keycode = _to_scancode(which)
	event.pressed = false
	return event


## Returns an [InputEventKey] event with [code]pressed = true[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
static func key_down(which) -> InputEventKey:
	var event = InputEventKey.new()
	event.keycode = _to_scancode(which)
	event.pressed = true
	return event


## Returns an "action up" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
static func action_up(which, strength=1.0) -> InputEventAction:
	var event  = InputEventAction.new()
	event.action = which
	event.strength = strength
	return event


## Returns an "action down" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
static func action_down(which, strength=1.0) -> InputEventAction:
	var event  = InputEventAction.new()
	event.action = which
	event.strength = strength
	event.pressed = true
	return event


## Returns a "button down" [InputEventMouseButton] for the left mouse button.
static func mouse_left_button_down(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, true, MOUSE_BUTTON_LEFT)
	return event


## Returns a "button up" [InputEventMouseButton] for the left mouse button.
static func mouse_left_button_up(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_LEFT)
	return event


## Returns a "double click" [InputEventMouseButton] for the left mouse button.
static func mouse_double_click(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_LEFT)
	event.double_click = true
	return event


## Returns a "button down" [InputEventMouseButton] for the right mouse button.
static func mouse_right_button_down(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, true, MOUSE_BUTTON_RIGHT)
	return event


## Returns a "button up" [InputEventMouseButton] for the right mouse button.
static func mouse_right_button_up(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_RIGHT)
	return event


## Returns a [InputEventMouseMotion] to move the mouse the specified positions.
static func mouse_motion(position, global_position=null) -> InputEventMouseMotion:
	var event = InputEventMouseMotion.new()
	event.position = position
	if(global_position != null):
		event.global_position = global_position
	return event


## Returns an [InputEventMouseMotion] that moves the mouse [param offset]
## from the last [method mouse_motion] or [method mouse_motion] call.
static func mouse_relative_motion(offset, last_motion_event=null, speed=Vector2(0, 0)) -> InputEventMouseMotion:
	var event = null
	if(last_motion_event == null):
		event = mouse_motion(offset)
		event.velocity = speed
	else:
		event = last_motion_event.duplicate()
		event.position += offset
		event.global_position += offset
		event.relative = offset
		event.velocity = speed
	return event

# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Description
# -----------
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/input_sender.gd
--------------------------------------------------
class_name GutInputSender
## The GutInputSender class.  It sends input to places.
##
## [br][br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url][br]
## See [wiki]Mocking-Input[/wiki] for examples.
## [br][br]
## This class can be used to send [code]InputEvent*[/code] events to various
## objects.  It also allows you to script out a series of inputs and play
## them back in real time.  You could use it to:[br]
##  - Verify that jump height depends on how long the jump button is pressed.[br]
##  - Double tap a direction performs a dash.[br]
##  - Down, Down-Forward, Forward + punch throws a fireball.[br]
## [br][br]
## And much much more.
## [br][br]
## As of 9.3.1 you can use [code skip-lint]GutInputSender[/code] instead of [code]InputSender[/code].  It's the same thing, but [code skip-lint]GutInputSender[/code] is a [code]class_name[/code] so you may have less warnings and auto-complete will work.
## [br][br]
## [b]Warning[/b][br]
## If you move the Godot window to a different monitor while tests are running it can cause input tests to fail.  [url=https://github.com/bitwes/Gut/issues/643]This issue[/url] has more details.



# Implemented InputEvent* convenience methods
# 	InputEventAction
# 	InputEventKey
# 	InputEventMouseButton
#	InputEventMouseMotion

# Yet to implement InputEvents
# 	InputEventJoypadButton
# 	InputEventJoypadMotion
# 	InputEventMagnifyGesture
# 	InputEventMIDI
# 	InputEventPanGesture
# 	InputEventScreenDrag
# 	InputEventScreenTouch



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class InputQueueItem:
	extends Node

	var events = []
	var time_delay = null
	var frame_delay = null
	var _waited_frames = 0
	var _is_ready = false
	var _delay_started = false

	signal event_ready

	# TODO should this be done in _physics_process instead or should it be
	# configurable?
	func _physics_process(delta):
		if(frame_delay > 0 and _delay_started):
			_waited_frames += 1
			if(_waited_frames >= frame_delay):
				event_ready.emit()

	func _init(t_delay,f_delay):
		time_delay = t_delay
		frame_delay = f_delay
		_is_ready = time_delay == 0 and frame_delay == 0

	func _on_time_timeout():
		_is_ready = true
		event_ready.emit()

	func _delay_timer(t):
		return Engine.get_main_loop().root.get_tree().create_timer(t)

	func is_ready():
		return _is_ready

	func start():
		_delay_started = true
		if(time_delay > 0):
			var t = _delay_timer(time_delay)
			t.connect("timeout",Callable(self,"_on_time_timeout"))




# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class MouseDraw:
	extends Node2D

	var down_color = Color(1, 1, 1, .25)
	var up_color = Color(0, 0, 0, .25)
	var line_color = Color(1, 0, 0)
	var disabled = true :
		get : return disabled
		set(val) :
			disabled = val
			queue_redraw()

	var _draw_at = Vector2(0, 0)
	var _b1_down = false
	var _b2_down = false


	func draw_event(event):
		if(event is InputEventMouse):
			_draw_at = event.position
			if(event is InputEventMouseButton):
				if(event.button_index == MOUSE_BUTTON_LEFT):
					_b1_down = event.pressed
				elif(event.button_index == MOUSE_BUTTON_RIGHT):
					_b2_down = event.pressed
		queue_redraw()


	func _draw_cicled_cursor():
		var r = 10
		var b1_color = up_color
		var b2_color = up_color

		if(_b1_down):
			var pos = _draw_at - (Vector2(r * 1.5, 0))
			draw_arc(pos, r / 2, 0, 360, 180, b1_color)

		if(_b2_down):
			var pos = _draw_at + (Vector2(r * 1.5, 0))
			draw_arc(pos, r / 2, 0, 360, 180, b2_color)

		draw_arc(_draw_at, r, 0, 360, 360, line_color, 1)
		draw_line(_draw_at - Vector2(0, r), _draw_at + Vector2(0, r), line_color)
		draw_line(_draw_at - Vector2(r, 0), _draw_at + Vector2(r, 0), line_color)


	func _draw_square_cursor():
		var r = 10
		var b1_color = up_color
		var b2_color = up_color

		if(_b1_down):
			b1_color = down_color

		if(_b2_down):
			b2_color = down_color

		var blen = r * .75
		# left button rectangle
		draw_rect(Rect2(_draw_at - Vector2(blen, blen), Vector2(blen, blen * 2)), b1_color)
		# right button rectrangle
		draw_rect(Rect2(_draw_at - Vector2(0, blen), Vector2(blen, blen * 2)), b2_color)
		# Crosshair
		draw_line(_draw_at - Vector2(0, r), _draw_at + Vector2(0, r), line_color)
		draw_line(_draw_at - Vector2(r, 0), _draw_at + Vector2(r, 0), line_color)


	func _draw():
		if(disabled):
			return
		_draw_square_cursor()







# ##############################################################################
#
# ##############################################################################
## Local reference to the GutInputFactory static class
const INPUT_WARN = 'If using Input as a reciever it will not respond to *_down events until a *_up event is recieved.  Call the appropriate *_up event or use hold_for(...) to automatically release after some duration.'

var _lgr = GutUtils.get_logger()
var _receivers = []
var _input_queue = []
var _next_queue_item = null

# used by hold_for and echo.
var _last_event = null
# indexed by keycode, each entry contains a boolean value indicating the
# last emitted "pressed" value for that keycode.
var _pressed_keys = {}
var _pressed_actions = {}
var _pressed_mouse_buttons = {}

var _auto_flush_input = false
var _tree_items_parent = null
var _mouse_draw = null;

var _default_mouse_position = {
	position = Vector2(0, 0),
	global_position = Vector2(0, 0)
}

var _last_mouse_position = {
}

## Warp mouse when sending InputEventMouse* events
var mouse_warp = false
## Draw mouse position cross hairs.  Useful to see where the mouse is at
## when not using [member mouse_warp]
var draw_mouse = true

## Emitted when all events in the input queue have been sent.
signal idle


## Accepts a single optional receiver.
func _init(r=null):
	if(r != null):
		add_receiver(r)

	_last_mouse_position = _default_mouse_position.duplicate()
	_tree_items_parent = Node.new()
	Engine.get_main_loop().root.add_child(_tree_items_parent)

	_mouse_draw = MouseDraw.new()
	_tree_items_parent.add_child(_mouse_draw)
	_mouse_draw.disabled = false


func _notification(what):
	if(what == NOTIFICATION_PREDELETE):
		if(is_instance_valid(_tree_items_parent)):
			_tree_items_parent.queue_free()


func _add_queue_item(item):
	item.connect("event_ready", _on_queue_item_ready.bind(item))
	_next_queue_item = item
	_input_queue.append(item)
	_tree_items_parent.add_child(item)
	if(_input_queue.size() == 1):
		item.start()


func _handle_pressed_keys(event):
	if(event is InputEventKey):
		if((event.pressed and !event.echo) and is_key_pressed(event.keycode)):
			_lgr.warn(str("InputSender:  key_down called for ", event.as_text(), " when that key is already pressed.  ", INPUT_WARN))
		_pressed_keys[event.keycode] = event.pressed
	elif(event is InputEventAction):
		if(event.pressed and is_action_pressed(event.action)):
			_lgr.warn(str("InputSender:  action_down called for ", event.action, " when that action is already pressed.  ", INPUT_WARN))
		_pressed_actions[event.action] = event.pressed
	elif(event is InputEventMouseButton):
		if(event.pressed and is_mouse_button_pressed(event.button_index)):
			_lgr.warn(str("InputSender:  mouse_button_down called for ", event.button_index, " when that mouse button is already pressed.  ", INPUT_WARN))
		_pressed_mouse_buttons[event.button_index] = event


func _handle_mouse_position(event):
	if(event is InputEventMouse):
		_mouse_draw.disabled = !draw_mouse
		_mouse_draw.draw_event(event)
		if(mouse_warp):
			DisplayServer.warp_mouse(event.position)


func _send_event(event):
	_handle_mouse_position(event)
	_handle_pressed_keys(event)

	for r in _receivers:
		if(r == Input):
			Input.parse_input_event(event)
			if(event is InputEventAction):
				if(event.pressed):
					Input.action_press(event.action)
				else:
					Input.action_release(event.action)
			if(_auto_flush_input):
				Input.flush_buffered_events()
		else:
			if(r.has_method(&"_input")):
				r._input(event)

			if(r.has_signal(&"gui_input")):
				r.gui_input.emit(event)

			if(r.has_method(&"_gui_input")):
				r._gui_input(event)

			if(r.has_method(&"_unhandled_input")):
				r._unhandled_input(event)


func _send_or_record_event(event):
	_last_event = event
	if(_next_queue_item != null):
		_next_queue_item.events.append(event)
	else:
		_send_event(event)


func _set_last_mouse_positions(event : InputEventMouse):
	_last_mouse_position.position = event.position
	_last_mouse_position.global_position = event.global_position


func _apply_last_position_and_set_last_position(event, position, global_position):
	event.position = GutUtils.nvl(position, _last_mouse_position.position)
	event.global_position = GutUtils.nvl(
		global_position, _last_mouse_position.global_position)
	_set_last_mouse_positions(event)


func _new_defaulted_mouse_button_event(position, global_position):
	var event = InputEventMouseButton.new()
	_apply_last_position_and_set_last_position(event, position, global_position)
	return event


func _new_defaulted_mouse_motion_event(position, global_position):
	var event = InputEventMouseMotion.new()
	_apply_last_position_and_set_last_position(event, position, global_position)
	for key in _pressed_mouse_buttons:
		if(_pressed_mouse_buttons[key].pressed):
			event.button_mask += key
	return event


# ------------------------------
# Events
# ------------------------------
func _on_queue_item_ready(item):
	for event in item.events:
		_send_event(event)

	var done_event = _input_queue.pop_front()
	done_event.queue_free()

	if(_input_queue.size() == 0):
		_next_queue_item = null
		idle.emit()
	else:
		_input_queue[0].start()


# ------------------------------
# Public
# ------------------------------


## Add an object to receive input events.
func add_receiver(obj):
	_receivers.append(obj)


## Returns the receivers that have been added.
func get_receivers():
	return _receivers


## Returns true if the input queue has items to be processed, false if not.
func is_idle():
	return _input_queue.size() == 0

func is_key_pressed(which):
	var event = GutInputFactory.key_up(which)
	return _pressed_keys.has(event.keycode) and _pressed_keys[event.keycode]

func is_action_pressed(which):
	return _pressed_actions.has(which) and _pressed_actions[which]

func is_mouse_button_pressed(which):
	return _pressed_mouse_buttons.has(which) and _pressed_mouse_buttons[which].pressed


## Get the value of [method set_auto_flush_input].
func get_auto_flush_input():
	return _auto_flush_input


## Enable/Disable auto flushing of input.  When enabled the [GutInputSender]
## will call [code]Input.flush_buffered_events[/code] after each event is sent.
## See the "use_accumulated_input" section in [wiki]Mocking-Input[/wiki] for more
## information.
func set_auto_flush_input(val):
	_auto_flush_input = val


## Adds a delay between the last input queue item added and any queue item added
## next.  By default this will wait [param t] seconds.  You can specify a
## number of frames to wait by passing a string composed of a number and "f".
## For example [code]wait("5f")[/code] will wait 5 frames.
func wait(t):
	if(typeof(t) == TYPE_STRING):
		var suffix = t.substr(t.length() -1, 1)
		var val = t.rstrip('s').rstrip('f').to_float()

		if(suffix.to_lower() == 's'):
			wait_secs(val)
		elif(suffix.to_lower() == 'f'):
			wait_frames(val)
	else:
		wait_secs(t)

	return self


## Clears the input queue and any state such as the last event sent and any
## pressed actions/buttons.  Does not clear the list of receivers.
## [br][br]
## This should be done between each test when the [GutInputSender] is a class
## level variable so that state does not leak between tests.
func clear():
	_last_event = null
	_next_queue_item = null

	for item in _input_queue:
		item.free()
	_input_queue.clear()

	_pressed_keys.clear()
	_pressed_actions.clear()
	_pressed_mouse_buttons.clear()
	_last_mouse_position = _default_mouse_position.duplicate()


# ------------------------------
# Event methods
# ------------------------------

## Sends a [InputEventKey] event with [code]pressed = false[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
func key_up(which):
	var event = GutInputFactory.key_up(which)
	_send_or_record_event(event)
	return self


## Sends a [InputEventKey] event with [code]pressed = true[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
func key_down(which):
	var event = GutInputFactory.key_down(which)
	_send_or_record_event(event)
	return self


## Sends an echo [InputEventKey] event of the last key event.
func key_echo():
	if(_last_event != null and _last_event is InputEventKey):
		var new_key = _last_event.duplicate()
		new_key.echo = true
		_send_or_record_event(new_key)
	return self


## Sends a "action up" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
func action_up(which, strength=1.0):
	var event  = GutInputFactory.action_up(which, strength)
	_send_or_record_event(event)
	return self


## Sends a "action down" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
func action_down(which, strength=1.0):
	var event  = GutInputFactory.action_down(which, strength)
	_send_or_record_event(event)
	return self


## Sends a "button down" [InputEventMouseButton] for the left mouse button.
func mouse_left_button_down(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = true
	event.button_index = MOUSE_BUTTON_LEFT
	_send_or_record_event(event)
	return self


## Sends a "button up" [InputEventMouseButton] for the left mouse button.
func mouse_left_button_up(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = false
	event.button_index = MOUSE_BUTTON_LEFT
	_send_or_record_event(event)
	return self


## Sends a "double click" [InputEventMouseButton] for the left mouse button.
func mouse_double_click(position=null, global_position=null):
	var event = GutInputFactory.mouse_double_click(position, global_position)
	event.double_click = true
	_send_or_record_event(event)
	return self


## Sends a "button down" [InputEventMouseButton] for the right mouse button.
func mouse_right_button_down(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = true
	event.button_index = MOUSE_BUTTON_RIGHT
	_send_or_record_event(event)
	return self


## Sends a "button up" [InputEventMouseButton] for the right mouse button.
func mouse_right_button_up(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = false
	event.button_index = MOUSE_BUTTON_RIGHT
	_send_or_record_event(event)
	return self


## Sends a [InputEventMouseMotion] to move the mouse the specified positions.
func mouse_motion(position, global_position=null):
	var event = _new_defaulted_mouse_motion_event(position, global_position)
	_send_or_record_event(event)
	return self


## Sends a [InputEventMouseMotion] that moves the mouse [param offset]
## from the last [method mouse_motion] or [method mouse_set_position] call.
func mouse_relative_motion(offset, speed=Vector2(0, 0)):
	var last_event = _new_defaulted_mouse_motion_event(null, null)
	var event = GutInputFactory.mouse_relative_motion(offset, last_event, speed)
	_set_last_mouse_positions(event)
	_send_or_record_event(event)
	return self


## Sets the mouse's position.  This does not send an event.  This position will
## be used for the next call to [method mouse_relative_motion].
func mouse_set_position(position, global_position=null):
	var event = _new_defaulted_mouse_motion_event(position, global_position)
	return self


## Performs a left click at the given position.
func mouse_left_click_at(where, duration = '5f'):
	wait_frames(1)
	mouse_left_button_down(where)
	hold_for(duration)
	wait_frames(10)
	return self


## Create your own event and use this to send it to all receivers.
func send_event(event):
	_send_or_record_event(event)
	return self


## Releases all [InputEventKey], [InputEventAction], and [InputEventMouseButton]
## events that have passed through this instance.  These events could have been
## generated via the various [code]_down[/code] methods or passed to
## [method send_event].
## [br][br]
## This will send the "release" event ([code]pressed = false[/code]) to all
## receivers.  This should be done between each test when using `Input` as a
## receiver.
func release_all():
	for key in _pressed_keys:
		if(_pressed_keys[key]):
			_send_event(GutInputFactory.key_up(key))
	_pressed_keys.clear()

	for key in _pressed_actions:
		if(_pressed_actions[key]):
			_send_event(GutInputFactory.action_up(key))
	_pressed_actions.clear()

	for key in _pressed_mouse_buttons:
		var event = _pressed_mouse_buttons[key].duplicate()
		if(event.pressed):
			event.pressed = false
			_send_event(event)
	_pressed_mouse_buttons.clear()

	return self

## Same as [method wait] but only accepts a number of frames to wait.
func wait_frames(num_frames):
	var item = InputQueueItem.new(0, num_frames)
	_add_queue_item(item)
	return self


## Same as [method wait] but only accepts a number of seconds to wait.
func wait_secs(num_secs):
	var item = InputQueueItem.new(num_secs, 0)
	_add_queue_item(item)
	return self


## This is a special [method wait] that will emit the previous input queue item
## with [code]pressed = false[/code] after a delay.  If you pass a number then
## it will wait that many seconds.  You can also use the `"4f"` format to wait
## a specific number of frames.
## [br][br]
## For example [code]sender.action_down('jump').hold_for("10f")[/code] will
## cause two [InputEventAction] instances to be sent.  The "jump-down" event
## from [method action_down] and then a "jump-up" event after 10 frames.
func hold_for(duration):
	if(_last_event != null and _last_event.pressed):
		var next_event = _last_event.duplicate()
		next_event.pressed = false

		wait(duration)
		send_event(next_event)
	return self


## Same as [method hold_for] but specifically holds for a number of physics
## frames.
func hold_frames(duration:int):
	return hold_for(str(duration, 'f'))


## Same as [method hold_for] but specifically holds for a number of seconds.
func hold_seconds(duration:float):
	return hold_for(duration)


# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Description
# -----------
# This class sends input to one or more recievers.  The receivers' _input,
# _unhandled_input, and _gui_input are called sending InputEvent* events.
# InputEvents can be sent via the helper methods or a custom made InputEvent
# can be sent via send_event(...)
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/junit_xml_export.gd
--------------------------------------------------
## Creates an export of a test run in the JUnit XML format.
##
## More words needed?

var _exporter = GutUtils.ResultExporter.new()

## @ignore should be private I think
func indent(s, ind):
	var to_return = ind + s
	to_return = to_return.replace("\n", "\n" + ind)
	return to_return

# Wraps content in CDATA section because it may contain special characters
# e.g. str(null) becomes <null> and can break XML parsing.
func wrap_cdata(content):
	return "<![CDATA[" + str(content) + "]]>"

## @ignore should be private I think
func add_attr(name, value):
	return str(name, '="', value, '" ')


func _export_test_result(test):
	var to_return = ''

	# Right now the pending and failure messages won't fit in the message
	# attribute because they can span multiple lines and need to be escaped.
	if(test.status == 'pending'):
		var skip_tag = str("<skipped message=\"pending\">", wrap_cdata(test.pending[0]), "</skipped>")
		to_return += skip_tag
	elif(test.status == 'fail'):
		var fail_tag = str("<failure message=\"failed\">", wrap_cdata(test.failing[0]), "</failure>")
		to_return += fail_tag

	return to_return


func _export_tests(script_result, classname):
	var to_return = ""

	for key in script_result.keys():
		var test = script_result[key]
		var assert_count = test.passing.size() + test.failing.size()
		to_return += "<testcase "
		to_return += add_attr("name", key)
		to_return += add_attr("assertions", assert_count)
		to_return += add_attr("status", test.status)
		to_return += add_attr("classname", classname.replace("res://", ""))
		to_return += add_attr("time", test.time_taken)
		to_return += ">\n"

		to_return += _export_test_result(test)

		to_return += "</testcase>\n"

	return to_return


func _sum_test_time(script_result, classname)->float:
	var to_return := 0.0

	for key in script_result.keys():
		var test = script_result[key]
		to_return += test.time_taken

	return to_return


func _export_scripts(exp_results):
	var to_return = ""
	for key in exp_results.test_scripts.scripts.keys():
		var s = exp_results.test_scripts.scripts[key]
		to_return += "<testsuite "
		to_return += add_attr("name", key.replace("res://", ""))
		to_return += add_attr("tests", s.props.tests)
		to_return += add_attr("failures", s.props.failures)
		to_return += add_attr("skipped", s.props.pending)
		to_return += add_attr("time", _sum_test_time(s.tests, key) )
		to_return += ">\n"

		to_return += indent(_export_tests(s.tests, key), "    ")

		to_return += "</testsuite>\n"

	return to_return


## Takes in an instance of GutMain and returns a string of XML representing the
## results of the run.
func get_results_xml(gut):
	var exp_results = _exporter.get_results_dictionary(gut)
	var to_return = '<?xml version="1.0" encoding="UTF-8"?>' + "\n"
	to_return += '<testsuites '
	to_return += add_attr("name", 'GutTests')
	to_return += add_attr("failures", exp_results.test_scripts.props.failures)
	to_return += add_attr('tests', exp_results.test_scripts.props.tests)
	to_return += ">\n"

	to_return += indent(_export_scripts(exp_results), "  ")

	to_return += '</testsuites>'
	return to_return


## Takes in an instance of GutMain and writes the XML file to the specified
## path
func write_file(gut, path):
	var xml = get_results_xml(gut)

	var f_result = GutUtils.write_file(path, xml)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result



--------------------------------------------------
FILE: res:///addons/gut/lazy_loader.gd
--------------------------------------------------
@tool
# ------------------------------------------------------------------------------
# Static
# ------------------------------------------------------------------------------
static var usage_counter = load('res://addons/gut/thing_counter.gd').new()
static var WarningsManager = load('res://addons/gut/warnings_manager.gd')

static func load_all():
	for key in usage_counter.things:
		key.get_loaded()


static func print_usage():
	for key in usage_counter.things:
		print(key._path, '  (', usage_counter.things[key], ')')


static func clear():
	usage_counter.things.clear()

# ------------------------------------------------------------------------------
# Class
# ------------------------------------------------------------------------------
var _loaded = null
var _path = null

func _init(path):
	_path = path
	usage_counter.add_thing_to_count(self)


func get_loaded():
	if(_loaded == null):
		_loaded = WarningsManager.load_script_ignoring_all_warnings(_path)
	usage_counter.add(self)
	return _loaded





--------------------------------------------------
FILE: res:///addons/gut/logger.gd
--------------------------------------------------
var types = {
	debug = 'debug',
	deprecated = 'deprecated',
	expected_error = 'expected_error',
	error = 'error',
	failed = 'failed',
	info = 'info',
	normal = 'normal',
	orphan = 'orphan',
	passed = 'passed',
	pending = 'pending',
	risky = 'risky',
	warn = 'warn',
}

var fmts = {
	red = 'red',
	yellow = 'yellow',
	green = 'green',
	blue = 'blue',

	bold = 'bold',
	underline = 'underline',

	none = null
}

var _type_data = {
	types.debug:		{disp='DEBUG', 		enabled=true, fmt=fmts.bold},
	types.deprecated:	{disp='DEPRECATED', enabled=true, fmt=fmts.none},
	types.error:		{disp='ERROR', 		enabled=true, fmt=fmts.red},
	types.expected_error:	{disp="ExpectedError", enabled=true, fmt=fmts.blue},
	types.failed:		{disp='Failed', 	enabled=true, fmt=fmts.red},
	types.info:			{disp='INFO', 		enabled=true, fmt=fmts.bold},
	types.normal:		{disp='NORMAL', 	enabled=true, fmt=fmts.none},
	types.orphan:		{disp='Orphans',	enabled=true, fmt=fmts.yellow},
	types.passed:		{disp='Passed', 	enabled=true, fmt=fmts.green},
	types.pending:		{disp='Pending',	enabled=true, fmt=fmts.yellow},
	types.risky:		{disp='Risky',		enabled=true, fmt=fmts.yellow},
	types.warn:			{disp='WARNING', 	enabled=true, fmt=fmts.yellow},
}

var _logs = {
	types.warn: [],
	types.error: [],
	types.info: [],
	types.debug: [],
	types.deprecated: [],
	types.expected_error: [],
	types.failed: [],
}

var _printers = {
	terminal = null,
	gui = null,
	console = null
}

var _gut = null
var _indent_level = 0
var _min_indent_level = 0
var _indent_string = '    '
var _less_test_names = false
var _yield_calls = 0
var _last_yield_text = ''




func _init():
	_printers.terminal = GutUtils.Printers.TerminalPrinter.new()
	_printers.console = GutUtils.Printers.ConsolePrinter.new()
	# There were some problems in the timing of disabling this at the right
	# time in gut_cmdln so it is disabled by default.  This is enabled
	# by plugin_control.gd based on settings.
	_printers.console.set_disabled(true)


func _indent_text(text):
	var to_return = text
	var ending_newline = ''

	if(text.ends_with("\n")):
		ending_newline = "\n"
		to_return = to_return.left(to_return.length() -1)

	var pad = get_indent()
	to_return = to_return.replace("\n", "\n" + pad)
	to_return += ending_newline

	return pad + to_return


func _should_print_to_printer(key_name):
	return _printers[key_name] != null and !_printers[key_name].get_disabled()


func _print_test_name():
	if(_gut == null):
		return

	var cur_test = _gut.get_current_test_object()
	if(cur_test == null):
		return false

	if(!cur_test.has_printed_name):
		var param_text = ''
		if(cur_test.arg_count > 0):
			# Just an FYI, parameter_handler in gut might not be set yet so can't
			# use it here for cooler output.
			param_text = '<parameterized>'
		_output(str('* ', cur_test.name, param_text, "\n"))
		cur_test.has_printed_name = true


func _output(text, fmt=null):
	for key in _printers:
		if(_should_print_to_printer(key)):
			_printers[key].send(text, fmt)


func _log(text, fmt=fmts.none):
	_print_test_name()
	var indented = _indent_text(text)
	_output(indented, fmt)

# ---------------
# Get Methods
# ---------------
func get_warnings():
	return get_log_entries(types.warn)


func get_errors():
	return get_log_entries(types.error)


func get_infos():
	return get_log_entries(types.info)


func get_debugs():
	return get_log_entries(types.debug)


func get_deprecated():
	return get_log_entries(types.deprecated)


func get_count(log_type=null):
	var count = 0
	if(log_type == null):
		for key in _logs:
			count += _logs[key].size()
	else:
		count = _logs[log_type].size()
	return count


func get_log_entries(log_type):
	return _logs[log_type]


func get_indent():
	var pad = ''
	for i in range(_indent_level):
		pad += _indent_string

	return pad


# ---------------
# Log methods
# ---------------
func _output_type(type, text):
	var td = _type_data[type]
	if(!td.enabled):
		# if(_logs.has(type)):
		# 	_logs[type].append(text)
		return

	_print_test_name()
	if(type != types.normal):
		if(_logs.has(type)):
			_logs[type].append(text)

		var start = str('[', td.disp, ']')
		if(text != null and text != ''):
			start += ':  '
		else:
			start += ' '
		var indented_start = _indent_text(start)
		var indented_end = _indent_text(text)
		indented_end = indented_end.lstrip(_indent_string)
		_output(indented_start, td.fmt)
		_output(indented_end + "\n")


func _output_type_no_indent(type, text):
	var td = _type_data[type]
	if(!td.enabled):
		# if(_logs.has(type)):
		# 	_logs[type].append(text)
		return

	_print_test_name()
	if(type != types.normal):
		if(_logs.has(type)):
			_logs[type].append(text)

		var start = str('[', td.disp, ']')
		_output(start, td.fmt)
		_output(text + "\n")


func debug(text):
	_output_type(types.debug, text)


# supply some text or the name of the deprecated method and the replacement.
func deprecated(text, alt_method=null):
	var msg = text
	if(alt_method):
		msg = str('The method ', text, ' is deprecated, use ', alt_method , ' instead.')
	return _output_type(types.deprecated, msg)


func error(text):
	_output_type(types.error, text)
	# Use the _gut one instead of GutUtils.get_error_tracker() for testing
	# purposes.  This probably means this should have its own reference but
	# that seems too difficult now.
	if(_gut != null):
		_gut.error_tracker.add_gut_error(text)


func expected_error(text):
	_output_type_no_indent(types.expected_error, text)


func failed(text):
	_output_type(types.failed, text)


func info(text):
	_output_type(types.info, text)


func orphan(text):
	var td = _type_data["orphan"]
	if(!td.enabled):
		return
	_output(_indent_text(text), td.fmt)
	_output("\n")
	# _output_type(types.orphan, text)


func passed(text):
	_output_type(types.passed, text)


func pending(text):
	_output_type(types.pending, text)


func risky(text):
	_output_type(types.risky, text)


func warn(text):
	_output_type(types.warn, text)


func log(text='', fmt=fmts.none):
	if(text == ''):
		_output("\n")
	else:
		_log(text + "\n", fmt)
	return null


func lograw(text, fmt=fmts.none):
	return _output(text, fmt)


# Print the test name if we aren't skipping names of tests that pass (basically
# what _less_test_names means))
func log_test_name():
	# suppress output if we haven't printed the test name yet and
	# what to print is the test name.
	if(!_less_test_names):
		_print_test_name()

# ---------------
# Misc
# ---------------
func get_gut():
	return _gut


func set_gut(gut):
	_gut = gut
	if(_gut == null):
		_printers.gui = null
	else:
		if(_printers.gui == null):
			_printers.gui = GutUtils.Printers.GutGuiPrinter.new()


func get_indent_level():
	return _indent_level


func set_indent_level(indent_level):
	_indent_level = max(_min_indent_level, indent_level)


func get_indent_string():
	return _indent_string


func set_indent_string(indent_string):
	_indent_string = indent_string


func clear():
	for key in _logs:
		_logs[key].clear()


func inc_indent():
	_indent_level += 1


func dec_indent():
	_indent_level = max(_min_indent_level, _indent_level -1)


func is_type_enabled(type):
	return _type_data[type].enabled


func set_type_enabled(type, is_enabled):
	_type_data[type].enabled = is_enabled


func get_less_test_names():
	return _less_test_names


func set_less_test_names(less_test_names):
	_less_test_names = less_test_names


func disable_printer(name, is_disabled):
	if(_printers[name] != null):
		_printers[name].set_disabled(is_disabled)


func is_printer_disabled(name):
	return _printers[name].get_disabled()


func disable_formatting(is_disabled):
	for key in _printers:
		_printers[key].set_format_enabled(!is_disabled)


func disable_all_printers(is_disabled):
	for p in _printers:
		disable_printer(p, is_disabled)


func get_printer(printer_key):
	return _printers[printer_key]


func _yield_text_terminal(text):
	var printer = _printers['terminal']
	if(_yield_calls != 0):
		printer.clear_line()
		printer.back(_last_yield_text.length())
	printer.send(text, fmts.yellow)


# Format and printing rules for the "Awaiting" messages.
func wait_msg(text):
	if(_type_data.warn.enabled):
		self.log(text, fmts.yellow)


func get_gui_bbcode():
	return _printers.gui.get_bbcode()



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This class wraps around the various printers and supplies formatting for the
# various message types (error, warning, etc).
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/method_maker.gd
--------------------------------------------------
class CallParameters:
	var p_name = null
	var default = null
	var vararg = false

	func _init(n,d):
		p_name = n
		default = d

	func get_signature():
		if(vararg):
			return "...args: Array"
		else:
			return str(p_name, "=", default)


# ------------------------------------------------------------------------------
# This class will generate method declaration lines based on method meta
# data.  It will create defaults that match the method data.
#
# --------------------
# function meta data
# --------------------
# name:
# flags:
# args: [{
# 	(class_name:),
# 	(hint:0),
# 	(hint_string:),
# 	(name:),
# 	(type:4),
# 	(usage:7)
# }]
# default_args []

var _lgr = GutUtils.get_logger()
const PARAM_PREFIX = 'p_'

# ------------------------------------------------------
# _supported_defaults
#
# This array contains all the data types that are supported for default values.
# If a value is supported it will contain either an empty string or a prefix
# that should be used when setting the parameter default value.
# For example int, real, bool do not need anything func(p1=1, p2=2.2, p3=false)
# but things like Vectors and Colors do since only the parameters to create a
# new Vector or Color are included in the metadata.
# ------------------------------------------------------
	# TYPE_NIL = 0  Variable is of type nil (only applied for null).
	# TYPE_BOOL = 1  Variable is of type bool.
	# TYPE_INT = 2  Variable is of type int.
	# TYPE_FLOAT = 3  Variable is of type float/real.
	# TYPE_STRING = 4  Variable is of type String.
	# TYPE_VECTOR2 = 5  Variable is of type Vector2.
	# TYPE_RECT2 = 6  Variable is of type Rect2.
	# TYPE_VECTOR3 = 7  Variable is of type Vector3.
	# TYPE_COLOR = 14  Variable is of type Color.
	# TYPE_OBJECT = 17  Variable is of type Object.
	# TYPE_DICTIONARY = 18  Variable is of type Dictionary.
	# TYPE_ARRAY = 19  Variable is of type Array.
	# TYPE_PACKED_VECTOR2_ARRAY = 24  Variable is of type PackedVector2Array.
	# TYPE_TRANSFORM3D = 13  Variable is of type Transform3D.
	# TYPE_TRANSFORM2D = 8  Variable is of type Transform2D.
	# TYPE_RID = 16  Variable is of type RID.
	# TYPE_PACKED_INT32_ARRAY = 21  Variable is of type PackedInt32Array.
	# TYPE_PACKED_FLOAT32_ARRAY = 22  Variable is of type PackedFloat32Array.
	# TYPE_PACKED_STRING_ARRAY = 23  Variable is of type PackedStringArray.


# TYPE_PLANE = 9  Variable is of type Plane.
# TYPE_QUATERNION = 10  Variable is of type Quaternion.
# TYPE_AABB = 11  Variable is of type AABB.
# TYPE_BASIS = 12  Variable is of type Basis.
# TYPE_NODE_PATH = 15  Variable is of type NodePath.
# TYPE_PACKED_BYTE_ARRAY = 20  Variable is of type PackedByteArray.
# TYPE_PACKED_VECTOR3_ARRAY = 25  Variable is of type PackedVector3Array.
# TYPE_PACKED_COLOR_ARRAY = 26  Variable is of type PackedColorArray.
# TYPE_MAX = 27  Marker for end of type constants.
# ------------------------------------------------------
var _supported_defaults = []

func _init():
	for _i in range(TYPE_MAX):
		_supported_defaults.append(null)

	# These types do not require a prefix for defaults
	_supported_defaults[TYPE_NIL] = ''
	_supported_defaults[TYPE_BOOL] = ''
	_supported_defaults[TYPE_INT] = ''
	_supported_defaults[TYPE_FLOAT] = ''
	_supported_defaults[TYPE_OBJECT] = ''
	_supported_defaults[TYPE_ARRAY] = ''
	_supported_defaults[TYPE_STRING] = ''
	_supported_defaults[TYPE_STRING_NAME] = ''
	_supported_defaults[TYPE_DICTIONARY] = ''
	_supported_defaults[TYPE_PACKED_VECTOR2_ARRAY] = ''
	_supported_defaults[TYPE_RID] = ''

	# These require a prefix for whatever default is provided
	_supported_defaults[TYPE_VECTOR2] = 'Vector2'
	_supported_defaults[TYPE_VECTOR2I] = 'Vector2i'
	_supported_defaults[TYPE_RECT2] = 'Rect2'
	_supported_defaults[TYPE_RECT2I] = 'Rect2i'
	_supported_defaults[TYPE_VECTOR3] = 'Vector3'
	_supported_defaults[TYPE_COLOR] = 'Color'
	_supported_defaults[TYPE_TRANSFORM2D] = 'Transform2D'
	_supported_defaults[TYPE_TRANSFORM3D] = 'Transform3D'
	_supported_defaults[TYPE_PACKED_INT32_ARRAY] = 'PackedInt32Array'
	_supported_defaults[TYPE_PACKED_FLOAT32_ARRAY] = 'PackedFloat32Array'
	_supported_defaults[TYPE_PACKED_STRING_ARRAY] = 'PackedStringArray'

# ###############
# Private
# ###############
var _func_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/function_template.txt')
var _init_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/init_template.txt')

func _is_supported_default(type_flag):
	return type_flag >= 0 and type_flag < _supported_defaults.size() and _supported_defaults[type_flag] != null


func _make_stub_default(method, index):
	return str('__gutdbl.default_val("', method, '",', index, ')')


func _make_arg_array(method_meta):
	var to_return = []

	var has_unsupported_defaults = false

	for i in range(method_meta.args.size()):
		var pname = method_meta.args[i].name
		var dflt_text = _make_stub_default(method_meta.name, i)
		to_return.append(CallParameters.new(PARAM_PREFIX + pname, dflt_text))

	if(method_meta.flags & METHOD_FLAG_VARARG):
		var cp = CallParameters.new("args", "")
		cp.vararg = true
		to_return.append(cp)

	return [has_unsupported_defaults, to_return];


# Creates a list of parameters with defaults of null unless a default value is
# found in the metadata.  If a default is found in the meta then it is used if
# it is one we know how support.
#
# If a default is found that we don't know how to handle then this method will
# return null.
func _get_arg_text(arg_array):
	var text = ''

	for i in range(arg_array.size()):
		text += arg_array[i].get_signature()
		if(i != arg_array.size() -1):
			text += ', '

	return text


# creates a call to the function in meta in the super's class.
func _get_super_call_text(method_name, args):
	var params = ''
	for i in range(args.size()):
		params += args[i].p_name
		if(i != args.size() -1):
			params += ', '

	return str('await super(', params, ')')


func _get_spy_call_parameters_text(args):
	var called_with = 'null'

	if(args.size() > 0):
		called_with = '['
		for i in range(args.size()):
			called_with += args[i].p_name
			if(i < args.size() - 1):
				called_with += ', '
		called_with += ']'

	return called_with


# ###############
# Public
# ###############

func _get_init_text(meta, args, method_params, param_array):
	var text = null

	var decleration = str('func ', meta.name, '(', method_params, ')')
	var super_params = ''
	if(args.size() > 0):
		for i in range(args.size()):
			super_params += args[i].p_name
			if(i != args.size() -1):
				super_params += ', '

	text = _init_text.format({
		"func_decleration":decleration,
		"super_params":super_params,
		"param_array":param_array,
		"method_name":meta.name,
	})

	return text


# Creates a delceration for a function based off of function metadata.  All
# types whose defaults are supported will have their values.  If a datatype
# is not supported and the parameter has a default, a warning message will be
# printed and the declaration will return null.
func get_function_text(meta, override_size=null):
	var method_params = ''
	var text = null
	var result = _make_arg_array(meta)
	var has_unsupported = result[0]
	var args = result[1]

	var param_array = _get_spy_call_parameters_text(args)
	if(has_unsupported):
		# This will cause a runtime error.  This is the most convenient way to
		# to stop running before the error gets more obscure.  _make_arg_array
		# generates a gut error when unsupported defaults are found.
		method_params = null
	else:
		method_params = _get_arg_text(args);

	if(param_array == 'null'):
		param_array = '[]'

	if(method_params != null):
		if(meta.name == '_init'):
			text =  _get_init_text(meta, args, method_params, param_array)
		else:
			var decleration = str('func ', meta.name, '(', method_params, '):')
			text = _func_text.format({
				"func_decleration":decleration,
				"method_name":meta.name,
				"param_array":param_array,
				"super_call":_get_super_call_text(meta.name, args),
			})

	return text


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


--------------------------------------------------
FILE: res:///addons/gut/one_to_many.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# This datastructure represents a simple one-to-many relationship.  It manages
# a dictionary of value/array pairs.  It ignores duplicates of both the "one"
# and the "many".
# ------------------------------------------------------------------------------
var items = {}

# return the size of items or the size of an element in items if "one" was
# specified.
func size(one=null):
	var to_return = 0
	if(one == null):
		to_return = items.size()
	elif(items.has(one)):
		to_return = items[one].size()
	return to_return


# Add an element to "one" if it does not already exist
func add(one, many_item):
	if(items.has(one)):
		if(!items[one].has(many_item)):
			items[one].append(many_item)
	else:
		items[one] = [many_item]


func clear():
	items.clear()


func has(one, many_item):
	var to_return = false
	if(items.has(one)):
		to_return = items[one].has(many_item)
	return to_return


func to_s():
	var to_return = ''
	for key in items:
		to_return += str(key, ":  ", items[key], "\n")
	return to_return


--------------------------------------------------
FILE: res:///addons/gut/orphan_counter.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# It keeps track of the orphans...so this is best name it could ever have.
# ------------------------------------------------------------------------------
class Orphanage:
	const UNGROUPED = "Outside Tests"
	const SUBGROUP_SEP = '->'

	var orphan_ids = {}
	var oprhans_by_group = {}
	var strutils = GutUtils.Strutils.new()

	# wrapper for stubbing
	func _get_system_orphan_node_ids():
		return Node.get_orphan_node_ids()


	func _make_group_key(group=null, subgroup=null):
		var to_return = UNGROUPED
		if(group != null):
			to_return = group

		if(subgroup == null):
			to_return += str(SUBGROUP_SEP, UNGROUPED)
		else:
			to_return += str(SUBGROUP_SEP, subgroup)

		return to_return


	func _add_orphan_by_group(id, group, subgroup):
		var key = _make_group_key(group, subgroup)
		if(oprhans_by_group.has(key)):
			oprhans_by_group[key].append(id)
		else:
			oprhans_by_group[key] = [id]


	func process_orphans(group=null, subgroup=null):
		var new_orphans = []
		for orphan_id in _get_system_orphan_node_ids():
			if(!orphan_ids.has(orphan_id)):
				new_orphans.append(orphan_id)
				orphan_ids[orphan_id] = {
					"group":GutUtils.nvl(group, UNGROUPED),
					"subgroup":GutUtils.nvl(subgroup, UNGROUPED),
					"instance":instance_from_id(orphan_id)
				}
				_add_orphan_by_group(orphan_id, group, subgroup)

		return new_orphans


	func get_orphan_ids(group=null, subgroup=null):
		var key = _make_group_key(group, subgroup)
		return oprhans_by_group.get(key, [])


	# Given the likely size, this was way easier than making a dictionary
	# of dictionaries of arrays.
	func get_all_group_orphans(group):
		var to_return = []
		for key in oprhans_by_group:
			if(key == group or key.begins_with(str(group, SUBGROUP_SEP))):
				to_return.append_array(oprhans_by_group[key])
		return to_return


	# clears out anything that is not still an orphan.
	func clean():
		oprhans_by_group.clear()
		for key in orphan_ids.keys():
			var inst = orphan_ids[key].instance
			if(!is_instance_valid(inst) or inst.get_parent() != null and not orphan_ids.has(inst.get_parent().get_instance_id())):
				orphan_ids.erase(key)
			else:
				_add_orphan_by_group(key, orphan_ids[key].group, orphan_ids[key].subgroup)




# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
var _strutils = GutStringUtils.new()

var orphanage : Orphanage = Orphanage.new()
var logger = GutUtils.get_logger()
var autofree = GutUtils.AutoFree.new()


func _count_all_children(instance):
	var count = instance.get_child_count()
	for child in instance.get_children():
		count += _count_all_children(child)
	return count


func get_orphan_list_text(orphan_ids):
	var text = ""
	for id in orphan_ids:
		var kid_count_text = ''
		var inst = orphanage.orphan_ids[id].instance
		if(is_instance_valid(inst) and inst.get_parent() == null):
			var kid_count = _count_all_children(inst)
			if(kid_count != 0):
				kid_count_text = str(' + ', kid_count)

			var autofree_text = ''
			if(autofree.has_instance_id(id)):
				autofree_text = (" (autofree)")

			if(text != ''):
				text += "\n"
			text += str('* [', _strutils.type2str(inst), ']', kid_count_text, autofree_text)

	return text


func orphan_count() -> int:
	return int(Performance.get_monitor(Performance.OBJECT_ORPHAN_NODE_COUNT))


func record_orphans(group, subgroup = null):
	return orphanage.process_orphans(group, subgroup)


func convert_instance_ids_to_valid_instances(instance_ids):
	var to_return = []
	for entry in instance_ids:
		if(is_instance_id_valid(entry)):
			to_return.append(instance_from_id(entry))
	return to_return


func end_script(script_path, should_log):
	record_orphans(script_path)
	var orphans = orphanage.get_all_group_orphans(script_path)
	if(orphans.size() > 0 and should_log):
		logger.orphan(str(orphans.size(), ' orphans'))


func end_test(script_path, test_name, should_log = true):
	record_orphans(script_path, test_name)
	orphanage.clean()
	# Must get all the orphans and not just the results of record_orphans
	# because record_orphans may have been called for this group/subgroup
	# already.
	var orphans = get_orphan_ids(script_path, test_name)
	if(orphans.size() > 0 and should_log):
		logger.orphan(str(orphans.size(), ' Orphans'))
		logger.inc_indent()
		logger.orphan(get_orphan_list_text(orphans))
		logger.dec_indent()


func get_orphan_ids(group=null, subgroup=null):
	var ids = []
	if(group == null):
		ids = orphanage.orphan_ids.keys()
	elif(subgroup == null):
		ids = orphanage.get_all_group_orphans(group)
	else:
		ids = orphanage.get_orphan_ids(group, subgroup)

	return ids


func get_count() -> int:
	return orphan_count()


func log_all():
	var last_script = ''
	var last_test = ''

	for id in orphanage.orphan_ids:
		var entry = orphanage.orphan_ids[id]

		if(last_script != entry.group):
			last_script = entry.group
			last_test = ''
			logger.log(entry.group)

		if(last_test != entry.subgroup):
			logger.inc_indent()
			logger.log(str('- ', entry.subgroup))
			last_test = entry.subgroup
			logger.inc_indent()
			var orphan_ids = orphanage.get_orphan_ids(last_script, last_test)
			logger.orphan(get_orphan_list_text(orphan_ids))
			logger.dec_indent()
			logger.dec_indent()


# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/parameter_factory.gd
--------------------------------------------------
## Creates parameter structures for parameterized tests.
##
## This is a static class accessible in a [GutTest] script through
## [member GutTest.ParameterFactory].  It contains methods for constructing parameters to be
## used in parameterized tests.  It currently only has one, if you have anyu
## ideas for more, make an issue.  More of them would be great since I prematurely
## decided to make this static class and it has such a long name.  I'd feel a lot
## better about it if there was more in here.
## [br]
## Additional Helper Ideas?[br]
## [li]File.  IDK what it would look like.  csv maybe.[/li]
## [li]Random values within a range?[/li]
## [li]All int values in a range or add an optioanal step.[/li]




## Creates an array of dictionaries.  It pairs up the names array with each set
## of values in values.  If more names than values are specified then the missing
## values will be filled with nulls.  If more values than names are specified
## those values will be ignored.
##
## Example:
##[codeblock]
## create_named_parameters(['a', 'b'], [[1, 2], ['one', 'two']]) returns
##    [{a:1, b:2}, {a:'one', b:'two'}]
##[/codeblock]
## [br]
## This allows you to increase readability of your parameterized tests:
## [br]
##[codeblock]
## var params = create_named_parameters(['a', 'b'], [[1, 2], ['one', 'two']])
## func test_foo(p = use_parameters(params)):
##    assert_eq(p.a, p.b)
##[/codeblock]
## [br]
## Parameters:[br]
##[li]names:  an array of names to be used as keys in the dictionaries[/li]
##[li]values:  an array of arrays of values.[/li]
static func named_parameters(names, values):
	var named = []
	for i in range(values.size()):
		var entry = {}

		var parray = values[i]
		if(typeof(parray) != TYPE_ARRAY):
			parray = [values[i]]

		for j in range(names.size()):
			if(j >= parray.size()):
				entry[names[j]] = null
			else:
				entry[names[j]] = parray[j]
		named.append(entry)

	return named



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This is the home for all parameter creation helpers.  These functions should
# all return an array of values to be used as parameters for parameterized
# tests.
# ##############################################################################

--------------------------------------------------
FILE: res:///addons/gut/parameter_handler.gd
--------------------------------------------------
var _params = null
var _call_count = 0
var _logger = null

func _init(params=null):
	_params = params
	_logger = GutUtils.get_logger()
	if(typeof(_params) != TYPE_ARRAY):
		_logger.error('You must pass an array to parameter_handler constructor.')
		_params = null


func next_parameters():
	_call_count += 1
	return _params[_call_count -1]

func get_current_parameters():
	return _params[_call_count]

func is_done():
	var done = true
	if(_params != null):
		done = _call_count == _params.size()
	return done

func get_logger():
	return _logger

func set_logger(logger):
	_logger = logger

func get_call_count():
	return _call_count

func get_parameter_count():
	return _params.size()


--------------------------------------------------
FILE: res:///addons/gut/printers.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# Interface and some basic functionality for all printers.
# ------------------------------------------------------------------------------
class Printer:
	var _format_enabled = true
	var _disabled = false
	var _printer_name = 'NOT SET'
	var _show_name = false # used for debugging, set manually

	func get_format_enabled():
		return _format_enabled

	func set_format_enabled(format_enabled):
		_format_enabled = format_enabled

	func send(text, fmt=null):
		if(_disabled):
			return

		var formatted = text
		if(fmt != null and _format_enabled):
			formatted = format_text(text, fmt)

		if(_show_name):
			formatted = str('(', _printer_name, ')') + formatted

		_output(formatted)

	func get_disabled():
		return _disabled

	func set_disabled(disabled):
		_disabled = disabled

	# --------------------
	# Virtual Methods (some have some default behavior)
	# --------------------
	func _output(text):
		pass

	func format_text(text, fmt):
		return text

# ------------------------------------------------------------------------------
# Responsible for sending text to a GUT gui.
# ------------------------------------------------------------------------------
class GutGuiPrinter:
	extends Printer
	var _textbox = null

	var _colors = {
			red = Color.RED,
			yellow = Color.YELLOW,
			green = Color.GREEN,
			blue = Color.BLUE
	}

	func _init():
		_printer_name = 'gui'

	func _wrap_with_tag(text, tag):
		return str('[', tag, ']', text, '[/', tag, ']')

	func _color_text(text, c_word):
		return '[color=' + c_word + ']' + text + '[/color]'

	# Remember, we have to use push and pop because the output from the tests
	# can contain [] in it which can mess up the formatting.  There is no way
	# as of 3.4 that you can get the bbcode out of RTL when using push and pop.
	#
	# The only way we could get around this is by adding in non-printable
	# whitespace after each "[" that is in the text.  Then we could maybe do
	# this another way and still be able to get the bbcode out, or generate it
	# at the same time in a buffer (like we tried that one time).
	#
	# Since RTL doesn't have good search and selection methods, and those are
	# really handy in the editor, it isn't worth making bbcode that can be used
	# there as well.
	#
	# You'll try to get it so the colors can be the same in the editor as they
	# are in the output.  Good luck, and I hope I typed enough to not go too
	# far that rabbit hole before finding out it's not worth it.
	func format_text(text, fmt):
		if(_textbox == null):
			return

		if(fmt == 'bold'):
			_textbox.push_bold()
		elif(fmt == 'underline'):
			_textbox.push_underline()
		elif(_colors.has(fmt)):
			_textbox.push_color(_colors[fmt])
		else:
			# just pushing something to pop.
			_textbox.push_normal()

		_textbox.add_text(text)
		_textbox.pop()

		return ''

	func _output(text):
		if(_textbox == null):
			return

		_textbox.add_text(text)

	func get_textbox():
		return _textbox

	func set_textbox(textbox):
		_textbox = textbox

	# This can be very very slow when the box has a lot of text.
	func clear_line():
		_textbox.remove_line(_textbox.get_line_count() - 1)
		_textbox.queue_redraw()

	func get_bbcode():
		return _textbox.text

	func get_disabled():
		return _disabled and _textbox != null

# ------------------------------------------------------------------------------
# This AND TerminalPrinter should not be enabled at the same time since it will
# result in duplicate output.  printraw does not print to the console so i had
# to make another one.
# ------------------------------------------------------------------------------
class ConsolePrinter:
	extends Printer
	var _buffer = ''

	func _init():
		_printer_name = 'console'

	# suppresses output until it encounters a newline to keep things
	# inline as much as possible.
	func _output(text):
		if(text.ends_with("\n")):
			print(_buffer + text.left(text.length() -1))
			_buffer = ''
		else:
			_buffer += text

# ------------------------------------------------------------------------------
# Prints text to terminal, formats some words.
# ------------------------------------------------------------------------------
class TerminalPrinter:
	extends Printer

	var escape = PackedByteArray([0x1b]).get_string_from_ascii()
	var cmd_colors  = {
		red = escape + '[31m',
		yellow = escape + '[33m',
		green = escape + '[32m',
		blue = escape + '[34m',

		underline = escape + '[4m',
		bold = escape + '[1m',

		default = escape + '[0m',

		clear_line = escape + '[2K'
	}

	func _init():
		_printer_name = 'terminal'

	func _output(text):
		# Note, printraw does not print to the console.
		printraw(text)

	func format_text(text, fmt):
		return cmd_colors[fmt] + text + cmd_colors.default

	func clear_line():
		send(cmd_colors.clear_line)

	func back(n):
		send(escape + str('[', n, 'D'))

	func forward(n):
		send(escape + str('[', n, 'C'))


--------------------------------------------------
FILE: res:///addons/gut/result_exporter.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# Creates a structure that contains all the data about the results of running
# tests.  This was created to make an intermediate step organizing the result
# of a run and exporting it in a specific format.  This can also serve as a
# unofficial GUT export format.
# ------------------------------------------------------------------------------
var json = JSON.new()
var strutils = GutStringUtils.new()

func _export_tests(gut, collected_script):
	var to_return = {}
	var tests = collected_script.tests
	for test in tests:
		if(test.get_status_text() != GutUtils.TEST_STATUSES.NOT_RUN):
			var orphans = gut.get_orphan_counter().get_orphan_ids(
				collected_script.get_filename_and_inner(),
				test.name)
			var orphan_node_strings = []
			for o in orphans:
				if(is_instance_id_valid(o)):
					orphan_node_strings.append(strutils.type2str(instance_from_id(o)))

			to_return[test.name] = {
				"status":test.get_status_text(),
				"passing":test.pass_texts,
				"failing":test.fail_texts,
				"pending":test.pending_texts,
				"orphan_count":orphan_node_strings.size(),
				"orphans":orphan_node_strings,
				"time_taken": test.time_taken
			}

	return to_return

# TODO
#	errors
func _export_scripts(gut):
	var collector = gut.get_test_collector()
	if(collector == null):
		return {}

	var scripts = {}

	for s in collector.scripts:
		var test_data = _export_tests(gut, s)
		scripts[s.get_full_name()] = {
			'props':{
				"tests":test_data.keys().size(),
				"pending":s.get_pending_count(),
				"failures":s.get_fail_count(),
				"skipped":s.was_skipped,
			},
			"tests":test_data
		}
	return scripts

func _make_results_dict():
	var result =  {
		'test_scripts':{
			"props":{
				"pending":0,
				"failures":0,
				"passing":0,
				"tests":0,
				"time":0,
				"orphans":0,
				"errors":0,
				"warnings":0,
				"risky":0
			},
			"scripts":[]
		}
	}
	return result


func get_results_dictionary(gut, include_scripts=true):
	var scripts = []

	if(include_scripts):
		scripts = _export_scripts(gut)

	var result =  _make_results_dict()

	var totals = gut.get_summary().get_totals()

	var props = result.test_scripts.props
	props.pending = totals.pending
	props.failures = totals.failing_tests
	props.passing = totals.passing_tests
	props.tests = totals.tests
	props.errors = gut.logger.get_errors().size()
	props.warnings = gut.logger.get_warnings().size()
	props.time =  gut.get_elapsed_time()
	props.orphans = gut.get_orphan_counter().get_count()
	props.risky = totals.risky

	result.test_scripts.scripts = scripts

	return result


func write_json_file(gut, path):
	var dict = get_results_dictionary(gut)
	var json_text = JSON.stringify(dict, ' ')

	var f_result = GutUtils.write_file(path, json_text)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result



func write_summary_file(gut, path):
	var dict = get_results_dictionary(gut, false)
	var json_text = JSON.stringify(dict, ' ')

	var f_result = GutUtils.write_file(path, json_text)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result


--------------------------------------------------
FILE: res:///addons/gut/script_parser.gd
--------------------------------------------------
# These methods didn't have flags that would exclude them from being used
# in a double and they appear to break things if they are included.
const BLACKLIST = [
	'get_script',
	'has_method',
]


# ------------------------------------------------------------------------------
# Combins the meta for the method with additional information.
# * flag for whether the method is local
# * adds a 'default' property to all parameters that can be easily checked per
#   parameter
# ------------------------------------------------------------------------------
class ParsedMethod:
	const NO_DEFAULT = '__no__default__'

	var _meta = {}
	var meta = _meta :
		get: return _meta
		set(val): return;

	var is_local = false
	var _parameters = []

	func _init(metadata):
		_meta = metadata
		var start_default = _meta.args.size() - _meta.default_args.size()
		for i in range(_meta.args.size()):
			var arg = _meta.args[i]
			# Add a "default" property to the metadata so we don't have to do
			# weird default paramter position math again.
			if(i >= start_default):
				arg['default'] = _meta.default_args[start_default - i]
			else:
				arg['default'] = NO_DEFAULT
			_parameters.append(arg)


	func is_eligible_for_doubling():
		var has_bad_flag = _meta.flags & \
			(METHOD_FLAG_OBJECT_CORE | METHOD_FLAG_VIRTUAL | METHOD_FLAG_STATIC)
		return !has_bad_flag and BLACKLIST.find(_meta.name) == -1


	func is_accessor():
		return _meta.name.begins_with('@') and \
			(_meta.name.ends_with('_getter') or _meta.name.ends_with('_setter'))


	func to_s():
		var s = _meta.name + "("

		for i in range(_meta.args.size()):
			var arg = _meta.args[i]
			if(str(arg.default) != NO_DEFAULT):
				var val = str(arg.default)
				if(val == ''):
					val = '""'
				s += str(arg.name, ' = ', val)
			else:
				s += str(arg.name)

			if(i != _meta.args.size() -1):
				s += ', '

		s += ")"
		return s




# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class ParsedScript:
	# All methods indexed by name.
	var _methods_by_name = {}

	var _script_path = null
	var script_path = _script_path :
		get: return _script_path
		set(val): return;

	var _subpath = null
	var subpath = null :
		get: return _subpath
		set(val): return;

	var _resource = null
	var resource = null :
		get: return _resource
		set(val): return;


	var _is_native = false
	var is_native = _is_native:
		get: return _is_native
		set(val): return;

	var _native_methods = {}
	var _native_class_name = ""



	func _init(script_or_inst, inner_class=null):
		var to_load = script_or_inst

		if(GutUtils.is_native_class(to_load)):
			_resource = to_load
			_is_native = true
			var inst = to_load.new()
			_native_class_name = inst.get_class()
			_native_methods = inst.get_method_list()
			if(!inst is RefCounted):
				inst.free()
		else:
			if(!script_or_inst is Resource):
				to_load = load(script_or_inst.get_script().get_path())

			_script_path = to_load.resource_path
			if(inner_class != null):
				_subpath = _find_subpath(to_load, inner_class)

			if(inner_class == null):
				_resource = to_load
			else:
				_resource = inner_class
				to_load = inner_class

		_parse_methods(to_load)


	func _print_flags(meta):
		print(str(meta.name, ':').rpad(30), str(meta.flags).rpad(4), ' = ', GutUtils.dec2bistr(meta.flags, 10))


	func _get_native_methods(base_type):
		var to_return = []
		if(base_type != null):
			var source = str('extends ', base_type)
			var inst = GutUtils.create_script_from_source(source).new()
			to_return = inst.get_method_list()
			if(! inst is RefCounted):
				inst.free()
		return to_return


	func _parse_methods(thing):
		var methods = []
		if(is_native):
			methods = _native_methods.duplicate()
		else:
			var base_type = thing.get_instance_base_type()
			methods = _get_native_methods(base_type)

		for m in methods:
			var parsed = ParsedMethod.new(m)
			_methods_by_name[m.name] = parsed
			# _init must always be included so that we can initialize
			# double_tools
			if(m.name == '_init'):
				parsed.is_local = true


		# This loop will overwrite all entries in _methods_by_name with the local
		# method object so there is only ever one listing for a function with
		# the right "is_local" flag.
		if(!is_native):
			methods = thing.get_script_method_list()
			for m in methods:
				var parsed_method = ParsedMethod.new(m)
				parsed_method.is_local = true
				_methods_by_name[m.name] = parsed_method


	func _find_subpath(parent_script, inner):
		var const_map = parent_script.get_script_constant_map()
		var consts = const_map.keys()
		var const_idx = 0
		var found = false
		var to_return = null

		while(const_idx < consts.size() and !found):
			var key = consts[const_idx]
			var const_val = const_map[key]
			if(typeof(const_val) == TYPE_OBJECT):
				if(const_val == inner):
					found = true
					to_return = key
				else:
					to_return = _find_subpath(const_val, inner)
					if(to_return != null):
						to_return = str(key, '.', to_return)
						found = true

			const_idx += 1

		return to_return


	func get_method(name):
		return _methods_by_name[name]


	func get_super_method(name):
		var to_return = get_method(name)
		if(to_return.is_local):
			to_return = null

		return to_return

	func get_local_method(name):
		var to_return = get_method(name)
		if(!to_return.is_local):
			to_return = null

		return to_return


	func get_sorted_method_names():
		var keys = _methods_by_name.keys()
		keys.sort()
		return keys


	func get_local_method_names():
		var names = []
		for method in _methods_by_name:
			if(_methods_by_name[method].is_local):
				names.append(method)

		return names


	func get_super_method_names():
		var names = []
		for method in _methods_by_name:
			if(!_methods_by_name[method].is_local):
				names.append(method)

		return names


	func get_local_methods():
		var to_return = []
		for key in _methods_by_name:
			var method = _methods_by_name[key]
			if(method.is_local):
				to_return.append(method)
		return to_return


	func get_super_methods():
		var to_return = []
		for key in _methods_by_name:
			var method = _methods_by_name[key]
			if(!method.is_local):
				to_return.append(method)
		return to_return


	func get_extends_text():
		var text = null
		if(is_native):
			text = str("extends ", _native_class_name)
		else:
			text = str("extends '", _script_path, "'")
			if(_subpath != null):
				text += '.' + _subpath
		return text


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
var scripts = {}

func _get_instance_id(thing):
	var inst_id = null

	if(GutUtils.is_native_class(thing)):
		var id_str = str(thing).replace("<", '').replace(">", '').split('#')[1]
		inst_id = id_str.to_int()
	elif(typeof(thing) == TYPE_STRING):
		if(FileAccess.file_exists(thing)):
			inst_id = load(thing).get_instance_id()
	else:
		inst_id = thing.get_instance_id()

	return inst_id


func parse(thing, inner_thing=null):
	var key = -1
	if(inner_thing == null):
		key = _get_instance_id(thing)
	else:
		key = _get_instance_id(inner_thing)

	var parsed = null

	if(key != null):
		if(scripts.has(key)):
			parsed = scripts[key]
		else:
			var obj = instance_from_id(_get_instance_id(thing))
			var inner = null
			if(inner_thing != null):
				inner = instance_from_id(_get_instance_id(inner_thing))

			if(obj is Resource or GutUtils.is_native_class(obj)):
				parsed = ParsedScript.new(obj, inner)
				scripts[key] = parsed

	return parsed



--------------------------------------------------
FILE: res:///addons/gut/signal_watcher.gd
--------------------------------------------------
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

# Some arbitrary string that should never show up by accident.  If it does, then
# shame on  you.
const ARG_NOT_SET = '_*_argument_*_is_*_not_set_*_'

# This hash holds the objects that are being watched, the signals that are being
# watched, and an array of arrays that contains arguments that were passed
# each time the signal was emitted.
#
# For example:
#	_watched_signals => {
#		ref1 => {
#			'signal1' => [[], [], []],
#			'signal2' => [[p1, p2]],
#			'signal3' => [[p1]]
#		},
#		ref2 => {
#			'some_signal' => [],
#			'other_signal' => [[p1, p2, p3], [p1, p2, p3], [p1, p2, p3]]
#		}
#	}
#
# In this sample:
#	- signal1 on the ref1 object was emitted 3 times and each time, zero
#	parameters were passed.
#	- signal3 on ref1 was emitted once and passed a single parameter
#	- some_signal on ref2 was never emitted.
#	- other_signal on ref2 was emitted 3 times, each time with 3 parameters.
var _watched_signals = {}
var _lgr = GutUtils.get_logger()

func _add_watched_signal(obj, name):
	# SHORTCIRCUIT - ignore dupes
	if(_watched_signals.has(obj) and _watched_signals[obj].has(name)):
		return

	if(!_watched_signals.has(obj)):
		_watched_signals[obj] = {name:[]}
	else:
		_watched_signals[obj][name] = []
	obj.connect(name,Callable(self,'_on_watched_signal').bind(obj,name))

# This handles all the signals that are watched.  It supports up to 9 parameters
# which could be emitted by the signal and the two parameters used when it is
# connected via watch_signal.  I chose 9 since you can only specify up to 9
# parameters when dynamically calling a method via call (per the Godot
# documentation, i.e. some_object.call('some_method', 1, 2, 3...)).
#
# Based on the documentation of emit_signal, it appears you can only pass up
# to 4 parameters when firing a signal.  I haven't verified this, but this should
# future proof this some if the value ever grows.
func _on_watched_signal(arg1=ARG_NOT_SET, arg2=ARG_NOT_SET, arg3=ARG_NOT_SET, \
						arg4=ARG_NOT_SET, arg5=ARG_NOT_SET, arg6=ARG_NOT_SET, \
						arg7=ARG_NOT_SET, arg8=ARG_NOT_SET, arg9=ARG_NOT_SET, \
						arg10=ARG_NOT_SET, arg11=ARG_NOT_SET):
	var args = [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11]

	# strip off any unused vars.
	var idx = args.size() -1
	while(str(args[idx]) == ARG_NOT_SET):
		args.remove_at(idx)
		idx -= 1

	# retrieve object and signal name from the array and remove_at them.  These
	# will always be at the end since they are added when the connect happens.
	var signal_name = args[args.size() -1]
	args.pop_back()
	var object = args[args.size() -1]
	args.pop_back()

	if(_watched_signals.has(object)):
		_watched_signals[object][signal_name].append(args)
	else:
		_lgr.error(str("signal_watcher._on_watched_signal:  Got signal for unwatched object:  ", object, '::', signal_name))

# This parameter stuff should go into test.gd not here.  This thing works
# just fine the way it is.
func _obj_name_pair(obj_or_signal, signal_name=null):
	var to_return = {
		'object' : obj_or_signal,
		'signal_name' : signal_name
	}
	if(obj_or_signal is Signal):
		to_return.object =  obj_or_signal.get_object()
		to_return.signal_name = obj_or_signal.get_name()

	return to_return


func does_object_have_signal(object, signal_name):
	var signals = object.get_signal_list()
	for i in range(signals.size()):
		if(signals[i]['name'] == signal_name):
			return true
	return false

func watch_signals(object):
	var signals = object.get_signal_list()
	for i in range(signals.size()):
		_add_watched_signal(object, signals[i]['name'])

func watch_signal(object, signal_name):
	var did = false
	if(does_object_have_signal(object, signal_name)):
		_add_watched_signal(object, signal_name)
		did = true
	else:
		GutUtils.get_logger().warn(str(object, ' does not have signal ', signal_name))
	return did

func get_emit_count(object, signal_name):
	var to_return = -1
	if(is_watching(object, signal_name)):
		to_return = _watched_signals[object][signal_name].size()
	return to_return

func did_emit(object, signal_name=null):
	var vals = _obj_name_pair(object, signal_name)
	var did = false
	if(is_watching(vals.object, vals.signal_name)):
		did = get_emit_count(vals.object, vals.signal_name) != 0
	return did

func print_object_signals(object):
	var list = object.get_signal_list()
	for i in range(list.size()):
		print(list[i].name, "\n  ", list[i])

func get_signal_parameters(object, signal_name, index=-1):
	var params = null
	if(is_watching(object, signal_name)):
		var all_params = _watched_signals[object][signal_name]
		if(all_params.size() > 0):
			if(index == -1):
				index = all_params.size() -1
			params = all_params[index]
	return params

func is_watching_object(object):
	return _watched_signals.has(object)

func is_watching(object, signal_name):
	return _watched_signals.has(object) and _watched_signals[object].has(signal_name)

func clear():
	for obj in _watched_signals:
		if(GutUtils.is_not_freed(obj)):
			for signal_name in _watched_signals[obj]:
				obj.disconnect(signal_name, Callable(self,'_on_watched_signal'))
	_watched_signals.clear()

# Returns a list of all the signal names that were emitted by the object.
# If the object is not being watched then an empty list is returned.
func get_signals_emitted(obj):
	var emitted = []
	if(is_watching_object(obj)):
		for signal_name in _watched_signals[obj]:
			if(_watched_signals[obj][signal_name].size() > 0):
				emitted.append(signal_name)

	return emitted


func get_signal_summary(obj):
	var emitted = {}
	if(is_watching_object(obj)):
		for signal_name in _watched_signals[obj]:
			if(_watched_signals[obj][signal_name].size() > 0):
				# maybe this could return parameters if any were sent.  should
				# have an empty list if no parameters were ever sent to the
				# signal.  Or this all just gets moved into print_signal_summary
				# since this wouldn't be that useful without more data in the
				# summary.
				var entry = {
					emit_count = get_emit_count(obj, signal_name)
				}
				emitted[signal_name] = entry

	return emitted


func print_signal_summary(obj):
	if(!is_watching_object(obj)):
		var msg = str('Not watching signals for ', obj)
		GutUtils.get_logger().warn(msg)
		return

	var summary = get_signal_summary(obj)
	print(obj, '::Signals')
	var sorted = summary.keys()
	sorted.sort()
	for key in sorted:
		print(' -  ', key, ' x ', summary[key].emit_count)


--------------------------------------------------
FILE: res:///addons/gut/spy.gd
--------------------------------------------------
# {
#   instance_id_or_path1:{
#       method1:[ [p1, p2], [p1, p2] ],
#       method2:[ [p1, p2], [p1, p2] ]
#   },
#   instance_id_or_path1:{
#       method1:[ [p1, p2], [p1, p2] ],
#       method2:[ [p1, p2], [p1, p2] ]
#   },
# }
var _calls = {}
var _lgr = GutUtils.get_logger()
var _compare = GutUtils.Comparator.new()

func _find_parameters(call_params, params_to_find):
	var found = false
	var idx = 0
	while(idx < call_params.size() and !found):
		var result = _compare.deep(call_params[idx], params_to_find)
		if(result.are_equal):
			found = true
		else:
			idx += 1
	return found


func _get_params_as_string(params):
	var to_return = ''
	if(params == null):
		return ''

	for i in range(params.size()):
		if(params[i] == null):
			to_return += 'null'
		else:
			if(typeof(params[i]) == TYPE_STRING):
				to_return += str('"', params[i], '"')
			else:
				to_return += str(params[i])
		if(i != params.size() -1):
			to_return += ', '
	return to_return


func add_call(variant, method_name, parameters=null):
	if(!_calls.has(variant)):
		_calls[variant] = {}

	if(!_calls[variant].has(method_name)):
		_calls[variant][method_name] = []

	_calls[variant][method_name].append(parameters)


func was_called(variant, method_name, parameters=null):
	var to_return = false
	if(_calls.has(variant) and _calls[variant].has(method_name)):
		if(parameters):
			to_return = _find_parameters(_calls[variant][method_name], parameters)
		else:
			to_return = true
	return to_return


func get_call_parameters(variant, method_name, index=-1):
	var to_return = null
	var get_index = -1

	if(_calls.has(variant) and _calls[variant].has(method_name)):
		var call_size = _calls[variant][method_name].size()
		if(index == -1):
			# get the most recent call by default
			get_index =  call_size -1
		else:
			get_index = index

		if(get_index < call_size):
			to_return = _calls[variant][method_name][get_index]
		else:
			_lgr.error(str('Specified index ', index, ' is outside range of the number of registered calls:  ', call_size))

	return to_return


func call_count(instance, method_name, parameters=null):
	var to_return = 0

	if(was_called(instance, method_name)):
		if(parameters):
			for i in range(_calls[instance][method_name].size()):
				if(_calls[instance][method_name][i] == parameters):
					to_return += 1
		else:
			to_return = _calls[instance][method_name].size()
	return to_return


func clear():
	_calls = {}


func get_call_list_as_string(instance):
	var to_return = ''
	if(_calls.has(instance)):
		for method in _calls[instance]:
			for i in range(_calls[instance][method].size()):
				to_return += str(method, '(', _get_params_as_string(_calls[instance][method][i]), ")\n")
	return to_return


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


--------------------------------------------------
FILE: res:///addons/gut/strutils.gd
--------------------------------------------------
class_name GutStringUtils

# Hash containing all the built in types in Godot.  This provides an English
# name for the types that corosponds with the type constants defined in the
# engine.
var types = {}

func _init_types_dictionary():
	types[TYPE_NIL] = 'NIL'
	types[TYPE_AABB] = 'AABB'
	types[TYPE_ARRAY] = 'ARRAY'
	types[TYPE_BASIS] = 'BASIS'
	types[TYPE_BOOL] = 'BOOL'
	types[TYPE_CALLABLE] = 'CALLABLE'
	types[TYPE_COLOR] = 'COLOR'
	types[TYPE_DICTIONARY] = 'DICTIONARY'
	types[TYPE_FLOAT] = 'FLOAT'
	types[TYPE_INT] = 'INT'
	types[TYPE_MAX] = 'MAX'
	types[TYPE_NODE_PATH] = 'NODE_PATH'
	types[TYPE_OBJECT] = 'OBJECT'
	types[TYPE_PACKED_BYTE_ARRAY] = 'PACKED_BYTE_ARRAY'
	types[TYPE_PACKED_COLOR_ARRAY] = 'PACKED_COLOR_ARRAY'
	types[TYPE_PACKED_FLOAT32_ARRAY] = 'PACKED_FLOAT32_ARRAY'
	types[TYPE_PACKED_FLOAT64_ARRAY] = 'PACKED_FLOAT64_ARRAY'
	types[TYPE_PACKED_INT32_ARRAY] = 'PACKED_INT32_ARRAY'
	types[TYPE_PACKED_INT64_ARRAY] = 'PACKED_INT64_ARRAY'
	types[TYPE_PACKED_STRING_ARRAY] = 'PACKED_STRING_ARRAY'
	types[TYPE_PACKED_VECTOR2_ARRAY] = 'PACKED_VECTOR2_ARRAY'
	types[TYPE_PACKED_VECTOR3_ARRAY] = 'PACKED_VECTOR3_ARRAY'
	types[TYPE_PLANE] = 'PLANE'
	types[TYPE_PROJECTION] = 'PROJECTION'
	types[TYPE_QUATERNION] = 'QUATERNION'
	types[TYPE_RECT2] = 'RECT2'
	types[TYPE_RECT2I] = 'RECT2I'
	types[TYPE_RID] = 'RID'
	types[TYPE_SIGNAL] = 'SIGNAL'
	types[TYPE_STRING_NAME] = 'STRING_NAME'
	types[TYPE_STRING] = 'STRING'
	types[TYPE_TRANSFORM2D] = 'TRANSFORM2D'
	types[TYPE_TRANSFORM3D] = 'TRANSFORM3D'
	types[TYPE_VECTOR2] = 'VECTOR2'
	types[TYPE_VECTOR2I] = 'VECTOR2I'
	types[TYPE_VECTOR3] = 'VECTOR3'
	types[TYPE_VECTOR3I] = 'VECTOR3I'
	types[TYPE_VECTOR4] = 'VECTOR4'
	types[TYPE_VECTOR4I] = 'VECTOR4I'

# Types to not be formatted when using _str
var _str_ignore_types = [
	TYPE_INT, TYPE_FLOAT, TYPE_STRING,
	TYPE_NIL, TYPE_BOOL
]

func _init():
	_init_types_dictionary()

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_filename(path):
	return path.split('/')[-1]

# ------------------------------------------------------------------------------
# Gets the filename of an object passed in.  This does not return the
# full path to the object, just the filename.
# ------------------------------------------------------------------------------
func _get_obj_filename(thing):
	var filename = null

	if(thing == null or
		GutUtils.is_native_class(thing) or
		!is_instance_valid(thing) or
		str(thing) == '<Object#null>' or
		typeof(thing) != TYPE_OBJECT or
		GutUtils.is_double(thing)):
		return

	if(thing.get_script() == null):
		if(thing is PackedScene):
			filename = _get_filename(thing.resource_path)
		else:
			# If it isn't a packed scene and it doesn't have a script then
			# we do nothing.  This just reads better.
			pass
	elif(!GutUtils.is_native_class(thing)):
		var dict = inst_to_dict(thing)
		filename = _get_filename(dict['@path'])
		if(str(dict['@subpath']) != ''):
			filename += str('/', dict['@subpath'])

	return filename

# ------------------------------------------------------------------------------
# Better object/thing to string conversion.  Includes extra details about
# whatever is passed in when it can/should.
# ------------------------------------------------------------------------------
func type2str(thing):
	var filename = _get_obj_filename(thing)
	var str_thing = str(thing)

	if(thing == null):
		# According to str there is a difference between null and an Object
		# that is somehow null.  To avoid getting '[Object:null]' as output
		# always set it to str(null) instead of str(thing).  A null object
		# will pass typeof(thing) == TYPE_OBJECT check so this has to be
		# before that.
		str_thing = str(null)
	elif(typeof(thing) == TYPE_FLOAT):
		if(!'.' in str_thing):
			str_thing += '.0'
	elif(typeof(thing) == TYPE_STRING):
		str_thing = str('"', thing, '"')
	elif(typeof(thing) in _str_ignore_types):
		# do nothing b/c we already have str(thing) in
		# to_return.  I think this just reads a little
		# better this way.
		pass
	elif(typeof(thing) == TYPE_OBJECT):
		if(GutUtils.is_native_class(thing)):
			str_thing = GutUtils.get_native_class_name(thing)
		elif(GutUtils.is_double(thing)):
			var double_path = _get_filename(thing.__gutdbl.thepath)
			if(thing.__gutdbl.subpath != ''):
				double_path += str('/', thing.__gutdbl.subpath)
			elif(thing.__gutdbl.from_singleton != ''):
				double_path = thing.__gutdbl.from_singleton + " Singleton"

			var double_type = "double"
			if(thing.__gutdbl.is_partial):
				double_type = "partial-double"

			str_thing += str("(", double_type, " of ", double_path, ")")

			filename = null
	elif(types.has(typeof(thing))):
		if(!str_thing.begins_with('(')):
			str_thing = '(' + str_thing + ')'
		str_thing = str(types[typeof(thing)], str_thing)

	if(filename != null):
		str_thing += str('(', filename, ')')
	return str_thing

# ------------------------------------------------------------------------------
# Returns the string truncated with an '...' in it.  Shows the start and last
# 10 chars.  If the string is  smaller than max_size the entire string is
# returned.  If max_size is -1 then truncation is skipped.
# ------------------------------------------------------------------------------
func truncate_string(src, max_size):
	var to_return = src
	if(src.length() > max_size - 10 and max_size != -1):
		to_return = str(src.substr(0, max_size - 10), '...',  src.substr(src.length() - 10, src.length()))
	return to_return


func _get_indent_text(times, pad):
	var to_return = ''
	for i in range(times):
		to_return += pad

	return to_return

func indent_text(text, times, pad):
	if(times == 0):
		return text

	var to_return = text
	var ending_newline = ''

	if(text.ends_with("\n")):
		ending_newline = "\n"
		to_return = to_return.left(to_return.length() -1)

	var padding = _get_indent_text(times, pad)
	to_return = to_return.replace("\n", "\n" + padding)
	to_return += ending_newline

	return padding + to_return


--------------------------------------------------
FILE: res:///addons/gut/stub_params.gd
--------------------------------------------------
var _is_return_override = false
var _is_defaults_override = false
var _is_call_override = false
var _method_meta : Dictionary = {}


var _lgr = GutUtils.get_logger()
var logger = _lgr :
	get: return _lgr
	set(val): _lgr = val

var return_val = null
var stub_target = null
var parameters = null # the parameter values to match method call on.
var stub_method = null
var call_super = false
var call_this = null

# Whether this is a stub for default parameter values as they are defined in
# the script, and not an overridden default value.
var is_script_default = false

var parameter_count = -1 :
	get():
		_lgr.deprecated("parameter count deprecated")
		return -1

# Default values for parameters.  This is used to store default values for
# scripts and to override those values.  I'm not sure if there is a need to
# override them anymore, since I think this was introduced for stubbing vararg
# methods, but you still can for now.  This value should only be used if
# is_defaults_override is true.
var parameter_defaults = []

const NOT_SET = '|_1_this_is_not_set_1_|'

func _init(target=null, method=null, _subpath=null):
	stub_target = target
	stub_method = method

	if(typeof(target) == TYPE_CALLABLE):
		stub_target = target.get_object()
		stub_method = target.get_method()
		parameters = target.get_bound_arguments()
		if(parameters.size() == 0):
			parameters = null
	elif(typeof(target) == TYPE_STRING):
		if(target.is_absolute_path()):
			stub_target = load(str(target))
		else:
			_lgr.warn(str(target, ' is not a valid path'))

	if(stub_target is PackedScene):
		stub_target = GutUtils.get_scene_script_object(stub_target)

	# this is used internally to stub default parameters for everything that is
	# doubled...or something.  Look for stub_defaults_from_meta for usage.  This
	# behavior is not to be used by end users.
	if(typeof(method) == TYPE_DICTIONARY):
		_method_meta = method
		_load_defaults_from_metadata(method)
		is_script_default = true


func _load_defaults_from_metadata(meta):
	stub_method = meta.name
	var values = meta.default_args.duplicate()
	while (values.size() < meta.args.size()):
		values.push_front(null)

	param_defaults(values)


func _get_method_meta():
	if(_method_meta == {} and typeof(stub_target) == TYPE_OBJECT):
		var found_meta = GutUtils.get_method_meta(stub_target, stub_method)
		if(found_meta != null):
			_method_meta = found_meta
	return _method_meta


# -------------------------
# Public
# -------------------------
func to_return(val):
	return_val = val
	call_super = false
	_is_return_override = true

	return self


func to_do_nothing():
	to_return(null)
	return self


func to_call_super():
	call_super = true
	_is_call_override = true
	return self


func to_call(callable : Callable):
	call_this = callable
	_is_call_override = true
	return self


func when_passed(p1=NOT_SET,p2=NOT_SET,p3=NOT_SET,p4=NOT_SET,p5=NOT_SET,p6=NOT_SET,p7=NOT_SET,p8=NOT_SET,p9=NOT_SET,p10=NOT_SET):
	parameters = [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10]
	var idx = 0
	while(idx < parameters.size()):
		if(str(parameters[idx]) == NOT_SET):
			parameters.remove_at(idx)
		else:
			idx += 1
	return self


func param_count(_x):
	_lgr.deprecated("Stubbing param_count is no longer required or supported.")
	return self


func param_defaults(values):
	var meta = _get_method_meta()
	if(meta != {} and meta.flags & METHOD_FLAG_VARARG):
		_lgr.error("Cannot stub defaults for methods with varargs.")
	else:
		parameter_defaults = values
		_is_defaults_override = true
	return self


func is_default_override_only():
	return is_defaults_override() and !is_return_override() and !is_call_override()


func is_return_override():
	return _is_return_override


func is_defaults_override():
	return _is_defaults_override


func is_call_override():
	return _is_call_override


func to_s():
	var base_string = str(stub_target, '.', stub_method)

	if(parameter_defaults.size() > 0):
		base_string += str(" defaults ", parameter_defaults)

	if(call_super):
		base_string += " to call SUPER"

	if(call_this != null):
		base_string += str(" to call ", call_this)

	if(parameters != null):
		base_string += str(' with params (', parameters, ') returns ', return_val)
	else:
		base_string += str(' returns ', return_val)

	return base_string


--------------------------------------------------
FILE: res:///addons/gut/stubber.gd
--------------------------------------------------

static var _class_db_name_hash = {} :
	get():
		if(_class_db_name_hash == {}):
			_class_db_name_hash = _make_crazy_dynamic_over_engineered_class_db_hash()
		return _class_db_name_hash


# So, I couldn't figure out how to get to a reference for a GDNative Class
# using a string.  ClassDB has all thier names...so I made a hash using those
# names and the classes.  Then I dynmaically make a script that has that as
# the source and grab the hash out of it and return it.  Super Rube Golbergery,
# but tons of fun.
static func _make_crazy_dynamic_over_engineered_class_db_hash():
	var text = "var all_the_classes: Dictionary = {\n"
	for classname in ClassDB.get_class_list():
		if(ClassDB.can_instantiate(classname)):
			text += str('"', classname, '": ', classname, ", \n")
		else:
			text += str('# ', classname, "\n")
	text += "}"
	var inst =  GutUtils.create_script_from_source(text).new()
	return inst.all_the_classes


# -------------
# returns{} and parameters {} have the followin structure
# -------------
# {
# 	inst_id_or_path1:{
# 		method_name1: [StubParams, StubParams],
# 		method_name2: [StubParams, StubParams]
# 	},
# 	inst_id_or_path2:{
# 		method_name1: [StubParams, StubParams],
# 		method_name2: [StubParams, StubParams]
# 	}
# }
var returns = {}
var _lgr = GutUtils.get_logger()
var _strutils = GutUtils.Strutils.new()


func _find_matches(obj, method):
	var matches = []
	var last_not_null_parent = null

	# Search for what is passed in first.  This could be a class or an instance.
	# We want to find the instance before we find the class.  If we do not have
	# an entry for the instance then see if we have an entry for the class.
	if(returns.has(obj) and returns[obj].has(method)):
		matches = returns[obj][method]
	elif(GutUtils.is_instance(obj)):
		var parent = obj.get_script()
		var found = false
		while(parent != null and !found):
			found = returns.has(parent)

			if(!found):
				last_not_null_parent = parent
				parent = parent.get_base_script()

		# Could not find the script so check to see if a native class of this
		# type was stubbed.
		if(!found):
			var base_type = last_not_null_parent.get_instance_base_type()
			if(_class_db_name_hash.has(base_type)):
				parent = _class_db_name_hash[base_type]
				found = returns.has(parent)

		if(found and returns[parent].has(method)):
			matches = returns[parent][method]

	return matches


# Searches returns for an entry that matches the instance or the class that
# passed in obj is.
#
# obj can be an instance, class, or a path.
func _find_stub(obj, method, parameters=null, find_overloads=false):
	var to_return = null
	var matches = _find_matches(obj, method)

	if(matches.size() == 0):
		return null

	var param_match = null
	var null_match = null
	var overload_match = null

	for i in range(matches.size()):
		var cur_stub = matches[i]
		if(cur_stub.parameters == parameters):
			param_match = cur_stub

		if(cur_stub.parameters == null and !cur_stub.is_default_override_only()):
			null_match = cur_stub

		if(cur_stub.is_defaults_override):
			if(overload_match == null || overload_match.is_script_default):
				overload_match = cur_stub

	if(find_overloads and overload_match != null):
		to_return = overload_match
	# We have matching parameter values so return the stub value for that
	elif(param_match != null):
		to_return = param_match
	# We found a case where the parameters were not specified so return
	# parameters for that.  Only do this if the null match is not *just*
	# a paramerter override stub.
	elif(null_match != null):
		to_return = null_match

	return to_return



# ##############
# Public
# ##############

func add_stub(stub_params):
	stub_params._lgr = _lgr
	var key = stub_params.stub_target

	if(!returns.has(key)):
		returns[key] = {}

	if(!returns[key].has(stub_params.stub_method)):
		returns[key][stub_params.stub_method] = []

	returns[key][stub_params.stub_method].append(stub_params)


# Gets a stubbed return value for the object and method passed in.  If the
# instance was stubbed it will use that, otherwise it will use the path and
# subpath of the object to try to find a value.
#
# It will also use the optional list of parameter values to find a value.  If
# the object was stubbed with no parameters than any parameters will match.
# If it was stubbed with specific parameter values then it will try to match.
# If the parameters do not match BUT there was also an empty parameter list stub
# then it will return those.
# If it cannot find anything that matches then null is returned.for
#
# Parameters
# obj:  this should be an instance of a doubled object.
# method:  the method called
# parameters:  optional array of parameter vales to find a return value for.
func get_return(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	if(stub_info != null):
		return stub_info.return_val
	else:
		_lgr.info(str('Call to [', method, '] was not stubbed for the supplied parameters ', parameters, '.  Null was returned.'))
		return null


func should_call_super(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	var is_partial = false
	if(typeof(obj) != TYPE_STRING): # some stubber tests test with strings
		is_partial = obj.__gutdbl.is_partial
	var should = is_partial

	if(stub_info != null):
		should = stub_info.call_super
	elif(!is_partial):
		# this log message is here because of how the generated doubled scripts
		# are structured.  With this log msg here, you will only see one
		# "unstubbed" info instead of multiple.
		_lgr.info('Unstubbed call to ' + method + '::' + _strutils.type2str(obj))
		should = false

	return should


func get_call_this(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	if(stub_info != null):
		return stub_info.call_this


func get_default_value(obj, method, p_index):
	var matches = _find_matches(obj, method)
	var the_defaults = []
	var script_defaults = []
	var i = matches.size() -1

	while(i >= 0 and the_defaults.is_empty()):
		if(matches[i].is_defaults_override()):
			if(matches[i].is_script_default):
				script_defaults = matches[i].parameter_defaults
			else:
				the_defaults = matches[i].parameter_defaults
		i -= 1

	if(the_defaults.is_empty() and !script_defaults.is_empty()):
		the_defaults = script_defaults

	var to_return = null
	if(the_defaults.size() > p_index):
		to_return = the_defaults[p_index]

	return to_return


func clear():
	returns.clear()


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


func to_s():
	var text = ''
	for thing in returns:
		text += str("-- ", thing, " --\n")
		for method in returns[thing]:
			text += str("\t", method, "\n")
			for i in range(returns[thing][method].size()):
				text += "\t\t" + returns[thing][method][i].to_s() + "\n"

	if(text == ''):
		text = 'Stubber is empty';

	return text


func stub_defaults_from_meta(target, method_meta):
	var params = GutUtils.StubParams.new(target, method_meta)
	params.is_script_default = true
	add_stub(params)


--------------------------------------------------
FILE: res:///addons/gut/summary.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# Prints things, mostly.  Knows too much about gut.gd, but it's only supposed to
# work with gut.gd, so I'm fine with that.
# ------------------------------------------------------------------------------
# a _test_collector to use when one is not provided.
var _gut = null


func _init(gut=null):
	_gut = gut

# ---------------------
# Private
# ---------------------
func _log_end_run_header(gut):
	var lgr = gut.get_logger()
	lgr.log('==============================================', lgr.fmts.yellow)
	lgr.log("= Run Summary", lgr.fmts.yellow)
	lgr.log('==============================================', lgr.fmts.yellow)


func _log_what_was_run(gut):
	if(!GutUtils.is_null_or_empty(gut._select_script)):
		gut.p('Ran Scripts matching "' + gut._select_script + '"')
	if(!GutUtils.is_null_or_empty(gut._unit_test_name)):
		gut.p('Ran Tests matching "' + gut._unit_test_name + '"')
	if(!GutUtils.is_null_or_empty(gut._inner_class_name)):
		gut.p('Ran Inner Classes matching "' + gut._inner_class_name + '"')


func _total_fmt(text, value):
	var space = 18
	if(str(value) == '0'):
		value = 'none'
	return str(text.rpad(space), str(value).lpad(5))


func _log_non_zero_total(text, value, lgr):
	if(str(value) != '0'):
		lgr.log(_total_fmt(text, value))
		return 1
	else:
		return 0


func _log_totals(gut, totals):
	var lgr = gut.get_logger()
	lgr.log()

	# lgr.log("---- Totals ----")
	lgr.log("Totals")
	lgr.log("------")
	var issue_count = 0
	issue_count += _log_non_zero_total('Errors', totals.errors, lgr)
	issue_count += _log_non_zero_total('Warnings', totals.warnings, lgr)
	issue_count += _log_non_zero_total('Deprecated', totals.deprecated, lgr)
	if(issue_count > 0):
		lgr.log("")

	lgr.log(_total_fmt( 'Scripts', totals.scripts))
	lgr.log(_total_fmt( 'Tests', gut.get_test_collector().get_ran_test_count()))
	lgr.log(_total_fmt( 'Passing Tests', totals.passing_tests))
	_log_non_zero_total('Failing Tests', totals.failing_tests, lgr)
	_log_non_zero_total('Risky/Pending', totals.risky + totals.pending, lgr)
	if(totals.failing == 0):
		lgr.log(_total_fmt( 'Asserts', totals.passing + totals.failing))
	else:
		lgr.log(_total_fmt( 'Asserts', str(totals.passing, '/', totals.passing + totals.failing)))
	_log_non_zero_total( 'Orphans', totals.orphans, lgr)
	lgr.log(_total_fmt( 'Time', str(gut.get_elapsed_time(), 's')))

	return totals


func _log_nothing_run(gut):
	var lgr = gut.get_logger()
	lgr.error("Nothing was run.")
	lgr.log('On the one hand nothing failed, on the other hand nothing did anything.')
	_log_what_was_run(gut)


# ---------------------
# Public
# ---------------------
func log_all_non_passing_tests(gut=_gut):
	var test_collector = gut.get_test_collector()
	var lgr = gut.get_logger()

	var to_return = {
		passing = 0,
		non_passing = 0
	}

	for test_script in test_collector.scripts:
		lgr.set_indent_level(0)

		if(test_script.was_skipped or test_script.get_fail_count() > 0 or test_script.get_pending_count() > 0):
			lgr.log("\n" + test_script.get_full_name(), lgr.fmts.underline)

		if(test_script.was_skipped):
			lgr.inc_indent()
			var skip_msg = str('[Risky] Script was skipped:  ', test_script.skip_reason)
			lgr.log(skip_msg, lgr.fmts.yellow)
			lgr.dec_indent()

		var test_fail_count = 0
		for test in test_script.tests:
			if(test.was_run):
				if(test.is_passing()):
					to_return.passing += 1
				else:
					to_return.non_passing += 1
					lgr.log(str('- ', test.name))
					lgr.inc_indent()

					for i in range(test.fail_texts.size()):
						lgr.failed(test.fail_texts[i])
						test_fail_count += 1
					for i in range(test.pending_texts.size()):
						lgr.pending(test.pending_texts[i])
					if(test.is_risky()):
						lgr.risky('Did not assert')
					lgr.dec_indent()

		if(test_script.get_fail_count() > test_fail_count):
			lgr.failed("before_all/after_all assert failed")

	return to_return


func log_the_final_line(totals, gut):
	var lgr = gut.get_logger()
	var grand_total_text = ""
	var grand_total_fmt = lgr.fmts.none
	if(totals.failing_tests > 0):
		grand_total_text = str(totals.failing_tests, " failing tests")
		grand_total_fmt = lgr.fmts.red
	elif(totals.failing > 0): # no failing tests, but some failing asserts
		grand_total_text = str(totals.failing, " assert(s) in before_all/after_all methods failed")
		grand_total_fmt = lgr.fmts.red
	elif(totals.risky > 0 or totals.pending > 0):
		grand_total_text = str(totals.risky + totals.pending, " pending/risky tests.")
		grand_total_fmt = lgr.fmts.yellow
	else:
		grand_total_text = "All tests passed!"
		grand_total_fmt = lgr.fmts.green

	lgr.log(str("---- ", grand_total_text, " ----"), grand_total_fmt)


func log_totals(gut, totals):
	var lgr = gut.get_logger()
	var orig_indent = lgr.get_indent_level()
	lgr.set_indent_level(0)
	_log_totals(gut, totals)
	lgr.set_indent_level(orig_indent)


func get_totals(gut=_gut):
	var tc = gut.get_test_collector()
	var lgr = gut.get_logger()

	var totals = {
		failing = 0,
		failing_tests = 0,
		passing = 0,
		passing_tests = 0,
		pending = 0,
		risky = 0,
		scripts = tc.get_ran_script_count(),
		tests = 0,

		deprecated = lgr.get_deprecated().size(),
		errors = lgr.get_errors().size(),
		warnings = lgr.get_warnings().size(),
	}

	for s in tc.scripts:
		# assert totals
		totals.passing += s.get_pass_count()
		totals.pending += s.get_pending_count()
		totals.failing += s.get_fail_count()

		# test totals
		totals.tests += s.get_ran_test_count()
		totals.passing_tests += s.get_passing_test_count()
		totals.failing_tests += s.get_failing_test_count()
		totals.risky += s.get_risky_count()

	totals.orphans = gut.get_orphan_counter().orphan_count()

	return totals


func log_end_run(gut=_gut):
	var totals = get_totals(gut)
	if(totals.tests == 0):
		_log_nothing_run(gut)
		return

	_log_end_run_header(gut)
	var lgr = gut.get_logger()

	log_all_non_passing_tests(gut)
	log_totals(gut, totals)
	lgr.log("\n")

	_log_what_was_run(gut)
	log_the_final_line(totals, gut)
	lgr.log("")


--------------------------------------------------
FILE: res:///addons/gut/test.gd
--------------------------------------------------
class_name GutTest
extends Node
## This is the base class for your GUT test scripts.[br]
## [br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br]
## Simple Example
## [codeblock]
##    extends GutTest
##
##    func before_all():
##        gut.p("before_all called"
##
##    func before_each():
##        gut.p("before_each called")
##
##    func after_each():
##        gut.p("after_each called")
##
##    func after_all():
##        gut.p("after_all called")
##
##    func test_assert_eq_letters():
##        assert_eq("asdf", "asdf", "Should pass")
##
##    func test_assert_eq_number_not_equal():
##        assert_eq(1, 2, "Should fail.  1 != 2")
## [/codeblock]


# Normalizes p1 and p2 into object/signal_name/signal_ref(sig).  Additional
# parameters are optional and will be placed into the others array.  This
# class is used in refactoring signal methods to accept a reference to the
# signal instead an object and the signal name.
class SignalAssertParameters:
	var object = null
	var signal_name = null
	var sig = null
	var others := []

	func _init(p1, p2, p3=null, p4=null, p5=null, p6=null):
		others = [p3, p4, p5, p6]
		if(p1 is Signal):
			object = p1.get_object()
			signal_name = p1.get_name()
			others.push_front(p2)
			sig = p1
		else:
			object = p1
			signal_name = p2
			sig = object.get(signal_name)


const EDITOR_PROPERTY = PROPERTY_USAGE_SCRIPT_VARIABLE | PROPERTY_USAGE_DEFAULT
const VARIABLE_PROPERTY = PROPERTY_USAGE_SCRIPT_VARIABLE
# Convenience copy of GutUtils.DOUBLE_STRATEGY
var DOUBLE_STRATEGY = GutUtils.DOUBLE_STRATEGY

## Reference to [addons/gut/parameter_factory.gd] script.
var ParameterFactory = GutUtils.ParameterFactory
## @ignore
var CompareResult = GutUtils.CompareResult
## Reference to [GutInputFactory] class that was originally used to reference
## the Input Factory before the class_name was introduced.
var InputFactory = GutInputFactory
## Reference to [GutInputSender].  This was the way you got to the [GutInputSender]
## before it was given a [code]class_name[/code]
var InputSender = GutUtils.InputSender

# Need a reference to the instance that is running the tests.  This
# is set by the gut class when it runs the test script.
var gut: GutMain = null
# Reference to the collected_script.gd instance that was used to create this.
# This makes getting to meta data about the test easier.  This is set by
# collected_script.get_new().
var collected_script = null
var wait_log_delay = .5 :
	set(val):
		if(_awaiter != null):
			_awaiter.await_logger.wait_log_delay = val
			wait_log_delay = val
var _compare = GutUtils.Comparator.new()
var _disable_strict_datatype_checks = false
# Holds all the text for a test's fail/pass.  This is used for testing purposes
# to see the text of a failed sub-test in test_test.gd
var _fail_pass_text = []
# Summary counts for the test.
var _summary = {
	asserts = 0,
	passed = 0,
	failed = 0,
	tests = 0,
	pending = 0
}

# This is used to watch signals so we can make assertions about them.
var _signal_watcher = load('res://addons/gut/signal_watcher.gd').new()
var _lgr = GutUtils.get_logger()
var _strutils = GutUtils.Strutils.new()
var _awaiter = null
var _was_ready_called = false


# I haven't decided if we should be using _ready or not.  Right now gut.gd will
# call this if _ready was not called (because it was overridden without a super
# call).  Maybe gut.gd should just call _do_ready_stuff (after we rename it to
# something better).  I'm leaving all this as it is until it bothers me more.
func _do_ready_stuff():
	_awaiter = GutUtils.Awaiter.new()
	_awaiter.await_logger.wait_log_delay = wait_log_delay
	add_child(_awaiter)
	_was_ready_called = true


func _ready():
	_do_ready_stuff()


func _notification(what):
	# Tests are never expected to re-enter the tree.  Tests are removed from the
	# tree after they are run.
	if(what == NOTIFICATION_EXIT_TREE):
		# print(_strutils.type2str(self), ':  exit_tree')
		_awaiter.queue_free()
	elif(what == NOTIFICATION_PREDELETE):
		# print(_strutils.type2str(self), ':  predelete')
		if(is_instance_valid(_awaiter)):
			_awaiter.queue_free()


#region Private
# ----------------


func _str(thing):
	return _strutils.type2str(thing)


func _str_precision(value, precision):
	var to_return = _str(value)
	var format = str('%.', precision, 'f')
	if(typeof(value) == TYPE_FLOAT):
		to_return = format % value
	elif(typeof(value) == TYPE_VECTOR2):
		to_return = str('VECTOR2(', format % value.x, ', ', format %value.y, ')')
	elif(typeof(value) == TYPE_VECTOR3):
		to_return = str('VECTOR3(', format % value.x, ', ', format %value.y, ', ', format % value.z, ')')

	return to_return


# Fail an assertion.  Causes test and script to fail as well.
func _fail(text):
	_summary.asserts += 1
	_summary.failed += 1
	_fail_pass_text.append('failed:  ' + text)
	if(gut):
		_lgr.failed(gut.get_call_count_text() + text)
		gut._fail(text)


# Pass an assertion.
func _pass(text):
	_summary.asserts += 1
	_summary.passed += 1
	_fail_pass_text.append('passed:  ' + text)
	if(gut):
		_lgr.passed(text)
		gut._pass(text)


# Checks if the datatypes passed in match.  If they do not then this will cause
# a fail to occur.  If they match then TRUE is returned, FALSE if not.  This is
# used in all the assertions that compare values.
func _do_datatypes_match__fail_if_not(got, expected, text):
	var did_pass = true

	if(!_disable_strict_datatype_checks):
		var got_type = typeof(got)
		var expect_type = typeof(expected)
		if(got_type != expect_type and got != null and expected != null):
			# If we have a mismatch between float and int (types 2 and 3) then
			# print out a warning but do not fail.
			if([2, 3].has(got_type) and [2, 3].has(expect_type)):
				_lgr.warn(str('Warn:  Float/Int comparison.  Got ', _strutils.types[got_type],
					' but expected ', _strutils.types[expect_type]))
			elif([TYPE_STRING, TYPE_STRING_NAME].has(got_type) and [TYPE_STRING, TYPE_STRING_NAME].has(expect_type)):
				pass
			else:
				_fail('Cannot compare ' + _strutils.types[got_type] + '[' + _str(got) + '] to ' + \
					_strutils.types[expect_type] + '[' + _str(expected) + '].  ' + text)
				did_pass = false

	return did_pass


# Create a string that lists all the methods that were called on an spied
# instance.
func _get_desc_of_calls_to_instance(inst):
	var BULLET = '  * '
	var calls = gut.get_spy().get_call_list_as_string(inst)
	# indent all the calls
	calls = BULLET + calls.replace("\n", "\n" + BULLET)
	# remove_at trailing newline and bullet
	calls = calls.substr(0, calls.length() - BULLET.length() - 1)
	return "Calls made on " + str(inst) + "\n" + calls



# Signal assertion helper.  Do not call directly, use _can_make_signal_assertions
func _fail_if_does_not_have_signal(object, signal_name):
	var did_fail = false
	if(!_signal_watcher.does_object_have_signal(object, signal_name)):
		_fail(str('Object ', object, ' does not have the signal [', signal_name, ']'))
		did_fail = true
	return did_fail


# Signal assertion helper.  Do not call directly, use _can_make_signal_assertions
func _fail_if_not_watching(object):
	var did_fail = false
	if(!_signal_watcher.is_watching_object(object)):
		_fail(str('Cannot make signal assertions because the object ', object, \
				' is not being watched.  Call watch_signals(some_object) to be able to make assertions about signals.'))
		did_fail = true
	return did_fail


# Returns text that contains original text and a list of all the signals that
# were emitted for the passed in object.
func _get_fail_msg_including_emitted_signals(text, object):
	return str(text," (Signals emitted: ", _signal_watcher.get_signals_emitted(object), ")")


# This validates that parameters is an array and generates a specific error
# and a failure with a specific message
func _fail_if_parameters_not_array(parameters):
	var invalid = parameters != null and typeof(parameters) != TYPE_ARRAY
	if(invalid):
		_lgr.error('The "parameters" parameter must be an array of expected parameter values.')
		_fail('Cannot compare parameter values because an array was not passed.')
	return invalid


# A bunch of common checkes used when validating a double/method pair.  If
# everything is ok then an empty string is returned, otherwise the message
# is returned.
func _get_bad_method_message(inst, method_name, what_you_cant_do):
	var to_return = ''

	if(!inst.has_method(method_name)):
		to_return = str("You cannot ", what_you_cant_do, " [", method_name, "] because the method does not exist.  ",
			"This can happen if the method is virtual and not overloaded (i.e. _ready) ",
			"or you have mistyped the name of the method.")
	elif(!inst.__gutdbl_values.doubled_methods.has(method_name)):
		to_return = str("You cannot ", what_you_cant_do, " [", method_name, "] because ",
			_str(inst), ' does not overload it or it was ignored with ',
			'ignore_method_when_doubling.  See Doubling ',
			'Strategy in the wiki for details on including non-overloaded ',
			'methods in a double.')

	return to_return


func _fail_if_not_double_or_does_not_have_method(inst, method_name):
	var to_return = OK

	if(!GutUtils.is_double(inst)):
		_fail(str("An instance of a Double was expected, you passed:  ", _str(inst)))
		to_return = ERR_INVALID_DATA
	else:
		var msg = _get_bad_method_message(inst, method_name, 'spy on')
		if(msg != ''):
			_fail(msg)
			to_return = ERR_INVALID_DATA

	return to_return


func _create_obj_from_type(type):
	var obj = null
	if type.is_class("PackedScene"):
		obj = type.instantiate()
		add_child(obj)
	else:
		obj = type.new()
	return obj


# Converts a Callabe passed through inst or inst/method_name/parameters into a
# hash so that methods that interact with Spy can accept both more easily.
func _convert_spy_args(inst, method_name, parameters):
	var to_return = {
		'object':inst,
		'method_name':method_name,
		'arguments':parameters,
		'invalid_message':'ok'
	}

	if(inst is Callable):
		if(parameters != null):
			to_return.invalid_message =\
				"3rd parameter to assert_called not supported when using a Callable."
		elif(method_name != null):
			to_return.invalid_message =\
				"2nd parameter to assert_called not supported when using a Callable."
		else:
			if(inst.get_bound_arguments_count() > 0):
				to_return.arguments = inst.get_bound_arguments()
			to_return.method_name = inst.get_method()
			to_return.object = inst.get_object()

	return to_return


func _get_typeof_string(the_type):
	var to_return = ""
	if(_strutils.types.has(the_type)):
		to_return += str(the_type, '(',  _strutils.types[the_type], ')')
	else:
		to_return += str(the_type)
	return to_return


# Validates the singleton_name is a string and exists.  Errors when conditions
# are not met.  Returns true/false if singleton_name is valid or not.
func _validate_singleton_name(singleton_name):
	var is_valid = true
	if(typeof(singleton_name) != TYPE_STRING):
		_lgr.error("double_singleton requires a Godot singleton name, you passed " + _str(singleton_name))
		is_valid = false
	# Sometimes they have underscores in front of them, sometimes they do not.
	# The doubler is smart enought of ind the right thing, so this has to be
	# that smart as well.
	elif(!ClassDB.class_exists(singleton_name) and !ClassDB.class_exists('_' + singleton_name)):
		var txt = str("The singleton [", singleton_name, "] could not be found.  ",
					"Check the GlobalScope page for a list of singletons.")
		_lgr.error(txt)
		is_valid = false
	return is_valid


# Checks the object for 'get_' and 'set_' methods for the specified property.
# If found a warning is generated.
func _warn_for_public_accessors(obj, property_name):
	var public_accessors = []
	var accessor_names = [
		str('get_', property_name),
		str('is_', property_name),
		str('set_', property_name)
	]

	for acc in accessor_names:
		if(obj.has_method(acc)):
			public_accessors.append(acc)

	if(public_accessors.size() > 0):
		_lgr.warn (str('Public accessors ', public_accessors, ' found for property ', property_name))


func _smart_double(thing, double_strat, partial):
	var override_strat = GutUtils.nvl(double_strat, gut.get_doubler().get_strategy())
	var to_return = null

	if(thing is PackedScene):
		if(partial):
			to_return =  gut.get_doubler().partial_double_scene(thing, override_strat)
		else:
			to_return =  gut.get_doubler().double_scene(thing, override_strat)

	elif(GutUtils.is_native_class(thing)):
		if(partial):
			to_return = gut.get_doubler().partial_double_gdnative(thing)
		else:
			to_return = gut.get_doubler().double_gdnative(thing)

	elif(thing is GDScript):
		if(partial):
			to_return = gut.get_doubler().partial_double(thing, override_strat)
		else:
			to_return = gut.get_doubler().double(thing, override_strat)

	return to_return


# This is here to aid in the transition to the new doubling sytnax.  Once this
# has been established it could be removed.  We must keep the is_instance check
# going forward though.
func _are_double_parameters_valid(thing, p2, p3):
	var bad_msg = ""
	if(p3 != null or typeof(p2) == TYPE_STRING):
		bad_msg += "Doubling using a subpath is not supported.  Call register_inner_class and then pass the Inner Class to double().\n"

	if(typeof(thing) == TYPE_STRING):
		bad_msg += "Doubling using the path to a script or scene is no longer supported.  Load the script or scene and pass that to double instead.\n"

	if(GutUtils.is_instance(thing)):
		bad_msg += "double requires a script, you passed an instance:  " + _str(thing)

	if(bad_msg != ""):
		_lgr.error(bad_msg)

	return bad_msg == ""

# ----------------
#endregion
#region Virtual Methods
# ----------------

## Virtual Method.  This is run after the script has been prepped for execution, but before `before_all` is executed.  If you implement this method and return `true` or a `String` (the string is displayed in the log) then GUT will stop executing the script and mark it as risky.  You might want to do this because:
## - You are porting tests from 3.x to 4.x and you don't want to comment everything out.[br]
## - Skipping tests that should not be run when in `headless` mode such as input testing that does not work in headless.[br]
## [codeblock]
##    func should_skip_script():
##        if DisplayServer.get_name() == "headless":
##            return "Skip Input tests when running headless"
## [/codeblock]
## - If you have tests that would normally cause the debugger to break on an error, you can skip the script if the debugger is enabled so that the run is not interrupted.[br]
## [codeblock]
##    func should_skip_script():
##        return EngineDebugger.is_active()
## [/codeblock]
func should_skip_script():
	return false


## Virtual method.  Run once before anything else in the test script is run.
func before_all():
	pass


## Virtual method.  Run before each test is executed
func before_each():
	pass

## Virtual method.  Run after each test is executed.
func after_each():
	pass


## Virtual method.  Run after all tests have been run.
func after_all():
	pass

# ----------------
#endregion
#region Misc Public
# ----------------
## Mark the current test as pending.
func pending(text=""):
	_summary.pending += 1
	if(gut):
		_lgr.pending(text)
		gut._pending(text)


## Returns true if the test is passing as of the time of this call.  False if not.
func is_passing():
	if(gut.get_current_test_object() != null and
		!['before_all', 'after_all'].has(gut.get_current_test_object().name)):
		return gut.get_current_test_object().is_passing() and \
			gut.get_current_test_object().assert_count > 0
	else:
		_lgr.error('No current test object found.  is_passing must be called inside a test.')
		return null


## Returns true if the test is failing as of the time of this call.  False if not.
func is_failing():
	if(gut.get_current_test_object() != null and
		!['before_all', 'after_all'].has(gut.get_current_test_object().name)):

		return gut.get_current_test_object().is_failing()
	else:
		_lgr.error('No current test object found.  is_failing must be called inside a test.')
		return null


## Marks the test as passing.  Does not override any failing asserts or calls to
## fail_test.  Same as a passing assert.
func pass_test(text):
	_pass(text)


## Marks the test as failing.  Same as a failing assert.
func fail_test(text):
	_fail(text)

## @internal
func clear_signal_watcher():
	_signal_watcher.clear()


## Returns the current double strategy.
func get_double_strategy():
	return gut.get_doubler().get_strategy()


## Sets the double strategy for all tests in the script.  This should usually
## be done in [method before_all].  The double strtegy can be set per
## run/script/double.  See [wiki]Double-Strategy[/wiki]
func set_double_strategy(double_strategy):
	gut.get_doubler().set_strategy(double_strategy)


## This method will cause Gut to pause before it moves on to the next test.
## This is useful for debugging, for instance if you want to investigate the
## screen or anything else after a test has finished executing.
## [br]
## Sometimes you get lazy, and you don't remove calls to
## [code skip-lint]pause_before_teardown[/code] after you are done with them.  You can
## tell GUT to ignore calls to this method through the panel or
## the command line.  Setting this in your `.gutconfig.json` file is recommended
## for CI/CD Pipelines.
func pause_before_teardown():
	gut.pause_before_teardown()


## @internal
func get_logger():
	return _lgr

## @internal
func set_logger(logger):
	_lgr = logger


## This must be called in order to make assertions based on signals being
## emitted.  __Right now, this only supports signals that are emitted with 9 or
## less parameters.__  This can be extended but nine seemed like enough for now.
## The Godot documentation suggests that the limit is four but in my testing
## I found you can pass more.
## [br]
## This must be called in each test in which you want to make signal based
## assertions in.  You can call it multiple times with different objects.
## You should not call it multiple times with the same object in the same test.
## The objects that are watched are cleared after each test (specifically right
## before `teardown` is called).  Under the covers, Gut will connect to all the
## signals an object has and it will track each time they fire.  You can then
## use the following asserts and methods to verify things are acting correct.
func watch_signals(object):
	_signal_watcher.watch_signals(object)


## This will return the number of times a signal was fired.  This gives you
## the freedom to make more complicated assertions if the spirit moves you.
## This will return -1 if the signal was not fired or the object was not being
## watched, or if the object does not have the signal.
## [br][br]
## Accepts either the object and the signal name or the signal.
func get_signal_emit_count(p1, p2=null):
	var sp = SignalAssertParameters.new(p1, p2)
	return _signal_watcher.get_emit_count(sp.object, sp.signal_name)


## If you need to inspect the parameters in order to make more complicate assertions, then this will give you access to
## the parameters of any watched signal.  This works the same way that
## [code skip-lint]assert_signal_emitted_with_parameters[/code] does.  It takes an object, signal name, and an optional
## index.  If the index is not specified then the parameters from the most recent emission will be returned.  If the
## object is not being watched, the signal was not fired, or the object does not have the signal then `null` will be
## returned.
##
## [br][br]
## [b]Signatures:[/b][br]
## - get_signal_parameters([param p1]:Signal, [param p2]:parameter-index (optional))[br]
## - get_signal_parameters([param p1]:object, [param p2]:signal name, [param p3]:parameter-index (optional)) [br]
## [br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_get_signal_parameters():
##     var obj = SignalObject.new()
##     watch_signals(obj)
##     obj.some_signal.emit(1, 2, 3)
##     obj.some_signal.emit('a', 'b', 'c')
##
##     # -- Passing --
##     # passes because get_signal_parameters returns the most recent emission
##     # by default
##     assert_eq(get_signal_parameters(obj, 'some_signal'), ['a', 'b', 'c'])
##     assert_eq(get_signal_parameters(obj.some_signal), ['a', 'b', 'c'])
##
##     assert_eq(get_signal_parameters(obj, 'some_signal', 0), [1, 2, 3])
##     assert_eq(get_signal_parameters(obj.some_signal, 0), [1, 2, 3])
##
##     # if the signal was not fired null is returned
##     assert_null(get_signal_parameters(obj, 'other_signal'))
##     # if the signal does not exist or isn't being watched null is returned
##     assert_null(get_signal_parameters(obj, 'signal_dne'))
##
##     # -- Failing --
##     assert_eq(get_signal_parameters(obj, 'some_signal'), [1, 2, 3])
##     assert_eq(get_signal_parameters(obj.some_signal, 0), ['a', 'b', 'c'])
## [/codeblock]
func get_signal_parameters(p1, p2=null, p3=-1):
	var sp := SignalAssertParameters.new(p1, GutUtils.nvl(p2, -1), p3)
	return _signal_watcher.get_signal_parameters(sp.object, sp.signal_name, sp.others[0])


## Get the parameters for a method call to a doubled object.  By default it will
## return the most recent call.  You can optionally specify an index for which
## call you want to get the parameters for.
##
## Can be called using a Callable for the first parameter instead of specifying
## an object and method name.  When you do this, the seoncd parameter is used
## as the index.
##
## Returns:
## * an array of parameter values if a call the method was found
## * null when a call to the method was not found or the index specified was
##   invalid.
func get_call_parameters(object, method_name_or_index = -1, idx=-1):
	var to_return = null
	var index = idx
	if(object is Callable):
		index = method_name_or_index
		method_name_or_index = null
	var converted = _convert_spy_args(object, method_name_or_index, null)

	if(GutUtils.is_double(converted.object)):
		to_return = gut.get_spy().get_call_parameters(
			converted.object, converted.method_name, index)
	else:
		_lgr.error('You must pass a doulbed object to get_call_parameters.')

	return to_return


## Returns the call count for a method with optional paramter matching.
##
## Can be called with a Callable instead of an object, method_name, and
## parameters.  Bound arguments will be used to match call arguments.
func get_call_count(object, method_name=null, parameters=null):
	var converted = _convert_spy_args(object, method_name, parameters)
	return gut.get_spy().call_count(converted.object, converted.method_name, converted.arguments)


## Simulate a number of frames by calling '_process' and '_physics_process' (if
## the methods exist) on an object and all of its descendents. The specified frame
## time, 'delta', will be passed to each simulated call.
##
## NOTE: Objects can disable their processing methods using 'set_process(false)' and
## 'set_physics_process(false)'. This is reflected in the 'Object' methods
## 'is_processing()' and 'is_physics_processing()', respectively. To make 'simulate'
## respect this status, for example if you are testing an object which toggles
## processing, pass 'check_is_processing' as 'true'.
func simulate(obj, times, delta, check_is_processing: bool = false):
	gut.simulate(obj, times, delta, check_is_processing)


# ------------------------------------------------------------------------------
## Replace the node at base_node.get_node(path) with with_this.  All references
## to the node via $ and get_node(...) will now return with_this.  with_this will
## get all the groups that the node that was replaced had.
## [br]
## The node that was replaced is queued to be freed.
## [br]
## TODO see replace_by method, this could simplify the logic here.
# ------------------------------------------------------------------------------
func replace_node(base_node, path_or_node, with_this):
	var path = path_or_node

	if(typeof(path_or_node) != TYPE_STRING):
		# This will cause an engine error if it fails.  It always returns a
		# NodePath, even if it fails.  Checking the name count is the only way
		# I found to check if it found something or not (after it worked I
		# didn't look any farther).
		path = base_node.get_path_to(path_or_node)
		if(path.get_name_count() == 0):
			_lgr.error('You passed an object that base_node does not have.  Cannot replace node.')
			return

	if(!base_node.has_node(path)):
		_lgr.error(str('Could not find node at path [', path, ']'))
		return

	var to_replace = base_node.get_node(path)
	var parent = to_replace.get_parent()
	var replace_name = to_replace.get_name()

	parent.remove_child(to_replace)
	parent.add_child(with_this)
	with_this.set_name(replace_name)
	with_this.set_owner(parent)

	var groups = to_replace.get_groups()
	for i in range(groups.size()):
		with_this.add_to_group(groups[i])

	to_replace.queue_free()


## Use this as the default value for the first parameter to a test to create
## a parameterized test.  See also the ParameterFactory and Parameterized Tests.
## [br][br]
## [b]Example[/b]
## [codeblock]
##    func test_with_parameters(p = use_parameters([1, 2, 3])):
## [/codeblock]
func use_parameters(params):
	var ph = gut.parameter_handler
	if(ph == null):
		ph = GutUtils.ParameterHandler.new(params)
		gut.parameter_handler = ph

	# DO NOT use gut.gd's get_call_count_text here since it decrements the
	# get_call_count value.  This method increments the call count in its
	# return statement.
	var output = str('- params[', ph.get_call_count(), ']','(', ph.get_current_parameters(), ')')
	gut.p(output, gut.LOG_LEVEL_TEST_AND_FAILURES)

	return ph.next_parameters()


## @internal
## When used as the default for a test method parameter, it will cause the test
## to be run x times.
##
## I Hacked this together to test a method that was occassionally failing due to
## timing issues.  I don't think it's a great idea, but you be the judge.  If
## you find a good use for it, let me know and I'll make it a legit member
## of the api.
func run_x_times(x):
	var ph = gut.parameter_handler
	if(ph == null):
		_lgr.warn(
			str("This test uses run_x_times and you really should not be ",
			"using it.  I don't think it's a good thing, but I did find it ",
			"temporarily useful so I left it in here and didn't document it.  ",
			"Well, you found it, might as well open up an issue and let me ",
			"know why you're doing this."))
		var params = []
		for i in range(x):
			params.append(i)

		ph = GutUtils.ParameterHandler.new(params)
		gut.parameter_handler = ph
	return ph.next_parameters()


## Checks the passed in version string (x.x.x) against the engine version to see
## if the engine version is less than the expected version.  If it is then the
## test is mareked as passed (for a lack of anything better to do).  The result
## of the check is returned.
## [br][br]
## [b]Example[/b]
## [codeblock]
##    if(skip_if_godot_version_lt('3.5.0')):
##        return
## [/codeblock]
func skip_if_godot_version_lt(expected):
	var should_skip = !GutUtils.is_godot_version_gte(expected)
	if(should_skip):
		_pass(str('Skipping: ', GutUtils.godot_version_string(), ' is less than ', expected))
	return should_skip


## Checks if the passed in version matches the engine version.  The passed in
## version can contain just the major, major.minor or major.minor.path.  If
## the version is not the same then the test is marked as passed.  The result of
## the check is returned.
## [br][br]
## [b]Example[/b]
## [codeblock]
##     if(skip_if_godot_version_ne('3.4')):
##        return
## [/codeblock]
func skip_if_godot_version_ne(expected):
	var should_skip = !GutUtils.is_godot_version(expected)
	if(should_skip):
		_pass(str('Skipping: ', GutUtils.godot_version_string(), ' is not ', expected))
	return should_skip


## Registers all the inner classes in a script with the doubler.  This is required
## before you can double any inner class.
func register_inner_classes(base_script):
	gut.get_doubler().inner_class_registry.register(base_script)


## Peforms a deep compare on both values, a CompareResult instnace is returned.
## The optional max_differences paramter sets the max_differences to be displayed.
func compare_deep(v1, v2, max_differences=null):
	var result = _compare.deep(v1, v2)
	if(max_differences != null):
		result.max_differences = max_differences
	return result


# ----------------
#endregion
#region Asserts
# ----------------

## Asserts that the expected value equals the value got.
## assert got == expected and prints optional text.  See [wiki]Comparing-Things[/wiki]
## for information about comparing dictionaries and arrays.
## [br]
## See also: [method assert_ne], [method assert_same], [method assert_not_same]
## [codeblock]
##    var one = 1
##    var node1 = Node.new()
##    var node2 = node1
##
##    # Passing
##    assert_eq(one, 1, 'one should equal one')
##    assert_eq('racecar', 'racecar')
##    assert_eq(node2, node1)
##    assert_eq([1, 2, 3], [1, 2, 3])
##    var d1_pass = {'a':1}
##    var d2_pass = d1_pass
##    assert_eq(d1_pass, d2_pass)
##
##    # Failing
##    assert_eq(1, 2) # FAIL
##    assert_eq('hello', 'world')
##    assert_eq(self, node1)
##    assert_eq([1, 'two', 3], [1, 2, 3, 4])
##    assert_eq({'a':1}, {'a':1})
## [/codeblock]
func assert_eq(got, expected, text=""):

	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		var disp = "[" + _str(got) + "] expected to equal [" + _str(expected) + "]:  " + text
		var result = null

		result = _compare.simple(got, expected)

		if(typeof(got) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			disp = str(result.summary, '  ', text)
			_lgr.info('Array/Dictionary compared by value.  Use assert_same to compare references.  Use assert_eq_deep to see diff when failing.')

		if(result.are_equal):
			_pass(disp)
		else:
			_fail(disp)


## asserts got != expected and prints optional text.  See
## [wiki]Comparing-Things[/wiki] for information about comparing dictionaries
## and arrays.
##[br]
## See also: [method assert_eq], [method assert_same], [method assert_not_same]
## [codeblock]
##    var two = 2
##    var node1 = Node.new()
##
##    # Passing
##    assert_ne(two, 1, 'Two should not equal one.')
##    assert_ne('hello', 'world')
##    assert_ne(self, node1)
##
##    # Failing
##    assert_ne(two, 2)
##    assert_ne('one', 'one')
##    assert_ne('2', 2)
## [/codeblock]
func assert_ne(got, not_expected, text=""):
	if(_do_datatypes_match__fail_if_not(got, not_expected, text)):
		var disp = "[" + _str(got) + "] expected to not equal [" + _str(not_expected) + "]:  " + text
		var result = null

		result = _compare.simple(got, not_expected)

		if(typeof(got) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			disp = str(result.summary, '  ', text)
			_lgr.info('Array/Dictionary compared by value.  Use assert_not_same to compare references.  Use assert_ne_deep to see diff.')

		if(result.are_equal):
			_fail(disp)
		else:
			_pass(disp)


## Asserts that [param got] is within the range of [param expected] +/- [param error_interval].
## The upper and lower bounds are included in the check.  Verified to work with
## integers, floats, and Vector2.  Should work with anything that can be
## added/subtracted.
##
## [codeblock]
##    # Passing
##    assert_almost_eq(0, 1, 1, '0 within range of 1 +/- 1')
##    assert_almost_eq(2, 1, 1, '2 within range of 1 +/- 1')
##    assert_almost_eq(1.2, 1.0, .5, '1.2 within range of 1 +/- .5')
##    assert_almost_eq(.5, 1.0, .5, '.5 within range of 1 +/- .5')
##    assert_almost_eq(Vector2(.5, 1.5), Vector2(1.0, 1.0), Vector2(.5, .5))
##    assert_almost_eq(Vector2(.5, 1.5), Vector2(1.0, 1.0), Vector2(.25, .25))
##
##    # Failing
##    assert_almost_eq(1, 3, 1, '1 outside range of 3 +/- 1')
##    assert_almost_eq(2.6, 3.0, .2, '2.6 outside range of 3 +/- .2')
## [/codeblock]
func assert_almost_eq(got, expected, error_interval, text=''):
	var disp = "[" + _str_precision(got, 20) + "] expected to equal [" + _str(expected) + "] +/- [" + str(error_interval) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text) and _do_datatypes_match__fail_if_not(got, error_interval, text)):
		if not _is_almost_eq(got, expected, error_interval):
			_fail(disp)
		else:
			_pass(disp)


## This is the inverse of [method assert_almost_eq].  This will pass if [param got] is
## outside the range of [param not_expected] +/- [param error_interval].
func assert_almost_ne(got, not_expected, error_interval, text=''):
	var disp = "[" + _str_precision(got, 20) + "] expected to not equal [" + _str(not_expected) + "] +/- [" + str(error_interval) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, not_expected, text) and _do_datatypes_match__fail_if_not(got, error_interval, text)):
		if _is_almost_eq(got, not_expected, error_interval):
			_fail(disp)
		else:
			_pass(disp)

# ------------------------------------------------------------------------------
# Helper function compares a value against a expected and a +/- range.  Compares
# all components of Vector2, Vector3, and Vector4 as well.
# ------------------------------------------------------------------------------
func _is_almost_eq(got, expected, error_interval) -> bool:
	var result = false
	var upper = expected + error_interval
	var lower = expected - error_interval

	if typeof(got) in [TYPE_VECTOR2, TYPE_VECTOR3, TYPE_VECTOR4]:
		result = got.clamp(lower, upper) == got
	else:
		result = got >= (lower) and got <= (upper)

	return(result)

## assserts got > expected
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_gt(bigger, smaller, 'Bigger should be greater than smaller')
##    assert_gt('b', 'a')
##    assert_gt('a', 'A')
##    assert_gt(1.1, 1)
##
##    # Failing
##    assert_gt('a', 'a')
##    assert_gt(1.0, 1)
##    assert_gt(smaller, bigger)
## [/codeblock]
func assert_gt(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be > than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got > expected):
			_pass(disp)
		else:
			_fail(disp)


## Asserts got is greater than or equal to expected.
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_gte(bigger, smaller, 'Bigger should be greater than or equal to smaller')
##    assert_gte('b', 'a')
##    assert_gte('a', 'A')
##    assert_gte(1.1, 1)
##    assert_gte('a', 'a')
##
##    # Failing
##    assert_gte(0.9, 1.0)
##    assert_gte(smaller, bigger)
## [/codeblock]
func assert_gte(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be >= than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got >= expected):
			_pass(disp)
		else:
			_fail(disp)

## Asserts [param got] is less than [param expected]
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_lt(smaller, bigger, 'Smaller should be less than bigger')
##    assert_lt('a', 'b')
##    assert_lt(99, 100)
##
##    # Failing
##    assert_lt('z', 'x')
##    assert_lt(-5, -5)
## [/codeblock]
func assert_lt(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be < than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got < expected):
			_pass(disp)
		else:
			_fail(disp)


## Asserts got is less than or equal to expected
func assert_lte(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be <= than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got <= expected):
			_pass(disp)
		else:
			_fail(disp)


## asserts that got is true.  Does not assert truthiness, only boolean values
## will pass.
func assert_true(got, text=""):
	if(typeof(got) == TYPE_BOOL):
		if(got):
			_pass(text)
		else:
			_fail(text)
	else:
		var msg = str("Cannot convert ", _strutils.type2str(got), " to boolean")
		_fail(msg)


## Asserts that got is false.  Does not assert truthiness, only boolean values
## will pass.
func assert_false(got, text=""):
	if(typeof(got) == TYPE_BOOL):
		if(got):
			_fail(text)
		else:
			_pass(text)
	else:
		var msg = str("Cannot convert ", _strutils.type2str(got), " to boolean")
		_fail(msg)


## Asserts value is between (inclusive) the two expected values.[br]
## got >= expect_low and <= expect_high
## [codeblock]
##    # Passing
##    assert_between(5, 0, 10, 'Five should be between 0 and 10')
##    assert_between(10, 0, 10)
##    assert_between(0, 0, 10)
##    assert_between(2.25, 2, 4.0)
##
##    # Failing
##    assert_between('a', 'b', 'c')
##    assert_between(1, 5, 10)
## [/codeblock]
func assert_between(got, expect_low, expect_high, text=""):
	var disp = "[" + _str_precision(got, 20) + "] expected to be between [" + _str(expect_low) + "] and [" + str(expect_high) + "]:  " + text

	if(_do_datatypes_match__fail_if_not(got, expect_low, text) and _do_datatypes_match__fail_if_not(got, expect_high, text)):
		if(expect_low > expect_high):
			disp = "INVALID range.  [" + str(expect_low) + "] is not less than [" + str(expect_high) + "]"
			_fail(disp)
		else:
			if(got < expect_low or got > expect_high):
				_fail(disp)
			else:
				_pass(disp)


## Asserts value is not between (exclusive) the two expected values.[br]
## asserts that got <= expect_low or got >=  expect_high.
## [codeblock]
##    # Passing
##    assert_not_between(1, 5, 10)
##    assert_not_between('a', 'b', 'd')
##    assert_not_between('d', 'b', 'd')
##    assert_not_between(10, 0, 10)
##    assert_not_between(-2, -2, 10)
##
##    # Failing
##    assert_not_between(5, 0, 10, 'Five shouldnt be between 0 and 10')
##    assert_not_between(0.25, -2.0, 4.0)
## [/codeblock]
func assert_not_between(got, expect_low, expect_high, text=""):
	var disp = "[" + _str_precision(got, 20) + "] expected not to be between [" + _str(expect_low) + "] and [" + str(expect_high) + "]:  " + text

	if(_do_datatypes_match__fail_if_not(got, expect_low, text) and _do_datatypes_match__fail_if_not(got, expect_high, text)):
		if(expect_low > expect_high):
			disp = "INVALID range.  [" + str(expect_low) + "] is not less than [" + str(expect_high) + "]"
			_fail(disp)
		else:
			if(got > expect_low and got < expect_high):
				_fail(disp)
			else:
				_pass(disp)


## Uses the 'has' method of the object passed in to determine if it contains
## the passed in element.
## [codeblock]
##    var an_array = [1, 2, 3, 'four', 'five']
##    var a_hash = { 'one':1, 'two':2, '3':'three'}
##
##    # Passing
##    assert_has(an_array, 'four') # PASS
##    assert_has(an_array, 2) # PASS
##    # the hash's has method checks indexes not values
##    assert_has(a_hash, 'one') # PASS
##    assert_has(a_hash, '3') # PASS
##
##    # Failing
##    assert_has(an_array, 5) # FAIL
##    assert_has(an_array, self) # FAIL
##    assert_has(a_hash, 3) # FAIL
##    assert_has(a_hash, 'three') # FAIL
## [/codeblock]
func assert_has(obj, element, text=""):
	var disp = str('Expected [', _str(obj), '] to contain value:  [', _str(element), ']:  ', text)
	if(obj.has(element)):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of assert_has.
func assert_does_not_have(obj, element, text=""):
	var disp = str('Expected [', _str(obj), '] to NOT contain value:  [', _str(element), ']:  ', text)
	if(obj.has(element)):
		_fail(disp)
	else:
		_pass(disp)


## asserts a file exists at the specified path
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_exists():
##        # Passing
##        assert_file_exists('res://addons/gut/gut.gd')
##        assert_file_exists('user://some_test_file')
##
##        # Failing
##        assert_file_exists('user://file_does_not.exist')
##        assert_file_exists('res://some_dir/another_dir/file_does_not.exist')
## [/codeblock]
func assert_file_exists(file_path):
	var disp = 'expected [' + file_path + '] to exist.'
	if(FileAccess.file_exists(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## asserts a file does not exist at the specified path
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_does_not_exist():
##        # Passing
##        assert_file_does_not_exist('user://file_does_not.exist')
##        assert_file_does_not_exist('res://some_dir/another_dir/file_does_not.exist')
##
##        # Failing
##        assert_file_does_not_exist('res://addons/gut/gut.gd')
## [/codeblock]
func assert_file_does_not_exist(file_path):
	var disp = 'expected [' + file_path + '] to NOT exist'
	if(!FileAccess.file_exists(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## asserts the specified file is empty
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_empty():
##        # Passing
##        assert_file_empty('user://some_test_file')
##
##        # Failing
##        assert_file_empty('res://addons/gut/gut.gd')
## [/codeblock]
func assert_file_empty(file_path):
	var disp = 'expected [' + file_path + '] to be empty'
	if(FileAccess.file_exists(file_path) and gut.is_file_empty(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts the specified file is not empty
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_not_empty():
##        # Passing
##        assert_file_not_empty('res://addons/gut/gut.gd') # PASS
##
##        # Failing
##        assert_file_not_empty('user://some_test_file') # FAIL
## [/codeblock]
func assert_file_not_empty(file_path):
	var disp = 'expected [' + file_path + '] to contain data'
	if(!gut.is_file_empty(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts that the passed in object has a method named [param method].
func assert_has_method(obj, method, text=''):
	var disp = _str(obj) + ' should have method: ' + method
	if(text != ''):
		disp = _str(obj) + ' ' + text
	assert_true(obj.has_method(method), disp)


## This is meant to make testing public get/set methods for a member variable.  This was originally created for early Godot 3.x setter and getter methods.  See [method assert_property] for verifying Godot 4.x accessors.  This makes multiple assertions to verify:
## [br]
## [li]The object has a method called [code]get_<PROPERTY_NAME>[/code][/li]
## [li]The object has a method called [code]set_<PROPERTY_NAME>[/code][/li]
## [li]The method [code]get_<PROPERTY_NAME>[/code] returns the expected default value when first called.[/li]
## [li]Once you set the property, the [code]get_<PROPERTY_NAME>[/code] returns the new value.[/li]
## [br]
func assert_accessors(obj, property, default, set_to):
	var fail_count = _summary.failed
	var get_func = 'get_' + property
	var set_func = 'set_' + property

	if(obj.has_method('is_' + property)):
		get_func = 'is_' + property

	assert_has_method(obj, get_func, 'should have getter starting with get_ or is_')
	assert_has_method(obj, set_func)
	# SHORT CIRCUIT
	if(_summary.failed > fail_count):
		return
	assert_eq(obj.call(get_func), default, 'It should have the expected default value.')
	obj.call(set_func, set_to)
	assert_eq(obj.call(get_func), set_to, 'The set value should have been returned.')


# Property search helper.  Used to retrieve Dictionary of specified property
# from passed object. Returns null if not found.
# If provided, property_usage constrains the type of property returned by
# passing either:
# EDITOR_PROPERTY for properties defined as: export var some_value: int
# VARIABLE_PROPERTY for properties defined as: var another_value
func _find_object_property(obj, property_name, property_usage=null):
	var result = null
	var found = false
	var properties = obj.get_property_list()

	while !found and !properties.is_empty():
		var property = properties.pop_back()
		if property['name'] == property_name:
			if property_usage == null or property['usage'] == property_usage:
				result = property
				found = true
	return result


## Asserts that [param obj] exports a property with the name
## [param property_name] and a type of [param type].  The [param type] must be
## one of the various Godot built-in [code]TYPE_[/code] constants.
## [codeblock]
##    class ExportClass:
##        export var some_number = 5
##        export(PackedScene) var some_scene
##        var some_variable = 1
##
##    func test_assert_exports():
##        var obj = ExportClass.new()
##
##        # Passing
##        assert_exports(obj, "some_number", TYPE_INT)
##        assert_exports(obj, "some_scene", TYPE_OBJECT)
##
##        # Failing
##        assert_exports(obj, 'some_number', TYPE_VECTOR2)
##        assert_exports(obj, 'some_scene', TYPE_AABB)
##        assert_exports(obj, 'some_variable', TYPE_INT)
## [/codeblock]
func assert_exports(obj, property_name, type):
	var disp = 'expected %s to have editor property [%s]' % [_str(obj), property_name]
	var property = _find_object_property(obj, property_name, EDITOR_PROPERTY)
	if property != null:
		disp += ' of type [%s]. Got type [%s].' % [_strutils.types[type], _strutils.types[property['type']]]
		if property['type'] == type:
			_pass(disp)
		else:
			_fail(disp)
	else:
		_fail(disp)


# Signal assertion helper.
#
# Verifies that the object and signal are valid for making signal assertions.
# This will fail with specific messages that indicate why they are not valid.
# This returns true/false to indicate if the object and signal are valid.
func _can_make_signal_assertions(object, signal_name):
	return !(_fail_if_not_watching(object) or _fail_if_does_not_have_signal(object, signal_name))


# Check if an object is connected to a signal on another object. Returns True
# if it is and false otherwise
func _is_connected(signaler_obj, connect_to_obj, signal_name, method_name=""):
	if(method_name != ""):
		return signaler_obj.is_connected(signal_name,Callable(connect_to_obj,method_name))
	else:
		var connections = signaler_obj.get_signal_connection_list(signal_name)
		for conn in connections:
			if(conn['signal'].get_name() == signal_name and conn['callable'].get_object() == connect_to_obj):
				return true
		return false


## Asserts that `signaler_obj` is connected to `connect_to_obj` on signal `signal_name`.  The method that is connected is optional.  If `method_name` is supplied then this will pass only if the signal is connected to the  method.  If it is not provided then any connection to the signal will cause a pass.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_connected([param p1]:Signal, [param p2]:connected-object)[br]
## - assert_connected([param p1]:Signal, [param p2]:connected-method)[br]
## - assert_connected([param p1]:object, [param p2]:connected-object, [param p3]:signal-name, [param p4]: connected-method-name <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class Signaler:
##     signal the_signal
##
## class Connector:
##     func connect_this():
##         pass
##     func  other_method():
##         pass
##
## func test_assert_connected():
##     var signaler = Signaler.new()
##     var connector  = Connector.new()
##     signaler.the_signal.connect(connector.connect_this)
##
##     # Passing
##     assert_connected(signaler.the_signal, connector.connect_this)
##     assert_connected(signaler.the_signal, connector)
##     assert_connected(signaler, connector, 'the_signal')
##     assert_connected(signaler, connector, 'the_signal', 'connect_this')
##
##     # Failing
##     assert_connected(signaler.the_signal, connector.other_method)
##
##     var foo = Connector.new()
##     assert_connected(signaler,  connector, 'the_signal', 'other_method')
##     assert_connected(signaler, connector, 'other_signal')
##     assert_connected(signaler, foo, 'the_signal')
## [/codeblock]
func assert_connected(p1, p2, p3=null, p4=""):
	var sp := SignalAssertParameters.new(p1, p3)
	var connect_to_obj = p2
	var method_name = p4

	if(connect_to_obj is  Callable):
		method_name = connect_to_obj.get_method()
		connect_to_obj = connect_to_obj.get_object()

	var method_disp = ''
	if (method_name != ""):
		method_disp = str(' using method: [', method_name, '] ')
	var disp = str('Expected object ', _str(sp.object),\
		' to be connected to signal: [', sp.signal_name, '] on ',\
		_str(connect_to_obj), method_disp)
	if(_is_connected(sp.object, connect_to_obj, sp.signal_name, method_name)):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of [method assert_connected].  See [method assert_connected] for parameter syntax.
## [br]
## This will fail with specific messages if the target object is connected to the specified signal on the source object.
func assert_not_connected(p1, p2, p3=null, p4=""):
	var sp := SignalAssertParameters.new(p1, p3)
	var connect_to_obj = p2
	var method_name = p4

	if(connect_to_obj is  Callable):
		method_name = connect_to_obj.get_method()
		connect_to_obj = connect_to_obj.get_object()

	var method_disp = ''
	if (method_name != ""):
		method_disp = str(' using method: [', method_name, '] ')
	var disp = str('Expected object ', _str(sp.object),\
		' to not be connected to signal: [', sp.signal_name, '] on ',\
		_str(sp.object), method_disp)
	if(_is_connected(sp.object, connect_to_obj, sp.signal_name, method_name)):
		_fail(disp)
	else:
		_pass(disp)


## Assert that the specified object emitted the named signal.  You must call
## [method watch_signals] and pass it the object that you are making assertions about.
## This will fail if the object is not being watched or if the object does not
## have the specified signal.  Since this will fail if the signal does not
## exist, you can often skip using [method assert_has_signal].
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emitted([param p1]:Signal, [param p2]: text <optional>)[br]
## - assert_signal_emitted([param p1]:object, [param p2]:signal-name, [param p3]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_assert_signal_emitted():
##     var obj = SignalObject.new()
##
##     watch_signals(obj)
##     obj.emit_signal('some_signal')
##
##     ## Passing
##     assert_signal_emitted(obj, 'some_signal')
##     assert_signal_emitted(obj.some_signal)
##
##     ## Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emitted(obj, 'signal_does_not_exist')
##     # Fails because the object passed is not being watched
##     assert_signal_emitted(SignalObject.new(), 'some_signal')
##     # Fails because the signal was not emitted
##     assert_signal_emitted(obj, 'other_signal')
##     assert_signal_emitted(obj.other_signal)
## [/codeblock]
func assert_signal_emitted(p1, p2='', p3=""):
	var sp := SignalAssertParameters.new(p1, p2, p3)
	var disp = str('Expected object ', _str(sp.object), ' to have emitted signal [', sp.signal_name, ']:  ', sp.others[0])
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			_pass(disp)
		else:
			_fail(_get_fail_msg_including_emitted_signals(disp, sp.object))


## This works opposite of `assert_signal_emitted`.  This will fail if the object
## is not being watched or if the object does not have the signal.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_not_emitted([param p1]:Signal, [param p2]: text <optional>)[br]
## - assert_signal_not_emitted([param p1]:object, [param p2]:signal-name, [param p3]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
##    class SignalObject:
##        signal some_signal
##        signal other_signal
##
##    func test_assert_signal_not_emitted():
##        var obj = SignalObject.new()
##
##        watch_signals(obj)
##        obj.emit_signal('some_signal')
##
##        # Passing
##        assert_signal_not_emitted(obj, 'other_signal')
##        assert_signal_not_emitted(obj.other_signal)
##
##        # Failing
##        # Fails with specific message that the object does not have the signal
##        assert_signal_not_emitted(obj, 'signal_does_not_exist')
##        # Fails because the object passed is not being watched
##        assert_signal_not_emitted(SignalObject.new(), 'some_signal')
##        # Fails because the signal was emitted
##        assert_signal_not_emitted(obj, 'some_signal')
## [/codeblock]
func assert_signal_not_emitted(p1, p2='', p3=''):
	var sp := SignalAssertParameters.new(p1, p2, p3)
	var disp = str('Expected object ', _str(sp.object), ' to NOT emit signal [', sp.signal_name, ']:  ', sp.others[0])
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			_fail(disp)
		else:
			_pass(disp)


## Asserts that a signal was fired with the specified parameters.  The expected
## parameters should be passed in as an array.  An optional index can be passed
## when a signal has fired more than once.  The default is to retrieve the most
## recent emission of the signal.
## [br]
## This will fail with specific messages if the object is not being watched or
## the object does not have the specified signal
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emitted_with_parameters([param p1]:Signal, [param p2]:expected-parameters, [param p3]: index <optional>)[br]
## - assert_signal_emitted_with_parameters([param p1]:object, [param p2]:signal-name, [param p3]:expected-parameters, [param p4]: index <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
## func test_assert_signal_emitted_with_parameters():
##     var obj = SignalObject.new()
##
##     watch_signals(obj)
##     # emit the signal 3 times to illustrate how the index works in
##     # assert_signal_emitted_with_parameters
##     obj.emit_signal('some_signal', 1, 2, 3)
##     obj.emit_signal('some_signal', 'a', 'b', 'c')
##     obj.emit_signal('some_signal', 'one', 'two', 'three')
##
##     # Passing
##     # Passes b/c the default parameters to check are the last emission of
##     # the signal
##     assert_signal_emitted_with_parameters(obj, 'some_signal', ['one', 'two', 'three'])
##     assert_signal_emitted_with_parameters(obj.some_signal, ['one', 'two', 'three'])
##
##     # Passes because the parameters match the specified emission based on index.
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3], 0)
##     assert_signal_emitted_with_parameters(obj.some_signal, [1, 2, 3], 0)
##
##     # Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emitted_with_parameters(obj, 'signal_does_not_exist', [])
##     # Fails because the object passed is not being watched
##     assert_signal_emitted_with_parameters(SignalObject.new(), 'some_signal', [])
##     # Fails because parameters do not match latest emission
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3])
##     # Fails because the parameters for the specified index do not match
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3], 1)
## [/codeblock]
func assert_signal_emitted_with_parameters(p1, p2, p3=-1, p4=-1):
	var sp := SignalAssertParameters.new(p1, p2, p3, p4)
	var parameters = sp.others[0]
	var index = sp.others[1]

	if(typeof(parameters) != TYPE_ARRAY):
		_lgr.error("The expected parameters must be wrapped in an array, you passed:  " + _str(parameters))
		_fail("Bad Parameters")
		return

	var disp = str('Expected object ', _str(sp.object), ' to emit signal [', sp.signal_name, '] with parameters ', parameters, ', got ')
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			var parms_got = _signal_watcher.get_signal_parameters(sp.object, sp.signal_name, index)
			var diff_result = _compare.deep(parameters, parms_got)
			if(diff_result.are_equal):
				_pass(str(disp, parms_got))
			else:
				_fail(str('Expected object ', _str(sp.object), ' to emit signal [', sp.signal_name, '] with parameters ', diff_result.summarize()))
		else:
			var text = str('Object ', sp.object, ' did not emit signal [', sp.signal_name, ']')
			_fail(_get_fail_msg_including_emitted_signals(text, sp.object))


## Asserts that a signal fired a specific number of times.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emit_count([param p1]:Signal, [param p2]:expected-count, [param p3]: text <optional>)[br]
## - assert_signal_emit_count([param p1]:object, [param p2]:signal-name, [param p3]:expected-count, [param p4]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_assert_signal_emit_count():
##     var obj_a = SignalObject.new()
##     var obj_b = SignalObject.new()
##
##     watch_signals(obj_a)
##     watch_signals(obj_b)
##
##     obj_a.emit_signal('some_signal')
##     obj_a.emit_signal('some_signal')
##
##     obj_b.emit_signal('some_signal')
##     obj_b.emit_signal('other_signal')
##
##     # Passing
##     assert_signal_emit_count(obj_a, 'some_signal', 2, 'passes')
##     assert_signal_emit_count(obj_a.some_signal, 2, 'passes')
##
##     assert_signal_emit_count(obj_a, 'other_signal', 0)
##     assert_signal_emit_count(obj_a.other_signal, 0)
##
##     assert_signal_emit_count(obj_b, 'other_signal', 1)
##
##     # Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emit_count(obj_a, 'signal_does_not_exist', 99)
##     # Fails because the object passed is not being watched
##     assert_signal_emit_count(SignalObject.new(), 'some_signal', 99)
##     # The following fail for obvious reasons
##     assert_signal_emit_count(obj_a, 'some_signal', 0)
##     assert_signal_emit_count(obj_b, 'other_signal', 283)
## [/codeblock]
func assert_signal_emit_count(p1, p2, p3=0, p4=""):
	var sp := SignalAssertParameters.new(p1, p2, p3, p4)
	var times = sp.others[0]
	var text = sp.others[1]

	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		var count = _signal_watcher.get_emit_count(sp.object, sp.signal_name)
		var disp = str('Expected the signal [', sp.signal_name, '] emit count of [', count, '] to equal [', times, ']: ', text)
		if(count== times):
			_pass(disp)
		else:
			_fail(_get_fail_msg_including_emitted_signals(disp, sp.object))


## Asserts the passed in object has a signal with the specified name.  It
## should be noted that all the asserts that verify a signal was/wasn't emitted
## will first check that the object has the signal being asserted against.  If
## it does not, a specific failure message will be given.  This means you can
## usually skip the step of specifically verifying that the object has a signal
## and move on to making sure it emits the signal correctly.
## [codeblock]
##    class SignalObject:
##        signal some_signal
##        signal other_signal
##
##    func test_assert_has_signal():
##        var obj = SignalObject.new()
##
##        ## Passing
##        assert_has_signal(obj, 'some_signal')
##        assert_has_signal(obj, 'other_signal')
##
##        ## Failing
##        assert_has_signal(obj, 'not_a real SIGNAL')
##        assert_has_signal(obj, 'yea, this one doesnt exist either')
##        # Fails because the signal is not a user signal.  Node2D does have the
##        # specified signal but it can't be checked this way.  It could be watched
##        # and asserted that it fired though.
##        assert_has_signal(Node2D.new(), 'exit_tree')
## [/codeblock]
func assert_has_signal(object, signal_name, text=""):
	var disp = str('Expected object ', _str(object), ' to have signal [', signal_name, ']:  ', text)
	if(_signal_watcher.does_object_have_signal(object, signal_name)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts that [param object] extends [param a_class].  object must be an instance of an
## object.  It cannot be any of the built in classes like Array or Int or Float.
## [param a_class] must be a class, it can be loaded via load, a GDNative class such as
## Node or Label or anything else.
## [codeblock]
##    # Passing
##    assert_is(Node2D.new(), Node2D)
##    assert_is(Label.new(), CanvasItem)
##    assert_is(SubClass.new(), BaseClass)
##    # Since this is a test script that inherits from test.gd, so
##    # this passes.  It's not obvious w/o seeing the whole script
##    # so I'm telling you.  You'll just have to trust me.
##    assert_is(self, load('res://addons/gut/test.gd'))
##
##    var Gut = load('res://addons/gut/gut.gd')
##    var a_gut = Gut.new()
##    assert_is(a_gut, Gut)
##
##    # Failing
##    assert_is(Node2D.new(), Node2D.new())
##    assert_is(BaseClass.new(), SubClass)
##    assert_is('a', 'b')
##    assert_is([], Node)
## [/codeblock]
func assert_is(object, a_class, text=''):
	var disp  = ''#var disp = str('Expected [', _str(object), '] to be type of [', a_class, ']: ', text)
	var bad_param_2 = 'Parameter 2 must be a Class (like Node2D or Label).  You passed '

	if(typeof(object) != TYPE_OBJECT):
		_fail(str('Parameter 1 must be an instance of an object.  You passed:  ', _str(object)))
	elif(typeof(a_class) != TYPE_OBJECT):
		_fail(str(bad_param_2, _str(a_class)))
	else:
		var a_str = _str(a_class)
		disp = str('Expected [', _str(object), '] to extend [', a_str, ']: ', text)
		if(!GutUtils.is_native_class(a_class) and !GutUtils.is_gdscript(a_class)):
			_fail(str(bad_param_2, a_str))
		else:
			if(is_instance_of(object, a_class)):
				_pass(disp)
			else:
				_fail(disp)


## Asserts that [param object] is the the [param type] specified.  [param type]
## should be one of the Godot [code]TYPE_[/code] constants.
## [codeblock]
##    # Passing
##    var c = Color(1, 1, 1, 1)
##    gr.test.assert_typeof(c, TYPE_COLOR)
##    assert_pass(gr.test)
##
##    # Failing
##    gr.test.assert_typeof('some string', TYPE_INT)
##    assert_fail(gr.test)
## [/codeblock]
func assert_typeof(object, type, text=''):
	var disp = str('Expected [typeof(', object, ') = ')
	disp += _get_typeof_string(typeof(object))
	disp += '] to equal ['
	disp += _get_typeof_string(type) +  ']'
	disp += '.  ' + text
	if(typeof(object) == type):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of [method assert_typeof]
func assert_not_typeof(object, type, text=''):
	var disp = str('Expected [typeof(', object, ') = ')
	disp += _get_typeof_string(typeof(object))
	disp += '] to not equal ['
	disp += _get_typeof_string(type) +  ']'
	disp += '.  ' + text
	if(typeof(object) != type):
		_pass(disp)
	else:
		_fail(disp)


## Assert that `text` contains `search`.  Can perform case insensitive search
## by passing false for `match_case`.
## [codeblock]
##    # Passing
##    assert_string_contains('abc 123', 'a')
##    assert_string_contains('abc 123', 'BC', false)
##    assert_string_contains('abc 123', '3')
##
##    # Failing
##    assert_string_contains('abc 123', 'A')
##    assert_string_contains('abc 123', 'BC')
##    assert_string_contains('abc 123', '012')
## [/codeblock]
func assert_string_contains(text, search, match_case=true):
	const empty_search = 'Expected text and search strings to be non-empty. You passed %s and %s.'
	const non_strings = 'Expected text and search to both be strings.  You passed %s and %s.'
	var disp = 'Expected \'%s\' to contain \'%s\', match_case=%s' % [text, search, match_case]
	if(typeof(text) != TYPE_STRING or typeof(search) != TYPE_STRING):
		_fail(non_strings % [_str(text), _str(search)])
	elif(text == '' or search == ''):
		_fail(empty_search % [_str(text), _str(search)])
	elif(match_case):
		if(text.find(search) == -1):
			_fail(disp)
		else:
			_pass(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == -1):
			_fail(disp)
		else:
			_pass(disp)


## Assert that text starts with search.  Can perform case insensitive check
## by passing false for match_case
## [codeblock]
##    # Passing
##    assert_string_starts_with('abc 123', 'a')
##    assert_string_starts_with('abc 123', 'ABC', false)
##    assert_string_starts_with('abc 123', 'abc 123')
##
##    ## Failing
##    assert_string_starts_with('abc 123', 'z')
##    assert_string_starts_with('abc 123', 'ABC')
##    assert_string_starts_with('abc 123', 'abc 1234')
## [/codeblock]
func assert_string_starts_with(text, search, match_case=true):
	var empty_search = 'Expected text and search strings to be non-empty. You passed \'%s\' and \'%s\'.'
	var disp = 'Expected \'%s\' to start with \'%s\', match_case=%s' % [text, search, match_case]
	if(text == '' or search == ''):
		_fail(empty_search % [text, search])
	elif(match_case):
		if(text.find(search) == 0):
			_pass(disp)
		else:
			_fail(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == 0):
			_pass(disp)
		else:
			_fail(disp)


## Assert that [param text] ends with [param search].  Can perform case insensitive check by passing false for [param match_case]
## [codeblock]
##    ## Passing
##    assert_string_ends_with('abc 123', '123')
##    assert_string_ends_with('abc 123', 'C 123', false)
##    assert_string_ends_with('abc 123', 'abc 123')
##
##    ## Failing
##    assert_string_ends_with('abc 123', '1234')
##    assert_string_ends_with('abc 123', 'C 123')
##    assert_string_ends_with('abc 123', 'nope')
## [/codeblock]
func assert_string_ends_with(text, search, match_case=true):
	var empty_search = 'Expected text and search strings to be non-empty. You passed \'%s\' and \'%s\'.'
	var disp = 'Expected \'%s\' to end with \'%s\', match_case=%s' % [text, search, match_case]
	var required_index = len(text) - len(search)
	if(text == '' or search == ''):
		_fail(empty_search % [text, search])
	elif(match_case):
		if(text.find(search) == required_index):
			_pass(disp)
		else:
			_fail(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == required_index):
			_pass(disp)
		else:
			_fail(disp)


# ------------------------------------------------------------------------------
## Assert that a method was called on an instance of a doubled class.  If
## parameters are supplied then the params passed in when called must match.
##
## Can be called with a Callabe instead of specifying the object, method_name,
## and parameters.  The Callable's object must be a double.  Bound arguments
## will be used to match calls based on values passed to the method.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    var my_double = double(Foobar).new()
##    ...
##    assert_called(my_double, 'foo')
##    assert_called(my_double.foo)
##    assert_called(my_double, 'foo', [1, 2, 3])
##    assert_called(my_double.foo.bind(1, 2, 3))
## [/codeblock]
func assert_called(inst, method_name=null, parameters=null):

	if(_fail_if_parameters_not_array(parameters)):
		return

	var converted = _convert_spy_args(inst, method_name, parameters)
	if(converted.invalid_message != 'ok'):
		fail_test(converted.invalid_message)
		return

	var disp = str('Expected [',converted.method_name,'] to have been called on ',_str(converted.object))
	if(converted.arguments != null):
		disp += str(' with parameters ', converted.arguments)

	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(gut.get_spy().was_called(
			converted.object, converted.method_name, converted.arguments)):
			_pass(disp)
		else:
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))


# ------------------------------------------------------------------------------
## Assert that a method was not called on an instance of a doubled class.  If
## parameters are specified then this will only fail if it finds a call that was
## sent matching parameters.
##
## Can be called with a Callabe instead of specifying the object, method_name,
## and parameters.  The Callable's object must be a double.  Bound arguments
## will be used to match calls based on values passed to the method.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    assert_not_called(my_double, 'foo')
##    assert_not_called(my_double.foo)
##    assert_not_called(my_double, 'foo', [1, 2, 3])
##    assert_not_called(my_double.foo.bind(1, 2, 3))
## [/codeblock]
func assert_not_called(inst, method_name=null, parameters=null):

	if(_fail_if_parameters_not_array(parameters)):
		return

	var converted = _convert_spy_args(inst, method_name, parameters)
	if(converted.invalid_message != 'ok'):
		fail_test(converted.invalid_message)
		return

	var disp = str('Expected [', converted.method_name, '] to NOT have been called on ', _str(converted.object))

	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(gut.get_spy().was_called(
			converted.object, converted.method_name, converted.arguments)):
			if(converted.arguments != null):
				disp += str(' with parameters ', converted.arguments)
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))
		else:
			_pass(disp)


## Asserts the the method of a double was called an expected number of times.
## If any arguments are bound to the callable then only calls with matching
## arguments will be counted.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    # assert foo was called on my_double 5 times
##    assert_called_count(my_double.foo, 5)
##    # assert foo, with parameters [1,2,3], was called on my_double 4 times.
##    assert_called_count(my_double.foo.bind(1, 2, 3), 4)
## [/codeblock]
func assert_called_count(callable : Callable, expected_count : int):
	var converted = _convert_spy_args(callable, null, null)
	var count = gut.get_spy().call_count(converted.object, converted.method_name, converted.arguments)

	var param_text = ''
	if(callable.get_bound_arguments_count() > 0):
		param_text = ' with parameters ' + str(callable.get_bound_arguments())
	var disp = 'Expected [%s] on %s to be called [%s] times%s.  It was called [%s] times.'
	disp = disp % [converted.method_name, _str(converted.object), expected_count, param_text, count]


	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(count == expected_count):
			_pass(disp)
		else:
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))


## Asserts the passed in value is null
func assert_null(got, text=''):
	var disp = str('Expected [', _str(got), '] to be NULL:  ', text)
	if(got == null):
		_pass(disp)
	else:
		_fail(disp)


## Asserts the passed in value is not null.
func assert_not_null(got, text=''):
	var disp = str('Expected [', _str(got), '] to be anything but NULL:  ', text)
	if(got == null):
		_fail(disp)
	else:
		_pass(disp)


## Asserts that the passed in object has been freed.  This assertion requires
## that  you pass in some text in the form of a title since, if the object is
## freed, we won't have anything to convert to a string to put in the output
## statement.
## [br]
## [b]Note[/b] that this currently does not detect if a node has been queued free.
## [codeblock]
##    var obj = Node.new()
##    obj.free()
##    test.assert_freed(obj, "New Node")
## [/codeblock]
func assert_freed(obj, title='something'):
	var disp = title
	if(is_instance_valid(obj)):
		disp = _strutils.type2str(obj) + title
	assert_true(not is_instance_valid(obj), "Expected [%s] to be freed" % disp)


## The inverse of [method assert_freed]
func assert_not_freed(obj, title='something'):
	var disp = title
	if(is_instance_valid(obj)):
		disp = _strutils.type2str(obj) + title
	assert_true(is_instance_valid(obj), "Expected [%s] to not be freed" % disp)


## This method will assert that no orphaned nodes have been introduced by the
## test when the assert is executed.  See the [wiki]Memory-Management[/wiki]
## page for more information.
func assert_no_new_orphans(text=''):
	var orphan_ids = gut.get_current_test_orphans()
	var count = orphan_ids.size()
	var msg = ''
	if(text != ''):
		msg = ':  ' + text
	# Note that get_counter will return -1 if the counter does not exist.  This
	# can happen with a misplaced assert_no_new_orphans.  Checking for > 0
	# ensures this will not cause some weird failure.
	if(count > 0):
		msg += str("\n", _strutils.indent_text(gut.get_orphan_counter().get_orphan_list_text(orphan_ids), 1, '    '))
		_fail(str('Expected no orphans, but found ', count, msg))
	else:
		_pass('No new orphans found.' + msg)


## @ignore
func assert_set_property(obj, property_name, new_value, expected_value):
	pending("this hasn't been implemented yet")


## @ignore
func assert_readonly_property(obj, property_name, new_value, expected_value):
	pending("this hasn't been implemented yet")


## Assumes backing varible with be _<property_name>.  This will perform all the
## asserts of assert_property.  Then this will set the value through the setter
## and check the backing variable value.  It will then reset throught the setter
## and set the backing variable and check the getter.
func assert_property_with_backing_variable(obj, property_name, default_value, new_value, backed_by_name=null):
	var setter_name = str('@', property_name, '_setter')
	var getter_name = str('@', property_name, '_getter')
	var backing_name = GutUtils.nvl(backed_by_name, str('_', property_name))
	var pre_fail_count = get_fail_count()

	var props = obj.get_property_list()
	var found = false
	var idx = 0
	while(idx < props.size() and !found):
		found = props[idx].name == backing_name
		idx += 1

	assert_true(found, str(obj, ' has ', backing_name, ' variable.'))
	assert_true(obj.has_method(setter_name), str('There should be a setter for ', property_name))
	assert_true(obj.has_method(getter_name), str('There should be a getter for ', property_name))

	if(pre_fail_count == get_fail_count()):
		var call_setter = Callable(obj, setter_name)
		var call_getter = Callable(obj, getter_name)

		assert_eq(obj.get(backing_name), default_value, str('Variable ', backing_name, ' has default value.'))
		assert_eq(call_getter.call(), default_value, 'Getter returns default value.')
		call_setter.call(new_value)
		assert_eq(call_getter.call(), new_value, 'Getter returns value from Setter.')
		assert_eq(obj.get(backing_name), new_value, str('Variable ', backing_name, ' was set'))

	_warn_for_public_accessors(obj, property_name)


## This will verify that the method has a setter and getter for the property.
## It will then use the getter to check the default.  Then use the
## setter with new_value and verify the getter returns the same value.
func assert_property(obj, property_name, default_value, new_value) -> void:
	var pre_fail_count = get_fail_count()

	var setter_name = str('@', property_name, '_setter')
	var getter_name = str('@', property_name, '_getter')

	if(typeof(obj) != TYPE_OBJECT):
		_fail(str(_str(obj), ' is not an object'))
		return

	assert_has_method(obj, setter_name)
	assert_has_method(obj, getter_name)

	if(pre_fail_count == get_fail_count()):
		var call_setter = Callable(obj, setter_name)
		var call_getter = Callable(obj, getter_name)

		assert_eq(call_getter.call(), default_value, 'Default value')
		call_setter.call(new_value)
		assert_eq(call_getter.call(), new_value, 'Getter gets Setter value')

	_warn_for_public_accessors(obj, property_name)


## Performs a deep comparison between two arrays or dictionaries and asserts
## they are equal.  If they are not equal then a formatted list of differences
## are displayed.  See [wiki]Comparing-Things[/wiki] for more information.
func assert_eq_deep(v1, v2):
	var result = compare_deep(v1, v2)
	if(result.are_equal):
		_pass(result.get_short_summary())
	else:
		_fail(result.summary)


## Performs a deep comparison of two arrays or dictionaries and asserts they
## are not equal.  See [wiki]Comparing-Things[/wiki] for more information.
func assert_ne_deep(v1, v2):
	var result = compare_deep(v1, v2)
	if(!result.are_equal):
		_pass(result.get_short_summary())
	else:
		_fail(result.get_short_summary())


## Assert v1 and v2 are the same using [code]is_same[/code].  See @GlobalScope.is_same.
func assert_same(v1, v2, text=''):
	var disp = "[" + _str(v1) + "] expected to be same as  [" + _str(v2) + "]:  " + text
	if(is_same(v1, v2)):
		_pass(disp)
	else:
		_fail(disp)


## Assert using v1 and v2 are not the same using [code]is_same[/code].  See @GlobalScope.is_same.
func assert_not_same(v1, v2, text=''):
	var disp = "[" + _str(v1) + "] expected to not be same as  [" + _str(v2) + "]:  " + text
	if(is_same(v1, v2)):
		_fail(disp)
	else:
		_pass(disp)

# ----------------
#endregion
#region Error Detection
# ----------------
var _error_type_check_methods = {
	"push_error": "is_push_error",
	"engine": "is_engine_error",
}

# smells like GutTrackedError needs some more constants but I'm not ready to
# make them yet
func _is_error_of_type(err, error_type_name):
	return err.call(_error_type_check_methods[error_type_name])


func _assert_error_count(count, error_type_name, msg):
	var consumed_count = 0
	var errors = gut.error_tracker.get_errors_for_test()
	var found = []
	var disp = msg

	for err in errors:
		if(_is_error_of_type(err, error_type_name)):
			if(consumed_count < count):
				err.handled = true
				consumed_count += 1
			found.append(err)

	if(disp != ''):
		disp = str(':  ', disp)
	else:
		disp = '.'
	disp = str("Expected ", count, " ", error_type_name, " errors.  Got ", found.size(), disp)
	if(found.size() == count):
		_pass(disp)
		if(!_lgr.is_type_enabled(_lgr.types.passed)):
			_lgr.expected_error(msg)
	else:
		_fail(disp)


func _assert_error_text(text, error_type_name, msg):
	var consumed_count = 0
	var errors = gut.error_tracker.get_errors_for_test()
	var found = []
	var disp = msg

	for err in errors:
		if(_is_error_of_type(err, error_type_name) and err.contains_text(text)):
			if(consumed_count == 0):
				err.handled = true
				consumed_count += 1
			found.append(err)

	disp = str("Expected ", error_type_name, " error containing '", text, "'.  ", msg)
	if(consumed_count == 1):
		_pass(disp)
		if(!_lgr.is_type_enabled(_lgr.types.passed)):
			_lgr.expected_error(disp)
	else:
		_fail(disp)


## Get all the errors in the test up to this point.  Each error is an instance
## of [GutTrackedError]. Setting the [member GutTrackedError.handled] [code]handled[/code] property of
## an element in the array will prevent it from causing a test to fail.
## [br][br]
## This method allows you to inspect the details of any errors that occured and
## decide if it's the error you are expecting or not.
## [br][br]
## [codeblock]
## func divide_them(a, b):
##     return a / b
##
## func test_with_script_error():
##     divide_them('one', 44)
##     push_error('this is a push error')
##     var errs = get_errors()
##     assert_eq(errs.size(), 2, 'expected error count')
##
##     # Maybe inspect some properties of the errors here.
##
##     # Mark all the errors as handled.
##     for e in errs:
##         e.handled = true
## [/codeblock]
## See [GutTrackedError], [wiki]Error-Tracking[/wiki].
func get_errors()->Array:
	return gut.error_tracker.get_errors_for_test()


## Asserts that a number of engine or a single engine error continating
## (case insensitive) text has occurred.  If the expected error(s) are
## found then this assert will pass and the test will not fail from an
## unexpected push_error.
## [br][br]
## This assert will pass/fail even if push_errors are not configured to cause
## a test failure.  This will not prevent the error from showing up in output.
## [br][br]
## [codeblock]
## func divide_them(a, b):
##     return a / b
##
## func test_asserting_engine_error_count():
##     divide_them('one', 44)
##     assert_engine_error(1, "expecing a script error")
##
## func test_asserting_engine_error_text():
##     divide_them('word', 91)
##     assert_engine_error('invalid operands')
##
## func test_asserting_multipe_engine_error_texts():
##     divide_them('foo', Node)
##     divide_them(1729, 0)
##     assert_engine_error('Division by zero')
##     assert_engine_error('invalid operands')
## [/codeblock]
## See [wiki]Error-Tracking[/wiki].
func assert_engine_error(count_or_text, msg=''):
	var t = typeof(count_or_text)
	if(t == TYPE_INT or t == TYPE_FLOAT):
		_assert_error_count(count_or_text, "engine", msg)
	elif(t == TYPE_STRING):
		_assert_error_text(count_or_text, 'engine', msg)
	else:
		_fail(str("Unexpected input:  ", count_or_text))


## Asserts that a number of push_errors or a single push error continating
## (case insensitive) text has occurred.  If the expected error(s) are
## found then this assert will pass and the test will not fail from an
## unexpected push_error.
## [br][br]
## This assert will pass/fail even if push_errors are not configured to cause
## a test failure.  This will not prevent the error from showing up in output.
## [codeblock]
## func test_with_push_error():
##     push_error("This is an error")
##     assert_push_error(1, 'This test should have caused a push_error)
##
## func test_push_error_text():
##     push_error("SpecialText")
##     assert_push_error("CIALtex")
##
## func test_push_error_multiple_texts():
##     push_error("Error One")
##     push_error("Expception two")
##     assert_push_error("one")
##     assert_push_error("two")
##
## [/codeblock]
## See [wiki]Error-Tracking[/wiki].
func assert_push_error(count_or_text, msg=''):
	var t = typeof(count_or_text)
	if(t == TYPE_INT or t == TYPE_FLOAT):
		_assert_error_count(count_or_text, "push_error", msg)
	elif(t == TYPE_STRING):
		_assert_error_text(count_or_text, 'push_error', msg)
	else:
		_fail(str("Unexpected input:  ", count_or_text))


# ----------------
#endregion
#region Await Helpers
# ----------------


## Use with await to wait an amount of time in seconds.  The optional message
## will be printed when the await starts.[br]
## See [wiki]Awaiting[/wiki]
func wait_seconds(time, msg=''):
	_awaiter.wait_seconds(time)
	return _awaiter.timeout


## Use with await to wait for a signal to be emitted or a maximum amount of
## time.  Returns true if the signal was emitted, false if not.[br]
## See [wiki]Awaiting[/wiki]
func wait_for_signal(sig : Signal, max_time, msg=''):
	watch_signals(sig.get_object())
	_awaiter.wait_for_signal(sig, max_time, msg)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout


## @deprecated
## Use wait_physics_frames or wait_process_frames
## See [wiki]Awaiting[/wiki].
func wait_frames(frames : int, msg=''):
	_lgr.deprecated("wait_frames has been replaced with wait_physics_frames which is counted in _physics_process.  " +
		"wait_process_frames has also been added which is counted in _process.")
	return wait_physics_frames(frames, msg)


## This returns a signal that is emitted after [param x] physics frames have
## elpased.  You can await this method directly to pause execution for [param x]
## physics frames.  The frames are counted prior to _physics_process being called
## on any node (when [signal SceneTree.physics_frame] is emitted).  This means the
## signal is emitted after [param x] frames and just before the x + 1 frame starts.
## [codeblock]
## await wait_physics_frames(10)
## [/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_physics_frames(x :int , msg=''):
	if(x <= 0):
		var text = str('wait_physics_frames:  frames must be > 0, you passed  ', x, '.  1 frames waited.')
		_lgr.error(text)
		x = 1

	_awaiter.wait_physics_frames(x, msg)
	return _awaiter.timeout


## Alias for [method GutTest.wait_process_frames]
func wait_idle_frames(x : int, msg=''):
	return wait_process_frames(x, msg)


## This returns a signal that is emitted after [param x] process/idle frames have
## elpased.  You can await this method directly to pause execution for [param x]
## process/idle frames.  The frames are counted prior to _process being called
## on any node (when [signal SceneTree.process_frame] is emitted).  This means the
## signal is emitted after [param x] frames and just before the x + 1 frame starts.
## [codeblock]
## await wait_process_frames(10)
## # wait_idle_frames is an alias of wait_process_frames
## await wait_idle_frames(10)
## [/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_process_frames(x : int, msg=''):
	if(x <= 0):
		var text = str('wait_process_frames:  frames must be > 0, you passed  ', x, '.  1 frames waited.')
		_lgr.error(text)
		x = 1

	_awaiter.wait_process_frames(x, msg)
	return _awaiter.timeout


## Use with await to wait for [param callable] to return the boolean value
## [code]true[/code] or a maximum amount of time.  All values that are not the
## boolean value [code]true[/code] are ignored.  [param callable] is called
## every [code]_physics_process[/code] tick unless an optional time between
## calls is specified.[br]
## [param p3] can be the optional message or an amount of time to wait between calls.[br]
## [param p4] is the optional message if you have specified an amount of time to
## wait between calls.[br]
## Returns [code]true[/code] if [param callable] returned true before the timeout, false if not.
##[br]
##[codeblock]
## var foo = 1
## func test_example():
##     var foo_func = func():
##         foo += 1
##         return foo == 10
##     foo = 1
##     wait_until(foo_func, 5, 'optional message')
##     # or give it a time between
##     foo = 1
##     wait_until(foo_func, 5, 1,
##         'this will timeout because we call it every second and are waiting a max of 10 seconds')
##
##[/codeblock]
## See also [method wait_while][br]
## See [wiki]Awaiting[/wiki]
func wait_until(callable, max_time, p3='', p4=''):
	var time_between = 0.0
	var message = p4
	if(typeof(p3) != TYPE_STRING):
		time_between = p3
	else:
		message = p3

	_awaiter.wait_until(callable, max_time, time_between, message)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout


## This is the inverse of [method wait_until].  This will continue to wait while
## [param callable] returns the boolean value [code]true[/code].  If [b]ANY[/b]
## other value is is returned then the wait will end.
## Returns [code]true[/code] if [param callable] returned a value other than
## [code]true[/code] before the timeout, [code]false[/code] if not.
##[codeblock]
## var foo = 1
## func test_example():
##     var foo_func = func():
##         foo += 1
##         if(foo < 10):
##             return true
##         else:
##             return 'this is not a boolean'
##     foo = 1
##     wait_while(foo_func, 5, 'optional message')
##     # or give it a time between
##     foo = 1
##     wait_while(foo_func, 5, 1,
##         'this will timeout because we call it every second and are waiting a max of 10 seconds')
##
##[/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_while(callable, max_time, p3='', p4=''):
	var time_between = 0.0
	var message = p4
	if(typeof(p3) != TYPE_STRING):
		time_between = p3
	else:
		message = p3

	_awaiter.wait_while(callable, max_time, time_between, message)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout



## Returns whether the last wait_* method timed out.  This is always true if
## the last method was wait_xxx_frames or wait_seconds.  It will be false when
## using wait_for_signal and wait_until if the timeout occurs before what
## is being waited on.  The wait_* methods return this value so you should be
## able to avoid calling this directly, but you can.
func did_wait_timeout():
	return _awaiter.did_last_wait_timeout

# ----------------
#endregion
#region Summary Data
# ----------------

## @internal
func get_summary():
	return _summary


## Returns the number of failing asserts in this script at the time this
## method was called.  Call in [method after_all] to get total count for script.
func get_fail_count():
	return _summary.failed


## Returns the number of passing asserts in this script at the time this method
## was called.  Call in [method after_all] to get total count for script.
func get_pass_count():
	return _summary.passed


## Returns the number of pending tests in this script at the time this method
## was called.  Call in [method after_all] to get total count for script.
func get_pending_count():
	return _summary.pending


## Returns the total number of asserts this script has made as of the time of
## this was called.  Call in [method after_all] to get total count for script.
func get_assert_count():
	return _summary.asserts


# Convert the _summary dictionary into text
## @internal
func get_summary_text():
	var to_return = get_script().get_path() + "\n"
	to_return += str('  ', _summary.passed, ' of ', _summary.asserts, ' passed.')
	if(_summary.pending > 0):
		to_return += str("\n  ", _summary.pending, ' pending')
	if(_summary.failed > 0):
		to_return += str("\n  ", _summary.failed, ' failed.')
	return to_return


# ----------------
#endregion
#region Double Methods
# ----------------


## Create a Double of [param thing].  [param thing] should be a Class, script,
## or scene.  See [wiki]Doubles[/wiki]
func double(thing, double_strat=null, not_used_anymore=null):
	if(!_are_double_parameters_valid(thing, double_strat, not_used_anymore)):
		return null

	return _smart_double(thing, double_strat, false)


## Create a Partial Double of [param thing].  [param thing] should be a Class,
## script, or scene.  See [wiki]Partial-Doubles[/wiki]
func partial_double(thing, double_strat=null, not_used_anymore=null):
	if(!_are_double_parameters_valid(thing, double_strat, not_used_anymore)):
		return null

	return _smart_double(thing, double_strat, true)


## @internal
func double_singleton(singleton_name):
	return null
	# var to_return = null
	# if(_validate_singleton_name(singleton_name)):
	# 	to_return = gut.get_doubler().double_singleton(singleton_name)
	# return to_return


## @internal
func partial_double_singleton(singleton_name):
	return null
	# var to_return = null
	# if(_validate_singleton_name(singleton_name)):
	# 	to_return = gut.get_doubler().partial_double_singleton(singleton_name)
	# return to_return


## This was implemented to allow the doubling of classes with static methods.
## There might be other valid use cases for this method, but you should always
## try stubbing before using this method.  Using
## [code]stub(my_double, 'method').to_call_super()[/code] or  creating a
## [method partial_double] works for any other known scenario.  You cannot stub
## or spy on methods passed to [code skip-lint]ignore_method_when_doubling[/code].
func ignore_method_when_doubling(thing, method_name):
	if(typeof(thing) == TYPE_STRING):
		_lgr.error('ignore_method_when_doubling no longer supports paths to scripts or scenes.  Load them and pass them instead.')
		return

	var r = thing
	if(thing is PackedScene):
		r = GutUtils.get_scene_script_object(thing)

	gut.get_doubler().add_ignored_method(r, method_name)


## Stub something.  See [wiki]Stubbing[/wiki] for detailed information about stubbing.
func stub(thing, p2=null, p3=null):
	var method_name = p2
	var subpath = null

	if(p3 != null):
		subpath = p2
		method_name = p3

	if(GutUtils.is_instance(thing) and !GutUtils.is_double(thing)):
		_lgr.error(str("An instance of a Double was expected, you passed:  ", _str(thing)))
		return GutUtils.StubParams.new()

	var sp = null
	if(typeof(thing) == TYPE_CALLABLE):
		if(p2 != null or p3 != null):
			_lgr.error("Only one parameter expected when using a callable.")
		sp = GutUtils.StubParams.new(thing)
	else:
		sp = GutUtils.StubParams.new(thing, method_name, subpath)

	if(GutUtils.is_instance(sp.stub_target)):
		var msg = _get_bad_method_message(sp.stub_target, sp.stub_method, 'stub')
		if(msg != ''):
			_lgr.error(msg)
			return GutUtils.StubParams.new()

	sp.logger = _lgr
	gut.get_stubber().add_stub(sp)
	return sp


# ----------------
#endregion
#region Memory Mgmt
# ----------------


## Marks whatever is passed in to be freed after the test finishes.  It also
## returns what is passed in so you can save a line of code.
##   var thing = autofree(Thing.new())
func autofree(thing):
	gut.get_autofree().add_free(thing)
	return thing


## Works the same as autofree except queue_free will be called on the object
## instead.  This also imparts a brief pause after the test finishes so that
## the queued object has time to free.
func autoqfree(thing):
	gut.get_autofree().add_queue_free(thing)
	return thing


## The same as autofree but it also adds the object as a child of the test.
func add_child_autofree(node, legible_unique_name = false):
	gut.get_autofree().add_free(node)
	# Explicitly calling super here b/c add_child MIGHT change and I don't want
	# a bug sneaking its way in here.
	super.add_child(node, legible_unique_name)
	return node


## The same as autoqfree but it also adds the object as a child of the test.
func add_child_autoqfree(node, legible_unique_name=false):
	gut.get_autofree().add_queue_free(node)
	# Explicitly calling super here b/c add_child MIGHT change and I don't want
	# a bug sneaking its way in here.
	super.add_child(node, legible_unique_name)
	return node


# ----------------
#endregion
#region Deprecated/Removed
# ----------------


## REMOVED
## @ignore
func compare_shallow(v1, v2, max_differences=null):
	_fail('compare_shallow has been removed.  Use compare_deep or just compare using == instead.')
	_lgr.error('compare_shallow has been removed.  Use compare_deep or just compare using == instead.')
	return null


## REMOVED
## @ignore
func assert_eq_shallow(v1, v2):
	_fail('assert_eq_shallow has been removed.  Use assert_eq/assert_same/assert_eq_deep')


## REMOVED
## @ignore
func assert_ne_shallow(v1, v2):
	_fail('assert_eq_shallow has been removed.  Use assert_eq/assert_same/assert_eq_deep')


## @deprecated: use wait_seconds
func yield_for(time, msg=''):
	_lgr.deprecated('yield_for', 'wait_seconds')
	return wait_seconds(time, msg)


## @deprecated: use wait_for_signal
func yield_to(obj, signal_name, max_wait, msg=''):
	_lgr.deprecated('yield_to', 'wait_for_signal')
	return await wait_for_signal(Signal(obj, signal_name), max_wait, msg)


## @deprecated: use wait_frames
func yield_frames(frames, msg=''):
	_lgr.deprecated("yield_frames", "wait_frames")
	return wait_frames(frames, msg)


## @deprecated: no longer supported.  Use double
func double_scene(path, strategy=null):
	_lgr.deprecated('test.double_scene has been removed.', 'double')
	return null


## @deprecated: no longer supported.  Use double
func double_script(path, strategy=null):
	_lgr.deprecated('test.double_script has been removed.', 'double')
	return null

	# var override_strat = GutUtils.nvl(strategy, gut.get_doubler().get_strategy())
	# return gut.get_doubler().double(path, override_strat)


## @deprecated: no longer supported.  Use register_inner_classes + double
func double_inner(path, subpath, strategy=null):
	_lgr.deprecated('double_inner should not be used.  Use register_inner_classes and double instead.', 'double')
	return null

	var override_strat = GutUtils.nvl(strategy, gut.get_doubler().get_strategy())
	return gut.get_doubler().double_inner(path, subpath, override_strat)


## @deprecated:  Use [method assert_called_count] instead.
func assert_call_count(inst, method_name, expected_count, parameters=null):
	gut.logger.deprecated('This has been replaced with assert_called_count which accepts a Callable with optional bound arguments.')
	var callable = Callable.create(inst, method_name)
	if(parameters != null):
		callable = callable.bindv(parameters)
	assert_called_count(callable, expected_count)


## @deprecated: no longer supported.
func assert_setget(
	instance, name_property,
	const_or_setter = null, getter="__not_set__"):
	_lgr.deprecated('assert_property')
	_fail('assert_setget has been removed.  Use assert_property, assert_set_property, assert_readonly_property instead.')


# ----------------
#endregion



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# View readme for usage details.
#
# Version - see gut.gd
# ##############################################################################
# Class that all test scripts must extend.`
#
# This provides all the asserts and other testing features.  Test scripts are
# run by the Gut class in gut.gd
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/test_collector.gd
--------------------------------------------------
# ------------------------------------------------------------------------------
# This class handles calling out to the test parser and maintaining an array of
# collected_script.gd.  This is used for both calling the tests and tracking
# the results of each script and test's execution.
#
# This also handles exporting and importing tests.
# ------------------------------------------------------------------------------
var CollectedScript = GutUtils.CollectedScript
var CollectedTest = GutUtils.CollectedTest

var _test_prefix = 'test_'
var _test_class_prefix = 'Test'

var _lgr = GutUtils.get_logger()


# Array of CollectedScripts.
var scripts = []


func _does_inherit_from_test(thing):
	var base_script = thing.get_base_script()
	var to_return = false
	if(base_script != null):
		var base_path = base_script.get_path()
		if(base_path == 'res://addons/gut/test.gd'):
			to_return = true
		else:
			to_return = _does_inherit_from_test(base_script)
	return to_return


func _populate_tests(test_script):
	var script =  test_script.load_script()
	if(script == null):
		print('  !!! ', test_script.path, ' could not be loaded')
		return false

	test_script.is_loaded = true
	var methods = script.get_script_method_list()
	for i in range(methods.size()):
		var name = methods[i]['name']
		if(name.begins_with(_test_prefix)):
			var t = CollectedTest.new()
			t.name = name
			t.arg_count = methods[i]['args'].size()
			test_script.tests.append(t)
			t.collected_script = weakref(test_script)


func _get_inner_test_class_names(loaded):
	var inner_classes = []
	var const_map = loaded.get_script_constant_map()
	for key in const_map:
		var thing = const_map[key]
		if(GutUtils.is_gdscript(thing)):
			if(key.begins_with(_test_class_prefix)):
				if(_does_inherit_from_test(thing)):
					inner_classes.append(key)
				else:
					_lgr.warn(str('Ignoring Inner Class ', key,
						' because it does not extend GutTest'))

			# This could go deeper and find inner classes within inner classes
			# but requires more experimentation.  Right now I'm keeping it at
			# one level since that is what the previous version did and there
			# has been no demand for deeper nesting.
			# _populate_inner_test_classes(thing)
	return inner_classes


func _parse_script(test_script):
	var inner_classes = []
	var scripts_found = []

	var loaded = GutUtils.WarningsManager.load_script_using_custom_warnings(
		test_script.path,
		GutUtils.warnings_when_loading_test_scripts)

	if(_does_inherit_from_test(loaded)):
		_populate_tests(test_script)
		scripts_found.append(test_script.path)
		inner_classes = _get_inner_test_class_names(loaded)
	else:
		return []

	for i in range(inner_classes.size()):
		var loaded_inner = loaded.get(inner_classes[i])
		if(_does_inherit_from_test(loaded_inner)):
			var ts = CollectedScript.new(_lgr)
			ts.path = test_script.path
			ts.inner_class_name = inner_classes[i]
			_populate_tests(ts)
			scripts.append(ts)
			scripts_found.append(test_script.path + '[' + inner_classes[i] +']')

	return scripts_found


# -----------------
# Public
# -----------------
func add_script(path):
	# SHORTCIRCUIT
	if(has_script(path)):
		return []

	# SHORTCIRCUIT
	if(!FileAccess.file_exists(path)):
		# This check was added so tests could create dynmaic scripts and add
		# them to be run through gut.  This helps cut down on creating test
		# scripts to be used in test/resources.
		if(ResourceLoader.has_cached(path)):
			_lgr.debug("Using cached version of " + path)
		else:
			_lgr.error('Could not find script:  ' + path)
			return

	var ts = CollectedScript.new(_lgr)
	ts.path = path
	# Append right away because if we don't test_doubler.gd.TestInitParameters
	# will HARD crash.  I couldn't figure out what was causing the issue but
	# appending right away, and then removing if it's not valid seems to fix
	# things.  It might have to do with the ordering of the test classes in
	# the test collecter.  I'm not really sure.
	scripts.append(ts)
	var parse_results = _parse_script(ts)

	if(parse_results.find(path) == -1):
		_lgr.warn(str('Ignoring script ', path, ' because it does not extend GutTest'))
		scripts.remove_at(scripts.find(ts))

	return parse_results


func clear():
	scripts.clear()


func has_script(path):
	var found = false
	var idx = 0
	while(idx < scripts.size() and !found):
		if(scripts[idx].get_full_name() == path):
			found = true
		else:
			idx += 1
	return found


func export_tests(path):
	var success = true
	var f = ConfigFile.new()
	for i in range(scripts.size()):
		scripts[i].export_to(f, str('CollectedScript-', i))
	var result = f.save(path)
	if(result != OK):
		_lgr.error(str('Could not save exported tests to [', path, '].  Error code:  ', result))
		success = false
	return success


func import_tests(path):
	var success = false
	var f = ConfigFile.new()
	var result = f.load(path)
	if(result != OK):
		_lgr.error(str('Could not load exported tests from [', path, '].  Error code:  ', result))
	else:
		var sections = f.get_sections()
		for key in sections:
			var ts = CollectedScript.new(_lgr)
			ts.import_from(f, key)
			_populate_tests(ts)
			scripts.append(ts)
		success = true
	return success


func get_script_named(name):
	return GutUtils.search_array(scripts, 'get_filename_and_inner', name)


func get_test_named(script_name, test_name):
	var s = get_script_named(script_name)
	if(s != null):
		return s.get_test_named(test_name)
	else:
		return null


func to_s():
	var to_return = ''
	for i in range(scripts.size()):
		to_return += scripts[i].to_s() + "\n"
	return to_return

# ---------------------
# Accessors
# ---------------------
func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


func get_test_prefix():
	return _test_prefix


func set_test_prefix(test_prefix):
	_test_prefix = test_prefix


func get_test_class_prefix():
	return _test_class_prefix


func set_test_class_prefix(test_class_prefix):
	_test_class_prefix = test_class_prefix


func get_scripts():
	return scripts


func get_ran_test_count():
	var count = 0
	for s in scripts:
		count += s.get_ran_test_count()
	return count


func get_ran_script_count():
	var count = 0
	for s in scripts:
		if(s.was_run):
			count += 1
	return count

func get_test_count():
	var count = 0
	for s in scripts:
		count += s.tests.size()
	return count


func get_assert_count():
	var count = 0
	for s in scripts:
		count += s.get_assert_count()
	return count


func get_pass_count():
	var count = 0
	for s in scripts:
		count += s.get_pass_count()
	return count


func get_fail_count():
	var count = 0
	for s in scripts:
		count += s.get_fail_count()
	return count


func get_pending_count():
	var count = 0
	for s in scripts:
		count += s.get_pending_count()
	return count



--------------------------------------------------
FILE: res:///addons/gut/thing_counter.gd
--------------------------------------------------
var things = {}

func get_unique_count():
	return things.size()


func add_thing_to_count(thing):
	if(!things.has(thing)):
		things[thing] = 0


func add(thing):
	if(things.has(thing)):
		things[thing] += 1
	else:
		things[thing] = 1


func has(thing):
	return things.has(thing)


func count(thing):
	var to_return = 0
	if(things.has(thing)):
		to_return = things[thing]
	return to_return


func sum():
	var to_return = 0
	for key in things:
		to_return += things[key]
	return to_return


func to_s():
	var to_return = ""
	for key in things:
		to_return += str(key, ":  ", things[key], "\n")
	to_return += str("sum: ", sum())
	return to_return


func get_max_count():
	var max_val = null
	for key in things:
		if(max_val == null or things[key] > max_val):
			max_val = things[key]
	return max_val


func add_array_items(array):
	for i in range(array.size()):
		add(array[i])


--------------------------------------------------
FILE: res:///addons/gut/utils.gd
--------------------------------------------------
@tool
class_name GutUtils
extends Object

const GUT_METADATA = '__gutdbl'

# Note, these cannot change since places are checking for TYPE_INT to determine
# how to process parameters.
enum DOUBLE_STRATEGY{
	INCLUDE_NATIVE,
	SCRIPT_ONLY,
}

enum DIFF {
	DEEP,
	SIMPLE
}

const TEST_STATUSES = {
	NO_ASSERTS = 'no asserts',
	SKIPPED = 'skipped',
	NOT_RUN = 'not run',
	PENDING = 'pending',
	# These two got the "ed" b/c pass is a reserved word and I could not
	# think of better words.
	FAILED = 'fail',
	PASSED = 'pass'
}

const DOUBLE_TEMPLATES = {
	FUNCTION = 'res://addons/gut/double_templates/function_template.txt',
	INIT = 'res://addons/gut/double_templates/init_template.txt',
	SCRIPT = 'res://addons/gut/double_templates/script_template.txt',
}

const NOTHING := '__NOTHING__'
const NO_TEST := 'NONE'
const GUT_ERROR_TYPE = 999

enum TREAT_AS {
	NOTHING,
	FAILURE,
}


## This dictionary defaults to all the native classes that we cannot call new
## on.  It is further populated during a run so that we only have to create
## a new instance once to get the class name string.
static var gdscript_native_class_names_by_type = {
	Tween:"Tween"
}


static var GutScene = load('res://addons/gut/GutScene.tscn')
static var LazyLoader = load('res://addons/gut/lazy_loader.gd')
static var VersionNumbers = load("res://addons/gut/version_numbers.gd")
static var WarningsManager = load("res://addons/gut/warnings_manager.gd")
static var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")
static var RunExternallyScene = load("res://addons/gut/gui/RunExternally.tscn")

# --------------------------------
# Lazy loaded scripts.  These scripts are lazy loaded so that they can be
# declared, but will not load when this script is loaded.  This gives us a
# window at the start of a run to adjust warning levels prior to loading
# everything.
# --------------------------------
static var AutoFree = LazyLoader.new('res://addons/gut/autofree.gd'):
	get: return AutoFree.get_loaded()
	set(val): pass
static var Awaiter = LazyLoader.new('res://addons/gut/awaiter.gd'):
	get: return Awaiter.get_loaded()
	set(val): pass
static var Comparator = LazyLoader.new('res://addons/gut/comparator.gd'):
	get: return Comparator.get_loaded()
	set(val): pass
static var CollectedTest = LazyLoader.new('res://addons/gut/collected_test.gd'):
	get: return CollectedTest.get_loaded()
	set(val): pass
static var CollectedScript = LazyLoader.new('res://addons/gut/collected_script.gd'):
	get: return CollectedScript.get_loaded()
	set(val): pass
static var CompareResult = LazyLoader.new('res://addons/gut/compare_result.gd'):
	get: return CompareResult.get_loaded()
	set(val): pass
static var DiffFormatter = LazyLoader.new("res://addons/gut/diff_formatter.gd"):
	get: return DiffFormatter.get_loaded()
	set(val): pass
static var DiffTool = LazyLoader.new('res://addons/gut/diff_tool.gd'):
	get: return DiffTool.get_loaded()
	set(val): pass
static var DoubleTools = LazyLoader.new("res://addons/gut/double_tools.gd"):
	get: return DoubleTools.get_loader()
	set(val): pass
static var Doubler = LazyLoader.new('res://addons/gut/doubler.gd'):
	get: return Doubler.get_loaded()
	set(val): pass
static var DynamicGdScript = LazyLoader.new("res://addons/gut/dynamic_gdscript.gd") :
	get: return DynamicGdScript.get_loaded()
	set(val): pass
static var Gut = LazyLoader.new('res://addons/gut/gut.gd'):
	get: return Gut.get_loaded()
	set(val): pass
static var GutConfig = LazyLoader.new('res://addons/gut/gut_config.gd'):
	get: return GutConfig.get_loaded()
	set(val): pass
static var GutFonts = LazyLoader.new("res://addons/gut/gut_fonts.gd"):
	get: return GutFonts.get_loaded()
	set(val): pass
static var HookScript = LazyLoader.new('res://addons/gut/hook_script.gd'):
	get: return HookScript.get_loaded()
	set(val): pass
static var InnerClassRegistry = LazyLoader.new('res://addons/gut/inner_class_registry.gd'):
	get: return InnerClassRegistry.get_loaded()
	set(val): pass
static var InputFactory = LazyLoader.new("res://addons/gut/input_factory.gd"):
	get: return InputFactory.get_loaded()
	set(val): pass
static var InputSender = LazyLoader.new("res://addons/gut/input_sender.gd"):
	get: return InputSender.get_loaded()
	set(val): pass
static var JunitXmlExport = LazyLoader.new('res://addons/gut/junit_xml_export.gd'):
	get: return JunitXmlExport.get_loaded()
	set(val): pass
static var GutLogger = LazyLoader.new('res://addons/gut/logger.gd') : # everything should use get_logger
	get: return GutLogger.get_loaded()
	set(val): pass
static var MethodMaker = LazyLoader.new('res://addons/gut/method_maker.gd'):
	get: return MethodMaker.get_loaded()
	set(val): pass
static var OneToMany = LazyLoader.new('res://addons/gut/one_to_many.gd'):
	get: return OneToMany.get_loaded()
	set(val): pass
static var OptionMaker = LazyLoader.new('res://addons/gut/gui/option_maker.gd'):
	get: return OptionMaker.get_loaded()
	set(val): pass
static var OrphanCounter = LazyLoader.new('res://addons/gut/orphan_counter.gd'):
	get: return OrphanCounter.get_loaded()
	set(val): pass
static var ParameterFactory = LazyLoader.new('res://addons/gut/parameter_factory.gd'):
	get: return ParameterFactory.get_loaded()
	set(val): pass
static var ParameterHandler = LazyLoader.new('res://addons/gut/parameter_handler.gd'):
	get: return ParameterHandler.get_loaded()
	set(val): pass
static var Printers = LazyLoader.new('res://addons/gut/printers.gd'):
	get: return Printers.get_loaded()
	set(val): pass
static var ResultExporter = LazyLoader.new('res://addons/gut/result_exporter.gd'):
	get: return ResultExporter.get_loaded()
	set(val): pass
static var ScriptCollector = LazyLoader.new('res://addons/gut/script_parser.gd'):
	get: return ScriptCollector.get_loaded()
	set(val): pass
static var SignalWatcher = LazyLoader.new('res://addons/gut/signal_watcher.gd'):
	get: return SignalWatcher.get_loaded()
	set(val): pass
static var Spy = LazyLoader.new('res://addons/gut/spy.gd'):
	get: return Spy.get_loaded()
	set(val): pass
static var Strutils = LazyLoader.new('res://addons/gut/strutils.gd'):
	get: return Strutils.get_loaded()
	set(val): pass
static var Stubber = LazyLoader.new('res://addons/gut/stubber.gd'):
	get: return Stubber.get_loaded()
	set(val): pass
static var StubParams = LazyLoader.new('res://addons/gut/stub_params.gd'):
	get: return StubParams.get_loaded()
	set(val): pass
static var Summary = LazyLoader.new('res://addons/gut/summary.gd'):
	get: return Summary.get_loaded()
	set(val): pass
static var Test = LazyLoader.new('res://addons/gut/test.gd'):
	get: return Test.get_loaded()
	set(val): pass
static var TestCollector = LazyLoader.new('res://addons/gut/test_collector.gd'):
	get: return TestCollector.get_loaded()
	set(val): pass
static var ThingCounter = LazyLoader.new('res://addons/gut/thing_counter.gd'):
	get: return ThingCounter.get_loaded()
	set(val): pass
# --------------------------------

static var gut_fonts = GutFonts.new()
static var avail_fonts = gut_fonts.get_font_names()

static var version_numbers = VersionNumbers.new(
	# gut_versrion (source of truth)
	'9.5.0',
	# required_godot_version
	'4.5'
)


static var warnings_at_start := { # WarningsManager dictionary
	exclude_addons = true
}

static var warnings_when_loading_test_scripts := { # WarningsManager dictionary
	enable = false
}


# ------------------------------------------------------------------------------
# Everything should get a logger through this.
#
# When running in test mode this will always return a new logger so that errors
# are not caused by getting bad warn/error/etc counts.
# ------------------------------------------------------------------------------
static var _lgr = null
static func get_logger():
	if(_lgr == null):
		_lgr = GutLogger.new()
	return _lgr

static var _error_tracker = null
static func get_error_tracker():
	if(_error_tracker == null):
		_error_tracker = GutErrorTracker.new()
	return _error_tracker


static var _dyn_gdscript = DynamicGdScript.new()
static func create_script_from_source(source, override_path=null):
	var are_warnings_enabled = WarningsManager.are_warnings_enabled()
	WarningsManager.enable_warnings(false)

	var DynamicScript = _dyn_gdscript.create_script_from_source(source, override_path)
	if(typeof(DynamicScript) == TYPE_INT):
		var l = get_logger()
		l.error(str('Could not create script from source.  Error:  ', DynamicScript))
		l.info(str("Source Code:\n", add_line_numbers(source)))

	WarningsManager.enable_warnings(are_warnings_enabled)

	return DynamicScript


# Get the EditorInterface instance without having to make a direct reference to
# it.  This allows for testing to be done on editor scripts that require it
# without having the parser error when you refer to it when not in the editor.
static func get_editor_interface():
	if(Engine.is_editor_hint()):
		var inst = load("res://addons/gut/get_editor_interface.gd").new()
		return inst.get_it()
	else:
		return null



static func godot_version_string():
	return version_numbers.make_godot_version_string()


static func is_godot_version(expected):
	return VersionNumbers.VerNumTools.is_godot_version_eq(expected)


static func is_godot_version_gte(expected):
	return VersionNumbers.VerNumTools.is_godot_version_gte(expected)


const INSTALL_OK_TEXT = 'Everything checks out'
static func make_install_check_text(template_paths=DOUBLE_TEMPLATES, ver_nums=version_numbers):
	var text = INSTALL_OK_TEXT
	if(!FileAccess.file_exists(template_paths.FUNCTION) or
		!FileAccess.file_exists(template_paths.INIT) or
		!FileAccess.file_exists(template_paths.SCRIPT)):

		text = 'One or more GUT template files are missing.  If this is an exported project, you must include *.txt files in the export to run GUT.  If it is not an exported project then reinstall GUT.'
	elif(!ver_nums.is_godot_version_valid()):
		text = ver_nums.get_bad_version_text()

	return text


static func is_install_valid(template_paths=DOUBLE_TEMPLATES, ver_nums=version_numbers):
	return make_install_check_text(template_paths, ver_nums) == INSTALL_OK_TEXT


# ------------------------------------------------------------------------------
# Gets the root node without having to be in the tree and pushing out an error
# if we don't have a main loop ready to go yet.
# ------------------------------------------------------------------------------
# static func get_root_node():
# 	var main_loop = Engine.get_main_loop()
# 	if(main_loop != null):
# 		return main_loop.root
# 	else:
# 		push_error('No Main Loop Yet')
# 		return null


# ------------------------------------------------------------------------------
# Gets the value from an enum.
# - If passed an integer value as a string it will convert it to an int and
# 	processes the int value.
# - If the value is a float then it is converted to an int and then processes
#	the int value
# - If the value is an int, or was converted to an int, then the enum is checked
#	to see if it contains the value, if so then the value is returned.
#	Otherwise the default is returned.
# - If the value is a string then it is uppercased and all spaces are replaced
#	with underscores.  It then checks to see if enum contains a key of that
#	name.  If so then the value for that key is returned, otherwise the default
#	is returned.
#
# This description is longer than the code, you should have just read the code
# and the tests.
# ------------------------------------------------------------------------------
static func get_enum_value(thing, e, default=null):
	var to_return = default

	if(typeof(thing) == TYPE_STRING and str(thing.to_int()) == thing):
		thing = thing.to_int()
	elif(typeof(thing) == TYPE_FLOAT):
		thing = int(thing)

	if(typeof(thing) == TYPE_STRING):
		var converted = thing.to_upper().replace(' ', '_')
		if(e.keys().has(converted)):
			to_return = e[converted]
	else:
		if(e.values().has(thing)):
			to_return = thing

	return to_return


# ------------------------------------------------------------------------------
# return if_null if value is null otherwise return value
# ------------------------------------------------------------------------------
static func nvl(value, if_null):
	if(value == null):
		return if_null
	else:
		return value


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
static func pretty_print(dict, indent = '  '):
	print(JSON.stringify(dict, indent))


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
static func print_properties(props, thing, print_all_meta=false):
	for i in range(props.size()):
		var prop_name = props[i].name
		var prop_value = thing.get(props[i].name)
		var print_value = str(prop_value)
		if(print_value.length() > 100):
			print_value = print_value.substr(0, 97) + '...'
		elif(print_value == ''):
			print_value = 'EMPTY'

		print(prop_name, ' = ', print_value)
		if(print_all_meta):
			print('  ', props[i])


static func print_method_list(thing):
	for entry in thing.get_method_list():
		print("* ", entry.name)


# ------------------------------------------------------------------------------
# Gets the value of the node_property 'script' from a PackedScene's root node.
# This does not assume the location of the root node in the PackedScene's node
# list.  This also does not assume the index of the 'script' node property in
# a nodes's property list.
# ------------------------------------------------------------------------------
static func get_scene_script_object(scene):
	var state = scene.get_state()
	var to_return = null
	var root_node_path = NodePath(".")
	var node_idx = 0

	while(node_idx < state.get_node_count() and to_return == null):
		if(state.get_node_path(node_idx) == root_node_path):
			for i in range(state.get_node_property_count(node_idx)):
				if(state.get_node_property_name(node_idx, i) == 'script'):
					to_return = state.get_node_property_value(node_idx, i)

		node_idx += 1

	return to_return


# ------------------------------------------------------------------------------
# returns true if the object has been freed, false if not
#
# From what i've read, the weakref approach should work.  It seems to work most
# of the time but sometimes it does not catch it.  The str comparison seems to
# fill in the gaps.  I've not seen any errors after adding that check.
# ------------------------------------------------------------------------------
static func is_freed(obj):
	var wr = weakref(obj)
	return !(wr.get_ref() and str(obj) != '<Freed Object>')


# ------------------------------------------------------------------------------
# Pretty self explanitory.
# ------------------------------------------------------------------------------
static func is_not_freed(obj):
	return !is_freed(obj)


# ------------------------------------------------------------------------------
# Checks if the passed in object is a GUT Double or Partial Double.
# ------------------------------------------------------------------------------
static func is_double(obj):
	var to_return = false
	if(typeof(obj) == TYPE_OBJECT and is_instance_valid(obj)):
		to_return = obj.has_method('__gutdbl_check_method__')
	return to_return


# ------------------------------------------------------------------------------
# Checks an object to see if it is a GDScriptNativeClass
# ------------------------------------------------------------------------------
static func is_native_class(thing):
	var it_is = false
	if(typeof(thing) == TYPE_OBJECT):
		it_is = str(thing).begins_with("<GDScriptNativeClass#")
	return it_is


# ------------------------------------------------------------------------------
# Checks if the passed in is an instance of a class
# ------------------------------------------------------------------------------
static func is_instance(obj):
	return typeof(obj) == TYPE_OBJECT and \
		!is_native_class(obj) and \
		!obj.has_method('new') and \
		!obj.has_method('instantiate')


# ------------------------------------------------------------------------------
# Checks if the passed in is a GDScript
# ------------------------------------------------------------------------------
static func is_gdscript(obj):
	return typeof(obj) == TYPE_OBJECT and str(obj).begins_with('<GDScript#')


# ------------------------------------------------------------------------------
# Checks if the passed in is an inner class
#
# Looks like the resource_path will be populated for gdscripts, and not populated
# for gdscripts inside a gdscript.
# ------------------------------------------------------------------------------
static func is_inner_class(obj):
	return is_gdscript(obj) and obj.resource_path == ''


# ------------------------------------------------------------------------------
# Returns an array of values by calling get(property) on each element in source
# ------------------------------------------------------------------------------
static func extract_property_from_array(source, property):
	var to_return = []
	for i in (source.size()):
		to_return.append(source[i].get(property))
	return to_return


# ------------------------------------------------------------------------------
# true if what is passed in is null or an empty string.
# ------------------------------------------------------------------------------
static func is_null_or_empty(text):
	return text == null or text == ''


# ------------------------------------------------------------------------------
# Get the name of a native class or null if the object passed in is not a
# native class.
# ------------------------------------------------------------------------------
static func get_native_class_name(thing):
	var to_return = null
	if(is_native_class(thing)):
		if(gdscript_native_class_names_by_type.has(thing)):
			to_return = gdscript_native_class_names_by_type[thing]
		else:
			var newone = thing.new()
			to_return = newone.get_class()
			if(!newone is RefCounted):
				newone.free()
			gdscript_native_class_names_by_type[thing] = to_return
	return to_return


# ------------------------------------------------------------------------------
# Write a file.
# ------------------------------------------------------------------------------
static func write_file(path, content):
	var f = FileAccess.open(path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
	f = null;

	return FileAccess.get_open_error()


# ------------------------------------------------------------------------------
# Returns the text of a file or an empty string if the file could not be opened.
# ------------------------------------------------------------------------------
static func get_file_as_text(path):
	var to_return = ''
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	else:
		var err = FileAccess.get_open_error()
		_lgr.error(str('Could not open file ', path, '.  Error ', err))
	f = null
	return to_return


# ------------------------------------------------------------------------------
# Loops through an array of things and calls a method or checks a property on
# each element until it finds the returned value.  -1 is returned if not found
# or the index is returned if found.
# ------------------------------------------------------------------------------
static func search_array_idx(ar, prop_method, value):
	var found = false
	var idx = 0

	while(idx < ar.size() and !found):
		var item = ar[idx]
		var prop = item.get(prop_method)
		if(!(prop is Callable)):
			if(item.get(prop_method) == value):
				found = true
		elif(prop != null):
			var called_val = prop.call()
			if(called_val == value):
				found = true

		if(!found):
			idx += 1

	if(found):
		return idx
	else:
		return -1


# ------------------------------------------------------------------------------
# Loops through an array of things and calls a method or checks a property on
# each element until it finds the returned value.  The item in the array is
# returned or null if it is not found (this method originally came first).
# ------------------------------------------------------------------------------
static func search_array(ar, prop_method, value):
	var idx = search_array_idx(ar, prop_method, value)

	if(idx != -1):
		return ar[idx]
	else:
		return null


static func are_datatypes_same(got, expected):
	return !(typeof(got) != typeof(expected) and got != null and expected != null)


static func get_script_text(obj):
	return obj.get_script().get_source_code()


# func get_singleton_by_name(name):
# 	var source = str("var singleton = ", name)
# 	var script = GDScript.new()
# 	script.set_source_code(source)
# 	script.reload()
# 	return script.new().singleton


static func dec2bistr(decimal_value, max_bits = 31):
	var binary_string = ""
	var temp
	var count = max_bits

	while(count >= 0):
		temp = decimal_value >> count
		if(temp & 1):
			binary_string = binary_string + "1"
		else:
			binary_string = binary_string + "0"
		count -= 1

	return binary_string


static func add_line_numbers(contents):
	if(contents == null):
		return ''

	var to_return = ""
	var lines = contents.split("\n")
	var line_num = 1
	for line in lines:
		var line_str = str(line_num).lpad(6, ' ')
		to_return += str(line_str, ' |', line, "\n")
		line_num += 1
	return to_return


static func get_display_size():
	return Engine.get_main_loop().get_viewport().get_visible_rect()



static func find_method_meta(methods, method_name):
	var meta = null
	var idx = 0
	while (idx < methods.size() and meta == null):
		var m = methods[idx]
		if(m.name == method_name):
			meta = m
		idx += 1

	return meta


static func get_method_meta(object, method_name):
	return find_method_meta(object.get_method_list(), method_name)

# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


--------------------------------------------------
FILE: res:///addons/gut/version_conversion.gd
--------------------------------------------------
class ConfigurationUpdater:
	var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")

	func warn(message):
		print('GUT Warning:  ', message)


	func info(message):
		print("GUT Info:  ", message)


	func moved_file(from, to):
		if(FileAccess.file_exists(from) and !FileAccess.file_exists(to)):
			info(str('Copying [', from, '] to [', to, ']'))
			var result = DirAccess.copy_absolute(from, to)
			if(result != OK):
				warn(str('Could not copy [', from, '] to [', to, ']'))

		if(FileAccess.file_exists(from) and FileAccess.file_exists(to)):
			warn(str('File [', from, '] has been moved to [', to, "].\n    You can delete ", from))


	func move_user_file(from, to):
		if(from.begins_with('user://') and to.begins_with('user://')):
			if(FileAccess.file_exists(from) and !FileAccess.file_exists(to)):
				info(str('Moving [', from, '] to [', to, ']'))
				var result = DirAccess.copy_absolute(from, to)
				if(result == OK):
					info(str('    ', 'Created ', to))
					result = DirAccess.remove_absolute(from)
					if(result != OK):
						warn(str('    ', 'Could not delete ', from))
					else:
						info(str('    ', 'Deleted ', from))
				else:
					warn(str('    ', 'Could not copy [', from, '] to [', to, ']'))
		else:
			warn(str('Attempt to move_user_file with files not in user:// ', from, '->', to))


	func remove_user_file(which):
		if(which.begins_with('user://') and FileAccess.file_exists(which)):
			info(str('Deleting obsolete file ', which))
			var result = DirAccess.remove_absolute(which)
			if(result != OK):
				warn(str('    ', 'Could not delete ', which))
			else:
				info(str('    ', 'Deleted ', which))

class v9_2_0:
	extends ConfigurationUpdater

	func validate():
		moved_file('res://.gut_editor_config.json', EditorGlobals.editor_run_gut_config_path)
		moved_file('res://.gut_editor_shortcuts.cfg', EditorGlobals.editor_shortcuts_path)
		remove_user_file('user://.gut_editor.bbcode')
		remove_user_file('user://.gut_editor.json')

# list=Array[Dictionary]([{
# "base": &"RefCounted",
# "class": &"DynamicGutTest",
# "icon": "",
# "language": &"GDScript",
# "path": "res://test/resources/tools/dynamic_gut_test.gd"
# }, {
# "base": &"RefCounted",
# "class": &"GutDoubleTestInnerClasses",
# "icon": "",
# "language": &"GDScript",
# "path": "res://test/resources/doubler_test_objects/inner_classes.gd"
# }, ... ])
static func get_missing_gut_class_names() -> Array:
	var gut_class_names = [
		"GutErrorTracker",
		"GutHookScript",
		"GutInputFactory",
		"GutInputSender",
		"GutMain",
		"GutStringUtils",
		"GutTest",
		"GutTrackedError",
		"GutUtils",
	]

	var class_cach_path = 'res://.godot/global_script_class_cache.cfg'
	var cfg = ConfigFile.new()
	cfg.load(class_cach_path)

	var all_class_names = {}
	var missing  = []
	var class_cache_entries = cfg.get_value('', 'list', [])

	for entry in class_cache_entries:
		if(entry.path.begins_with(&"res://addons/gut/")):
			# print(entry["class"], ':  ', entry["path"])
			all_class_names[entry["class"]] = entry

	for cn in gut_class_names:
		if(!all_class_names.has(cn)):
			missing.append(cn)

	return missing


static func error_if_not_all_classes_imported() -> bool:
	var missing_class_names = get_missing_gut_class_names()
	if(missing_class_names.size() > 0):
		push_error(str("Some GUT class_names have not been imported.  Please restart the Editor or run godot --headless --import\n",
			"Missing class_names:  ",
			missing_class_names))
		return true
	else:
		return false




static func convert():
	var inst = v9_2_0.new()
	inst.validate()


--------------------------------------------------
FILE: res:///addons/gut/version_numbers.gd
--------------------------------------------------
# ##############################################################################
#
# ##############################################################################
class VerNumTools:

	static func _make_version_array_from_string(v):
		var parts = Array(v.split('.'))
		for i in range(parts.size()):
			var int_val = parts[i].to_int()
			if(str(int_val) == parts[i]):
				parts[i] = parts[i].to_int()
		return parts


	static func make_version_array(v):
		var to_return = []
		if(typeof(v) == TYPE_STRING):
			to_return = _make_version_array_from_string(v)
		elif(typeof(v) == TYPE_DICTIONARY):
			return [v.major, v.minor, v.patch]
		elif(typeof(v) == TYPE_ARRAY):
			to_return = v
		return to_return


	static func make_version_string(version_parts):
		var to_return = 'x.x.x'
		if(typeof(version_parts) == TYPE_ARRAY):
			to_return =  ".".join(version_parts)
		elif(typeof(version_parts) == TYPE_DICTIONARY):
			to_return = str(version_parts.major,  '.',  version_parts.minor,  '.',  version_parts.patch)
		elif(typeof(version_parts) == TYPE_STRING):
			to_return = version_parts
		return to_return


	static func is_version_gte(version, required):
		var is_ok = null
		var v = make_version_array(version)
		var r = make_version_array(required)

		var idx = 0
		while(is_ok == null and idx < v.size() and idx < r.size()):
			if(v[idx] > r[idx]):
				is_ok = true
			elif(v[idx] < r[idx]):
				is_ok = false

			idx += 1

		# still null means each index was the same.
		return GutUtils.nvl(is_ok, true)


	static func is_version_eq(version, expected):
		var version_array = make_version_array(version)
		var expected_array = make_version_array(expected)

		if(expected_array.size() > version_array.size()):
			return false

		var is_version = true
		var i = 0
		while(i < expected_array.size() and i < version_array.size() and is_version):
			if(expected_array[i] == version_array[i]):
				i += 1
			else:
				is_version = false

		return is_version


	static func is_godot_version_eq(expected):
		return VerNumTools.is_version_eq(Engine.get_version_info(), expected)


	static func is_godot_version_gte(expected):
		return VerNumTools.is_version_gte(Engine.get_version_info(), expected)




# ##############################################################################
#
# ##############################################################################
var gut_version = '0.0.0'
var required_godot_version = '0.0.0'

func _init(gut_v = gut_version, required_godot_v = required_godot_version):
	gut_version = gut_v
	required_godot_version = required_godot_v


# ------------------------------------------------------------------------------
# Blurb of text with GUT and Godot versions.
# ------------------------------------------------------------------------------
func get_version_text():
	var v_info = Engine.get_version_info()
	var gut_version_info =  str('GUT version:  ', gut_version)
	var godot_version_info  = str('Godot version:  ', v_info.major,  '.',  v_info.minor,  '.',  v_info.patch)
	return godot_version_info + "\n" + gut_version_info


# ------------------------------------------------------------------------------
# Returns a nice string for erroring out when we have a bad Godot version.
# ------------------------------------------------------------------------------
func get_bad_version_text():
	var info = Engine.get_version_info()
	var gd_version = str(info.major, '.', info.minor, '.', info.patch)
	return 'GUT ' + gut_version + ' requires Godot ' + required_godot_version + \
		' or greater.  Godot version is ' + gd_version


# ------------------------------------------------------------------------------
# Checks the Godot version against required_godot_version.
# ------------------------------------------------------------------------------
func is_godot_version_valid():
	return VerNumTools.is_version_gte(Engine.get_version_info(), required_godot_version)


func make_godot_version_string():
	return VerNumTools.make_version_string(Engine.get_version_info())


--------------------------------------------------
FILE: res:///addons/gut/warnings_manager.gd
--------------------------------------------------
const IGNORE = 0
const WARN = 1
const ERROR = 2


const WARNING_LOOKUP = {
	IGNORE : 'IGNORE',
	WARN : 'WARN',
	ERROR : 'ERROR'
}

const GDSCRIPT_WARNING = 'debug/gdscript/warnings/'


# ---------------------------------------
# Static
# ---------------------------------------
static var _static_init_called = false
# This is static and set in _static_init so that we can get the current settings as
# soon as possible.
static var _project_warnings : Dictionary = {}

static var _disabled = false
# should never be true, unless it is, but it shouldn't be.  Whatever it is, it
# should stay the same for the entire run.  Read only.
static var disabled = _disabled:
	get: return _disabled
	set(val):pass

static var project_warnings := {} :
	get:
		# somehow this gets called before _project_warnings is initialized when
		# loading a project in the editor.  It causes an error stating that
		# duplicate can't be called on nil.  It seems there might be an
		# implicit "get" call happening.  Using push_error I saw a message
		# in this method, but not one from _static_init upon loading the project
		if(_static_init_called):
			return _project_warnings.duplicate()
		else:
			return {}
	set(val): pass


static func _static_init():
	_project_warnings = create_warnings_dictionary_from_project_settings()
	_static_init_called = true
	if(disabled):
		print("""
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!! Warnings Manager has been disabled
		!!
		!! Do not push this up buddy
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		""".dedent())


static func are_warnings_enabled():
	return ProjectSettings.get(str(GDSCRIPT_WARNING, 'enable'))


## Turn all warnings on/off.  Use reset_warnings to restore the original value.
static func enable_warnings(should=true):
	if(disabled):
		return
	ProjectSettings.set(str(GDSCRIPT_WARNING, 'enable'), should)


## Turn on/off excluding addons.  Use reset_warnings to restore the original value.
static func exclude_addons(should=true):
	if(disabled):
		return
	ProjectSettings.set(str(GDSCRIPT_WARNING, 'exclude_addons'), should)


## Resets warning settings to what they are set to in Project Settings
static func reset_warnings():
	apply_warnings_dictionary(_project_warnings)



static func set_project_setting_warning(warning_name : String, value : Variant):
	if(disabled):
		return

	var property_name = str(GDSCRIPT_WARNING, warning_name)
	# This check will generate a warning if the setting does not exist
	if(property_name in ProjectSettings):
		ProjectSettings.set(property_name, value)


static func apply_warnings_dictionary(warning_values : Dictionary):
	if(disabled):
		return

	for key in warning_values:
		set_project_setting_warning(key, warning_values[key])


static func create_ignore_all_dictionary():
	return replace_warnings_values(project_warnings, -1, IGNORE)


static func create_warn_all_warnings_dictionary():
	return replace_warnings_values(project_warnings, -1, WARN)


static func replace_warnings_with_ignore(dict):
	return replace_warnings_values(dict, WARN, IGNORE)


static func replace_errors_with_warnings(dict):
	return replace_warnings_values(dict, ERROR, WARN)


static func replace_warnings_values(dict, replace_this, with_this):
	var to_return = dict.duplicate()
	for key in to_return:
		if(typeof(to_return[key]) == TYPE_INT and (replace_this == -1 or to_return[key] == replace_this)):
			to_return[key] = with_this
	return to_return


static func create_warnings_dictionary_from_project_settings() -> Dictionary :
	var props = ProjectSettings.get_property_list()
	var to_return = {}
	for i in props.size():
		if(props[i].name.begins_with(GDSCRIPT_WARNING)):
			var prop_name = props[i].name.replace(GDSCRIPT_WARNING, '')
			to_return[prop_name] = ProjectSettings.get(props[i].name)
	return to_return


static func print_warnings_dictionary(which : Dictionary):
	var is_valid = true
	for key in which:
		var value_str = str(which[key])
		if(_project_warnings.has(key)):
			if(typeof(which[key]) == TYPE_INT):
				if(WARNING_LOOKUP.has(which[key])):
					value_str = WARNING_LOOKUP[which[key]]
				else:
					push_warning(str(which[key], ' is not a valid value for ', key))
					is_valid = false
		else:
			push_warning(str(key, ' is not a valid warning setting'))
			is_valid = false
		var s = str(key, ' = ', value_str)
		print(s)
	return is_valid


static func load_script_ignoring_all_warnings(path : String) -> Variant:
	return load_script_using_custom_warnings(path, create_ignore_all_dictionary())


static func load_script_using_custom_warnings(path : String, warnings_dictionary : Dictionary) -> Variant:
	var current_warns = create_warnings_dictionary_from_project_settings()
	apply_warnings_dictionary(warnings_dictionary)
	var s = load(path)
	apply_warnings_dictionary(current_warns)

	return s


--------------------------------------------------
FILE: res:///addons/loggie/assets/theme/loggie_border_box.tres
--------------------------------------------------
[gd_resource type="StyleBoxFlat" format=3 uid="uid://ckw36egxdynxc"]

[resource]
draw_center = false
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.71, 0.52114, 0.1704, 0.772549)
border_blend = true
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10


--------------------------------------------------
FILE: res:///addons/loggie/assets/theme/loggie_theme.tres
--------------------------------------------------
[gd_resource type="Theme" load_steps=10 format=3 uid="uid://bntkg3oi4b314"]

[ext_resource type="FontFile" uid="uid://btuvtbhws7p8s" path="res://addons/loggie/assets/theme/fonts/PatrickHandSC-Regular.ttf" id="1_ucfms"]
[ext_resource type="Texture2D" uid="uid://bfnp2a0sbhi2x" path="res://addons/loggie/assets/theme/checkbox/checkbox_checked.png" id="2_tqabx"]
[ext_resource type="Texture2D" uid="uid://dqf5cye21gyw8" path="res://addons/loggie/assets/theme/checkbox/checkbox_checked_disabled.png" id="3_plx1a"]
[ext_resource type="Texture2D" uid="uid://bib1lwikra5kr" path="res://addons/loggie/assets/theme/checkbox/checkbox_unchecked.png" id="4_yp55b"]
[ext_resource type="Texture2D" uid="uid://cloe7vx2ej0nf" path="res://addons/loggie/assets/theme/checkbox/checkbox_unchecked_disabled.png" id="5_0424s"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_gb03k"]
bg_color = Color(0.349691, 0.30101, 0.201282, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.361244, 0.323458, 0.213348, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_73pt3"]
bg_color = Color(0.767332, 0.598222, 0.330864, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.943861, 0.775452, 0.522251, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_xxk7l"]
bg_color = Color(0.661808, 0.507874, 0.261375, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.83, 0.629555, 0.3071, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_i1fiu"]
bg_color = Color(0.6, 0.4574, 0.228, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.83, 0.629555, 0.3071, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[resource]
Button/constants/outline_size = 6
Button/font_sizes/font_size = 30
Button/fonts/font = ExtResource("1_ucfms")
Button/styles/disabled = SubResource("StyleBoxFlat_gb03k")
Button/styles/focus = SubResource("StyleBoxFlat_73pt3")
Button/styles/hover = SubResource("StyleBoxFlat_xxk7l")
Button/styles/normal = SubResource("StyleBoxFlat_i1fiu")
CheckBox/icons/checked = ExtResource("2_tqabx")
CheckBox/icons/checked_disabled = ExtResource("3_plx1a")
CheckBox/icons/radio_checked = ExtResource("2_tqabx")
CheckBox/icons/radio_checked_disabled = ExtResource("3_plx1a")
CheckBox/icons/radio_unchecked = ExtResource("4_yp55b")
CheckBox/icons/radio_unchecked_disabled = ExtResource("5_0424s")
CheckBox/icons/unchecked = ExtResource("4_yp55b")
CheckBox/icons/unchecked_disabled = ExtResource("5_0424s")
Label/colors/font_color = Color(0.980392, 0.843137, 0.619608, 1)
Label/constants/outline_size = 3
Label/font_sizes/font_size = 21


--------------------------------------------------
FILE: res:///addons/loggie/channels/discord.gd
--------------------------------------------------
class_name DiscordLoggieMsgChannel extends LoggieMsgChannel

const discord_msg_character_limit = 2000 # The max. amount of characters the content of the message can contain before discord refuses to post it.
var debug_domain = "_d_loggie_discord"
var debug_enabled = false

func _init() -> void:
	self.ID = "discord"
	self.preprocess_flags = 0 # For this type of channel, this will be applied dynamically by Loggie after it loads LoggieSettings.

func send(msg : LoggieMsg, msg_type : LoggieEnums.MsgType):
	# Validate variables.
	var loggie = msg.get_logger()
	if loggie == null:
		push_error("Attempt to send a message that's coming from an invalid logger.")
		return
	
	# Wait until loggie is inside tree so that we can use add_child(http) on it without errors.
	if !loggie.is_inside_tree():
		loggie.tree_entered.connect(func():
			send(msg, msg_type)
		, CONNECT_ONE_SHOT)
		return

	var webhook_url = loggie.settings.discord_webhook_url_live if loggie.is_in_production() else loggie.settings.discord_webhook_url_dev
	if webhook_url == null or (webhook_url is String and webhook_url.is_empty()):
		push_error("Attempt to send a message to the Discord channel with an invalid webhook_url.")
		return

	var output_text = LoggieTools.convert_string_to_format_mode(msg.last_preprocess_result, LoggieEnums.MsgFormatMode.MARKDOWN)

	# Chunk the given string into chunks of maximum supported size by Discord, so we don't end up hitting the character limit
	# which would prevent the message from getting posted.
	var chunks = LoggieTools.chunk_string(output_text, discord_msg_character_limit)
	if chunks.size() > 1:
		loggie.debug("Chunking a long (", output_text.length(), "length ) message while sending to Discord into:", chunks.size(), "chunks.")
	for chunk : String in chunks:
		call_deferred("send_post_request", loggie, chunk, webhook_url)

func send_post_request(logger : Variant, output_text : String, webhook_url : String):
	# Enable debug messages if configured.
	logger.set_domain_enabled(debug_domain, debug_enabled)

	# Create a new HTTPRequest POST request that will be sent to Discord and add it into the scenetree.
	var http = HTTPRequest.new()
	logger.add_child(http)

	# When the request is completed, destroy it.
	http.request_completed.connect(func(result, response_code, headers, body):
		var debug_msg = logger.msg("HTTP Request Completed:").color(Color.ORANGE).header().domain(debug_domain).channel("terminal")
		debug_msg.nl().msg("Result:").color(Color.ORANGE).bold().space().msg(result).nl()
		debug_msg.msg("Response Code:").color(Color.ORANGE).bold().space().msg(response_code).nl()
		debug_msg.msg("Headers:").color(Color.ORANGE).bold().space().msg(headers).nl()
		debug_msg.msg("Body:").color(Color.ORANGE).bold().space().msg(body)
		debug_msg.debug()
		
		## Inform the user about a received non-success response code.
		if response_code < 200 or response_code > 299:
			logger.msg("Discord responded with a non-success code: ").bold().msg(response_code, " - This is an indicator that something about the message you tried to send to Discord does not comply with their request body standards (e.g. content is too long, invalid format, etc.)").channel("terminal").warn()
		
		http.queue_free()
	)
	
	# Convert the [LoggieMsg]'s contents into markdown and post that to the target webhook url.
	var json = JSON.stringify({"content": output_text})
	var header = ["Content-Type: application/json"]

	# Construct debug message.
	if debug_enabled:
		var debug_msg_post = logger.msg("Sending POST Request:").color(Color.CORNFLOWER_BLUE).header().channel("terminal").domain(debug_domain).nl()
		debug_msg_post.msg("JSON stringified (length {size}):".format({"size": output_text.length()})).color(Color.LIGHT_SLATE_GRAY).bold().space().msg(json).color(Color.SLATE_GRAY)
		debug_msg_post.debug()
	
	# Send the request.
	http.request(webhook_url, header, HTTPClient.METHOD_POST, json)


--------------------------------------------------
FILE: res:///addons/loggie/channels/slack.gd
--------------------------------------------------
class_name SlackLoggieMsgChannel extends LoggieMsgChannel

var debug_domain = "_d_loggie_slack"
var debug_enabled = false

func _init() -> void:
	self.ID = "slack"
	self.preprocess_flags = 0 # For this type of channel, this will be applied dynamically by Loggie after it loads LoggieSettings.

func send(msg : LoggieMsg, msg_type : LoggieEnums.MsgType):
	# Validate variables.
	var loggie = msg.get_logger()
	if loggie == null:
		push_error("Attempt to send a message that's coming from an invalid logger.")
		return
	
	# Wait until loggie is inside tree so that we can use add_child(http) on it without errors.
	if !loggie.is_inside_tree():
		loggie.tree_entered.connect(func():
			send(msg, msg_type)
		, CONNECT_ONE_SHOT)
		return
		
	var webhook = loggie.settings.slack_webhook_url_live if loggie.is_in_production() else loggie.settings.slack_webhook_url_dev
	if webhook == null or (webhook is String and webhook.is_empty()):
		push_error("Attempt to send a message to the Slack channel with an invalid webhook.")
		return

	# Enable debug messages if configured.
	loggie.set_domain_enabled(debug_domain, debug_enabled)

	# Create a new HTTPRequest POST request that will be sent to Slack and add it into the scenetree.
	var http = HTTPRequest.new()
	loggie.add_child(http)

	# When the request is completed, destroy it.
	http.request_completed.connect(func(result, response_code, headers, body):
		var debug_msg = loggie.msg("HTTP Request Completed:").color(Color.ORANGE).header().domain(debug_domain)
		debug_msg.nl().msg("Result:").color(Color.ORANGE).bold().space().msg(result).nl()
		debug_msg.msg("Response Code:").color(Color.ORANGE).bold().space().msg(response_code).nl()
		debug_msg.msg("Headers:").color(Color.ORANGE).bold().space().msg(headers).nl()
		debug_msg.msg("Body:").color(Color.ORANGE).bold().space().msg(body)
		debug_msg.debug()

		## Inform the user about a received non-success response code.
		if response_code < 200 or response_code > 299:
			loggie.msg("Slack responded with a non-success code: ").bold().msg(response_code, " - This is an indicator that something about the message you tried to send to Slack does not comply with their request body standards (e.g. content is too long, invalid format, etc.)").channel("terminal").warn()
	
		http.queue_free()
	)
	
	# Convert the [LoggieMsg]'s contents into markdown and post that to the target webhook url.
	var md_text = LoggieTools.convert_string_to_format_mode(msg.last_preprocess_result, LoggieEnums.MsgFormatMode.PLAIN)
	var json = JSON.stringify({"text": md_text})
	var header = ["Content-Type: application/json"]
	
	# Construct debug message.
	if debug_enabled:
		var debug_msg_post = loggie.msg("Sending POST Request:").color(Color.ORANGE).header().domain(debug_domain).nl()
		debug_msg_post.msg("Preprocessed message:").color(Color.ORANGE).bold().space().msg(msg.last_preprocess_result).nl()
		debug_msg_post.msg("JSON stringified:").color(Color.ORANGE).bold().space().msg(json)
		debug_msg_post.debug()
	
	# Send the request.
	http.request(webhook, header, HTTPClient.METHOD_POST, json)


--------------------------------------------------
FILE: res:///addons/loggie/channels/terminal.gd
--------------------------------------------------
class_name TerminalLoggieMsgChannel extends LoggieMsgChannel

func _init() -> void:
	self.ID = "terminal"
	self.preprocess_flags = 0 # For this type of channel, this will be applied dynamically by Loggie after it loads LoggieSettings.

func send(msg : LoggieMsg, msg_type : LoggieEnums.MsgType):
	var loggie = msg.get_logger()
	var text = LoggieTools.convert_string_to_format_mode(msg.last_preprocess_result, loggie.settings.msg_format_mode)

	match loggie.settings.msg_format_mode:
		LoggieEnums.MsgFormatMode.ANSI, LoggieEnums.MsgFormatMode.BBCODE:
			print_rich(text)
		LoggieEnums.MsgFormatMode.PLAIN, _:
			print(text)

	# Dump a non-preprocessed terminal-ready version of the message in additional ways if that has been configured.
	if msg_type == LoggieEnums.MsgType.ERROR and loggie.settings.print_errors_to_console:
		push_error(LoggieTools.convert_string_to_format_mode(msg.string(), LoggieEnums.MsgFormatMode.PLAIN))
	if msg_type == LoggieEnums.MsgType.WARN and loggie.settings.print_warnings_to_console:
		push_warning(LoggieTools.convert_string_to_format_mode(msg.string(), LoggieEnums.MsgFormatMode.PLAIN))


--------------------------------------------------
FILE: res:///addons/loggie/loggie.gd
--------------------------------------------------
@tool

## Loggie is a basic logging utility for those who need common minor improvements and helpers around the basic [method print], [method print_rich]
## and other default Godot printing functions. Loggie creates instances of [LoggieMsg], which are a wrapper around a string that needs to manipulated,
## then uses them to properly format, arrange and present them in the console and .log files. Loggie uses the default Godot logging mechanism under the hood.
extends Node

## The current version of Loggie.
## Needs to be updated manually when changing the version.
var version : LoggieVersion = LoggieVersion.new(3,0)

## Emitted any time Loggie attempts to log a message.
## Useful for capturing the messages that pass through Loggie.
## [br][param msg] is the message Loggie attempted to log (before any preprocessing).
## [br][param msg_string] is a shortcut providing the string content of that message.
## [br][param result] describes the final result of the attempt to log that message.
signal log_attempted(msg : LoggieMsg, msg_string : String, result : LoggieEnums.LogAttemptResult)

## A reference to the settings of this Loggie. Read more about [LoggieSettings].
var settings : LoggieSettings

## Holds a mapping between all registered domains (string keys) and bool values representing whether
## those domains are currently enabled. Enable domains with [method set_domain_enabled].
## You can then place [LoggieMsg] messages into a domain by calling [method LoggieMsg.domain].
## Messages belonging to a disabled domain will never be outputted.
var domains : Dictionary = {}

## Holds a mapping between script paths and the names of the classes defined in those scripts.
var class_names : Dictionary = {}

## Holds a mapping between channel IDs (string) and the
## [LoggieMsgChannel] objects those IDs are representing.
var available_channels = {}

## Stores a reference to a [LoggieVersionManager] that will be used to manage the
## version of this instance.
var version_manager : LoggieVersionManager = LoggieVersionManager.new()

## Stores a reference to each [LoggiePreset] that was created.
## The key is the ID (string) of the preset, and the value is the [LoggieMsg] that was saved as a preset.
var presets : Dictionary = {}

func _init() -> void:
	# Connect the version manager to this logger.
	version_manager.connect_logger(self)

	# Load and initialize the settings.
	var uses_original_settings_file = true
	var default_settings_path = get_script().get_path().get_base_dir().path_join("loggie_settings.gd")
	var custom_settings_path = get_script().get_path().get_base_dir().path_join("custom_settings.gd")
	
	if self.settings == null:
		if custom_settings_path != null and custom_settings_path != "" and ResourceLoader.exists(custom_settings_path):
			var loaded_successfully = load_settings_from_path(custom_settings_path)
			if loaded_successfully:
				uses_original_settings_file = false

	if uses_original_settings_file:
		var _settings = ResourceLoader.load(default_settings_path)
		if _settings != null:
			self.settings = _settings.new()
			self.settings.load()
		else:
			push_error("Loggie loaded neither a custom nor a default settings file. This will break the plugin. Make sure that a valid loggie_settings.gd is in the same directory where loggie.gd is.")
			return

	# Enforce certain settings if configured to do so.
	if self.settings.enforce_optimal_settings_in_release_build == true and is_in_production():
		apply_production_optimal_settings()

	# Set the default custom string converter.
	self.settings.custom_string_converter = LoggieTools.convert_to_string

	# Install all the built-in channels.
	var terminal_channel : TerminalLoggieMsgChannel = load("res://addons/loggie/channels/terminal.gd").new()
	terminal_channel.preprocess_flags = self.settings.preprocess_flags_terminal_channel
	add_channel(terminal_channel)
	var discord_channel : DiscordLoggieMsgChannel = load("res://addons/loggie/channels/discord.gd").new()
	discord_channel.preprocess_flags = self.settings.preprocess_flags_discord_channel
	add_channel(discord_channel)
	var slack_channel : SlackLoggieMsgChannel = load("res://addons/loggie/channels/slack.gd").new()
	slack_channel.preprocess_flags = self.settings.preprocess_flags_slack_channel
	add_channel(slack_channel)

	# Already cache the name of the singleton found at loggie's script path.
	class_names[self.get_script().resource_path] = LoggieSettings.loggie_singleton_name

	# Prepopulate class data from ProjectSettings to avoid needing to read files.
	if OS.has_feature("debug"):
		for class_data: Dictionary in ProjectSettings.get_global_class_list():
			class_names[class_data.path] = class_data.class
	  
		for autoload_setting: String in ProjectSettings.get_property_list().map(func(prop): return prop.name).filter(func(prop): return prop.begins_with("autoload/") and ProjectSettings.has_setting(prop)):
			var autoload_class: String = autoload_setting.trim_prefix("autoload/")
			var class_path: String = ProjectSettings.get_setting(autoload_setting)
			class_path = class_path.trim_prefix("*")      
			if not class_names.has(class_path):
				class_names[class_path] = autoload_class

	# And don't proceed further if we're in Editor mode, since we don't need to show loggie boot messages in that case.
	if Engine.is_editor_hint():
		return 
	
	# Print the Loggie boot messages.
	if self.settings.show_loggie_specs != LoggieEnums.ShowLoggieSpecsMode.DISABLED:
		msg(" Loggie {version}{isproxy} booted.".format({
			"version" : self.version_manager.version,
			"isproxy" : " (proxy for {original})".format({"original": self.version_manager.version.proxy_for}) if self.version_manager.version.proxy_for != null else ""
		})).color(Color.ORANGE).header().nl().info()
		var loggie_specs_msg = LoggieSystemSpecsMsg.new().use_logger(self)
		loggie_specs_msg.add(msg("|\t Using Custom Settings File: ").bold(), !uses_original_settings_file).nl().add("|\t ").hseparator(35).nl()
		
		match self.settings.show_loggie_specs:
			LoggieEnums.ShowLoggieSpecsMode.ESSENTIAL:
				loggie_specs_msg.embed_essential_logger_specs()
			LoggieEnums.ShowLoggieSpecsMode.ADVANCED:
				loggie_specs_msg.embed_advanced_logger_specs()

		loggie_specs_msg.preprocessed(false).info()

	if self.settings.show_system_specs:
		var system_specs_msg = LoggieSystemSpecsMsg.new().use_logger(self)
		system_specs_msg.embed_specs().preprocessed(false).info()

## Attempts to instantiate and use a LoggieSettings object from the script at the given [param path].
## Returns true if successful, otherwise false and prints an error.
func load_settings_from_path(path : String) -> bool:
	var settings_resource = ResourceLoader.load(path)
	var settings_instance

	if settings_resource != null:
		settings_instance = settings_resource.new()

	if (settings_instance is LoggieSettings):
		self.settings = settings_instance
		self.settings.load()
		return true
	else:
		push_error("Unable to instantiate a LoggieSettings object from the script at path {path}. Check that loggie.gd -> custom_settings_path is pointing to a valid .gd script that contains the class definition of a class that either extends LoggieSettings, or is LoggieSettings.".format({"path": path}))
		return false

## Checks if Loggie is running in production (release) mode of the game.
## While it is, every [LoggieMsg] will have plain output.
## Uses a sensible default check for most projects, but
## you can rewrite this function to your needs if necessary.
## TODO: Port this out of Loggie into LoggieSettings so users can override it easier.
func is_in_production() -> bool:
	return OS.has_feature("release")

## Returns a custom list of channels that messages from the given [param domain_name] will be sent to.
## This list can be set through the [method set_domain_enabled] method.
## If the list is empty, default channels will be used.
func get_domain_custom_target_channels(domain_name : String) -> Array:
	if domains.has(domain_name):
		return domains[domain_name].custom_target_channels
	return []

## Sets whether the domain with the given name is enabled.
## If [param custom_target_channels] is provided, it will be used as the list of channels that messages from the given domain will be sent to.
## It can be provided as a string (if only one channel is used), or an array of strings (if multiple channels are used).
## Otherwise, the default channels will be used.
func set_domain_enabled(domain_name : String, enabled : bool, custom_target_channels : Variant = []) -> void:
	var pruned_target_channels = []

	if custom_target_channels is String:
		custom_target_channels = [custom_target_channels]

	# Prune the array to ensure only string content is used.
	if custom_target_channels is Array:
		for entry in custom_target_channels:
			if entry is String or entry is StringName:
				pruned_target_channels.push_back(entry)
	else:
		push_error("Attempt to set a custom target channel for domain {domain_name} with an invalid value: {custom_target_channels}. The value must be a string or an array of strings. Default channels will be used instead.".format({
			"domain_name": domain_name,
			"custom_target_channels": custom_target_channels
		}))

	domains[domain_name] = {"enabled": enabled, "custom_target_channels": pruned_target_channels}

## Checks whether the domain with the given name is enabled.
## The domain name "" (empty string) is the default one for all newly created messages,
## and is designed to always be enabled.
func is_domain_enabled(domain_name : String) -> bool:
	if domain_name == "":
		return true
	
	if domains.has(domain_name) and domains[domain_name].enabled == true:
		return true
	
	return true


## Returns an available channel with the given ID (if one exists), otherwise null.
func get_channel(channel_id : String) -> LoggieMsgChannel:
	if available_channels.has(channel_id):
		return available_channels[channel_id]
	return null

## Adds a new channel for sending messages to.
## Multiple channels with the same ID can not be added, so make sure your ID
## does not clash with one of the existing channels' IDs, which are:
## [param terminal], [param discord], [param slack].
func add_channel(channel : LoggieMsgChannel):
	if not available_channels.has(channel.ID):
		available_channels[channel.ID] = channel
	else:
		push_error("Attempt to add a channel with ID {ID} failed, a channel with that ID already exists in Loggie.".format({
			"ID": channel.ID
		}))

## Gets a [LoggiePreset] message with the given ID, or creates one if it doesn't exist and returns it.
## The ID cannot be an empty string.
func preset(id : String) -> LoggiePreset:
	if id.is_empty():
		push_error("Attempt to create or get a LoggiePreset with an empty ID - not allowed.")
		return null
	
	if presets.has(id):
		return presets[id]
	else:
		var newPreset : LoggiePreset = LoggiePreset.new()
		newPreset.use_logger(self)
		presets[id] = newPreset
		return newPreset

## Creates a new [LoggieMsg] out of the given [param msg] and extra arguments (by converting them to strings and concatenating them to the msg).
## You may continue to modify the [LoggieMsg] with additional functions from that class, then when you are ready to output it, use methods like:
## [method LoggieMsg.info], [method LoggieMsg.warn], etc.
func msg(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	var loggieMsg = LoggieMsg.new(message, arg1, arg2, arg3, arg4, arg5)
	loggieMsg.use_logger(self)
	return loggieMsg

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the info level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func info(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).info()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the warn level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func warn(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).warn()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the error level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func error(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).error()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the debug level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func debug(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).debug()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the notice level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func notice(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).notice()

## Returns the path to the directory from which within this script is running.
func get_directory_path() -> String:
	return get_script().resource_path.get_base_dir()

## Returns a [LoggieMsg] that comes inserted with stylized content describing the stack trace obtained via [method get_stack].
## This function only works in debug builds, and on the main thread, because it uses [method get_stack].
## Read more about why in that function's documentation.
func stack() -> LoggieMsg:
	if !OS.has_feature("debug"):
		return msg()

	const FALLBACK_TXT_TO_FORMAT = "{index}: {fn_name}:{line} (in {source_path})"
	var stack = get_stack()
	var stack_msg = msg()
	
	var text_to_format = settings.format_stacktrace_entry if is_instance_valid(settings) else FALLBACK_TXT_TO_FORMAT
	
	stack.reverse()
	
	for index in stack.size():
		var file_name = stack[index].source.get_file().get_basename()

		if settings.skipped_filenames_in_stack_trace.has(file_name):
			continue

		var entry_msg = LoggieMsg.new()
		entry_msg.add(text_to_format.format({
			"index": index,
			"source_path": stack[index].source,
			"fn_name": stack[index].function,
			"line": stack[index].line
		}))

		if index == 0 or index < stack.size():
			entry_msg.prefix("\n  ")
			entry_msg.endseg()

		stack_msg.add(entry_msg)

	return stack_msg

## Changes the values of certain members of [member settings] to values which are optimal for
## use in production builds. Used when [member LoggieSettings.enforce_optimal_settings_in_release_build]
## needs to be enforced.
func apply_production_optimal_settings():
	self.settings.msg_format_mode = LoggieEnums.MsgFormatMode.PLAIN
	self.settings.box_characters_mode = LoggieEnums.BoxCharactersMode.COMPATIBLE


--------------------------------------------------
FILE: res:///addons/loggie/loggie_message.gd
--------------------------------------------------
@tool

## LoggieMsg represents a mutable object that holds an array of strings ([member content]) [i](referred to as 'content segments')[/i], and
## a bunch of helper methods that make it easy to manipulate these segments and chain together additions and changes to them.
## [br][br]For example:
## [codeblock]
### Prints: "Hello world!" at the INFO debug level.
##var msg = LoggieMsg.new("Hello world").color(Color.RED).suffix("!").info() 
##[/codeblock]
## [br] You can also use [method Loggie.msg] to quickly construct a message.
## [br] Example of usage:
## [codeblock]Loggie.msg("Hello world").color(Color("#ffffff")).suffix("!").info()[/codeblock]
class_name LoggieMsg extends RefCounted

## The full content of this message. By calling various helper methods in this class, this content is further altered.
## The content is an array of strings which represents segments of the message which are ultimately appended together 
## to form the final message. You can start a new segment by calling [method msg] on this class.
## You can then output the whole message with methods like [method info], [method debug], etc.
var content : Array = [""]

## The segment of [member content] that is currently being edited.
var current_segment_index : int = 0

## The (key string) domain this message belongs to.
## "" is the default domain which is always enabled.
## If this message attempts to be outputted, but belongs to a disabled domain, it will not be outputted.
## You can change which domains are enabled in Loggie at any time with [Loggie.set_domain_enabled].
## This is useful for creating blocks of debugging output that you can simply turn off/on with a boolean when you actually need them.
var domain_name : String = ""

## Stores a reference to the logger that generated this message, from which we need to read settings and other data.
## This variable should be set with [method use_logger] before an attempt is made to log this message out.
var _logger : Variant

## Stores an array of IDs of all channels this message should be sent to when being outputted.
var used_channels : Array = ["terminal"]

## Whether this message should be preprocessed and modified during [method output].
var preprocess : bool = true

## Usually, the [LoggieMsgChannel] this message gets outputted on sets the preprocessing steps this message should use.
## But sometimes we may want to use a specific set of preprocessing steps on this message,
## overriding the channel's set of rules.
## In that case, set this variable to the value of the [LoggieEnums.PreprocessStep] flags you want this message to use with
## [method preprocess].
var custom_preprocess_flags : int = -1

## Stores the string which was obtained the last time the [method get_preprocessed] was called on this message.
## You need to call it at least once for this to have any results.
var last_preprocess_result : String = ""

## Stores the integer value of a [enum LoggieEnums.LogLevel], matching the log level
## this message was most recently outputted at. If value is `-1`, the message was never
## outputted yet.
var last_outputted_at_log_level : int = -1

## Whether this message should append the stack trace during preprocessing.
var appends_stack : bool = false

## Controls whether the [enum LoggieEnums.MsgType] of this message, during [method output], 
## will be decided dynamically, based on the [enum LoggieEnums.LogLevel] the message is being output at.
## If disabled, the [member strict_type] will be used instead.
var dynamic_type : bool = true

## The [LoggieEnums.MsgType] this message will be considered typed as, if [member dynamic_type] is set
## to [param false].
var strict_type : LoggieEnums.MsgType = LoggieEnums.MsgType.INFO

## The environment in which this message should be outputted based on the context the output is being requested from.
## (e.g. only in-engine (during tool scripts), or only ingame, or both).
var environment_mode : LoggieEnums.MsgEnvironment = LoggieEnums.MsgEnvironment.BOTH

## If set to true, the [signal Loggie.log_attempted] signal will not be emitted when this message attempts to be outputted.
var dont_emit_log_attempted_signal : bool = false

func _init(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> void:
	var args = [message, arg1, arg2, arg3, arg4, arg5]
	self.content[0] = LoggieTools.concatenate_args(args)
	self.set_meta("initial_args", args)

## Returns a reference to the logger object that created this message.
func get_logger() -> Variant:
	return self._logger

## Sets this message to use the given [param logger] as the logger from which it will be reading
## settings. The given logger should be of class [Loggie] or an extension of it.
func use_logger(logger_to_use : Variant) -> LoggieMsg:
	self._logger = logger_to_use
	self.used_channels = self._logger.settings.default_channels
	
	# Now that a logger is connected, we can re-format the first segment
	# using that Logger's converter function if it has a custom one defined.
	if self.has_meta("initial_args"):
		var initial_args = self.get_meta("initial_args")
		if initial_args is Array:
			var converter_fn = self._logger.settings.custom_string_converter if is_instance_valid(self._logger) and is_instance_valid(self._logger.settings) else null
			if converter_fn != LoggieTools.convert_to_string:
				self.content[0] = LoggieTools.concatenate_args(initial_args, converter_fn)
		self.remove_meta("initial_args") # Clean up.

	return self

## Sets the list of channels this message should be sent to when outputted.
## [param channels] should either be provided as a single channel ID (String), or
## as an array of channel IDs (Array of strings).
func channel(channels : Variant) -> LoggieMsg:
	if typeof(channels) != TYPE_ARRAY and typeof(channels) != TYPE_PACKED_STRING_ARRAY:
		channels = [str(channels)]
	self.used_channels = channels
	return self

## Returns a processed version of the content of this message, which has modifications applied to
## it based on the requested [param type] and other settings defined by the provided preprocess [param flags].
## Available preprocess flags are found in [enum LoggieEnums.PreprocessStep].
func get_preprocessed(flags : int, _level : LoggieEnums.LogLevel, type : LoggieEnums.MsgType) -> String:
	var loggie = get_logger()
	var message = self.string()

	match type:
		LoggieEnums.MsgType.ERROR:
			message = loggie.settings.format_error_msg.format({"msg": message})
		LoggieEnums.MsgType.WARN:
			message = loggie.settings.format_warning_msg.format({"msg": message})
		LoggieEnums.MsgType.NOTICE:
			message = loggie.settings.format_notice_msg.format({"msg": message})
		LoggieEnums.MsgType.INFO:
			message = loggie.settings.format_info_msg.format({"msg": message})
		LoggieEnums.MsgType.DEBUG:
			message = loggie.settings.format_debug_msg.format({"msg": message})

	if (flags & LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME != 0) and !self.domain_name.is_empty():
		message = _apply_format_domain(message)

	if (flags & LoggieEnums.PreprocessStep.APPEND_CLASS_NAME != 0) and OS.has_feature("debug"):
		message = _apply_format_class_name(message)

	if (flags & LoggieEnums.PreprocessStep.APPEND_TIMESTAMPS != 0):
		message = _apply_format_timestamp(message)

	if self.appends_stack or (loggie.settings.debug_msgs_print_stack_trace and type == LoggieEnums.MsgType.DEBUG):
		message = _apply_format_stack(message)

	return message

## Outputs the given string [param message] at the given output [param level] to the standard output using either [method print_rich] or [method print].
## The domain from which the message is considered to be coming can be provided via [param target_domain].
## The message type can be provided via [param msg_type], but it will be ignored if [member dynamic_type] is false,
## in which case, the [member strict_type] will be used.
## It also does a number of changes to the given [param msg] based on various Loggie settings.
## Designed to be called internally. You should consider using [method info], [method error], [method warn], [method notice], [method debug] instead.
func output(level : LoggieEnums.LogLevel, msg_type : LoggieEnums.MsgType = LoggieEnums.MsgType.INFO) -> void:
	var loggie = get_logger()
	var message = self.string()
	var target_domain = self.domain_name
	var target_channels = self.used_channels
	
	if loggie == null:
		push_error("Attempt to log output with an invalid _logger. Make sure to call LoggieMsg.use_logger to set the appropriate logger before working with the message.")
		return
		
	if loggie.settings == null:
		push_error("Attempt to use a _logger with invalid settings to print: {msg}".format({"msg": message}))
		return

	# We don't output the message if the settings dictate that messages of that level shouldn't be outputted.
	if level > loggie.settings.log_level:
		_emit_log_attempted_signal(LoggieEnums.LogAttemptResult.LOG_LEVEL_INSUFFICIENT)
		return

	# We don't output the message if the domain from which it comes is not enabled.
	if not loggie.is_domain_enabled(target_domain):
		_emit_log_attempted_signal(LoggieEnums.LogAttemptResult.DOMAIN_DISABLED)
		return

	# We don't output the message if the environment the output is being requested from is not compatible with 
	# the environment this message is configured to be outputted in.
	match environment_mode:
		LoggieEnums.MsgEnvironment.ENGINE:
			if not Engine.is_editor_hint():
				_emit_log_attempted_signal(LoggieEnums.LogAttemptResult.WRONG_ENVIRONMENT)
				return
		LoggieEnums.MsgEnvironment.RUNTIME:
			if Engine.is_editor_hint():
				_emit_log_attempted_signal(LoggieEnums.LogAttemptResult.WRONG_ENVIRONMENT)
				return

	# Enforce the strict type of this message if it is configured not to allow dynamic type.
	if !dynamic_type:
		msg_type = strict_type

	# Send the message on all configured channels.
	var custom_target_channels = loggie.get_domain_custom_target_channels(target_domain)
	if custom_target_channels.size() > 0:
		target_channels = custom_target_channels

	for channel_id : String in target_channels:
		var channel : LoggieMsgChannel = loggie.get_channel(channel_id)

		if channel == null:
			_emit_log_attempted_signal(LoggieEnums.LogAttemptResult.INVALID_CHANNEL)
			continue

		# Preprocessing Stage:
		#   Apply full preprocessing only if explicitly enabled.
		#   Otherwise, simply concatenate together all the [member content].
		if self.preprocess:
			var flags = self.custom_preprocess_flags if self.custom_preprocess_flags != -1 else channel.preprocess_flags
			self.last_preprocess_result = get_preprocessed(flags, level, msg_type)
		else:
			self.last_preprocess_result = self.string()

		self.last_outputted_at_log_level = int(level)
		channel.send(self, msg_type)
		
	# Emit signal deferred so if this is called from a thread, it doesn't cry about it.
	_emit_log_attempted_signal(LoggieEnums.LogAttemptResult.SUCCESS, true)

## Outputs this message from Loggie as an Error type message.
## The [Loggie.settings.log_level] must be equal to or higher to the ERROR level for this to work.
func error() -> LoggieMsg:
	output(LoggieEnums.LogLevel.ERROR, LoggieEnums.MsgType.ERROR)
	return self

## Outputs this message from Loggie as an Warning type message.
## The [Loggie.settings.log_level] must be equal to or higher to the WARN level for this to work.
func warn() -> LoggieMsg:
	output(LoggieEnums.LogLevel.WARN, LoggieEnums.MsgType.WARN)
	return self

## Outputs this message from Loggie as an Notice type message.
## The [Loggie.settings.log_level] must be equal to or higher to the NOTICE level for this to work.
func notice() -> LoggieMsg:
	output(LoggieEnums.LogLevel.NOTICE, LoggieEnums.MsgType.NOTICE)
	return self

## Outputs this message from Loggie as an Info type message.
## The [Loggie.settings.log_level] must be equal to or higher to the INFO level for this to work.
func info() -> LoggieMsg:
	output(LoggieEnums.LogLevel.INFO, LoggieEnums.MsgType.INFO)
	return self

## Outputs this message from Loggie as a Debug type message.
## The [Loggie.settings.log_level] must be equal to or higher to the DEBUG level for this to work.
func debug() -> LoggieMsg:
	output(LoggieEnums.LogLevel.DEBUG, LoggieEnums.MsgType.DEBUG)
	return self

## Returns the string content of this message.
## If [param segment] is provided, it should be an integer indicating which segment of the message to return.
## If its value is -1, all segments are concatenated together and returned.
func string(segment : int = -1) -> String:
	if segment == -1:
		return "".join(self.content)
	else:
		if segment < self.content.size():
			return self.content[segment]
		else:
			push_error("Attempt to access a non-existent segment of a LoggieMsg. Make sure to use a valid segment index.")
			return ""

## Converts the current content of this message to an ANSI compatible form.
func to_ANSI() -> LoggieMsg:
	var new_content : Array = []
	for segment in self.content:
		new_content.append(LoggieTools.rich_to_ANSI(segment))
	self.content = new_content
	return self

## Strips all the BBCode in the current content of this message.
func strip_BBCode() -> LoggieMsg:
	var new_content : Array = []
	for segment in self.content:
		new_content.append(LoggieTools.remove_BBCode(segment))
	self.content = new_content
	return self

## Wraps the content of the current segment of this message in the given color.
## The [param color] can be provided as a [Color], a recognized Godot color name (String, e.g. "red"), or a color hex code (String, e.g. "#ff0000").
func color(_color : Variant) -> LoggieMsg:
	if _color is Color:
		_color = _color.to_html()
	
	self.content[current_segment_index] = "[color={colorstr}]{msg}[/color]".format({
		"colorstr": _color, 
		"msg": self.content[current_segment_index]
	})

	return self

## Stylizes the current segment of this message to be bold.
func bold() -> LoggieMsg:
	self.content[current_segment_index] = "[b]{msg}[/b]".format({"msg": self.content[current_segment_index]})
	return self

## Stylizes the current segment of this message to be italic.
func italic() -> LoggieMsg:
	self.content[current_segment_index] = "[i]{msg}[/i]".format({"msg": self.content[current_segment_index]})
	return self

## Makes the current segment of this message a hyperlink to the given [param url].
## Optionally, you can provide a [param color], as the same type of parameter that [method color] uses,
## to colorize the link. This is a shortcut for additionally calling [method color] on the link.
## [br][br]If the link doesn't work when rendered inside of a [RichTextLabel], you may need to connect to the [signal RichTextLabel.meta_clicked] signal,
## and handle the opening of the link there. Read the docs of that signal for more info.
## [br][br][WARNING]: Appending URLs to messages is potentially dangerous. 
## Please read this article for more info: https://docs.godotengine.org/en/latest/tutorials/ui/bbcode_in_richtextlabel.html#handling-user-input-safely
func link(url : String, _color : Variant = null) -> LoggieMsg:
	self.content[current_segment_index] = "[url={url}]{msg}[/url]".format({"url": url, "msg": self.content[current_segment_index]})
	if _color:
		self.color(_color)
	return self

## Stylizes the current segment of this message as a header.
func header() -> LoggieMsg:
	var loggie = get_logger()
	self.content[current_segment_index] = loggie.settings.format_header.format({"msg": self.content[current_segment_index]})
	return self

## Sets whether this message should append the stack trace during preprocessing.
## If used in a different thread, it doesn't work, because it relies on [method get_stack] and
## that method doesn't work within threads.
func stack(enabled : bool = true) -> LoggieMsg:
	self.appends_stack = enabled
	return self

## Constructs a decorative box with the given horizontal padding around the current segment
## of this message. Messages containing a box are not going to be preprocessed, so they are best
## used only as a special header or decoration.
func box(h_padding : int = 4) -> LoggieMsg:
	var loggie = get_logger()
	var stripped_content = LoggieTools.remove_BBCode(self.content[current_segment_index]).strip_edges(true, true)
	var content_length = stripped_content.length()
	var h_fill_length = content_length + (h_padding * 2)
	var box_character_source = loggie.settings.box_symbols_compatible if loggie.settings.box_characters_mode == LoggieEnums.BoxCharactersMode.COMPATIBLE else loggie.settings.box_symbols_pretty

	var top_row_design = "{top_left_corner}{h_fill}{top_right_corner}".format({
		"top_left_corner" : box_character_source.top_left,
		"h_fill" : box_character_source.h_line.repeat(h_fill_length),
		"top_right_corner" : box_character_source.top_right
	})

	var middle_row_design = "{vert_line}{padding}{content}{space_fill}{padding}{vert_line}".format({
		"vert_line" : box_character_source.v_line,
		"content" : self.content[current_segment_index],
		"padding" : " ".repeat(h_padding),
		"space_fill" : " ".repeat(h_fill_length - stripped_content.length() - h_padding*2)
	})
	
	var bottom_row_design = "{bottom_left_corner}{h_fill}{bottom_right_corner}".format({
		"bottom_left_corner" : box_character_source.bottom_left,
		"h_fill" : box_character_source.h_line.repeat(h_fill_length),
		"bottom_right_corner" : box_character_source.bottom_right
	})
	
	self.content[current_segment_index] = "{top_row}\n{middle_row}\n{bottom_row}\n".format({
		"top_row" : top_row_design,
		"middle_row" : middle_row_design,
		"bottom_row" : bottom_row_design
	})
	
	self.preprocessed(false)
	return self
	
## Appends additional content to this message at the end of the current content and its stylings.
## This does not create a new message segment, just appends to the current one.
func add(message : Variant = null, arg1 : Variant = null, arg2 : Variant = null, arg3 : Variant = null, arg4 : Variant = null, arg5 : Variant = null) -> LoggieMsg:
	var converter_fn = self._logger.settings.custom_string_converter if is_instance_valid(self._logger) and is_instance_valid(self._logger.settings) else null
	self.content[current_segment_index] = self.content[current_segment_index] + LoggieTools.concatenate_args([message, arg1, arg2, arg3, arg4, arg5], converter_fn)
	return self

## Adds a specified amount of newlines to the end of the current segment of this message.
func nl(amount : int = 1) -> LoggieMsg:
	self.content[current_segment_index] += "\n".repeat(amount)
	return self

## Adds a specified amount of spaces to the end of the current segment of this message.
func space(amount : int = 1) -> LoggieMsg:
	self.content[current_segment_index] += " ".repeat(amount)
	return self

## Adds a specified amount of tabs to the end of the current segment of this message.
func tab(amount : int = 1) -> LoggieMsg:
	self.content[current_segment_index] += "\t".repeat(amount)
	return self

## Sets this message to belong to the domain with the given name.
## If it attempts to be outputted, but the domain is disabled, it won't be outputted.
func domain(_domain_name : String) -> LoggieMsg:
	self.domain_name = _domain_name
	return self

## Prepends the given prefix string to the start of the message (first segment) with the provided separator.
func prefix(str_prefix : String, separator : String = "") -> LoggieMsg:
	self.content[0] = "{prefix}{separator}{content}".format({
		"prefix" : str_prefix,
		"separator" : separator,
		"content" : self.content[0]
	})
	return self

## Appends the given suffix string to the end of the message (last segment) with the provided separator.
func suffix(str_suffix : String, separator : String = "") -> LoggieMsg:
	self.content[self.content.size() - 1] = "{content}{separator}{suffix}".format({
		"suffix" : str_suffix,
		"separator" : separator,
		"content" : self.content[self.content.size() - 1]
	})
	return self

## Appends a horizontal separator with the given length to the current segment of this message.
## If [param alternative_symbol] is provided, it should be a String, and it will be used as the symbol for the separator instead of the default one.
func hseparator(size : int = 16, alternative_symbol : Variant = null) -> LoggieMsg:
	var loggie = get_logger()
	var symbol = loggie.settings.h_separator_symbol if alternative_symbol == null else str(alternative_symbol)
	self.content[current_segment_index] = self.content[current_segment_index] + (symbol.repeat(size))
	return self

## Ends the current segment of the message and starts a new one.
func endseg() -> LoggieMsg:
	self.content.push_back("")
	self.current_segment_index = self.content.size() - 1
	return self

## Sets the environment in which this message should be outputted based on the context the output is being requested from.
## (e.g. only in-engine (during tool scripts), or only ingame, or both).
func env(mode : LoggieEnums.MsgEnvironment) -> LoggieMsg:
	self.environment_mode = mode
	return self

## Creates a new segment in this message and sets its content to the given message.
## Acts as a shortcut for calling [method endseg] + [method add].
func msg(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	self.endseg()
	var converter_fn = self._logger.settings.custom_string_converter if is_instance_valid(self._logger) and is_instance_valid(self._logger.settings) else null
	self.content[current_segment_index] = LoggieTools.concatenate_args([message, arg1, arg2, arg3, arg4, arg5], converter_fn)
	return self

## Sets whether this message should be preprocessed and potentially modified with prefixes and suffixes during [method output].
## If turned off, while outputting this message, Loggie will skip the steps where it appends the messaage domain, class name, timestamp, etc.
## Whether preprocess is set to true doesn't affect the final conversion from RICH to ANSI or PLAIN, which always happens 
## under some circumstances that are based on other settings.
func preprocessed(shouldPreprocess : bool) -> LoggieMsg:
	self.preprocess = shouldPreprocess
	return self

## Sets this message's [LoggieEnums.MsgType] to be strictly the provided value,
## instead of dynamically decided by the log level at which it is being outputted.
## [br][param loggie_enums_msgtype_key_or_value] should either be provided as a direct value of the enum,
## (e.g. [enum LoggieEnum.MsgType.INFO]) or as a string matching one of the keys in that enum (e.g.
## `"info"` or `"INFO"`, case-insensitive).
func type(loggie_enums_msgtype_key_or_value : Variant) -> LoggieMsg:
	var isValid = false
	var _type : LoggieEnums.MsgType

	if loggie_enums_msgtype_key_or_value is LoggieEnums.MsgType:
		_type = loggie_enums_msgtype_key_or_value
		isValid = true
	elif loggie_enums_msgtype_key_or_value is String:
		var uppercase_key = loggie_enums_msgtype_key_or_value.to_upper()
		if LoggieEnums.MsgType.keys().has(uppercase_key):
			_type = LoggieEnums.MsgType[uppercase_key]
			isValid = true 
	
	if isValid:
		dynamic_type = false
		strict_type = _type
	else:
		push_error("Attempt to set LoggieMsg type to {value} - could not be converted to a proper [LoggieEnums.MsgType]. Either provide a [LoggieEnums.MsgType], or a string that matches a key in that enum (case-insensitive).".format({"value": str(loggie_enums_msgtype_key_or_value)}))

	return self

## If [param enabled], the [signal Loggie.log_attempted] signal will not be emitted when this message attempts to be outputted.
func no_signal(enabled : bool = true) -> LoggieMsg:
	dont_emit_log_attempted_signal = enabled
	return self

## Applies the [LoggiePreset] with the given [param id] to this message.
## [br]If [param apply_only_to_current_segment] is [param true], the styles from the preset will only be
## applied to the current content segment of this message. Otherwise, the entire content of this message
## will be collapsed into a single segment, and the styles will be applied to that.
func preset(id : String, apply_only_to_current_segment : bool = false) -> LoggieMsg:
	var loggie = get_logger()
	var preset_to_use : LoggiePreset = loggie.preset(id)
	if preset_to_use:
		preset_to_use.apply_to(self, apply_only_to_current_segment)
	else:
		push_error("Attempt to obtain LoggiePreset with ID {id} returned null. Something went terribly wrong, as this should usually be impossible.")
	return self

## Internal method. Emits the [signal Loggie.log_attempted] signal (unless that feature is disabled).
## Used during [method output]. If [param call_deferred] is true, the string of the message's content will
## be prepared immediately, but the emission of the signal will be deferred.
func _emit_log_attempted_signal(result : LoggieEnums.LogAttemptResult, call_deferred : bool = false) -> void:
	if dont_emit_log_attempted_signal:
		return

	var loggie = get_logger()
	var string_content = self.string()

	if call_deferred:
		loggie.call_deferred("emit_signal", "log_attempted", self, string_content, result)
	else:
		loggie.log_attempted.emit(self, string_content, result)

## Adds this message's configured domain to the start of the given [param message] and returns the modifier version of it.
func _apply_format_domain(message : String) -> String:
	var loggie = get_logger()
	message = loggie.settings.format_domain_prefix.format({"domain" : self.domain_name, "msg" : message})
	return message

## Adds a formatted class name to the given [param message] and returns the modified version of it.
func _apply_format_class_name(message : String) -> String:
	var loggie = get_logger()
	var stack_frame : Dictionary = LoggieTools.get_current_stack_frame_data()
	var _class_name : String

	var scriptPath = stack_frame.source
	if loggie.class_names.has(scriptPath):
		_class_name = loggie.class_names[scriptPath]
	else:
		_class_name = LoggieTools.get_class_name_from_script(scriptPath, loggie.settings.nameless_class_name_proxy)
		loggie.class_names[scriptPath] = _class_name
	
	if _class_name != "":
		message = "[b]({class_name})[/b] {msg}".format({
			"class_name" : _class_name,
			"msg" : message
		})
	return message

## Adds a formatted timestamp to the given [param message] and returns the modified version of it.
func _apply_format_timestamp(message : String) -> String:
	var loggie = get_logger()
	var format_dict : Dictionary = Time.get_datetime_dict_from_system(loggie.settings.timestamps_use_utc)
	for field in ["month", "day", "hour", "minute", "second"]:
		format_dict[field] = "%02d" % format_dict[field]

	# Add the millisecond
	var unix_time: float = Time.get_unix_time_from_system()
	var millisecond: int = int((unix_time - int(unix_time)) * 1000.0)
	format_dict["millisecond"] = "%03d" % millisecond
	
	# Add the startup time to the format dictionary.
	var elapsed_millisecond: int = Time.get_ticks_msec()
	var startup_hour: int = elapsed_millisecond / 3_600_000
	var startup_minute: int = (elapsed_millisecond % 3_600_000) / 60_000
	var startup_second: int = (elapsed_millisecond % 60_000) / 1000
	var startup_millisecond: int = elapsed_millisecond % 1000
	format_dict["startup_hour"] = "%02d" % startup_hour
	format_dict["startup_minute"] = "%02d" % startup_minute
	format_dict["startup_second"] = "%02d" % startup_second
	format_dict["startup_millisecond"] = "%03d" % startup_millisecond

	message = "{formatted_time} {msg}".format({
		"formatted_time" : loggie.settings.format_timestamp.format(format_dict),
		"msg" : message
	})
	
	return message

## Adds the stack trace to the given [param message] and returns the modified version of it.
func _apply_format_stack(message : String) -> String:
	var loggie = get_logger()
	var stack_msg = loggie.stack()
	message = message + stack_msg.string()
	return message


--------------------------------------------------
FILE: res:///addons/loggie/loggie_message_channel.gd
--------------------------------------------------
@tool

## A class that describes a channel that can be used to output Loggie Messages.
class_name LoggieMsgChannel extends RefCounted

## The ID of the channel.
var ID : String = ""

## The preprocessing steps a [method LoggieMsg] that's about to be
## sent to this channel has to go through. See: [LoggieEnums.PreprocessStep] for
## the list of flags that can be used.
var preprocess_flags : int = 0

## Defines what happens when some [LoggieMsg] wants to be sent with this channel.
## [br]If you're implementing your own channel, override this function to define
## how your channel outputs the message. 
##
## You can access the last known preprocessed version of the message 
## in [LoggieMsg.last_preprocess_result].
##
## If your channel requires extra data, the data can be embedded into a message
## with [method LoggieMsg.set_meta] and read here with [method LoggieMsg.get_meta].
func send(msg : LoggieMsg, type : LoggieEnums.MsgType):
	pass


--------------------------------------------------
FILE: res:///addons/loggie/loggie_preset.gd
--------------------------------------------------
## An extension of the [LoggieMsg] class, meant to clearly differentiate between a message
## that was created with the sole purpose of being used as a Preset.
## Future behaviors of the message may diverge from regular behaviors of LoggieMsg, hence
## being separated into a different class.
class_name LoggiePreset extends LoggieMsg

## A placeholder that will be placed into the content of this preset as soon as it's initialized.
## This placeholder then gets wrapped with various styles as you call methods (e.g. [method bold],
## [method italic], etc.) on the preset. Later, only this string part of the content
## gets replaced by the actual content of a message this preset is being applied to, keeping the
## wrapped styles around it. 
const content_placeholder = "{content}"

func _init(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> void:
	self.content = [content_placeholder]

## Applies the settings and styles from this preset onto the given [LoggieMsg], modifying that message
## (does not create a duplicate) and returning that same message after it has been modified.
##
## [br][br]If any styles are applied to this [LoggiePreset], the entire content of the given [LoggieMsg] will
## be collapsed into a single segment, then have this preset's styles wrapped around that segment.
## [b]This directly resizes the [member LoggieMsg.content] array on the modified message.[/b]
##
## [br][br]However, if [param only_to_current_segment] is true, only the [member LoggieMsg.content] of
## the message found at its [member LoggieMsg.current_segment_index] will be wrapped in this preset's styles and modified,
## hence no resizing of the [member LoggieMsg.content] array will occur.
##
## [br]Neither of the above described actions will occur if this preset's content was not modified by any styles in any way.
func apply_to(msg : LoggieMsg, only_to_current_segment : bool = false) -> LoggieMsg:
	if msg is LoggiePreset:
		push_error("Attempt to apply a [LoggiePreset] to another [LoggiePreset] - unsupported behavior.")
		return
	
	# Apply the settings from this setting on the given message.
	msg.domain_name = self.domain_name
	msg.used_channels = self.used_channels.duplicate()
	msg.preprocess = self.preprocess
	msg.custom_preprocess_flags = self.custom_preprocess_flags
	msg.appends_stack = self.appends_stack
	msg.dynamic_type = self.dynamic_type
	msg.strict_type = self.strict_type
	msg.environment_mode = self.environment_mode
	msg.dont_emit_log_attempted_signal = self.dont_emit_log_attempted_signal
	
	# If no modifications were done to this preset's content (no styles applied),
	# we don't need to go further.
	if self.content[0] == content_placeholder:
		return msg
	
	# Otherwise,
	# Based on the value of [param only_to_current_segment], either:
	# 1. (if true): Replace the content of the [param msg] on its current segment to be that same content, but wrapped in the styles of this preset.
	# 2. (if false): Smush the entire content of the [param msg] into a single segment, then wrap that segment in the styles of this preset. 
	var content_to_apply_preset_to : String
	
	if only_to_current_segment:
		content_to_apply_preset_to = msg.string(msg.current_segment_index)
		var new_segment_content = self.content[0].format({"content": content_to_apply_preset_to})
		msg.content[msg.current_segment_index] = new_segment_content
	else:
		content_to_apply_preset_to = msg.string()
		var new_message_content = self.content[0].format({"content": content_to_apply_preset_to})
		msg.content = [new_message_content]
	
	return msg

## Overrides the parent class method by the same name to disable its functionality.
## Presets cannot have additional segments added.
func endseg() -> LoggieMsg:
	push_warning("Attempt to call LoggieMsg.endseg on a LoggiePreset. This is not allowed. Presets shouldn't have more than 1 string content segment.")
	return self

## Overrides the parent class method by the same name to disable its functionality.
## Presets cannot have their content modified.
func msg(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	push_warning("Attempt to call LoggieMsg.msg on a LoggiePreset. This is not allowed. Presets cannot have string content.")
	return self

## Overrides the parent class method by the same name to disable its functionality.
## Presets cannot be outputted, they are only meant to be applied to other [LoggieMsg]s.
func output(level : LoggieEnums.LogLevel, msg_type : LoggieEnums.MsgType = LoggieEnums.MsgType.INFO) -> void:
	push_warning("Attempt to call LoggieMsg.output on a LoggiePreset. This is not allowed. Presets should only be applied to other [LoggieMsg] instances, not used directly.")
	return


--------------------------------------------------
FILE: res:///addons/loggie/loggie_settings.gd
--------------------------------------------------
@tool

## Defines a set of variables through which all the relevant settings of Loggie can have their
## values set, read and documented. An instance of this class is found in [member Loggie.settings], and that's where Loggie
## ultimately reads from when it's asking for the value of a setting. For user convenience, settings are (by default) exported
## as custom Godot project settings and are loaded from there into these variables during [method load], however,
## you can extend or overwrite this class' [method load] method to define a different way of loading these settings if you prefer.
## [i](e.g. loading from a config.ini file, or a .json file, etc.)[/i].[br][br]
## 
## Loggie calls [method load] on this class during its [method _ready] function.
class_name LoggieSettings extends Resource

## The name that will be used for the singleton referring to Loggie.
## [br][br][i][b]Note:[/b] You may change this to something you're more used to, such as "log" or "logger".[/i]
## When doing so, make sure to either do it while the Plugin is enabled, then disable and re-enable the plugin,
## or that you manually clear out the previously created autoload (should be called "Loggie") in Project Settings -> Autoloads.
static var loggie_singleton_name = "Loggie"

# ----------------------------------------------- #
#region Project Settings
# ----------------------------------------------- #
## The dictionary which is used to grab the defaults and other values associated with each setting
## relevant to Loggie, particularly important for the default way of loading [LoggieSettings] and
## setting up Godot Project Settings related to Loggie.
const project_settings = {
	"update_check_mode" = {
		"path": "loggie/general/check_for_updates",
		"default_value" : LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Never:0,Only print notice if available:1,Print notice and auto-install:2,Yes and show updater window:3",
		"doc" : "Sets which behavior Loggie should use when checking for updates.",
	},
	"remove_settings_if_plugin_disabled" = {
		"path": "loggie/general/remove_settings_if_plugin_disabled",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "Choose whether you want Loggie project settings to be wiped from ProjectSettings if the Loggie plugin is disabled.",
	},
	"msg_format_mode" = {
		"path": "loggie/general/msg_format_mode",
		"default_value" : LoggieEnums.MsgFormatMode.BBCODE,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Plain:0,ANSI:1,BBCode:2,Markdown:3",
		"doc" : "Choose the format for which loggie should preprocess the output so that it displays correctly on the intended output medium.[br][br]Use BBCode for Godot console.[br]Use ANSI for Powershell, Bash, etc.[br]Use MARKDOWN for Discord.[br]Use PLAIN for log files.",
	},
	"log_level" = {
		"path": "loggie/general/log_level",
		"default_value" : LoggieEnums.LogLevel.INFO,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Error:0,Warn:1,Notice:2,Info:3,Debug:4",
		"doc" : "Choose the level of messages which should be displayed. Loggie displays all messages that are outputted at the currently set level (or any lower level).",
	},
	"show_system_specs" = {
		"path": "loggie/general/show_system_specs",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "Should Loggie log the system and device specs of the user as soon as it is booted?",
	},
	"show_loggie_specs" = {
		"path": "loggie/general/show_loggie_specs",
		"default_value" : LoggieEnums.ShowLoggieSpecsMode.ESSENTIAL,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Disabled:0,Essential:1,Advanced:2",
		"doc" : "Defines which way Loggie should print its own specs when it is booted.",
	},
	"enforce_optimal_settings_in_release_build" = {
		"path": "loggie/general/enforce_optimal_settings_in_release_build",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "Should Loggie enforce certain settings to automatically change to optimal values in production/release builds?",
	},
	"default_channels" = {
		"path": "loggie/general/default_channels",
		"default_value" : ["terminal"],
		"type" : TYPE_PACKED_STRING_ARRAY,
		"hint" : PROPERTY_HINT_TYPE_STRING,
		"hint_string" : "",
		"doc" : "The channels messages outputted from Loggie will be sent to by default (if not modified with LoggieMsg.channel method).",
	},
	"skipped_filenames_in_stack_trace" = {
		"path": "loggie/general/skipped_filenames_in_stack_trace",
		"default_value" : ["loggie", "loggie_message"],
		"type" : TYPE_PACKED_STRING_ARRAY,
		"hint" : PROPERTY_HINT_TYPE_STRING,
		"hint_string" : "",
		"doc" : "The file names, which, when appearing in a stack trace, should be omitted from the output.",
	},
	"discord_webhook_url_live" = {
		"path": "loggie/general/discord/live_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Discord webhook used when Loggie is running in a production build.",
	},
	"discord_webhook_url_dev" = {
		"path": "loggie/general/discord/dev_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Discord webhook used when Loggie is not running in a production build.",
	},
	"slack_webhook_url_live" = {
		"path": "loggie/general/slack/live_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Slack webhook used when Loggie is running in a production build.",
	},
	"slack_webhook_url_dev" = {
		"path": "loggie/general/slack/dev_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Slack webhook used when Loggie is not running in a production build.",
	},
	"timestamps_use_utc" = {
		"path": "loggie/preprocessing/timestamps_use_utc",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If 'Output Timestamps' is true, should those timestamps use the UTC time. If not, local system time is used instead.",
	},
	"output_errors_to_console" = {
		"path": "loggie/preprocessing/terminal/output_errors_also_to_console",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If true, errors printed by Loggie will also be visible through an additional print in the main output.",
	},
	"output_warnings_to_console" = {
		"path": "loggie/preprocessing/terminal/output_warnings_also_to_console",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If true, warnings printed by Loggie will also be visible through an additional print in the main output.",
	},
	"debug_msgs_print_stack_trace" = {
		"path": "loggie/preprocessing/terminal/debug_msgs_print_stack_trace",
		"default_value" : false,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If true, 'debug' level messages outputted by Loggie will also print the stack trace.",
	},
	"nameless_class_name_proxy" = {
		"path": "loggie/preprocessing/nameless_class_name_proxy",
		"default_value" : LoggieEnums.NamelessClassExtensionNameProxy.BASE_TYPE,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Nothing:0,ScriptName:1,BaseType:2",
		"doc" : "If 'Derive and Display Class Names From Scripts' is enabled, and a script doesn't have a 'class_name', which text should we use as a substitute?",
	},
	"preprocess_flags_terminal_channel" = {
		"path": "loggie/preprocessing/terminal/preprocess_flags",
		"default_value" : LoggieEnums.PreprocessStep.APPEND_TIMESTAMPS | LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_FLAGS,
		"hint_string" : "Append Timestamp:1,Append Domain Name:2,Append Class Name:4",
		"doc" : "Defines the flags which LoggieMessages sent to the terminal channel will use during preprocessing.",
	},
	"preprocess_flags_discord_channel" = {
		"path": "loggie/preprocessing/discord/preprocess_flags",
		"default_value" : LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_FLAGS,
		"hint_string" : "Append Timestamp:1,Append Domain Name:2,Append Class Name:4",
		"doc" : "Defines the flags which LoggieMessages sent to the Discord channel will use during preprocessing.",
	},
	"preprocess_flags_slack_channel" = {
		"path": "loggie/preprocessing/slack/preprocess_flags",
		"default_value" : LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_FLAGS,
		"hint_string" : "Append Timestamp:1,Append Domain Name:2,Append Class Name:4",
		"doc" : "Defines the flags which LoggieMessages sent to the Slack channel will use during preprocessing.",
	},
	"format_timestamp" = {
		"path": "loggie/formats/timestamp",
		"default_value" : "[{day}.{month}.{year} {hour}:{minute}:{second}]",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for timestamps which are prepended to the message when the appending of timestamps is enabled.",
	},
	"format_stacktrace_entry" = {
		"path": "loggie/formats/stacktrace_entry",
		"default_value" : "{index}: [color=#ff7085]func[/color] [color=#53b1c3][b]{fn_name}[/b]:{line}[/color] [color=slate_gray][i](in {source_path})[/i][/color]",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for stack trace entries when trace logging is enabled.",
	},
	"format_debug_msg" = {
		"path": "loggie/formats/debug_message",
		"default_value" : "[b][color=pink][DEBUG]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for debug messages.",
	},
	"format_info_msg" = {
		"path": "loggie/formats/info_message",
		"default_value" : "{msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for info messages.",
	},
	"format_notice_msg" = {
		"path": "loggie/formats/notice_message",
		"default_value" : "[b][color=cyan][NOTICE]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for notice messages.",
	},
	"format_warning_msg" = {
		"path": "loggie/formats/warning_message",
		"default_value" : "[b][color=orange][WARN]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for warning messages.",
	},
	"format_error_msg" = {
		"path": "loggie/formats/error_message",
		"default_value" : "[b][color=red][ERROR]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for error messages.",
	},
	"format_domain_prefix" = {
		"path": "loggie/formats/domain_prefix",
		"default_value" : "[b]({domain})[/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for domain prefixes.",
	},
	"format_header" = {
		"path": "loggie/formats/header",
		"default_value" : "[b][i]{msg}[/i][/b]",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for headers.",
	},
	"h_separator_symbol" = {
		"path": "loggie/formats/h_separator_symbol",
		"default_value" : "-",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The symbol used for the horizontal separator.",
	},
	"box_characters_mode" = {
		"path": "loggie/formats/box_characters_mode",
		"default_value" : LoggieEnums.BoxCharactersMode.COMPATIBLE,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Compatible:0,Pretty:1",
		"doc" : "There are two sets of box characters defined in LoggieSettings - one set contains prettier characters that produce a nicer looking box, but may not render correctly in the context of various terminals. The other set contains characters that produce a less pretty box, but are compatible with being shown in most terminals.",
	}
}

#endregion
# ----------------------------------------------- #
#region Variables
# ----------------------------------------------- #

## The current behavior Loggie uses to check for updates.
var update_check_mode : LoggieEnums.UpdateCheckType = LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW

## The current Message Format Mode of Loggie.
## Message Format Mode determines whether BBCode, ANSI or some other type of
## formatting is used to convey text effects, such as bold, italic, colors, etc.
## [br][br]BBCode is compatible with the Godot console.
## [br]ANSI is compatible with consoles like Powershell and Windows CMD.
## [br]PLAIN is used to strip any effects and use plain text instead, which is good for saving raw logs into log files.
var msg_format_mode : LoggieEnums.MsgFormatMode = LoggieEnums.MsgFormatMode.BBCODE

## The current log level of Loggie.
## It determines which types of messages are allowed to be logged.
## Set this using [method setLogLevel].
var log_level : LoggieEnums.LogLevel = LoggieEnums.LogLevel.INFO

## Whether or not Loggie should log the loggie specs on ready.
var show_loggie_specs : LoggieEnums.ShowLoggieSpecsMode = LoggieEnums.ShowLoggieSpecsMode.ESSENTIAL

## Whether or not Loggie should log the system specs on ready.
var show_system_specs : bool = true

## Whether to, in addition to logging errors with [method push_error], 
## Loggie should also print the error as a message in the standard output.
var print_errors_to_console : bool = true

## Whether to, in addition to logging errors with [method push_warning], 
## Loggie should also print the error as a message in the standard output.
var print_warnings_to_console : bool = true

## Defines which text will be used as a substitute for the 'class_name' of scripts that do not have a 'class_name'.
## Relevant only during the [member LoggieEnums.PreprocessStep.APPEND_CLASS_NAME] step of preprocessing.
var nameless_class_name_proxy : LoggieEnums.NamelessClassExtensionNameProxy

## Whether the outputted timestamps use UTC or local machine time.
var timestamps_use_utc : bool = true

## If true, when outputting Debug level messages, the stack trace will also be appended.
var debug_msgs_print_stack_trace : bool = false

## Whether Loggie should enforce optimal values for certain settings when in a Release/Production build.
## [br]If true, Loggie will enforce:
## [br]  * [member msg_format_mode] to [member LoggieEnums.MsgFormatMode.PLAIN]
## [br]  * [member box_characters_mode] to [member LoggieEnums.BoxCharactersMode.COMPATIBLE]
var enforce_optimal_settings_in_release_build : bool = true

## Endpoint URL for the Discord webhook (used in dev environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var discord_webhook_url_dev : String = "" 

## Endpoint URL for the Discord webhook (used in production/release environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var discord_webhook_url_live : String = "" 

## Endpoint URL for the Slack webhook (used in dev environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var slack_webhook_url_dev : String = "" 

## Endpoint URL for the Slack webhook (used in production/release environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var slack_webhook_url_live : String = "" 

## Defines the flags which LoggieMessages sent to the terminal channel will use during preprocessing.
var preprocess_flags_terminal_channel = LoggieEnums.PreprocessStep.APPEND_TIMESTAMPS | LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME

## Defines the flags which LoggieMessages sent to the Discord channel output will use during preprocessing.
var preprocess_flags_discord_channel = LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME

## Defines the flags which LoggieMessages sent to the Slack channel output will use during preprocessing.
var preprocess_flags_slack_channel = LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME

## The list of channels a message outputted from Loggie should be sent to by default.
var default_channels : PackedStringArray = ["terminal"]

## The list of file names, which, when appearing in a stack trace, should be omitted from the output..
var skipped_filenames_in_stack_trace : PackedStringArray = ["loggie", "loggie_message"]

#endregion
# ----------------------------------------------- #
#region Formats for prints
# ----------------------------------------------- #
# As per the `print_rich` documentation, supported colors are: black, red, green, yellow, blue, magenta, pink, purple, cyan, white, orange, gray.
# Any other color will be displayed in the Godot console or an ANSI based console, but the color tag (in case of BBCode) won't be properly stripped
# when written to the .log file, resulting in BBCode visible in .log files.

## The format used to decorate a message as a header when using [method LoggieMsg.header].[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
var format_header = "[b][i]{msg}[/i][/b]"

## The format used when appending a domain to a message.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## The [param {domain}] is a variable that will be replaced with the domain key.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_domain_prefix = "[b]({domain})[/b] {msg}"

## The format used when outputting error messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_error_msg = "[b][color=red][ERROR]:[/color][/b] {msg}"

## The format used when outputting warning messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_warning_msg = "[b][color=orange][WARN]:[/color][/b] {msg}"

## The format used when outputting notice messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_notice_msg = "[b][color=cyan][NOTICE]:[/color][/b] {msg}"

## The format used when outputting info messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_info_msg = "{msg}"

## The format used when outputting debug messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_debug_msg = "[b][color=pink][DEBUG]:[/color][/b] {msg}"

## The format used for timestamps when they are prepended to the output.[br]
## The variables [param {day}], [param {month}], [param {year}], [param {hour}], [param {minute}], [param {second}], [param {weekday}], and [param {dst}] are supported.
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_timestamp = "[{day}.{month}.{year} {hour}:{minute}:{second}]"

## The format used for each entry in a stack trace that is obtained through [method Loggie.stack].
## The variables [param {fn_name}], [param {index}], [param {source_path}], [param {line}] are supported.
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_stacktrace_entry = "{index}: [color=#ff7085]func[/color] [color=#53b1c3][b]{fn_name}[/b]:{line}[/color] [color=slate_gray][i](in {source_path})[/i][/color]"

## The symbol which will be used for the HSeparator.
var h_separator_symbol = "-"

## The mode used for drawing boxes.
var box_characters_mode : LoggieEnums.BoxCharactersMode

## The symbols which will be used to construct a box decoration that will properly
## display on any kind of terminal or text reader.
## For a prettier but potentially incompatible box, use [member box_symbols_pretty] instead.
var box_symbols_compatible = {
	# ANSI and .log compatible box characters:
	"top_left" : "-",
	"top_right" : "-",
	"bottom_left" : "-",
	"bottom_right" : "-",
	"h_line" : "-",
	"v_line" : ":",
}

## The symbols which will be used to construct pretty box decoration.
## These may not be compatible with some terminals or text readers.
## Use the [member box_symbols_compatible] instead as an alternative.
var box_symbols_pretty = {
	"top_left" : "",
	"top_right" : "",
	"bottom_left" : "",
	"bottom_right" : "",
	"h_line" : "",
	"v_line" : "",
}

#endregion
# ----------------------------------------------- #

## A [Callable] function that takes 1 parameter [param something] (Variant),
## and returns a [String] which represents the given [param something] in text.
## By default, Loggie sets this to `LoggieTools.convert_to_string` when initialized.
## [br][br]
## You can, however, override that by changing this value to a valid replacement [Callable], 
## after Loggie has initialized.
var custom_string_converter : Callable

## Loads the initial (default) values for all of the LoggieSettings variables.
## (By default, loads them from ProjectSettings (if any modifications there exist), 
## or looks in [LoggieEditorPlugin..project_settings] for default values).
## [br][br]Extend this class and override this function to write your own logic for 
## how loggie should obtain these settings if you have a need for a different approach.
func load():
	update_check_mode = ProjectSettings.get_setting(project_settings.update_check_mode.path, project_settings.update_check_mode.default_value)
	msg_format_mode = ProjectSettings.get_setting(project_settings.msg_format_mode.path, project_settings.msg_format_mode.default_value)
	log_level = ProjectSettings.get_setting(project_settings.log_level.path, project_settings.log_level.default_value)
	show_loggie_specs = ProjectSettings.get_setting(project_settings.show_loggie_specs.path, project_settings.show_loggie_specs.default_value)
	show_system_specs = ProjectSettings.get_setting(project_settings.show_system_specs.path, project_settings.show_system_specs.default_value)
	timestamps_use_utc = ProjectSettings.get_setting(project_settings.timestamps_use_utc.path, project_settings.timestamps_use_utc.default_value)
	enforce_optimal_settings_in_release_build = ProjectSettings.get_setting(project_settings.enforce_optimal_settings_in_release_build.path, project_settings.enforce_optimal_settings_in_release_build.default_value)
	default_channels = ProjectSettings.get_setting(project_settings.default_channels.path, project_settings.default_channels.default_value)
	skipped_filenames_in_stack_trace = ProjectSettings.get_setting(project_settings.skipped_filenames_in_stack_trace.path, project_settings.skipped_filenames_in_stack_trace.default_value)

	print_errors_to_console = ProjectSettings.get_setting(project_settings.output_errors_to_console.path, project_settings.output_errors_to_console.default_value)
	print_warnings_to_console = ProjectSettings.get_setting(project_settings.output_warnings_to_console.path, project_settings.output_warnings_to_console.default_value)
	debug_msgs_print_stack_trace = ProjectSettings.get_setting(project_settings.debug_msgs_print_stack_trace.path, project_settings.debug_msgs_print_stack_trace.default_value)

	nameless_class_name_proxy = ProjectSettings.get_setting(project_settings.nameless_class_name_proxy.path, project_settings.nameless_class_name_proxy.default_value)
	box_characters_mode = ProjectSettings.get_setting(project_settings.box_characters_mode.path, project_settings.box_characters_mode.default_value)

	format_timestamp = ProjectSettings.get_setting(project_settings.format_timestamp.path, project_settings.format_timestamp.default_value)
	format_stacktrace_entry = ProjectSettings.get_setting(project_settings.format_stacktrace_entry.path, project_settings.format_stacktrace_entry.default_value)
	format_info_msg = ProjectSettings.get_setting(project_settings.format_info_msg.path, project_settings.format_info_msg.default_value)
	format_notice_msg = ProjectSettings.get_setting(project_settings.format_notice_msg.path, project_settings.format_notice_msg.default_value)
	format_warning_msg = ProjectSettings.get_setting(project_settings.format_warning_msg.path, project_settings.format_warning_msg.default_value)
	format_error_msg = ProjectSettings.get_setting(project_settings.format_error_msg.path, project_settings.format_error_msg.default_value)
	format_debug_msg = ProjectSettings.get_setting(project_settings.format_debug_msg.path, project_settings.format_debug_msg.default_value)
	h_separator_symbol = ProjectSettings.get_setting(project_settings.h_separator_symbol.path, project_settings.h_separator_symbol.default_value)
	
	discord_webhook_url_live = ProjectSettings.get_setting(project_settings.discord_webhook_url_live.path, project_settings.discord_webhook_url_live.default_value)
	discord_webhook_url_dev = ProjectSettings.get_setting(project_settings.discord_webhook_url_dev.path, project_settings.discord_webhook_url_dev.default_value)
	preprocess_flags_discord_channel = ProjectSettings.get_setting(project_settings.preprocess_flags_discord_channel.path, project_settings.preprocess_flags_discord_channel.default_value)
	slack_webhook_url_live = ProjectSettings.get_setting(project_settings.slack_webhook_url_live.path, project_settings.slack_webhook_url_live.default_value)
	slack_webhook_url_dev = ProjectSettings.get_setting(project_settings.slack_webhook_url_dev.path, project_settings.slack_webhook_url_dev.default_value)
	preprocess_flags_slack_channel = ProjectSettings.get_setting(project_settings.preprocess_flags_slack_channel.path, project_settings.preprocess_flags_slack_channel.default_value)
	preprocess_flags_terminal_channel = ProjectSettings.get_setting(project_settings.preprocess_flags_terminal_channel.path, project_settings.preprocess_flags_terminal_channel.default_value)

## Returns a dictionary where the indices are names of relevant variables in the LoggieSettings class,
## and the values are their current values.
func to_dict() -> Dictionary:
	var dict = {}
	var included = [
		"preprocess_flags_discord_channel", "preprocess_flags_slack_channel", "preprocess_flags_terminal_channel",
		"default_channels", "skipped_filenames_in_stack_trace", "msg_format_mode", "log_level", "show_loggie_specs", "show_system_specs", "enforce_optimal_settings_in_release_build",
		"print_errors_to_console", "print_warnings_to_console",
		"debug_msgs_print_stack_trace", "nameless_class_name_proxy",
		"timestamps_use_utc", "format_header", "format_domain_prefix", "format_error_msg",
		"format_warning_msg", "format_notice_msg", "format_info_msg", "format_debug_msg", "format_timestamp",
		"h_separator_symbol", "box_characters_mode", "box_symbols_compatible", "box_symbols_pretty",
	]
	
	for var_name in included:
		dict[var_name] = get(var_name)
	return dict


--------------------------------------------------
FILE: res:///addons/loggie/plugin.gd
--------------------------------------------------
@tool
class_name LoggieEditorPlugin extends EditorPlugin

func _enter_tree():
	add_loggie_project_settings()
	Engine.set_meta("LoggieEditorPlugin", self)
	if Engine.is_editor_hint():
		Engine.set_meta("LoggieEditorInterfaceBaseControl", EditorInterface.get_base_control())
	
func _enable_plugin() -> void:
	add_autoload_singleton(LoggieSettings.loggie_singleton_name, "res://addons/loggie/loggie.gd")
	add_loggie_project_settings()

func _disable_plugin() -> void:
	var wipe_setting_exists = ProjectSettings.has_setting(LoggieSettings.project_settings.remove_settings_if_plugin_disabled.path)
	if (not wipe_setting_exists) or (wipe_setting_exists and ProjectSettings.get_setting(LoggieSettings.project_settings.remove_settings_if_plugin_disabled.path, true)):
		push_warning("The Loggie plugin is being disabled, and all of its ProjectSettings are erased from Godot. If you wish to prevent this behavior, look for the 'Project Settings -> Loggie -> General -> Remove Settings if Plugin Disabled' option while the plugin is enabled.")
		remove_loggie_project_setings()
	else:
		push_warning("The Loggie plugin is being disabled, but its ProjectSettings have been prevented from being removed from Godot. If you wish to allow that behavior, look for the 'Project Settings -> Loggie -> General -> Remove Settings if Plugin Disabled' option while the plugin is enabled.")
	remove_autoload_singleton(LoggieSettings.loggie_singleton_name)

## Adds new Loggie related ProjectSettings to Godot.
func add_loggie_project_settings():
	for setting in LoggieSettings.project_settings.values():
		add_project_setting(setting["path"], setting["default_value"], setting["type"], setting["hint"], setting["hint_string"], setting["doc"])

## Removes Loggie related ProjectSettings from Godot.
func remove_loggie_project_setings():
	for setting in LoggieSettings.project_settings.values():
		ProjectSettings.set_setting(setting["path"], null)
	
	var error: int = ProjectSettings.save()
	if error != OK: 
		push_error("Loggie - Encountered error %d while saving project settings." % error)

## Adds a new project setting to Godot.
## (WARNING): Unfortunately, as of Godot 4.3, it has been confirmed that it is not possible to set the
## popup tooltip text for a project setting. This should be implemented here as soon as that becomes possible.
func add_project_setting(setting_name: String, default_value : Variant, value_type: int, type_hint: int = PROPERTY_HINT_NONE, hint_string: String = "", documentation : String = ""):
	if !ProjectSettings.has_setting(setting_name):
		ProjectSettings.set_setting(setting_name, default_value)
		
	ProjectSettings.set_initial_value(setting_name, default_value)
	ProjectSettings.add_property_info({	"name": setting_name, "type": value_type, "hint": type_hint, "hint_string": hint_string})
	ProjectSettings.set_as_basic(setting_name, true)

	var error: int = ProjectSettings.save()
	if error: 
		push_error("Loggie - Encountered error %d while saving project settings." % error)


--------------------------------------------------
FILE: res:///addons/loggie/tools/UIAssetGenerator.gd
--------------------------------------------------
@tool
extends EditorScript

const OUT_PATH = "res://ui/assets/"
const SIZE = 256

func _run() -> void:
	# 1. Ensure directory exists
	if not DirAccess.dir_exists_absolute(OUT_PATH):
		DirAccess.make_dir_recursive_absolute(OUT_PATH)
		
	print("--- Generating Chronicler UI Kit ---")
	
	# 2. Generate all textures
	_gen_parchment()    # For Backgrounds
	_gen_wood()         # For Panels/Buttons
	_gen_shield()       # For RTS Buttons
	_gen_wax_seal()     # For Event Choices
	_gen_scroll_vertical() # For Storefront
	_gen_tapestry()     # For Dynasty Tree
	# --- NEW: Generate Resource Tag ---
	_gen_resource_tag()
	_gen_tooltip_bg()
	_gen_icons()
	_gen_resource_icons()
	
	print("Assets Saved to ", OUT_PATH)
	
	# 3. Refresh Godot to see files
	EditorInterface.get_resource_filesystem().scan()

func _gen_parchment() -> void:
	var img = Image.create(SIZE, SIZE, false, Image.FORMAT_RGBA8)
	var noise = FastNoiseLite.new()
	noise.frequency = 0.03
	noise.noise_type = FastNoiseLite.TYPE_PERLIN
	
	for x in SIZE:
		for y in SIZE:
			# Base: Cool Grey
			var col = Color("#aeb5bd")
			
			var n = noise.get_noise_2d(x, y)
			col = col.darkened(n * 0.1)
			
			img.set_pixel(x, y, col)
	img.save_png(OUT_PATH + "parchment_bg.png")
	
func _gen_wood() -> void:
	var img = Image.create(SIZE, SIZE, false, Image.FORMAT_RGBA8)
	var noise = FastNoiseLite.new()
	noise.frequency = 0.02
	
	for x in SIZE:
		for y in SIZE:
			# Stretched grain
			var n = noise.get_noise_2d(x * 0.1, y * 4.0) 
			# Dark Oak
			var base = Color("#4a3c31") 
			img.set_pixel(x, y, base.darkened(n * 0.3))
	img.save_png(OUT_PATH + "wood_bg.png")

func _gen_shield() -> void:
	# RTS Button Background
	var s = 128
	var img = Image.create(s, s, false, Image.FORMAT_RGBA8)
	var center = Vector2(s / 2.0, s / 2.0)
	var radius = (s / 2.0) - 2.0
	
	for x in s:
		for y in s:
			var d = Vector2(x, y).distance_to(center)
			if d < radius:
				# Iron Rim
				if d > radius - 8:
					img.set_pixel(x, y, Color("#555555"))
				# Wood Body
				else:
					var grain = sin(x * 0.5) * 0.1
					var base = Color("#6d543e").lightened(grain)
					img.set_pixel(x, y, base)
					
				# Boss (Center bump)
				if d < 12:
					img.set_pixel(x, y, Color("#777777"))
					
	img.save_png(OUT_PATH + "shield_btn.png")

func _gen_wax_seal() -> void:
	# Event Choice Button
	var s = 64
	var img = Image.create(s, s, false, Image.FORMAT_RGBA8)
	var center = Vector2(s / 2.0, s / 2.0)
	var radius = (s / 2.0) - 4.0
	
	for x in s:
		for y in s:
			var d = Vector2(x, y).distance_to(center)
			if d < radius:
				# Wax Red
				var col = Color("#a83232") 
				# Edge bevel
				if d > radius - 8.0:
					col = col.darkened(0.1) 
				img.set_pixel(x, y, col)
	img.save_png(OUT_PATH + "wax_seal.png")

func _gen_scroll_vertical() -> void:
	# Storefront Background
	var w = 256
	var h = 512
	var img = Image.create(w, h, false, Image.FORMAT_RGBA8)
	
	for x in w:
		for y in h:
			var col = Color("#f5e6d3")
			# Shadow on edges to look rolled
			var dist_x = min(x, w - x)
			if dist_x < 20:
				col = col.darkened((20 - dist_x) * 0.02)
			img.set_pixel(x, y, col)
			
	img.save_png(OUT_PATH + "scroll_bg.png")

func _gen_tapestry() -> void:
	# Dynasty Background
	var img = Image.create(SIZE, SIZE, false, Image.FORMAT_RGBA8)
	for x in SIZE:
		for y in SIZE:
			# Woven texture pattern
			var weave = (int(x) % 4 == 0) or (int(y) % 4 == 0)
			# Dark cloth
			var col = Color("#2e222f") 
			if weave:
				col = col.lightened(0.05)
			img.set_pixel(x, y, col)
	img.save_png(OUT_PATH + "tapestry_bg.png")
	
func _gen_resource_tag() -> void:
	# A dark, iron-wood background for text labels
	var w = 128
	var h = 48
	var img = Image.create(w, h, false, Image.FORMAT_RGBA8)
	
	for x in w:
		for y in h:
			# Dark Iron/Wood Color (#2F2F2F)
			var col = Color("#2F2F2F")
			
			# Add slight bevel at edges
			if x < 2 or x > w - 3 or y < 2 or y > h - 3:
				col = col.lightened(0.3)
			elif x < 4 or x > w - 5 or y < 4 or y > h - 5:
				col = col.darkened(0.5)
				
			img.set_pixel(x, y, col)
			
	img.save_png(OUT_PATH + "resource_tag.png")

func _gen_tooltip_bg() -> void:
	var img = Image.create(64, 64, false, Image.FORMAT_RGBA8)
	for x in 64:
		for y in 64:
			# Dark Slate Blue/Grey (#1e2124)
			img.set_pixel(x, y, Color("#1e2124"))
	
	# Add a gold border (1px)
	for i in 64:
		var gold = Color("#c5a54e")
		img.set_pixel(i, 0, gold)
		img.set_pixel(i, 63, gold)
		img.set_pixel(0, i, gold)
		img.set_pixel(63, i, gold)
		
	img.save_png(OUT_PATH + "tooltip_bg.png")

func _gen_resource_icons() -> void:
	var resources = ["res_gold", "res_wood", "res_food", "res_stone", "res_peasant", "res_thrall"]
	
	for name in resources:
		var img = Image.create(64, 64, false, Image.FORMAT_RGBA8)
		
		# Helper to fill a rect
		var fill_rect = func(rect: Rect2i, color: Color):
			for x in range(rect.position.x, rect.end.x):
				for y in range(rect.position.y, rect.end.y):
					img.set_pixel(x, y, color)
		
		# Helper to fill a circle
		var fill_circle = func(center: Vector2, radius: float, color: Color):
			for x in 64:
				for y in 64:
					if Vector2(x,y).distance_to(center) <= radius:
						img.set_pixel(x, y, color)

		match name:
			"res_gold":
				# Stack of 3 Yellow Coins
				fill_circle.call(Vector2(20, 40), 12, Color.GOLD)
				fill_circle.call(Vector2(44, 40), 12, Color.GOLD)
				fill_circle.call(Vector2(32, 24), 12, Color("#ffff00")) # Bright Top
				
			"res_wood":
				# 3 Brown Logs (Rectangles)
				fill_rect.call(Rect2i(10, 10, 44, 12), Color("#8b4513"))
				fill_rect.call(Rect2i(10, 26, 44, 12), Color("#a0522d"))
				fill_rect.call(Rect2i(10, 42, 44, 12), Color("#8b4513"))
				
			"res_food":
				# Red Apple / Meat
				fill_circle.call(Vector2(32, 36), 20, Color("#cd5c5c")) # Meat
				fill_rect.call(Rect2i(30, 10, 4, 10), Color.WHITE) # Bone/Stem
				
			"res_stone":
				# Grey Boulder
				fill_circle.call(Vector2(32, 32), 22, Color.GRAY)
				fill_circle.call(Vector2(24, 24), 8, Color.LIGHT_GRAY) # Highlight
				
			"res_peasant":
				# Tan Face + Green Hood
				fill_circle.call(Vector2(32, 32), 24, Color("#556b2f")) # Hood
				fill_circle.call(Vector2(32, 32), 16, Color("#f5deb3")) # Face
				
			"res_thrall":
				# Iron Shackle
				fill_circle.call(Vector2(32, 32), 22, Color.DIM_GRAY) # Ring
				fill_circle.call(Vector2(32, 32), 14, Color(0,0,0,0)) # Hole (Transparent)
				fill_rect.call(Rect2i(28, 40, 8, 24), Color.DIM_GRAY) # Chain link

		img.save_png(OUT_PATH + name + ".png")

func _gen_icons() -> void:
	var icons = ["icon_build", "icon_army", "icon_crown", "icon_map", "icon_time", "icon_manage", "icon_family"]
	
	for name in icons:
		var img = Image.create(64, 64, false, Image.FORMAT_RGBA8)
		
		# --- FIX: Pure White for maximum visibility ---
		var col = Color.WHITE 
		# ----------------------------------------------
		
		# Helper for drawing shapes
		var draw_box = func(r: Rect2i):
			for x in range(r.position.x, r.end.x):
				for y in range(r.position.y, r.end.y):
					img.set_pixel(x, y, col)
					
		match name:
			"icon_build": # Hammer
				draw_box.call(Rect2i(20, 20, 24, 12)) # Head
				draw_box.call(Rect2i(28, 32, 8, 24))  # Handle
			"icon_army": # Sword
				draw_box.call(Rect2i(30, 10, 4, 30)) # Blade
				draw_box.call(Rect2i(24, 40, 16, 4)) # Guard
				draw_box.call(Rect2i(30, 44, 4, 10)) # Hilt
			"icon_crown": # Crown
				draw_box.call(Rect2i(16, 40, 32, 8)) # Base
				draw_box.call(Rect2i(16, 20, 8, 20)) # Left
				draw_box.call(Rect2i(28, 20, 8, 20)) # Mid
				draw_box.call(Rect2i(40, 20, 8, 20)) # Right
			"icon_map": # Square Map
				draw_box.call(Rect2i(16, 16, 32, 32))
				# Cut center
				for x in range(20, 44):
					for y in range(20, 44):
						img.set_pixel(x, y, Color(0,0,0,0))
			"icon_time": # Hourglass
				draw_box.call(Rect2i(20, 16, 24, 4)) # Top
				draw_box.call(Rect2i(20, 44, 24, 4)) # Bot
				draw_box.call(Rect2i(28, 20, 8, 24)) # Middle
			"icon_manage": # Gear
				draw_box.call(Rect2i(20, 20, 24, 24))
				for x in range(26, 38):
					for y in range(26, 38):
						img.set_pixel(x, y, Color(0,0,0,0)) # Hole
			"icon_family": # Tree
				draw_box.call(Rect2i(28, 32, 8, 24)) # Trunk
				draw_box.call(Rect2i(20, 10, 24, 22)) # Leaves

		img.save_png(OUT_PATH + name + ".png")


--------------------------------------------------
FILE: res:///addons/loggie/tools/loggie_enums.gd
--------------------------------------------------
@tool
class_name LoggieEnums extends Node

## Based on which log level is currently set to be used by the Loggie., attempting to log a message that's on
## a higher-than-configured log level will result in nothing happening.
enum LogLevel {
	ERROR, 	## Log level which includes only the logging of Error type messages.
	WARN, 	## Log level which includes the logging of Error and Warning type messages.
	NOTICE, ## Log level which includes the logging of Error, Warning and Notice type messages.
	INFO,	## Log level which includes the logging of Error, Warning, Notice and Info type messages.
	DEBUG	## Log level which includes the logging of Error, Warning, Notice, Info and Debug type messages.
}

## The classification of message types that can be used to distinguish two identical strings in nature
## of their origin. This is different from [enum LogLevel].
enum MsgType {
	ERROR, ## A message that is considered to be an error message.
	WARN, ## A message that is considered to be a warning message.
	NOTICE, ## A message that is considered to be a notice.
	INFO, ## A message that is considered a standard text that is not special in any way.
	DEBUG, ## A message that is considered to be a message used only during debugging.
}

enum MsgFormatMode {
	PLAIN, ## Prints will be plain text.
	ANSI,  ## Prints will be styled using the ANSI standard. Compatible with Powershell, Win CMD, etc.
	BBCODE, ## Prints will be styled using the Godot BBCode rules. Compatible with the Godot console.
	MARKDOWN, ## Prints will be styled using the Markdown standard. Compatible with most Markdown readers.
}

## Classifies various steps that can happen during preprocessing.
enum PreprocessStep {
	## A timestamp will be added to the message.
	APPEND_TIMESTAMPS = 1 << 0, 
	
	## The name of the domain from which the message is coming will be added to the message.
	APPEND_DOMAIN_NAME = 1 << 1, 

	## Whether Loggie should use the scripts from which it is being called to 
	## figure out a class name for the class that called a loggie function,
	## and append it to the outputted message.
	## This only works in debug builds because it uses [method @GDScript.get_stack]. 
	## See that method's documentation to see why that can't be used in release builds.
	APPEND_CLASS_NAME = 1 << 2,
}

enum BoxCharactersMode {
	COMPATIBLE, ## Boxes are drawn using characters that compatible with any kind of terminal or text reader.
	PRETTY ## Boxes are drawn using special unicode characters that create a prettier looking box which may not display properly in some terminals or text readers.
}

## Defines a list of possible approaches that can be taken to derive some kind of a class name proxy from a script that doesn't have a 'class_name' clause.
enum NamelessClassExtensionNameProxy {
	NOTHING, ## If there is no class_name, nothing will be displayed.
	SCRIPT_NAME, ## Use the name of the script whose class_name we tried to read. (e.g. "my_script.gd").
	BASE_TYPE, ## Use the name of the base type which the script extends (e.g. 'Node2D', 'Control', etc.)
}

## Defines a list of possible behaviors for the 'show_loggie_specs' setting.
enum ShowLoggieSpecsMode {
	DISABLED, ## Loggie specs won't be shown.
	ESSENTIAL, ## Show only the essentials.
	ADVANCED ## Show all loggie specs.
}

## Defines a list of possible outcomes that can happen when attempting to log a message.
enum LogAttemptResult {
	SUCCESS, ## Message will be logged successfully.
	LOG_LEVEL_INSUFFICIENT, ## Message won't be logged because it was output at a log level higher than what Loggie is currently set to.
	DOMAIN_DISABLED, ## Message won't be logged because it was outputted from a disabled domain.
	INVALID_CHANNEL, ## Message won't be logged because the channel which was supposed to send it doesn't exist.
	WRONG_ENVIRONMENT, ## Message won't be logged because the environment the output is being requested from is not compatible with the environment this message is configured to be outputted in.
}

## Defines a list of possible ways to configure Loggie to check for updates.
enum UpdateCheckType {
	DONT_CHECK, ## If the user doesn't want Loggie to check for updates at all.
	CHECK_AND_SHOW_MSG, ## If the user wants Loggie to check for updates, and display info in a terminal message.
	CHECK_DOWNLOAD_AND_SHOW_MSG, ## If the user wants Loggie to check for updates, download the update, and display info in a terminal message.
	CHECK_AND_SHOW_UPDATER_WINDOW, ## If the user wants Loggie to check for updats, and display the updater window.
}

## Defines a lists of possible environments in which a [LoggieMsg] can be outputted.
enum MsgEnvironment {
	BOTH, ## The message will be outputted both in-engine (tool scripts) and when the project is running.
	ENGINE, ## The message will be outputted only in-engine (tool scripts).
	RUNTIME, ## The message will be outputted only when the project is running.
}


--------------------------------------------------
FILE: res:///addons/loggie/tools/loggie_system_specs.gd
--------------------------------------------------
@tool

## LoggieSystemSpecs is a helper class that defines various functions on how to access data about the local machine and its specs
## and creates displayable strings out of them.
class_name LoggieSystemSpecsMsg extends LoggieMsg

## Embeds various system specs into the content of this message.
func embed_specs() -> LoggieSystemSpecsMsg:
	self.embed_system_specs()
	self.embed_localization_specs()
	self.embed_date_data().nl()
	self.embed_hardware_specs().nl()
	self.embed_video_specs().nl()
	self.embed_display_specs().nl()
	self.embed_audio_specs().nl()
	self.embed_engine_specs().nl()
	self.embed_input_specs()
	return self

## Embeds essential data about the logger into the content of this message.
func embed_essential_logger_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	self.add(loggie.msg("|\t Is in Production:").bold(), loggie.is_in_production()).nl()
	self.add(loggie.msg("|\t Default Channel(s):").bold(),loggie.settings.default_channels).nl()
	self.add(loggie.msg("|\t Msg Format Mode:").bold(), LoggieEnums.MsgFormatMode.keys()[loggie.settings.msg_format_mode]).nl()
	self.add(loggie.msg("|\t Log Level:").bold(), LoggieEnums.LogLevel.keys()[loggie.settings.log_level]).nl()
	return self

## Embeds advanced data about the logger into the content of this message.
func embed_advanced_logger_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	
	self.add(loggie.msg("|\t Is in Production:").bold(), loggie.is_in_production()).nl()
	
	var settings_dict = loggie.settings.to_dict()
	for setting_var_name : String in settings_dict.keys():
		var setting_value = settings_dict[setting_var_name]
		var content_to_print = setting_value
		
		match setting_var_name:
			"msg_format_mode":
				content_to_print = LoggieEnums.MsgFormatMode.keys()[setting_value]
			"log_level":
				content_to_print = LoggieEnums.LogLevel.keys()[setting_value]
			"box_characters_mode":
				content_to_print = LoggieEnums.BoxCharactersMode.keys()[setting_value]

		self.add(loggie.msg("|\t", setting_var_name.capitalize(), ":").bold(), content_to_print).nl()
	
	return self

## Adds data about the user's software to the content of this message.
func embed_system_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Operating System: ").color(Color.ORANGE).add(OS.get_name()).box(4)
	self.add(header)
	return self
	
## Adds data about localization to the content of this message.
func embed_localization_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Localization: ").color(Color.ORANGE).add(OS.get_locale()).box(7)
	self.add(header)
	return self

## Adds data about the current date/time to the content of this message.
func embed_date_data() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Date").color(Color.ORANGE).box(15)
	self.add(header)
	self.add(loggie.msg("Date and time (local):").bold(), Time.get_datetime_string_from_system(false, true)).nl()
	self.add(loggie.msg("Date and time (UTC):").bold(), Time.get_datetime_string_from_system(true, true)).nl()
	self.add(loggie.msg("Date (local):").bold(), Time.get_date_string_from_system(false)).nl()
	self.add(loggie.msg("Date (UTC):").bold(), Time.get_date_string_from_system(true)).nl()
	self.add(loggie.msg("Time (local):").bold(), Time.get_time_string_from_system(false)).nl()
	self.add(loggie.msg("Time (UTC):").bold(), Time.get_time_string_from_system(true)).nl()
	self.add(loggie.msg("Timezone:").bold(), Time.get_time_zone_from_system()).nl()
	self.add(loggie.msg("UNIX time:").bold(), Time.get_unix_time_from_system()).nl()
	return self

## Adds data about the user's hardware to the content of this message.
func embed_hardware_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Hardware").color(Color.ORANGE).box(13)
	self.add(header)
	self.add(loggie.msg("Model name:").bold(), OS.get_model_name()).nl()
	self.add(loggie.msg("Processor name:").bold(), OS.get_processor_name()).nl()
	return self

## Adds data about the video system to the content of this message.
func embed_video_specs() -> LoggieSystemSpecsMsg:
	const adapter_type_to_string = ["Other (Unknown)", "Integrated", "Discrete", "Virtual", "CPU"]
	var adapter_type_string = adapter_type_to_string[RenderingServer.get_video_adapter_type()]
	var video_adapter_driver_info = OS.get_video_adapter_driver_info()
	var loggie = get_logger()

	var header = loggie.msg("Video").color(Color.ORANGE).box(15)
	self.add(header)
	self.add(loggie.msg("Adapter name:").bold(), RenderingServer.get_video_adapter_name()).nl()
	self.add(loggie.msg("Adapter vendor:").bold(), RenderingServer.get_video_adapter_vendor()).nl()
	self.add(loggie.msg("Adapter type:").bold(), adapter_type_string).nl()
	self.add(loggie.msg("Adapter graphics API version:").bold(), RenderingServer.get_video_adapter_api_version()).nl()

	if video_adapter_driver_info.size() > 0:
		self.add(loggie.msg("Adapter driver name:").bold(), video_adapter_driver_info[0]).nl()
	if video_adapter_driver_info.size() > 1:
		self.add(loggie.msg("Adapter driver version:").bold(), video_adapter_driver_info[1]).nl()

	return self

## Adds data about the display to the content of this message.
func embed_display_specs() -> LoggieSystemSpecsMsg:
	const screen_orientation_to_string = [
		"Landscape",
		"Portrait",
		"Landscape (reverse)",
		"Portrait (reverse)",
		"Landscape (defined by sensor)",
		"Portrait (defined by sensor)",
		"Defined by sensor",
	]
	var screen_orientation_string = screen_orientation_to_string[DisplayServer.screen_get_orientation()]
	var loggie = get_logger()

	var header = loggie.msg("Display").color(Color.ORANGE).box(13)
	self.add(header)
	self.add(loggie.msg("Screen count:").bold(), DisplayServer.get_screen_count()).nl()
	self.add(loggie.msg("DPI:").bold(), DisplayServer.screen_get_dpi()).nl()
	self.add(loggie.msg("Scale factor:").bold(), DisplayServer.screen_get_scale()).nl()
	self.add(loggie.msg("Maximum scale factor:").bold(), DisplayServer.screen_get_max_scale()).nl()
	self.add(loggie.msg("Startup screen position:").bold(), DisplayServer.screen_get_position()).nl()
	self.add(loggie.msg("Startup screen size:").bold(), DisplayServer.screen_get_size()).nl()
	self.add(loggie.msg("Startup screen refresh rate:").bold(), ("%f Hz" % DisplayServer.screen_get_refresh_rate()) if DisplayServer.screen_get_refresh_rate() > 0.0 else "").nl()
	self.add(loggie.msg("Usable (safe) area rectangle:").bold(), DisplayServer.get_display_safe_area()).nl()
	self.add(loggie.msg("Screen orientation:").bold(), screen_orientation_string).nl()
	return self

## Adds data about the audio system to the content of this message.
func embed_audio_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Audio").color(Color.ORANGE).box(14)
	self.add(header)
	self.add(loggie.msg("Mix rate:").bold(), "%d Hz" % AudioServer.get_mix_rate()).nl()
	self.add(loggie.msg("Output latency:").bold(), "%f ms" % (AudioServer.get_output_latency() * 1000)).nl()
	self.add(loggie.msg("Output device list:").bold(), ", ".join(AudioServer.get_output_device_list())).nl()
	self.add(loggie.msg("Capture device list:").bold(), ", ".join(AudioServer.get_input_device_list())).nl()
	return self

## Adds data about the godot engine to the content of this message.
func embed_engine_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Engine").color(Color.ORANGE).box(14)
	self.add(header)
	self.add(loggie.msg("Version:").bold(), Engine.get_version_info()["string"]).nl()
	self.add(loggie.msg("Command-line arguments:").bold(), str(OS.get_cmdline_args())).nl()
	self.add(loggie.msg("Is debug build:").bold(), OS.is_debug_build()).nl()
	self.add(loggie.msg("Filesystem is persistent:").bold(), OS.is_userfs_persistent()).nl()
	return self

## Adds data about the input device to the content of this message.
func embed_input_specs() -> LoggieSystemSpecsMsg:
	var has_virtual_keyboard = DisplayServer.has_feature(DisplayServer.FEATURE_VIRTUAL_KEYBOARD)
	var loggie = get_logger()

	var header = loggie.msg("Input").color(Color.ORANGE).box(14)
	self.add(header)
	self.add(loggie.msg("Device has touch screen:").bold(), DisplayServer.is_touchscreen_available()).nl()
	self.add(loggie.msg("Device has virtual keyboard:").bold(), has_virtual_keyboard).nl()

	if has_virtual_keyboard:
		self.add(loggie.msg("Virtual keyboard height:").bold(), DisplayServer.virtual_keyboard_get_height())

	return self

## Prints out a bunch of useful data about a given script.
## Useful for debugging.
func embed_script_data(script : Script):
	var loggie = get_logger()
	self.add("Script Data for:", script.get_path()).color("pink")
	self.add(":").nl()
	self.add(loggie.msg("get_class(): ").color("slate_blue").bold()).add(script.get_class()).nl()
	self.add(loggie.msg("get_global_name(): ").color("slate_blue").bold()).add(script.get_global_name()).nl()
	self.add(loggie.msg("get_base_script(): ").color("slate_blue").bold()).add(script.get_base_script().resource_path if script.get_base_script() != null else "No base script.").nl()
	self.add(loggie.msg("get_instance_base_type(): ").color("slate_blue").bold()).add(script.get_instance_base_type()).nl()
	self.add(loggie.msg("get_script_property_list(): ").color("slate_blue").bold()).add(script.get_script_property_list()).nl()
	return self


--------------------------------------------------
FILE: res:///addons/loggie/tools/loggie_tools.gd
--------------------------------------------------
@tool
class_name LoggieTools extends Node

## Removes BBCode from the given text.
## If [param specific_tags] is an array, it removes only the tags found in that array.
## Otherwise, it removes the tags found in the default_tags array:[br]
## [param ["b", "i", "u", "s", "indent", "code", "url", "center", "right", "color", "bgcolor", "fgcolor"]]
static func remove_BBCode(text: String, specific_tags = null) -> String:
	# The bbcode tags to remove.
	var default_tags = ["b", "i", "u", "s", "indent", "code", "url", "center", "right", "color", "bgcolor", "fgcolor"]
	var tags = specific_tags if specific_tags is Array else default_tags

	var regex = RegEx.new()
	var tags_pattern = "|".join(tags)
	regex.compile("\\[/?(" + tags_pattern + ")(=[^\\]]*)?\\]")

	var stripped_text = regex.sub(text, "", true)
	return stripped_text

## Concatenates all elements of the given [param args] array into one single string, in consecutive order.
## If [param custom_converter_fn] is provided, and is a [Callable], that function will be used to convert each element of the array into a string
## instead of using [method convert_to_string]. That function will receive 1 argument, which will be a 'Variant', and it has to return a 'String'.
static func concatenate_args(args : Array, custom_converter_fn : Variant = null) -> String:
	if args.size() == 0:
		return ""

	var converter_fn : Callable = LoggieTools.convert_to_string
	if custom_converter_fn is Callable and custom_converter_fn.is_valid() and !custom_converter_fn.is_null():
		converter_fn = custom_converter_fn

	# Start with first element without modifying array
	var final_msg : String = converter_fn.call(args[0])

	# Start from index 1 since we already handled index 0
	for i in range(1, args.size()):
		var arg = args[i]
		var is_not_followed_by_a_null_arg = true if (i + 1 <= args.size() - 1) and (args[i + 1] != null) else false
		if (arg != null) or (arg == null and is_not_followed_by_a_null_arg):
			var converted_arg : String = converter_fn.call(arg)
			final_msg += (" " + converted_arg)

	return final_msg

## Converts a text with BBCode in it to markdown.
## A limited set of BBCode tags are supported for this conversion, because standard Markdown can't handle everything
## that BBCode can. For example, colors will be entirely stripped.
static func convert_BBCode_to_markdown(text: String) -> String:
	# Purge the unsupported tags.
	var unsupported_tags = ["indent", "url", "center", "right", "color", "bgcolor", "fgcolor"]
	text = LoggieTools.remove_BBCode(text, unsupported_tags)

	# Space out all instances where "*" characters from multiple tags are strung together,
	# since that would break them from rendering with the proper effect in markdown.
	# This is only an issue with [b] and [i] tags because they both use the same "*" character
	# in markdown to be represented.
	text = text.replace("[/b][i]", "** *")
	text = text.replace("[/b][/i]", "** *")
	text = text.replace("[/i][b]", "* **")
	text = text.replace("[/i][/b]", "* **")
	text = text.replace("[/i][i]", "* *")
	text = text.replace("[/i][/i]", "* *")
	text = text.replace("[/b][b]", "** **")
	text = text.replace("[/b][/b]", "** **")

	# Perform all supported conversion.
	var supported_conversions = {
		"[b]" : "**", "[/b]" : "**",
		"[i]" : "*",  "[/i]" : "*",
		"[u]" : "__", "[/u]" : "__",
		"[s]" : "~~", "[/s]" : "~~",
	}
	for bbcodetag in supported_conversions.keys():
		text = text.replace(bbcodetag, supported_conversions[bbcodetag])

	return text

## Converts [param something] into a string, with custom handling for
## certain native and custom classes.
static func convert_to_string(something : Variant) -> String:
	var result : String
	if something is Dictionary:
		result = JSON.new().stringify(something, "  ", false, true)
	elif something is LoggieMsg:
		result = something.string()
	else:
		result = str(something)
	return result

## Takes the given [param str] and returns a terminal-ready version of it by converting its content
## to the appropriate format required to display the string correctly in the provided [param mode]
## msg format mode.
## [b]The provided [param str] is expected to be either in Plain or BBCode format.[/b]
static func convert_string_to_format_mode(str : String, mode : LoggieEnums.MsgFormatMode) -> String:
	match mode:
		LoggieEnums.MsgFormatMode.ANSI:
			# We put the message through the rich_to_ANSI converter which takes care of converting BBCode
			# to appropriate ANSI. (Only if the MsgFormatMode is set to ANSI).
			# Godot claims to be already preparing BBCode output for ANSI, but it only works with a small
			# predefined set of colors, and I think it totally strips stuff like [b], [i], etc.
			# It is possible to display those stylings in ANSI, but we have to do our own conversion here
			# to support these features instead of having them stripped.
			str = LoggieTools.rich_to_ANSI(str)
		LoggieEnums.MsgFormatMode.BBCODE:
			# No need to do anything for BBCODE mode, because we already expect all strings to
			# start out with this format in mind.
			pass
		LoggieEnums.MsgFormatMode.MARKDOWN:
			str = LoggieTools.convert_BBCode_to_markdown(str)
		LoggieEnums.MsgFormatMode.PLAIN, _:
			str = LoggieTools.remove_BBCode(str)
	return str

## Converts a given [Color] to an ANSI compatible representation of it in code.
static func color_to_ANSI(color: Color) -> String:
	var r = int(color.r * 255)
	var g = int(color.g * 255)
	var b = int(color.b * 255)
	return "\u001b[38;2;%d;%d;%dm" % [r, g, b]

## Strips the BBCode from the given text, and converts all [b], [i] and [color] tags to appropriate ANSI representable codes,
## then returns the converted string. The result of this conversion becomes an ANSI compatible representation of the given [param text].
static func rich_to_ANSI(text: String) -> String:
	var regex_color = RegEx.new()
	regex_color.compile("\\[color=(.*?)\\](.*?)\\[/color\\]")
	
	# Process color tags first.
	while regex_color.search(text):
		var match = regex_color.search(text)
		var color_str = match.get_string(1).to_upper()
		var color: Color
		var color_code: String
		var reset_code = "\u001b[0m"
		
		# Try to parse the color string
		if LoggieTools.NamedColors.has(color_str):
			color = LoggieTools.NamedColors[color_str]
		else:
			color = Color(color_str)
		
		if color:
			color_code = color_to_ANSI(color)
		else:
			color_code = ""
			reset_code = ""
		
		var replacement = color_code + match.get_string(2) + reset_code
		text = text.replace(match.get_string(0), replacement)
	
	# Process bold and italic tags.
	var bold_on = "\u001b[1m"
	var bold_off = "\u001b[22m"
	var italic_on = "\u001b[3m"
	var italic_off = "\u001b[23m"

	text = text.replace("[b]", bold_on).replace("[/b]", bold_off)
	text = text.replace("[i]", italic_on).replace("[/i]", italic_off)

	# Remove any other BBCode tags but retain the text between them.
	var regex_bbcode = RegEx.new()
	regex_bbcode.compile("\\[(b|/b|i|/i|color=[^\\]]+|/color)\\]")
	text = regex_bbcode.sub(text, "", true)

	return text

## Returns a dictionary of call stack data related to the stack the call to this function is a part of.
## This function only works in debug builds, and on the main thread, because it uses [method get_stack].
## Read more about why in that function's documentation.
static func get_current_stack_frame_data() -> Dictionary:
	var stack = get_stack()
	if stack.size() > 0:
		stack.reverse()
		# Prune the frames starting from the first one that comes from loggie_message and onwards.
		var pruned_stack = []
		for index in stack.size():
			var source : String = stack[index].source
			var prune_breakpoint_files = ["loggie", "loggie_message"]
			if prune_breakpoint_files.has(source.get_file().get_basename()):
				break
			pruned_stack.push_back(stack[index])
		
		# The back-most remaining entry in the pruned stack is the first non-Loggie caller.
		if pruned_stack.size() >= 1:
			return pruned_stack.back()

	return {
		"source" : "UnknownStackFrameSource",
		"line" : 0,
		"function" : "UnknownFunction"
	}

## Returns the `class_name` of a script.
## [br][param path_or_script] should be either an absolute path to the script 
## (String, e.g. "res://my_script.gd"), or a [Script] object.
## [br][param proxy] defines which kind of text will be used as a replacement
## for the class name if the script has no 'class_name'.
static func get_class_name_from_script(path_or_script : Variant, proxy : LoggieEnums.NamelessClassExtensionNameProxy) -> String:
	var script
	var _class_name = ""

	if path_or_script is String or path_or_script is StringName:
		if !ResourceLoader.exists(path_or_script, "Script"):
			return _class_name
		script = load(path_or_script)
	elif path_or_script is Script:
		script = path_or_script

	if not (script is Script):
		push_error("Invalid 'path_or_script' param provided to get_class_name_from_script: {path}".format({"path" : path_or_script}))
	else:
		if not script.has_method("get_global_name"):
			# User is using a pre-4.3 version of Godot that doesn't have Script.get_global_name.
			# We must use a different method to achieve this then.
			return extract_class_name_from_gd_script(path_or_script, proxy)

		# Try to get the class name directly.
		_class_name = script.get_global_name()

		if _class_name != "":
			return _class_name

		# If that's empty, the script is either a base class, or a class without a name.
		# Check if this script has a base script, and if so, use that one as the target whose name to obtain.
		# If it doesn't have it, use what the [param proxy] demands.
		var base_script = script.get_base_script()
		if base_script != null:
			return get_class_name_from_script(base_script, proxy)
		else:
			match proxy:
				LoggieEnums.NamelessClassExtensionNameProxy.BASE_TYPE:
					_class_name = script.get_instance_base_type()
				LoggieEnums.NamelessClassExtensionNameProxy.SCRIPT_NAME:
					_class_name = script.get_script_property_list().front()["name"]

	return _class_name

## Opens and reads a .gd script file to find out its 'class_name' or what it 'extends'.
## [param path_or_script] should be either an absolute path to the script 
## (String, e.g. "res://my_script.gd"), or a [Script] object.
## [br][param proxy] defines which kind of text will be used as a replacement
## for the class name if the script has no 'class_name'.
## [br][br][b]Note:[/b] This is a compatibility method that will be used on older versions of Godot which
## don't support [method Script.get_global_name].
static func extract_class_name_from_gd_script(path_or_script : Variant, proxy : LoggieEnums.NamelessClassExtensionNameProxy) -> String:
	var path : String

	if path_or_script is String:
		path = path_or_script
	elif path_or_script is Script:
		path = path_or_script.resource_path
	else:
		push_error("Invalid 'path_or_script' param provided to extract_class_name_from_gd_script: {path}".format({"path" : path_or_script}))
		return ""

	var file = FileAccess.open(path, FileAccess.READ)
	if not file:
		return "File Open Error {filepath}".format({"filepath" : path})

	var _class_name: String = ""

	for line_num in 40:  # Loop only up to 40 lines
		if file.eof_reached():
			break

		var line = file.get_line().strip_edges()

		if line.begins_with("class_name"):
			_class_name = line.split(" ")[1]
			break

	if _class_name == "":
		var script = load(path)
		if script is Script:
			match proxy:
				LoggieEnums.NamelessClassExtensionNameProxy.BASE_TYPE:
					_class_name = script.get_instance_base_type()
				LoggieEnums.NamelessClassExtensionNameProxy.SCRIPT_NAME:
					_class_name = script.get_script_property_list().front()["name"]

	file.close()
	return _class_name

## Takes the given [param string] and returns an array made out of chunks of the given size.
## The string is chunked from start to end.
static func chunk_string(string : String, chunk_size : int) -> Array:
	var message_chunks = []
	if string.length() >= chunk_size:
		# Cut chunk_size pieces from the left side of the string and push them to message_chunks.
		while string.length() >= chunk_size:
			message_chunks.append(string.left(chunk_size))
			string = string.substr(chunk_size, -1)
			
		# Append the remaining slice as the final chunk.
		if string.length() > 0:
			message_chunks.append(string)
		return message_chunks
	else:
		return [string]

## Copies the directory at the given [param path_dir_to_copy] path and places the copy at the given [param path_dir_to_copy_into] path.
## Returns a dictionary with 2 keys:
##[codeblock]
##`errors` : Array[Error] # An array of all errors that occured during the process. ('Error.OK' is an exception and won't be included here)
##`messages` : Array[LoggieMsg] # An array of messages describing the process, including informational or error related content.
##[/codeblock]
static func copy_dir_absolute(path_dir_to_copy: String, path_dir_to_copy_into: String, overwrite_existing_files_with_same_name : bool = false) -> Dictionary:
	const debug_enabled = false
	var result = {
		"errors" : [],
		"messages" : []
	}
	
	# Ensure source directory is openable.
	var source_dir = DirAccess.open(path_dir_to_copy)
	if source_dir == null:
		var open_error = DirAccess.get_open_error()
		result.errors.push_back(open_error)
		result.messages.push_back(LoggieMsg.new("Failed to open source directory: ", path_dir_to_copy, " with error: ", error_string(open_error)))
		return result

	# Ensure target directory is openable.
	var target_dir = DirAccess.open(path_dir_to_copy_into)
	var target_dir_path_abs = ProjectSettings.globalize_path(path_dir_to_copy_into)
	if target_dir == null:
		var msg = LoggieMsg.new(" Target directory not found - creating it at:").msg(path_dir_to_copy_into).color(Color.CADET_BLUE)
		result.messages.push_back(msg)
		DirAccess.make_dir_recursive_absolute(path_dir_to_copy_into)
		target_dir = DirAccess.open(path_dir_to_copy_into)

	# Copy all files from the current source directory into the target directory.
	for file_name : String in source_dir.get_files():
		var file_path_abs = ProjectSettings.globalize_path(path_dir_to_copy.path_join(file_name))
		var target_file_path_abs = target_dir_path_abs.path_join(file_name)
		var copying_msg = LoggieMsg.new(" Copying file...")
		copying_msg.msg(file_path_abs).italic().color(Color.CORNFLOWER_BLUE).add(" -> ")
		copying_msg.msg(target_file_path_abs).bold().color(Color.CORNFLOWER_BLUE)
		
		var is_overwrite_required = false
		if FileAccess.file_exists(target_file_path_abs):
			is_overwrite_required = true
			if overwrite_existing_files_with_same_name:
				copying_msg.nl().msg("\t[!] Target file already exists and will be overwritten.").bold().color(Color.DARK_KHAKI)
			else:
				copying_msg.nl().msg("\t File will not be copied as overwriting existing files is disabled.").bold().color(Color.SALMON)

		result.messages.push_back(copying_msg)
		
		if (not is_overwrite_required) or (is_overwrite_required and overwrite_existing_files_with_same_name):
			var copy_error = DirAccess.copy_absolute(file_path_abs, target_file_path_abs)
			if copy_error != OK:
				result.errors.push_back(copy_error)
				result.messages.push_back(LoggieMsg.new("Attempt to copy file failed with error: '", error_string(copy_error)))

	# Create all of source directory's subdirectories in the target directory and copy their contents.
	for dir_name : String in source_dir.get_directories():
		var source_subdir_path = path_dir_to_copy.path_join(dir_name)
		var source_subdir_path_abs = ProjectSettings.globalize_path(source_subdir_path)
		var target_subdir_path = path_dir_to_copy_into.path_join(dir_name)
		var dir_path_abs = ProjectSettings.globalize_path(target_subdir_path)

		result.messages.push_back(LoggieMsg.new(" Creating directory: ").msg("{dir}".format({"dir": dir_path_abs})).color(Color.CADET_BLUE))
		var make_dir_error = DirAccess.make_dir_recursive_absolute(dir_path_abs)
		if make_dir_error != OK:
			result.errors.push_back(make_dir_error)
			var error_msg = LoggieMsg.new("Attempt to create directory at absolute path recursively failed with error: '", error_string(make_dir_error))
			result.messages.push_back(error_msg)
			continue

		# Recursively copy the contents of the subdirectory
		var subdir_copy_result = copy_dir_absolute(source_subdir_path_abs, target_subdir_path, overwrite_existing_files_with_same_name)
		result.errors = result.errors + subdir_copy_result.errors
		result.messages = result.messages + subdir_copy_result.messages
	
	if debug_enabled:
		for msg : LoggieMsg in result.messages:
			print_rich(msg.string())
			
	return result

## A dictionary of named colors matching the constants from [Color] used to help with rich text coloring.
## There may be a way to obtain these Color values without this dictionary if one can somehow check for the 
## existence and value of a constant on the Color class (since they're already there),
## but I can't seem to find a way, so this will have to do for now.
static var NamedColors = {
	"ALICE_BLUE": Color(0.941176, 0.972549, 1, 1),
	"ANTIQUE_WHITE": Color(0.980392, 0.921569, 0.843137, 1),
	"AQUA": Color(0, 1, 1, 1),
	"AQUAMARINE": Color(0.498039, 1, 0.831373, 1),
	"AZURE": Color(0.941176, 1, 1, 1),
	"BEIGE": Color(0.960784, 0.960784, 0.862745, 1),
	"BISQUE": Color(1, 0.894118, 0.768627, 1),
	"BLACK": Color(0, 0, 0, 1),
	"BLANCHED_ALMOND": Color(1, 0.921569, 0.803922, 1),
	"BLUE": Color(0, 0, 1, 1),
	"BLUE_VIOLET": Color(0.541176, 0.168627, 0.886275, 1),
	"BROWN": Color(0.647059, 0.164706, 0.164706, 1),
	"BURLYWOOD": Color(0.870588, 0.721569, 0.529412, 1),
	"CADET_BLUE": Color(0.372549, 0.619608, 0.627451, 1),
	"CHARTREUSE": Color(0.498039, 1, 0, 1),
	"CHOCOLATE": Color(0.823529, 0.411765, 0.117647, 1),
	"CORAL": Color(1, 0.498039, 0.313726, 1),
	"CORNFLOWER_BLUE": Color(0.392157, 0.584314, 0.929412, 1),
	"CORNSILK": Color(1, 0.972549, 0.862745, 1),
	"CRIMSON": Color(0.862745, 0.0784314, 0.235294, 1),
	"CYAN": Color(0, 1, 1, 1),
	"DARK_BLUE": Color(0, 0, 0.545098, 1),
	"DARK_CYAN": Color(0, 0.545098, 0.545098, 1),
	"DARK_GOLDENROD": Color(0.721569, 0.52549, 0.0431373, 1),
	"DARK_GRAY": Color(0.662745, 0.662745, 0.662745, 1),
	"DARK_GREEN": Color(0, 0.392157, 0, 1),
	"DARK_KHAKI": Color(0.741176, 0.717647, 0.419608, 1),
	"DARK_MAGENTA": Color(0.545098, 0, 0.545098, 1),
	"DARK_OLIVE_GREEN": Color(0.333333, 0.419608, 0.184314, 1),
	"DARK_ORANGE": Color(1, 0.54902, 0, 1),
	"DARK_ORCHID": Color(0.6, 0.196078, 0.8, 1),
	"DARK_RED": Color(0.545098, 0, 0, 1),
	"DARK_SALMON": Color(0.913725, 0.588235, 0.478431, 1),
	"DARK_SEA_GREEN": Color(0.560784, 0.737255, 0.560784, 1),
	"DARK_SLATE_BLUE": Color(0.282353, 0.239216, 0.545098, 1),
	"DARK_SLATE_GRAY": Color(0.184314, 0.309804, 0.309804, 1),
	"DARK_TURQUOISE": Color(0, 0.807843, 0.819608, 1),
	"DARK_VIOLET": Color(0.580392, 0, 0.827451, 1),
	"DEEP_PINK": Color(1, 0.0784314, 0.576471, 1),
	"DEEP_SKY_BLUE": Color(0, 0.74902, 1, 1),
	"DIM_GRAY": Color(0.411765, 0.411765, 0.411765, 1),
	"DODGER_BLUE": Color(0.117647, 0.564706, 1, 1),
	"FIREBRICK": Color(0.698039, 0.133333, 0.133333, 1),
	"FLORAL_WHITE": Color(1, 0.980392, 0.941176, 1),
	"FOREST_GREEN": Color(0.133333, 0.545098, 0.133333, 1),
	"FUCHSIA": Color(1, 0, 1, 1),
	"GAINSBORO": Color(0.862745, 0.862745, 0.862745, 1),
	"GHOST_WHITE": Color(0.972549, 0.972549, 1, 1),
	"GOLD": Color(1, 0.843137, 0, 1),
	"GOLDENROD": Color(0.854902, 0.647059, 0.12549, 1),
	"GRAY": Color(0.745098, 0.745098, 0.745098, 1),
	"GREEN": Color(0, 1, 0, 1),
	"GREEN_YELLOW": Color(0.678431, 1, 0.184314, 1),
	"HONEYDEW": Color(0.941176, 1, 0.941176, 1),
	"HOT_PINK": Color(1, 0.411765, 0.705882, 1),
	"INDIAN_RED": Color(0.803922, 0.360784, 0.360784, 1),
	"INDIGO": Color(0.294118, 0, 804, 1),
	"IVORY": Color(1, 1, 0.941176, 1),
	"KHAKI": Color(0.941176, 0.901961, 0.54902, 1),
	"LAVENDER": Color(0.901961, 0.901961, 0.980392, 1),
	"LAVENDER_BLUSH": Color(1, 0.941176, 0.960784, 1),
	"LAWN_GREEN": Color(0.486275, 0.988235, 0, 1),
	"LEMON_CHIFFON": Color(1, 0.980392, 0.803922, 1),
	"LIGHT_BLUE": Color(0.678431, 0.847059, 0.901961, 1),
	"LIGHT_CORAL": Color(0.941176, 0.501961, 0.501961, 1),
	"LIGHT_CYAN": Color(0.878431, 1, 1, 1),
	"LIGHT_GOLDENROD": Color(0.980392, 0.980392, 0.823529, 1),
	"LIGHT_GRAY": Color(0.827451, 0.827451, 0.827451, 1),
	"LIGHT_GREEN": Color(0.564706, 0.933333, 0.564706, 1),
	"LIGHT_PINK": Color(1, 0.713726, 0.756863, 1),
	"LIGHT_SALMON": Color(1, 0.627451, 0.478431, 1),
	"LIGHT_SEA_GREEN": Color(0.12549, 0.698039, 0.666667, 1),
	"LIGHT_SKY_BLUE": Color(0.529412, 0.807843, 0.980392, 1),
	"LIGHT_SLATE_GRAY": Color(0.466667, 0.533333, 0.6, 1),
	"LIGHT_STEEL_BLUE": Color(0.690196, 0.768627, 0.870588, 1),
	"LIGHT_YELLOW": Color(1, 1, 0.878431, 1),
	"LIME": Color(0, 1, 0, 1),
	"LIME_GREEN": Color(0.196078, 0.803922, 0.196078, 1),
	"LINEN": Color(0.980392, 0.941176, 0.901961, 1),
	"MAGENTA": Color(1, 0, 1, 1),
	"MAROON": Color(0.690196, 0.188235, 0.376471, 1),
	"MEDIUM_AQUAMARINE": Color(0.4, 0.803922, 0.666667, 1),
	"MEDIUM_BLUE": Color(0, 0, 0.803922, 1),
	"MEDIUM_ORCHID": Color(0.729412, 0.333333, 0.827451, 1),
	"MEDIUM_PURPLE": Color(0.576471, 0.439216, 0.858824, 1),
	"MEDIUM_SEA_GREEN": Color(0.235294, 0.701961, 0.443137, 1),
	"MEDIUM_SLATE_BLUE": Color(0.482353, 0.407843, 0.933333, 1),
	"MEDIUM_SPRING_GREEN": Color(0, 0.980392, 0.603922, 1),
	"MEDIUM_TURQUOISE": Color(0.282353, 0.819608, 0.8, 1),
	"MEDIUM_VIOLET_RED": Color(0.780392, 0.0823529, 0.521569, 1),
	"MIDNIGHT_BLUE": Color(0.0980392, 0.0980392, 0.439216, 1),
	"MINT_CREAM": Color(0.960784, 1, 0.980392, 1),
	"MISTY_ROSE": Color(1, 0.894118, 0.882353, 1),
	"MOCCASIN": Color(1, 0.894118, 0.709804, 1),
	"NAVAJO_WHITE": Color(1, 0.870588, 0.678431, 1),
	"NAVY_BLUE": Color(0, 0, 0.501961, 1),
	"OLD_LACE": Color(0.992157, 0.960784, 0.901961, 1),
	"OLIVE": Color(0.501961, 0.501961, 0, 1),
	"OLIVE_DRAB": Color(0.419608, 0.556863, 0.137255, 1),
	"ORANGE": Color(1, 0.647059, 0, 1),
	"ORANGE_RED": Color(1, 0.270588, 0, 1),
	"ORCHID": Color(0.854902, 0.439216, 0.839216, 1),
	"PALE_GOLDENROD": Color(0.933333, 0.909804, 0.666667, 1),
	"PALE_GREEN": Color(0.596078, 0.984314, 0.596078, 1),
	"PALE_TURQUOISE": Color(0.686275, 0.933333, 0.933333, 1),
	"PALE_VIOLET_RED": Color(0.858824, 0.439216, 0.576471, 1),
	"PAPAYA_WHIP": Color(1, 0.937255, 0.835294, 1),
	"PEACH_PUFF": Color(1, 0.854902, 0.72549, 1),
	"PERU": Color(0.803922, 0.521569, 0.247059, 1),
	"PINK": Color(1, 0.752941, 0.796078, 1),
	"PLUM": Color(0.866667, 0.627451, 0.866667, 1),
	"POWDER_BLUE": Color(0.690196, 0.878431, 0.901961, 1),
	"PURPLE": Color(0.627451, 0.12549, 0.941176, 1),
	"REBECCA_PURPLE": Color(0.4, 0.2, 0.6, 1),
	"RED": Color(1, 0, 0, 1),
	"ROSY_BROWN": Color(0.737255, 0.560784, 0.560784, 1),
	"ROYAL_BLUE": Color(0.254902, 0.411765, 0.882353, 1),
	"SADDLE_BROWN": Color(0.545098, 0.270588, 0.0745098, 1),
	"SALMON": Color(0.980392, 0.501961, 0.447059, 1),
	"SANDY_BROWN": Color(0.956863, 0.643137, 0.376471, 1),
	"SEA_GREEN": Color(0.180392, 0.545098, 0.341176, 1),
	"SEASHELL": Color(1, 0.960784, 0.933333, 1),
	"SIENNA": Color(0.627451, 0.321569, 0.176471, 1),
	"SILVER": Color(0.752941, 0.752941, 0.752941, 1),
	"SKY_BLUE": Color(0.529412, 0.807843, 0.921569, 1),
	"SLATE_BLUE": Color(0.415686, 0.352941, 0.803922, 1),
	"SLATE_GRAY": Color(0.439216, 0.501961, 0.564706, 1),
	"SNOW": Color(1, 0.980392, 0.980392, 1),
	"SPRING_GREEN": Color(0, 1, 0.498039, 1),
	"STEEL_BLUE": Color(0.27451, 0.509804, 0.705882, 1),
	"TAN": Color(0.823529, 0.705882, 0.54902, 1),
	"TEAL": Color(0, 0.501961, 0.501961, 1),
	"THISTLE": Color(0.847059, 0.74902, 0.847059, 1),
	"TOMATO": Color(1, 0.388235, 0.278431, 1),
	"TRANSPARENT": Color(1, 1, 1, 0),
	"TURQUOISE": Color(0.25098, 0.878431, 0.815686, 1),
	"VIOLET": Color(0.933333, 0.509804, 0.933333, 1),
	"WEB_GRAY": Color(0.501961, 0.501961, 0.501961, 1),
	"WEB_GREEN": Color(0, 0.501961, 0, 1),
	"WEB_MAROON": Color(0.501961, 0, 0, 1),
	"WEB_PURPLE": Color(0.501961, 0, 0.501961, 1),
	"WHEAT": Color(0.960784, 0.870588, 0.701961, 1),
	"WHITE": Color(1, 1, 1, 1),
	"WHITE_SMOKE": Color(0.960784, 0.960784, 0.960784, 1),
	"YELLOW": Color(1, 1, 0, 1),
	"YELLOW_GREEN": Color(0.603922, 0.803922, 0.196078, 1)
}


--------------------------------------------------
FILE: res:///addons/loggie/version_management/loggie_update.gd
--------------------------------------------------
@tool
class_name LoggieUpdate extends Node

## Emitted when this update fails.
signal failed()

## Emitted when this update succeeds.
signal succeeded()

## Emitted when this declares that it has made some progress.
signal progress(value : float)

## Emitted when this declares that it wants a new status/substatus message to be used.
signal status_changed(status_msg : Variant, substatus_msg : Variant)

## Emitted when this update is starting.
signal starting()

## Emitted when the 'is_in_progress' status of this update changes.
signal is_in_progress_changed(new_value : bool)

## The path to the directory that should have a temporary file created and filled with the patch zipball buffer.
const TEMP_FILES_DIR = "user://"

## If this is set to a non-empty string, it will be used as the directory into which the new update will be
## installed. Used for testing/debugging. When set to empty string, Loggie will automatically figure out
## where it is being updated from and use that directory instead.
const ALT_LOGGIE_PLUGIN_CONTAINER_DIR = ""

## The domain from which status report [LoggieMsg]s from this update will be logged from.
const REPORTS_DOMAIN : String = "loggie_update_status_reports"

## Stores a reference to the logger that's requesting this update.
var _logger : Variant

## The URL used to visit a page that contains the release notes for this update.
var release_notes_url = ""

## Stores a reference to the previous version the connected [member _logger] is/was using.
var prev_version : LoggieVersion = null

## Stores a reference to the new version the connected [member _logger] should be using after the update.
var new_version : LoggieVersion = null

## Indicates whether this update is currently in progress.
var is_in_progress : bool = false

## Whether the update should retain or purge the backup it makes of the previous version files once it is done
## installing and applying the new update.
var _clean_up_backup_files : bool = true

func _init(_prev_version : LoggieVersion, _new_version : LoggieVersion) -> void:
	self.prev_version = _prev_version
	self.new_version = _new_version

## Returns a reference to the logger that's requesting this update.
func get_logger() -> Variant:
	return self._logger
	
## Sets the URL used to visit a page that contains the release notes for this update.
func set_release_notes_url(url : String) -> void:
	self.release_notes_url = url

## Sets whether this window is currently performing the update.
func set_is_in_progress(value : bool) -> void:
	self.is_in_progress = value
	self.is_in_progress_changed.emit(value)

## Tries to start the version update. Prevents the update from starting
## if something is not configured correctly and pushes a warning/error.
func try_start():
	if Engine.has_meta("LoggieUpdateSuccessful") and Engine.get_meta("LoggieUpdateSuccessful"):
		# No plan to allow multiple updates to run during a single Engine session anyway so no need to start another one.
		# Also, this helps with internal testing of the updater and prevents an updated plugin from auto-starting another update
		# when dealing with proxy versions.
		return

	if self._logger == null:
		push_warning("Attempt to start Loggie update failed - member '_logger' on the LoggieUpdate object is null.")
		return

	if self.is_in_progress:
		push_warning("Attempt to start Loggie update failed - the update is already in progress.")
		return

	if self.new_version == null or self.prev_version == null:
		push_warning("Attempt to start Loggie update failed - the updater prompt has the 'new_version' or 'prev_version' variable at null value.")
		return
	elif !self.new_version.is_higher_than(self.prev_version):
		push_warning("Attempt to start Loggie update failed - the 'new_version' is not higher than 'prev_version'.")
		return

	if self.new_version.has_meta("github_data"):
		var github_data = self.new_version.get_meta("github_data")
		if !github_data.has("zipball_url"):
			push_error("Attempt to start Loggie update failed - the meta key 'github_data' on the 'new_version' is a dictionary that does not contain the required 'zipball_url' key/value pair.")
			return
	else:
		push_error("Attempt to start Loggie update failed - the meta key 'github_data' on the 'new_version' was not found.")
		return
	
	_start()
	
## Internal function. Starts the updating of the [param _logger] to the [param new_version].
## Do not run without verification that configuration is correct.
## Use [method try_start] to call this safely.
func _start():
	var loggie = self.get_logger()

	loggie.msg("Loggie is updating from version {v_prev} to {v_new}.".format({
		"v_prev" : self.prev_version,
		"v_new" : self.new_version
	})).domain(REPORTS_DOMAIN).color(Color.ORANGE).box(12).info()
	
	set_is_in_progress(true)
	starting.emit()

	# Make request to configured endpoint.
	var update_data = self.new_version.get_meta("github_data")
	var http_request = HTTPRequest.new()
	loggie.add_child(http_request)
	http_request.request_completed.connect(_on_download_request_completed)
	http_request.request(update_data.zipball_url)

## Internal callback function. 
## Defines what happens when new update content is successfully downloaded from GitHub.
## Called automatically during [method _start] if everything is going according to plan.
func _on_download_request_completed(result: int, response_code: int, headers: PackedStringArray, body: PackedByteArray) -> void:
	var loggie = self.get_logger()

	if loggie == null:
		_failure("The _logger used by the updater window is null.")
		return

	if result != HTTPRequest.RESULT_SUCCESS:
		_failure("Download request returned non-zero code: " + str(result))
		return

	#region || Prepare: Define variables and callbacks that will be used throughout.
	# The path to the directory which is supposed to contain the plugin directory.
	# This will usually be 'res://addons/', but could be anything else too. We'll read it dynamically
	# from the connected logger to guarantee correctness.
	var LOGGIE_PLUGIN_CONTAINER_DIR = ALT_LOGGIE_PLUGIN_CONTAINER_DIR if !ALT_LOGGIE_PLUGIN_CONTAINER_DIR.is_empty() else loggie.get_directory_path().get_base_dir() + "/"
	
	# The path to the `loggie` plugin directory.
	var LOGGIE_PLUGIN_DIR = ProjectSettings.globalize_path(LOGGIE_PLUGIN_CONTAINER_DIR.path_join("loggie/"))
	
	# The full path filename of the temporary .zip archive that will be created to store the downloaded data.
	var TEMP_ZIP_FILE_PATH = ProjectSettings.globalize_path(TEMP_FILES_DIR.path_join("_temp_loggie_{ver}.zip".format({"ver": str(new_version)})))
	
	# The path to the directory where a temporary backup of current loggie plugin files will be copied to.
	# (will be created if doesn't exist).
	var TEMP_PREV_VER_FILES_DIR_PATH = ProjectSettings.globalize_path(TEMP_FILES_DIR.path_join("_temp_loggie_{ver}_backup".format({"ver": str(prev_version)})))
	
	# A callable that can be reused within this function that cleans up the temporary and unused directories,
	# once this function comes to a conclusion.
	var clean_up : Callable = func():
		if FileAccess.file_exists(TEMP_ZIP_FILE_PATH):
			OS.move_to_trash(TEMP_ZIP_FILE_PATH)
		if DirAccess.dir_exists_absolute(TEMP_PREV_VER_FILES_DIR_PATH) and self._clean_up_backup_files:
			OS.move_to_trash(TEMP_PREV_VER_FILES_DIR_PATH)

	# A callable that can be used to replace the currently existing Loggie plugin directory
	# with whatever is currently (temporarily) stored as its backup.
	var revert_to_backup = func():
		if FileAccess.file_exists(LOGGIE_PLUGIN_DIR):
			OS.move_to_trash(LOGGIE_PLUGIN_DIR)
		if DirAccess.dir_exists_absolute(TEMP_PREV_VER_FILES_DIR_PATH):
			DirAccess.rename_absolute(TEMP_PREV_VER_FILES_DIR_PATH, LOGGIE_PLUGIN_DIR)
			
	#endregion

	#region || Step 1: Store the downloaded content into a temporary zip file.
	send_progress_update(20, "Processing Files", "Storing patch locally...")

	var zip_file: FileAccess = FileAccess.open(TEMP_ZIP_FILE_PATH, FileAccess.WRITE)
	if zip_file == null:
		_failure("Failed to open temp. file for writing: {path}".format({"path": TEMP_ZIP_FILE_PATH}))
		clean_up.call()
		return

	zip_file.store_buffer(body)
	zip_file.close()
	#endregion

	#region || Step 2: Make a temporary backup of the currently used Loggie plugin directory.
	send_progress_update(30, "Processing Files", "Backing up previous version files...")
	
	if !DirAccess.dir_exists_absolute(LOGGIE_PLUGIN_DIR):
		_failure("The Loggie plugin directory ({path}) could not be found.".format({
			"path" : LOGGIE_PLUGIN_DIR
		}))
		clean_up.call()
		return

	var copy_prev_ver_result = LoggieTools.copy_dir_absolute(LOGGIE_PLUGIN_DIR, TEMP_PREV_VER_FILES_DIR_PATH, true)
	if copy_prev_ver_result.errors.size() > 0:
		var copy_prev_var_result_errors_msg = LoggieMsg.new("Errors encountered:")
		for error in copy_prev_ver_result.errors:
			copy_prev_var_result_errors_msg.nl().add(error_string(error))
		_failure(copy_prev_var_result_errors_msg.string())
		clean_up.call()
		return
	#endregion

	#region || Step 3: Remove currently used Loggie plugin directory and create a new one in its place populated with new version files.
	send_progress_update(50, "Processing Files", "Copying new version files...")
	var zip_reader: ZIPReader = ZIPReader.new()
	var zip_reader_open_error = zip_reader.open(TEMP_ZIP_FILE_PATH)
	if zip_reader_open_error != OK:
		_failure("Attempt to open temp. file(s) archive at {path} failed with error: {err_str}".format({
			"path": LOGGIE_PLUGIN_DIR,
			"err_str" : error_string(zip_reader_open_error)
		}))
		clean_up.call()
		return
	
	# Trash the previously existing loggie plugin dir entirely.
	# A new one will be created in a moment.
	OS.move_to_trash(LOGGIE_PLUGIN_DIR)
	
	# Get a list of all files and dirs in the zip.
	var files : PackedStringArray = zip_reader.get_files() 

	# This will always be the "addons" directory in the zip archive in which we expect
	# to find the "loggie" directory containing the plugin.
	var base_path_in_zip = files[1] 

	# Remove the first 2 parts of the path that we won't be needing at all.
	files.remove_at(0)
	files.remove_at(0)

	# Create all needed files and directories.
	for path in files:
		var new_file_path: String = path.replace(base_path_in_zip, "")
		if path.ends_with("/"):
			DirAccess.make_dir_recursive_absolute(LOGGIE_PLUGIN_CONTAINER_DIR + new_file_path)
		else:
			var abs_path = LOGGIE_PLUGIN_CONTAINER_DIR + new_file_path
			var file : FileAccess = FileAccess.open(abs_path, FileAccess.WRITE)
			if file == null:
				_failure("Error while storing buffer data into temporary files - write target directory or file {target} gave the error: {error}".format({
					"error" : error_string(FileAccess.get_open_error()), 
					"target" : abs_path
				}))
				revert_to_backup.call()
				clean_up.call()
				return
			else:
				var file_content = zip_reader.read_file(path)
				file.store_buffer(file_content)
				file.close()

	zip_reader.close()
	#endregion

	#region || Step 4: Move the user's 'custom_settings.gd' to the new version directory if it existed in prev version.
	send_progress_update(70, "Processing Files", "Reapplying custom settings...")
	var CUSTOM_SETTINGS_IN_PREV_VER_PATH = TEMP_PREV_VER_FILES_DIR_PATH.path_join("custom_settings.gd")
	if FileAccess.file_exists(CUSTOM_SETTINGS_IN_PREV_VER_PATH):
		var CUSTOM_SETTINGS_IN_NEW_VER_PATH = ProjectSettings.globalize_path(LOGGIE_PLUGIN_DIR.path_join("custom_settings.gd"))
		var custom_settings_copy_error = DirAccess.copy_absolute(CUSTOM_SETTINGS_IN_PREV_VER_PATH, CUSTOM_SETTINGS_IN_NEW_VER_PATH)
		if custom_settings_copy_error != OK:
			push_error("Attempt to copy the 'custom_settings.gd' file from {p1} to {p2} failed with error: {error}".format({
				"p1" : CUSTOM_SETTINGS_IN_PREV_VER_PATH,
				"p2" : CUSTOM_SETTINGS_IN_NEW_VER_PATH,
				"error" : error_string(custom_settings_copy_error)
			}))
	#endregion

	#region || Step 5: Move the user's 'channels/custom_channels' directory to the new version if it existed in prev version.
	send_progress_update(80, "Processing Files", "Reapplying custom channels...")
	var CUSTOM_CHANNELS_IN_PREV_VER_PATH = ProjectSettings.globalize_path(TEMP_PREV_VER_FILES_DIR_PATH.path_join("channels/custom_channels/"))
	if DirAccess.dir_exists_absolute(CUSTOM_CHANNELS_IN_PREV_VER_PATH):
		var CUSTOM_CHANNELS_IN_NEW_VER_PATH = ProjectSettings.globalize_path(LOGGIE_PLUGIN_DIR.path_join("channels/custom_channels/"))
		var copy_prev_ver_custom_channels_result = LoggieTools.copy_dir_absolute(CUSTOM_CHANNELS_IN_PREV_VER_PATH, CUSTOM_CHANNELS_IN_NEW_VER_PATH, true)
		if copy_prev_ver_custom_channels_result.errors.size() > 0:
			var copy_prev_var_result_errors_msg = LoggieMsg.new("Errors encountered:")
			for error in copy_prev_ver_result.errors:
				copy_prev_var_result_errors_msg.nl().add(error_string(error))
			push_error("Attempt to copy the 'channels/custom_channels' directory from {p1} to {p2} failed with error: {error}".format({
				"p1" : CUSTOM_CHANNELS_IN_PREV_VER_PATH,
				"p2" : CUSTOM_CHANNELS_IN_NEW_VER_PATH,
				"error" : copy_prev_var_result_errors_msg.string()
			}))
	else:
		print("The {path} directory doesn't exist.".format({"path": CUSTOM_CHANNELS_IN_PREV_VER_PATH}))
	#endregion

	#region || Step 6: Clean up temporarily created files and close filewrite.
	send_progress_update(90, "Processing Files", "Cleaning up...")
	clean_up.call()
	#endregion
	
	#region || Step 7: Declare successful. Wrap up.
	send_progress_update(100, "Finishing up", "")
	_success()
	#endregion

## Internal function used at the end of the updating process if it is successfully completed.
func _success():
	set_is_in_progress(false)

	var msg = " You may see temporary errors in the console due to Loggie files being re-scanned and reloaded on the spot.\nIt should be safe to dismiss them, but for the best experience, reload the Godot editor (and the plugin, if something seems wrong).\n\n If you see a 'Files have been modified on disk' window pop up, choose 'Discard local changes and reload' to accept incoming changes."
	status_changed.emit(null, msg)
	succeeded.emit()

	print_rich(LoggieMsg.new(" Loggie updated to version {new_ver}!".format({"new_ver": self.new_version})).bold().color(Color.ORANGE).string())
	print_rich(LoggieMsg.new("\t Release Notes: ").bold().msg("[url={url}]{url}[/url]".format({"url": release_notes_url})).color(Color.CORNFLOWER_BLUE).string())
	print_rich(LoggieMsg.new("\t Support, Development & Feature Requests: ").bold().msg("[url=https://discord.gg/XPdxpMqmcs]https://discord.gg/XPdxpMqmcs[/url]").color(Color.CORNFLOWER_BLUE).string())

	if Engine.is_editor_hint():
		var editor_plugin = Engine.get_meta("LoggieEditorPlugin")
		editor_plugin.get_editor_interface().get_resource_filesystem().scan()
		editor_plugin.get_editor_interface().call_deferred("set_plugin_enabled", "loggie", true)
		editor_plugin.get_editor_interface().set_plugin_enabled("loggie", false)
		Engine.set_meta("LoggieUpdateSuccessful", true)
		print_rich("[b]Updater:[/b] ", msg)

## Internal function used to interrupt an ongoing update and cause it to fail.
func _failure(status_msg : String):
	var loggie = self.get_logger()
	loggie.msg(status_msg).color(Color.SALMON).preprocessed(false).error()
	loggie.msg("\t If this issue persists, consider reporting: ").bold().msg("https://github.com/Shiva-Shadowsong/loggie/issues").color(Color.CORNFLOWER_BLUE).preprocessed(false).info()
	set_is_in_progress(false)
	failed.emit()
	status_changed.emit(null, status_msg)

## Informs the listeners of the [signal progress] / [signal status_changed] signals about a change in the progress of the update.
func send_progress_update(progress_amount : float, status_msg : String, substatus_msg : String):
	var loggie = self.get_logger()
	if !substatus_msg.is_empty():
		loggie.msg(" ").msg(substatus_msg).domain(REPORTS_DOMAIN).preprocessed(false).info()
	progress.emit(progress_amount)
	status_changed.emit(status_msg, substatus_msg)


--------------------------------------------------
FILE: res:///addons/loggie/version_management/loggie_version.gd
--------------------------------------------------
## A utility class that helps with storing data about a Loggie Version and converting and comparing version strings.
class_name LoggieVersion extends Resource

var minor : int = -1 ## The minor component of the version.
var major : int = -1 ## The major component of the version.
var proxy_for : LoggieVersion = null ## The version that this version is a proxy for. (Internal use only)

func _init(_major : int = -1, _minor : int = -1) -> void:
	self.minor = _minor
	self.major = _major
	
func _to_string() -> String:
	return str(self.major) + "." + str(self.minor)

## Checks if this version is valid.
## (neither minor nor major component can be less than 0).
func is_valid() -> bool:
	return (minor >= 0 and major >= 0)

## Checks if the given [param version] if higher than this version.
func is_higher_than(version : LoggieVersion):
	if self.major > version.major:
		return true
	if self.minor > version.minor:
		return true
	return false

## Given a string that has 2 sets of digits separated by a ".", breaks that down
## into a version with a major and minor version component (ints).
static func from_string(version_string : String) -> LoggieVersion:
	var version : LoggieVersion = LoggieVersion.new()
	var regex = RegEx.new()
	regex.compile("(\\d+)\\.(\\d+)")
	
	var result = regex.search(version_string)
	if result:
		version.major = result.get_string(1).to_int()
		version.minor = result.get_string(2).to_int()
	return version


--------------------------------------------------
FILE: res:///addons/loggie/version_management/loggie_version_manager.gd
--------------------------------------------------
@tool
## A class that can be used to inquire about, generate, and operate on [LoggieVersion]s. 
## It is also responsible for notifying about an available update, and starting it, if configured to do so.
class_name LoggieVersionManager extends RefCounted

## Emitted when this version manager updates the known [member latest_version].
signal latest_version_updated()

## Emitted when this version manager has created a valid [LoggieUpdate] and is ready to use it.
signal update_ready()

## The URL where loggie releases on GitHub can be found.
const REMOTE_RELEASES_URL = "https://api.github.com/repos/Shiva-Shadowsong/loggie/releases"

## The domain from which [LoggieMsg]s from this version manager will be logged from.
const REPORTS_DOMAIN : String = "loggie_version_check_reports"

## Stores the result of reading the Loggie version with [method get_current_Version].
var version : LoggieVersion = null

## Stores the result of reading the latest Loggie version with [method get_latest_version].
var latest_version : LoggieVersion = null

## Stores a reference to a ConfigFile which will be loaded from [member CONFIG_PATH] during [method find_and_store_current_version].
var config : ConfigFile = ConfigFile.new()

## Stores a reference to the logger that's using this version manager.
var _logger : Variant = null

## Stores a reference to the [LoggieUpdate] that has been created to handle an available update.
var _update : LoggieUpdate = null

## Internal debug variable.
## If not null, this version manager will treat the [LoggieVersion] provided under this variable to be the current [param version].
## Useful for debugging this module when you want to simulate that the current version is something different than it actually is.
var _version_proxy : LoggieVersion = null

## Initializes this version manager, connecting it to the logger that's using it and updating the version cache based on that logger,
## which will further prompt the emission of signals in this class, and so on.
func connect_logger(logger : Variant) -> void:
	self.latest_version_updated.connect(on_latest_version_updated)
	self._logger = logger

	# Set to true during development to enable debug prints related to version management.
	self._logger.set_domain_enabled(self.REPORTS_DOMAIN, false)

	update_version_cache()

## Returns a reference to the logger object that is using this version manager.
func get_logger() -> Variant:
	return self._logger

## Reads the current version of Loggie from plugin.cfg and stores it in [member version].
func find_and_store_current_version():
	var detected_version = self._logger.version
	if self._version_proxy != null:
		self.version = self._version_proxy
		self.version.proxy_for = detected_version
	else:
		self.version = detected_version

## Reads the latest version of Loggie from a GitHub API response and stores it in [member latest_version].
func find_and_store_latest_version():
	var loggie = self.get_logger()
	var http_request = HTTPRequest.new()
	loggie.add_child(http_request)
	loggie.msg("Retrieving version(s) info from endpoint:", REMOTE_RELEASES_URL).domain(REPORTS_DOMAIN).debug()
	http_request.request_completed.connect(_on_get_latest_version_request_completed, CONNECT_ONE_SHOT)
	http_request.request(REMOTE_RELEASES_URL)

## Defines what happens once this version manager emits the signal saying that an update is available.
func on_update_available_detected() -> void:
	var loggie = self.get_logger()
	if loggie.settings.update_check_mode == LoggieEnums.UpdateCheckType.DONT_CHECK:
		return
	
	self._update = LoggieUpdate.new(self.version, self.latest_version)
	self._update._logger = loggie

	var github_data = self.latest_version.get_meta("github_data")
	var latest_release_notes_url = github_data.html_url
	self._update.set_release_notes_url(latest_release_notes_url)
	loggie.add_child(self._update)
	update_ready.emit()

	# No plan to allow multiple updates to run during a single Engine session anyway so no need to start another one.
	# Also, this helps with internal testing of the updater and prevents an updated plugin from auto-starting another update
	# when dealing with proxy versions.
	var hasUpdatedAlready = Engine.has_meta("LoggieUpdateSuccessful") and Engine.get_meta("LoggieUpdateSuccessful")

	match loggie.settings.update_check_mode:
		LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW:
			if hasUpdatedAlready:
				loggie.info("Update already performed. ")
				return
			create_and_show_updater_widget(self._update)
		LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_MSG:
			loggie.msg(" Loggie update available!").color(Color.ORANGE).header().msg(" > Current version: {version}, Latest version: {latest}".format({
				"version" : self.version,
				"latest" : self.latest_version
			})).info()
		LoggieEnums.UpdateCheckType.CHECK_DOWNLOAD_AND_SHOW_MSG:
			if hasUpdatedAlready:
				loggie.info("Update already performed. ")
				return
			loggie.set_domain_enabled("loggie_update_status_reports", true)
			self._update.try_start()

## Defines what happens when the request to GitHub API which grabs all the Loggie releases is completed.
func _on_get_latest_version_request_completed(result : int, response_code : int, headers : PackedStringArray, body: PackedByteArray):
	var loggie = self.get_logger()
	loggie.msg("Response for request received:", response_code).domain(REPORTS_DOMAIN).debug()

	if result != HTTPRequest.RESULT_SUCCESS: 
		return

	var response = JSON.parse_string(body.get_string_from_utf8())

	if typeof(response) != TYPE_ARRAY:
		loggie.error("The response parsed from GitHub was not an array. Response received in an unsupported format.")
		return
	
	var latest_version_data = response[0] # GitHub releases are in order of creation, so grab the first one from the response, that's the latest one.
	self.latest_version = LoggieVersion.from_string(latest_version_data.tag_name)
	self.latest_version.set_meta("github_data", latest_version_data)

	loggie.msg("Current version of Loggie:", self.version).msg(" (proxy for: {value})".format({"value": self.version.proxy_for})).domain(REPORTS_DOMAIN).debug()
	loggie.msg("Latest version of Loggie:", self.latest_version).domain(REPORTS_DOMAIN).debug()
	latest_version_updated.emit()

## Executes every time this version manager updates the known latest_version.
func on_latest_version_updated() -> void:
	var loggie = self.get_logger()
	if loggie == null:
		return

	# Check if update is available.
	if loggie.settings.update_check_mode != LoggieEnums.UpdateCheckType.DONT_CHECK:
		loggie.msg(" Loggie:").bold().color("orange").msg(" Checking for updates...").info()
		if is_update_available():
			on_update_available_detected()
		else:
			loggie.msg(" Loggie:").bold().color("orange").msg(" Up to date. ").color(Color.LIGHT_GREEN).info()
		
## Displays the widget which informs the user of the available update and offers actions that they can take next.
func create_and_show_updater_widget(update : LoggieUpdate) -> Window:
	const PATH_TO_WIDGET_SCENE = "addons/loggie/version_management/update_prompt_window.tscn"
	var WIDGET_SCENE = load(PATH_TO_WIDGET_SCENE)
	if !is_instance_valid(WIDGET_SCENE):
		push_error("Loggie Update Prompt Window scene not found on expected path: {path}".format({"path": PATH_TO_WIDGET_SCENE}))
		return

	var loggie = self.get_logger()
	if loggie == null:
		return
	
	var popup_parent = null
	if Engine.is_editor_hint() and Engine.has_meta("LoggieEditorInterfaceBaseControl"):
		popup_parent = Engine.get_meta("LoggieEditorInterfaceBaseControl")
	else:
		popup_parent = SceneTree.current_scene

	# Configure popup window.
	var _popup = Window.new()
	update.succeeded.connect(func():
		_popup.queue_free()
		var success_dialog = AcceptDialog.new()
		var msg = " You may see temporary errors in the console due to Loggie files being re-scanned and reloaded on the spot.\nIt should be safe to dismiss them, but for the best experience, reload the Godot editor (and the plugin, if something seems wrong).\n\n If you see a 'Files have been modified on disk' window pop up, choose 'Discard local changes and reload' to accept incoming changes."
		success_dialog.dialog_text = msg
		success_dialog.title = "Loggie Updater"
		if is_instance_valid(popup_parent):
			popup_parent.add_child(success_dialog)
			success_dialog.popup_centered()
	)
	var on_close_requested = func():
		_popup.queue_free()

	_popup.close_requested.connect(on_close_requested, CONNECT_ONE_SHOT)
	_popup.borderless = false
	_popup.unresizable = true
	_popup.transient = true
	_popup.title = "Update Available"
	
	# Configure window widget and add it as a child of the popup window.
	var widget : LoggieUpdatePrompt = WIDGET_SCENE.instantiate()
	widget.connect_to_update(update)
	widget.set_anchors_preset(Control.PRESET_FULL_RECT)
	widget._logger = loggie
	widget.close_requested.connect(on_close_requested, CONNECT_ONE_SHOT)
	
	if is_instance_valid(popup_parent):
		popup_parent.add_child(_popup)
		_popup.popup_centered(widget.host_window_size)
	_popup.add_child(widget)

	return _popup

## Updates the local variables which point to the current and latest version of Loggie.
func update_version_cache():
	# Read and cache the current version of Loggie from plugin.cfg.
	find_and_store_current_version()

	# Read and cache the latest version of Loggie from GitHub.
	# (Do it only if running in editor, no need for this if running in a game).
	var logger = self.get_logger()
	if logger is Node:
		if !Engine.is_editor_hint():
			return
		if logger.is_node_ready():
			find_and_store_latest_version()
		else:
			logger.ready.connect(func():
				find_and_store_latest_version()
			, CONNECT_ONE_SHOT)

## Checks if an update for Loggie is available. Run only after running [method update_version_cache].
func is_update_available() -> bool:
	var loggie = self.get_logger()
	if !(self.version is LoggieVersion and self.version.is_valid()):
		loggie.error("The current version of Loggie is not valid. Run `find_and_store_current_version` once to obtain this value first.")
		return false
	if !(self.latest_version is LoggieVersion and self.latest_version.is_valid()):
		loggie.error("The latest version of Loggie is not valid. Run `find_and_store_latest_version` once to obtain this value first.")
		return false
	return self.latest_version.is_higher_than(self.version)


--------------------------------------------------
FILE: res:///addons/loggie/version_management/update_prompt_window.gd
--------------------------------------------------
@tool
## The Loggie Update Prompt is a control node that is meant to be created and added as a child of some other node, most commonly a [Window].
## It connects to a [LoggieUpdate] via its [method connect_to_update] method, then displays data about that update depending on what kind of
## data that [LoggieUpdate] provides with its signals.
class_name LoggieUpdatePrompt extends Panel

## Emitted when the user requests to close the update prompt.
signal close_requested()

## The animation player that will be used to animate the appearance of this window.
@export var animator : AnimationPlayer

## The size the window that's hosting this panel will be forced to assume when
## it's ready to pop this up on the screen.
@export var host_window_size : Vector2 = Vector2(1063, 672)

## Stores a reference to the logger that's using this window.
var _logger : Variant

## The update this window is visually representing.
var _update : LoggieUpdate

## Stores a boolean which indicates whether the update is currently in progress.
var is_currently_updating : bool = false

func _ready() -> void:
	connect_control_effects()
	%UpdateNowBtn.grab_focus()
	refresh_remind_later_btn()
	animator.play("RESET")

## Connects this window to an instance of [LoggieUpdate] whose progress and properties this window is supposed to track.
func connect_to_update(p_update : LoggieUpdate) -> void:
	self._update = p_update
	_update.is_in_progress_changed.connect(is_update_in_progress_changed)
	_update.starting.connect(on_update_starting)
	_update.succeeded.connect(on_update_succeeded)
	_update.failed.connect(on_update_failed)
	_update.progress.connect(on_update_progress)
	_update.status_changed.connect(on_update_status_changed)

## Returns a reference to the logger object that is using this widget.
func get_logger() -> Variant:
	return self._logger
	
## Defines what happens when the update this window is representing updates its "is in progress" status.
func is_update_in_progress_changed(is_in_progress : bool) -> void:
	self.is_currently_updating = is_in_progress
	
	# The first time we enter the UpdateMonitor view and start an update,
	# the %Notice node and its children should no longer (ever) be interactive or processing,
	# since there is no way to get back to that view anymore.
	if is_in_progress and %Notice.process_mode != Node.PROCESS_MODE_DISABLED:
		%Notice.process_mode = Node.PROCESS_MODE_DISABLED
		for child in %NoticeButtons.get_children():
			if child is Button:
				child.focus_mode = Button.FOCUS_NONE
	
## Connects the effects and functionalities of various controls in this window.
func connect_control_effects():
	if !is_instance_valid(self._update):
		return

	# Configure version(s) labels.
	%LabelCurrentVersion.text = str(self._update.prev_version)
	%LabelLatestVersion.text = str(self._update.new_version)
	%LabelOldVersion.text = str(self._update.prev_version)
	%LabelNewVersion.text = str(self._update.new_version)
	
	# Configure onhover/focused effects.
	var buttons_with_on_focushover_effect = [%OptionExitBtn, %OptionRestartGodotBtn, %OptionRetryUpdateBtn, %ReleaseNotesBtn, %RemindLaterBtn, %UpdateNowBtn]
	for button : Button in buttons_with_on_focushover_effect:
		button.focus_entered.connect(_on_button_focus_entered.bind(button))
		button.focus_exited.connect(_on_button_focus_exited.bind(button))
		button.mouse_entered.connect(_on_button_focus_entered.bind(button))
		button.mouse_exited.connect(_on_button_focus_exited.bind(button))
		button.pivot_offset = button.size * 0.5
		
	# Connect behavior which executes when "Update Now" is pressed.
	%UpdateNowBtn.pressed.connect(func():
		self._update.try_start()
	)
	
	# Configure Release Notes button.
	%ReleaseNotesBtn.visible = !self._update.release_notes_url.is_empty()
	%ReleaseNotesBtn.tooltip_text = "Opens {url} in browser.".format({"url": self._update.release_notes_url})
	%ReleaseNotesBtn.pressed.connect(func():
		if !self._update.release_notes_url.is_empty():
			OS.shell_open(self._update.release_notes_url)
	)
	
	# Connect behavior which executes when the "Remind Me Later / Close" is pressed.
	%RemindLaterBtn.pressed.connect(func(): close_requested.emit())
	%OptionExitBtn.pressed.connect(func(): close_requested.emit())
	
	# Connect behavior which executes when the "Retry" button is pressed.
	%OptionRetryUpdateBtn.pressed.connect(self._update.try_start)
	
	# Connect behavior which executes when the "Restart Godot" button is pressed.
	%OptionRestartGodotBtn.pressed.connect(func():
		close_requested.emit()
		if Engine.is_editor_hint():
			var editor_plugin = Engine.get_meta("LoggieEditorPlugin")
			editor_plugin.get_editor_interface().restart_editor(true)
	)

	# The "Don't show again checkbox" updates project settings whenever it is toggled.
	%DontShowAgainCheckbox.toggled.connect(func(toggled_on : bool):
		var loggie = self.get_logger()
		if Engine.is_editor_hint() and loggie != null:
			if toggled_on:
				loggie.settings.update_check_mode = LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_MSG
				ProjectSettings.set_setting(loggie.settings.project_settings.update_check_mode.path, LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_MSG)
			else:
				loggie.settings.update_check_mode = LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW
				ProjectSettings.set_setting(loggie.settings.project_settings.update_check_mode.path, LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW)
		refresh_remind_later_btn()
	)

## Updates the content of the "Remind Later Btn" to show text appropriate to the current state of the "Don't show again" checkbox.
func refresh_remind_later_btn():
	if %DontShowAgainCheckbox.button_pressed:
		%RemindLaterBtn.text = "close"
	else:
		%RemindLaterBtn.text = "remind later"

## Defines what happens when the [member _update] is detected to be starting.
func on_update_starting():
	if animator.current_animation != "show_update_overview":
		animator.queue("show_update_overview")
	%ProgressBar.value = 0
	%LabelMainStatus.text = "Downloading"
	%LabelUpdateStatus.text = "Waiting for server response."
	%OptionExitBtn.disabled = true
	%OptionExitBtn.visible = false
	%OptionRetryUpdateBtn.disabled = true
	%OptionRetryUpdateBtn.visible = false
	%OptionRestartGodotBtn.disabled = true
	%OptionRestartGodotBtn.visible = false

## Defines what happens when the [member _update] declares it has made progress.
func on_update_progress(value : float):
	%ProgressBar.value = value

## Defines what happens when the [member _update] declares it has succeeded.
func on_update_succeeded():
	%LabelMainStatus.text = "Updated"
	%OptionExitBtn.disabled = false
	%OptionExitBtn.visible = true
	%OptionRestartGodotBtn.disabled = false
	%OptionRestartGodotBtn.visible = true
	if animator.is_playing():
		animator.stop()
	animator.play("finish_success")

## Defines what happens when the [member _update] declares it wants the status message to change.
func on_update_status_changed(status_msg : Variant, substatus_msg : Variant):
	if status_msg is String:
		%LabelMainStatus.text = status_msg
	if substatus_msg is String:
		%LabelUpdateStatus.text = substatus_msg

## Defines what happens when the [member _update] declares it has failed.
func on_update_failed():
	%ProgressBar.value = 0
	%LabelMainStatus.text = "Failed"
	%OptionExitBtn.disabled = false
	%OptionExitBtn.visible = true
	%OptionRetryUpdateBtn.disabled = false
	%OptionRetryUpdateBtn.visible = true
	%OptionRestartGodotBtn.disabled = true
	%OptionRestartGodotBtn.visible = false

func _on_button_focus_entered(button : Button):
	if button.has_meta("scale_tween"):
		var old_tween = button.get_meta("scale_tween")
		old_tween.kill()
		button.set_meta("scale_tween", null)

	var tween : Tween = button.create_tween()
	tween.tween_property(button, "scale", Vector2(1.2, 1.2), 0.1)
	button.set_meta("scale_tween", tween)

func _on_button_focus_exited(button : Button):
	if button.has_meta("scale_tween"):
		var old_tween = button.get_meta("scale_tween")
		old_tween.kill()
		button.set_meta("scale_tween", null)

	var tween : Tween = button.create_tween()
	tween.tween_property(button, "scale", Vector2(1.0, 1.0), 0.1).from_current()
	button.set_meta("scale_tween", tween)


--------------------------------------------------
FILE: res:///addons/loggie/version_management/update_prompt_window.tscn
--------------------------------------------------
[gd_scene load_steps=32 format=3 uid="uid://d2eq0khfi3s15"]

[ext_resource type="Script" path="res://addons/loggie/version_management/update_prompt_window.gd" id="1_xb7je"]
[ext_resource type="Texture2D" uid="uid://cgh6hd3u8nlpj" path="res://addons/loggie/assets/updater_bg.png" id="2_lbawe"]
[ext_resource type="FontFile" uid="uid://e3rpni7mpu0p" path="res://addons/loggie/assets/theme/fonts/coffee_soda.ttf" id="3_a36jf"]
[ext_resource type="FontFile" uid="uid://btuvtbhws7p8s" path="res://addons/loggie/assets/theme/fonts/PatrickHandSC-Regular.ttf" id="4_lnh27"]
[ext_resource type="StyleBox" uid="uid://ckw36egxdynxc" path="res://addons/loggie/assets/theme/loggie_border_box.tres" id="5_avea8"]
[ext_resource type="Texture2D" uid="uid://bfnp2a0sbhi2x" path="res://addons/loggie/assets/theme/checkbox/checkbox_checked.png" id="6_yoxpw"]
[ext_resource type="Texture2D" uid="uid://bib1lwikra5kr" path="res://addons/loggie/assets/theme/checkbox/checkbox_unchecked.png" id="7_xu2hn"]
[ext_resource type="Texture2D" uid="uid://dqf5cye21gyw8" path="res://addons/loggie/assets/theme/checkbox/checkbox_checked_disabled.png" id="8_4h2cx"]
[ext_resource type="Texture2D" uid="uid://cloe7vx2ej0nf" path="res://addons/loggie/assets/theme/checkbox/checkbox_unchecked_disabled.png" id="9_51n7f"]
[ext_resource type="Texture2D" uid="uid://2fr6et0qni2y" path="res://addons/loggie/assets/icon.png" id="10_abt8m"]
[ext_resource type="Theme" uid="uid://bntkg3oi4b314" path="res://addons/loggie/assets/theme/loggie_theme.tres" id="11_5uxhl"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_3bh8r"]
draw_center = false
border_width_bottom = 4
border_color = Color(0.86, 0.6794, 0.344, 1)

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_rjg43"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_bwgrr"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_qbrxo"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_3asxb"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_86pfv"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_rw12e"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_j1ttd"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_3sc8x"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_ndum7"]

[sub_resource type="Gradient" id="Gradient_wnvcb"]
colors = PackedColorArray(0.0311948, 0.0139167, 0.0080977, 1, 0.125625, 0.1125, 0.15, 1)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_k1b6u"]
gradient = SubResource("Gradient_wnvcb")

[sub_resource type="Gradient" id="Gradient_rkgx7"]
interpolation_mode = 2
offsets = PackedFloat32Array(0, 0.270059, 1)
colors = PackedColorArray(0.584314, 0.337255, 0.145098, 1, 0.495303, 0.287021, 0.13981, 1, 0.188235, 0.113725, 0.121569, 1)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_p6ad4"]
gradient = SubResource("Gradient_rkgx7")
fill_from = Vector2(0.239316, 0)
fill_to = Vector2(0.303419, 0.876068)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_y40yc"]
bg_color = Color(0.12, 0.0528, 0.09088, 0.556863)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 6
border_color = Color(0.533576, 0.418125, 0.23421, 1)
border_blend = true
corner_radius_top_left = 11
corner_radius_top_right = 11
corner_radius_bottom_right = 11
corner_radius_bottom_left = 11

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_h3ybw"]
bg_color = Color(0.69, 0.49128, 0.2484, 0.486275)
border_width_right = 4
border_color = Color(0.94, 0.6768, 0.282, 0.541176)
corner_radius_top_left = 18
corner_radius_top_right = 18
corner_radius_bottom_right = 18
corner_radius_bottom_left = 18

[sub_resource type="Animation" id="Animation_almc7"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, -673)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:visible")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [false]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("VBoxContainer/OptionButtons/OptionRetryUpdateBtn:disabled")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [true]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("VBoxContainer/OptionButtons/OptionExitBtn:disabled")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [true]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("VBoxContainer/OptionButtons/OptionRetryUpdateBtn:visible")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [false]
}
tracks/5/type = "value"
tracks/5/imported = false
tracks/5/enabled = true
tracks/5/path = NodePath("VBoxContainer/OptionButtons/OptionExitBtn:visible")
tracks/5/interp = 1
tracks/5/loop_wrap = true
tracks/5/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [false]
}
tracks/6/type = "value"
tracks/6/imported = false
tracks/6/enabled = true
tracks/6/path = NodePath("%LabelOldVersion:modulate")
tracks/6/interp = 1
tracks/6/loop_wrap = true
tracks/6/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}
tracks/7/type = "value"
tracks/7/imported = false
tracks/7/enabled = true
tracks/7/path = NodePath("%LabelNewVersion:modulate")
tracks/7/interp = 1
tracks/7/loop_wrap = true
tracks/7/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}
tracks/8/type = "value"
tracks/8/imported = false
tracks/8/enabled = true
tracks/8/path = NodePath("%ProgressBar:modulate")
tracks/8/interp = 1
tracks/8/loop_wrap = true
tracks/8/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}
tracks/9/type = "value"
tracks/9/imported = false
tracks/9/enabled = true
tracks/9/path = NodePath("VBoxContainer:position")
tracks/9/interp = 1
tracks/9/loop_wrap = true
tracks/9/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 532)]
}
tracks/10/type = "value"
tracks/10/imported = false
tracks/10/enabled = true
tracks/10/path = NodePath("LoggieIcon:scale")
tracks/10/interp = 1
tracks/10/loop_wrap = true
tracks/10/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(1, 1)]
}

[sub_resource type="Animation" id="Animation_dewq5"]
resource_name = "finish_success"
length = 0.5
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 0)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:visible")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [true]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("%LabelOldVersion:modulate")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0, 0.2),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Color(1, 1, 1, 1), Color(1, 1, 1, 0)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("%LabelNewVersion:modulate")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0, 0.2),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Color(1, 1, 1, 1), Color(1, 1, 1, 0)]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("%ProgressBar:modulate")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0, 0.2),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Color(1, 1, 1, 1), Color(1, 1, 1, 0)]
}
tracks/5/type = "value"
tracks/5/imported = false
tracks/5/enabled = true
tracks/5/path = NodePath("VBoxContainer:position")
tracks/5/interp = 1
tracks/5/loop_wrap = true
tracks/5/keys = {
"times": PackedFloat32Array(0, 0.466667),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Vector2(0, 532), Vector2(1, 432)]
}
tracks/6/type = "value"
tracks/6/imported = false
tracks/6/enabled = true
tracks/6/path = NodePath("LoggieIcon:scale")
tracks/6/interp = 1
tracks/6/loop_wrap = true
tracks/6/keys = {
"times": PackedFloat32Array(0, 0.166667, 0.2, 0.3, 0.366667, 0.433333),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1),
"update": 0,
"values": [Vector2(1, 1), Vector2(1, 1), Vector2(1.33, 1), Vector2(1.075, 1.575), Vector2(0.735, 1.465), Vector2(1, 1)]
}

[sub_resource type="Animation" id="Animation_jm1cu"]
resource_name = "show_update_overview"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:position")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.2, 0.266667, 0.333333),
"transitions": PackedFloat32Array(1, 1, 1, 1),
"update": 0,
"values": [Vector2(0, -673), Vector2(0, 0), Vector2(0, 16), Vector2(0, 0)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:visible")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [true]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("%ProgressBar:modulate")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("%LabelOldVersion:modulate")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}
tracks/4/type = "value"
tracks/4/imported = false
tracks/4/enabled = true
tracks/4/path = NodePath("%LabelNewVersion:modulate")
tracks/4/interp = 1
tracks/4/loop_wrap = true
tracks/4/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Color(1, 1, 1, 1)]
}
tracks/5/type = "value"
tracks/5/imported = false
tracks/5/enabled = true
tracks/5/path = NodePath("LoggieIcon:scale")
tracks/5/interp = 1
tracks/5/loop_wrap = true
tracks/5/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(1, 1)]
}
tracks/6/type = "value"
tracks/6/imported = false
tracks/6/enabled = true
tracks/6/path = NodePath("VBoxContainer:position")
tracks/6/interp = 1
tracks/6/loop_wrap = true
tracks/6/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 532)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_lwiu5"]
_data = {
"RESET": SubResource("Animation_almc7"),
"finish_success": SubResource("Animation_dewq5"),
"show_update_overview": SubResource("Animation_jm1cu")
}

[node name="UpdatePromptWindow" type="Panel" node_paths=PackedStringArray("animator")]
anchors_preset = -1
anchor_right = 0.923
anchor_bottom = 1.037
offset_right = -0.296021
offset_bottom = 0.0239868
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_xb7je")
animator = NodePath("AnimationPlayer")

[node name="Notice" type="Control" parent="."]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Background" type="TextureRect" parent="Notice"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
texture = ExtResource("2_lbawe")
expand_mode = 1

[node name="LabelLatestVersion" type="Label" parent="Notice"]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = -1
anchor_left = 0.148
anchor_top = 0.549
anchor_right = 0.352
anchor_bottom = 0.735
offset_left = 0.414978
offset_top = 0.115936
offset_right = -0.122009
offset_bottom = 0.123932
grow_horizontal = 2
grow_vertical = 0
theme_override_colors/font_color = Color(0.878431, 0.662745, 0.266667, 1)
theme_override_colors/font_shadow_color = Color(0, 0, 0, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/shadow_offset_x = 3
theme_override_constants/shadow_offset_y = 3
theme_override_constants/outline_size = 18
theme_override_constants/shadow_outline_size = 3
theme_override_fonts/font = ExtResource("3_a36jf")
theme_override_font_sizes/font_size = 133
text = "X.Y"

[node name="LabelCurrentVersion" type="Label" parent="Notice"]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = -1
anchor_left = 0.76
anchor_top = 0.454
anchor_right = 0.869
anchor_bottom = 0.571
offset_left = 0.0449829
offset_top = 0.18399
offset_right = 57.004
offset_bottom = -0.107056
grow_horizontal = 0
grow_vertical = 2
theme_override_colors/font_color = Color(0.784314, 0.619608, 0.317647, 1)
theme_override_colors/font_shadow_color = Color(0, 0, 0, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/shadow_offset_x = 3
theme_override_constants/shadow_offset_y = 3
theme_override_constants/outline_size = 18
theme_override_constants/shadow_outline_size = 3
theme_override_fonts/font = ExtResource("3_a36jf")
theme_override_font_sizes/font_size = 73
text = "X.Y"

[node name="VBoxContainer" type="VBoxContainer" parent="Notice"]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.229
anchor_top = 0.789
anchor_right = 0.771
anchor_bottom = 0.926
offset_left = 0.0729828
offset_top = -0.208008
offset_right = -0.0730591
offset_bottom = 9.72797
grow_horizontal = 2
theme_override_constants/separation = -15

[node name="Label" type="Label" parent="Notice/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_colors/font_color = Color(0.872047, 0.774098, 0.671572, 1)
theme_override_constants/outline_size = 7
theme_override_fonts/font = ExtResource("4_lnh27")
theme_override_font_sizes/font_size = 32
text = "a new version of Loggie is available for download."
horizontal_alignment = 1

[node name="HBoxContainer" type="HBoxContainer" parent="Notice/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 4
alignment = 1

[node name="NoticeButtons" type="HBoxContainer" parent="Notice/VBoxContainer/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 6
theme_override_constants/separation = 51

[node name="ReleaseNotesBtn" type="Button" parent="Notice/VBoxContainer/HBoxContainer/NoticeButtons"]
unique_name_in_owner = true
visible = false
layout_mode = 2
mouse_default_cursor_shape = 2
theme_override_colors/font_disabled_color = Color(0.53, 0.475145, 0.3869, 1)
theme_override_colors/font_hover_pressed_color = Color(0.996078, 0.94902, 0.882353, 1)
theme_override_colors/font_hover_color = Color(0.98, 0.67571, 0.1862, 1)
theme_override_colors/font_pressed_color = Color(0.994326, 0.950716, 0.88154, 1)
theme_override_colors/font_focus_color = Color(0.996078, 0.94902, 0.882353, 1)
theme_override_colors/font_color = Color(0.980932, 0.843799, 0.621104, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 8
theme_override_fonts/font = ExtResource("4_lnh27")
theme_override_font_sizes/font_size = 43
theme_override_styles/focus = SubResource("StyleBoxFlat_3bh8r")
theme_override_styles/disabled_mirrored = SubResource("StyleBoxEmpty_rjg43")
theme_override_styles/disabled = SubResource("StyleBoxEmpty_bwgrr")
theme_override_styles/hover_pressed_mirrored = SubResource("StyleBoxEmpty_qbrxo")
theme_override_styles/hover_pressed = SubResource("StyleBoxEmpty_3asxb")
theme_override_styles/hover_mirrored = SubResource("StyleBoxEmpty_86pfv")
theme_override_styles/hover = SubResource("StyleBoxFlat_3bh8r")
theme_override_styles/pressed_mirrored = SubResource("StyleBoxEmpty_rw12e")
theme_override_styles/pressed = SubResource("StyleBoxEmpty_j1ttd")
theme_override_styles/normal_mirrored = SubResource("StyleBoxEmpty_3sc8x")
theme_override_styles/normal = SubResource("StyleBoxEmpty_ndum7")
text = "release notes"

[node name="UpdateNowBtn" type="Button" parent="Notice/VBoxContainer/HBoxContainer/NoticeButtons"]
unique_name_in_owner = true
layout_mode = 2
mouse_default_cursor_shape = 2
theme_override_colors/font_disabled_color = Color(0.53, 0.475145, 0.3869, 1)
theme_override_colors/font_hover_pressed_color = Color(0.996078, 0.94902, 0.882353, 1)
theme_override_colors/font_hover_color = Color(0.98, 0.67571, 0.1862, 1)
theme_override_colors/font_pressed_color = Color(0.994326, 0.950716, 0.88154, 1)
theme_override_colors/font_focus_color = Color(0.996078, 0.94902, 0.882353, 1)
theme_override_colors/font_color = Color(0.980932, 0.843799, 0.621104, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 8
theme_override_fonts/font = ExtResource("4_lnh27")
theme_override_font_sizes/font_size = 43
theme_override_styles/focus = SubResource("StyleBoxFlat_3bh8r")
theme_override_styles/disabled_mirrored = SubResource("StyleBoxEmpty_rjg43")
theme_override_styles/disabled = SubResource("StyleBoxEmpty_bwgrr")
theme_override_styles/hover_pressed_mirrored = SubResource("StyleBoxEmpty_qbrxo")
theme_override_styles/hover_pressed = SubResource("StyleBoxEmpty_3asxb")
theme_override_styles/hover_mirrored = SubResource("StyleBoxEmpty_86pfv")
theme_override_styles/hover = SubResource("StyleBoxFlat_3bh8r")
theme_override_styles/pressed_mirrored = SubResource("StyleBoxEmpty_rw12e")
theme_override_styles/pressed = SubResource("StyleBoxEmpty_j1ttd")
theme_override_styles/normal_mirrored = SubResource("StyleBoxEmpty_3sc8x")
theme_override_styles/normal = SubResource("StyleBoxEmpty_ndum7")
text = "update now"

[node name="RemindLaterBtn" type="Button" parent="Notice/VBoxContainer/HBoxContainer/NoticeButtons"]
unique_name_in_owner = true
layout_mode = 2
mouse_default_cursor_shape = 2
theme_override_colors/font_disabled_color = Color(0.53, 0.475145, 0.3869, 1)
theme_override_colors/font_hover_pressed_color = Color(0.996078, 0.94902, 0.882353, 1)
theme_override_colors/font_hover_color = Color(0.98, 0.67571, 0.1862, 1)
theme_override_colors/font_pressed_color = Color(0.994326, 0.950716, 0.88154, 1)
theme_override_colors/font_focus_color = Color(0.996078, 0.94902, 0.882353, 1)
theme_override_colors/font_color = Color(0.98, 0.49, 0.5635, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 8
theme_override_fonts/font = ExtResource("4_lnh27")
theme_override_font_sizes/font_size = 43
theme_override_styles/focus = SubResource("StyleBoxFlat_3bh8r")
theme_override_styles/disabled_mirrored = SubResource("StyleBoxEmpty_rjg43")
theme_override_styles/disabled = SubResource("StyleBoxEmpty_bwgrr")
theme_override_styles/hover_pressed_mirrored = SubResource("StyleBoxEmpty_qbrxo")
theme_override_styles/hover_pressed = SubResource("StyleBoxEmpty_3asxb")
theme_override_styles/hover_mirrored = SubResource("StyleBoxEmpty_86pfv")
theme_override_styles/hover = SubResource("StyleBoxFlat_3bh8r")
theme_override_styles/pressed_mirrored = SubResource("StyleBoxEmpty_rw12e")
theme_override_styles/pressed = SubResource("StyleBoxEmpty_j1ttd")
theme_override_styles/normal_mirrored = SubResource("StyleBoxEmpty_3sc8x")
theme_override_styles/normal = SubResource("StyleBoxEmpty_ndum7")
text = "remind later"

[node name="DontShowAgainCheckbox" type="CheckBox" parent="Notice"]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -289.0
offset_top = 9.0
offset_right = -20.0
offset_bottom = 62.0
grow_horizontal = 0
mouse_default_cursor_shape = 2
theme_override_colors/font_hover_color = Color(0.490196, 0.701961, 0.501961, 1)
theme_override_colors/font_focus_color = Color(0.92549, 0.92549, 0.756863, 1)
theme_override_colors/font_color = Color(0.980932, 0.843799, 0.621104, 1)
theme_override_constants/outline_size = 7
theme_override_fonts/font = ExtResource("4_lnh27")
theme_override_font_sizes/font_size = 27
theme_override_styles/focus = ExtResource("5_avea8")
theme_override_icons/checked = ExtResource("6_yoxpw")
theme_override_icons/unchecked = ExtResource("7_xu2hn")
theme_override_icons/radio_checked = ExtResource("6_yoxpw")
theme_override_icons/radio_unchecked = ExtResource("7_xu2hn")
theme_override_icons/checked_disabled = ExtResource("8_4h2cx")
theme_override_icons/unchecked_disabled = ExtResource("9_51n7f")
theme_override_icons/radio_checked_disabled = ExtResource("8_4h2cx")
theme_override_icons/radio_unchecked_disabled = ExtResource("9_51n7f")
text = "do not show this again"

[node name="UpdateMonitor" type="Control" parent="."]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -673.0
offset_bottom = -673.0
grow_horizontal = 2
grow_vertical = 2

[node name="BackgroundUnder" type="TextureRect" parent="UpdateMonitor"]
modulate = Color(1, 1, 1, 0.811765)
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
texture = SubResource("GradientTexture1D_k1b6u")

[node name="BackgroundOver" type="TextureRect" parent="UpdateMonitor"]
modulate = Color(1, 1, 1, 0.752941)
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
texture = SubResource("GradientTexture2D_p6ad4")

[node name="ProgressBar" type="ProgressBar" parent="UpdateMonitor"]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -448.5
offset_top = -224.0
offset_right = 449.5
offset_bottom = -160.0
grow_horizontal = 2
grow_vertical = 0
theme_override_constants/outline_size = 19
theme_override_fonts/font = ExtResource("3_a36jf")
theme_override_font_sizes/font_size = 31
theme_override_styles/background = SubResource("StyleBoxFlat_y40yc")
theme_override_styles/fill = SubResource("StyleBoxFlat_h3ybw")

[node name="LabelMainStatus" type="Label" parent="UpdateMonitor"]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -201.0
offset_top = -13.0
offset_right = 201.0
offset_bottom = 63.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0.878431, 0.662745, 0.266667, 1)
theme_override_colors/font_shadow_color = Color(0, 0, 0, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 14
theme_override_fonts/font = ExtResource("3_a36jf")
theme_override_font_sizes/font_size = 81
text = "status"
horizontal_alignment = 1

[node name="LabelOldVersion" type="Label" parent="UpdateMonitor"]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -426.5
offset_top = 77.0
offset_right = -24.5
offset_bottom = 153.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0.878431, 0.662745, 0.266667, 1)
theme_override_colors/font_shadow_color = Color(0, 0, 0, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 14
theme_override_fonts/font = ExtResource("3_a36jf")
theme_override_font_sizes/font_size = 25
text = "v_old"

[node name="LabelNewVersion" type="Label" parent="UpdateMonitor"]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = 33.5
offset_top = 76.0
offset_right = 435.5
offset_bottom = 152.0
grow_horizontal = 2
grow_vertical = 2
theme_override_colors/font_color = Color(0.878431, 0.662745, 0.266667, 1)
theme_override_colors/font_shadow_color = Color(0, 0, 0, 1)
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 14
theme_override_fonts/font = ExtResource("3_a36jf")
theme_override_font_sizes/font_size = 25
text = "V_NEW"
horizontal_alignment = 2

[node name="LoggieIcon" type="TextureRect" parent="UpdateMonitor"]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -79.5
offset_top = -213.0
offset_right = 80.5
offset_bottom = -53.0
grow_horizontal = 2
grow_vertical = 2
pivot_offset = Vector2(80, 84)
texture = ExtResource("10_abt8m")

[node name="VBoxContainer" type="VBoxContainer" parent="UpdateMonitor"]
layout_mode = 1
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -140.0
offset_bottom = 77.0002
grow_horizontal = 2
grow_vertical = 0
theme_override_constants/separation = 5

[node name="OptionButtons" type="HBoxContainer" parent="UpdateMonitor/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 24
alignment = 1

[node name="OptionRetryUpdateBtn" type="Button" parent="UpdateMonitor/VBoxContainer/OptionButtons"]
unique_name_in_owner = true
visible = false
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
mouse_default_cursor_shape = 2
theme = ExtResource("11_5uxhl")
disabled = true
text = "Retry"

[node name="OptionRestartGodotBtn" type="Button" parent="UpdateMonitor/VBoxContainer/OptionButtons"]
unique_name_in_owner = true
visible = false
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
mouse_default_cursor_shape = 2
theme = ExtResource("11_5uxhl")
disabled = true
text = "Reload Godot"

[node name="OptionExitBtn" type="Button" parent="UpdateMonitor/VBoxContainer/OptionButtons"]
unique_name_in_owner = true
visible = false
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
mouse_default_cursor_shape = 2
theme = ExtResource("11_5uxhl")
theme_override_colors/font_color = Color(0.980919, 0.500031, 0.570874, 1)
theme_override_colors/font_outline_color = Color(0.224555, 0.120107, 0.0255992, 1)
theme_override_constants/outline_size = 8
disabled = true
text = "Exit"

[node name="LabelUpdateStatus" type="Label" parent="UpdateMonitor/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme = ExtResource("11_5uxhl")
theme_override_font_sizes/font_size = 20
text = "UPDATE_STATUS_DETAILED"
horizontal_alignment = 1
autowrap_mode = 2

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
unique_name_in_owner = true
root_node = NodePath("../UpdateMonitor")
libraries = {
"": SubResource("AnimationLibrary_lwiu5")
}


--------------------------------------------------
FILE: res:///assets/placeholder_tile.tres
--------------------------------------------------
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 100
height = 100
noise = SubResource("FastNoiseLite_cemhj")


--------------------------------------------------
FILE: res:///autoload/DynastyManager.gd
--------------------------------------------------
#DynastyManager.gd
extends Node

signal jarl_stats_updated(jarl_data: JarlData)
signal year_ended

var current_jarl: JarlData
var minimum_inherited_legitimacy: int = 0
var loaded_legacy_upgrades: Array[LegacyUpgradeData] = []

var active_year_modifiers: Dictionary[String, float] = {
	"damage_mult": 0.0,
	"xp_mult": 0.0,
	"birth_chance": 0.0,
	"harvest_mult": 0.0
}
var current_year: int = 867 
# --- SEASON STATE ---
enum Season { SPRING, SUMMER, AUTUMN, WINTER }
var current_season: Season = Season.SPRING

# --- CONSTANTS ---
const USER_DYNASTY_PATH = "user://savegame_dynasty.tres"
const DEFAULT_JARL_PATH = "res://data/characters/PlayerJarl.tres"

func _ready() -> void:
	_load_game_data()
	EventBus.succession_choices_made.connect(_on_succession_choices_made)
	EventBus.advance_season_requested.connect(advance_season)

# --- SEASON LOGIC ---

func advance_season() -> void:
	match current_season:
		Season.SPRING:
			_transition_to_season(Season.SUMMER)
		Season.SUMMER:
			_transition_to_season(Season.AUTUMN)
		Season.AUTUMN:
			_transition_to_season(Season.WINTER)
			start_winter_cycle() 
		Season.WINTER:
			end_winter_cycle_complete()
	

func _transition_to_season(new_season: Season) -> void:
	current_season = new_season
	var names = ["Spring", "Summer", "Autumn", "Winter"]
	var s_name = names[current_season]
	
	Loggie.msg("Season Advanced to: %s" % s_name).domain(LogDomains.DYNASTY).info()
	EventBus.season_changed.emit(s_name)
	
	# --- ORCHESTRATION: The Game Loop ---
	
	# 1. Labor (Construction)
	# Called explicitly here because EconomyManager is now decoupled
	if SettlementManager.has_method("process_construction_labor"):
		SettlementManager.process_construction_labor()
	
	# 2. Economy & Payout
	var payout_report = EconomyManager.calculate_seasonal_payout(s_name)
	
	# 3. Winter Specifics (Hunger)
	if s_name == "Winter":
		if SettlementManager.has_method("process_warband_hunger"):
			var warnings = SettlementManager.process_warband_hunger()
			if not warnings.is_empty():
				if not payout_report.has("_messages"): payout_report["_messages"] = []
				payout_report["_messages"].append_array(warnings)
	
	# 4. Save State (Orchestrator Responsibility)
	if SettlementManager.has_method("save_settlement"):
		SettlementManager.save_settlement()
	
	# 5. Display Feedback
	_display_seasonal_feedback(s_name, payout_report)

func _display_seasonal_feedback(season_name: String, payout: Dictionary) -> void:
	var center_screen = Vector2(960, 500)
	var color = Color.WHITE
	
	if season_name == "Autumn": color = Color.ORANGE
	elif season_name == "Winter": color = Color.CYAN
	
	EventBus.floating_text_requested.emit("%s Arrives" % season_name, center_screen, color)
	
	var offset_y = 40
	for res in payout:
		# Skip non-resource keys
		if res == "_messages" or res == "population_growth": continue 
		
		var amount = payout[res]
		if typeof(amount) == TYPE_INT and amount > 0:
			var text = "+%d %s" % [amount, res.capitalize()]
			var pos = center_screen + Vector2(0, offset_y)
			
			var res_color = Color.WHITE
			if res == "gold": res_color = Color.GOLD
			elif res == "food": res_color = Color.GREEN_YELLOW
			elif res == "wood": res_color = Color.BURLYWOOD
			
			EventBus.floating_text_requested.emit(text, pos, res_color)
			offset_y += 30
			
	if payout.has("_messages"):
		for msg in payout["_messages"]:
			var clean_msg = msg.replace("[color=green]", "").replace("[/color]", "")
			var pos = center_screen + Vector2(0, offset_y)
			EventBus.floating_text_requested.emit(clean_msg, pos, Color.LIGHT_BLUE)
			offset_y += 30

func get_current_season_name() -> String:
	var names = ["Spring", "Summer", "Autumn", "Winter"]
	return names[current_season]

func aggregate_card_effects(card: SeasonalCardResource) -> void:
	if not card: return
	
	# 1. Map Explicit Inspector Variables (The "Main" Stats)
	# We map these manually to keep the nice sliders in the Inspector working.
	if "mod_unit_damage" in card:
		active_year_modifiers["mod_unit_damage"] = active_year_modifiers.get("mod_unit_damage", 0.0) + card.mod_unit_damage
	if "mod_raid_xp" in card:
		active_year_modifiers["mod_raid_xp"] = active_year_modifiers.get("mod_raid_xp", 0.0) + card.mod_raid_xp
	if "mod_birth_chance" in card:
		active_year_modifiers["mod_birth_chance"] = active_year_modifiers.get("mod_birth_chance", 0.0) + card.mod_birth_chance
	if "mod_harvest_yield" in card:
		active_year_modifiers["mod_harvest_yield"] = active_year_modifiers.get("mod_harvest_yield", 0.0) + card.mod_harvest_yield
		
	# 2. Map Dynamic Dictionary (The "Custom" Stats)
	# This enables you to add ANY modifier in the Inspector via a 'modifiers' dictionary on the card
	# without editing this script.
	if "modifiers" in card and card.modifiers is Dictionary:
		for key in card.modifiers:
			var value = card.modifiers[key]
			if value is float or value is int:
				active_year_modifiers[key] = active_year_modifiers.get(key, 0.0) + value
	
	Loggie.msg("DynastyManager: Aggregated effects from '%s'. New Stats: %s" % [card.display_name, active_year_modifiers]).domain(LogDomains.DYNASTY).debug()

## Resets all seasonal modifiers. Called at the end of the Winter Cycle (start of Spring).
func reset_year_stats() -> void:
	# We clear and re-initialize to ensure we don't keep stale dynamic keys forever
	active_year_modifiers.clear()
	
	# Re-init defaults (Optional, but good for autocomplete consistency if using typed dicts elsewhere)
	active_year_modifiers["mod_unit_damage"] = 0.0
	active_year_modifiers["mod_raid_xp"] = 0.0
	active_year_modifiers["mod_birth_chance"] = 0.0
	active_year_modifiers["mod_harvest_yield"] = 0.0
	
	Loggie.msg("DynastyManager: Year stats reset for new cycle.").domain(LogDomains.DYNASTY).info()
# --- EXISTING LOGIC ---

func _load_game_data() -> void:
	_load_legacy_upgrades_from_disk()
	
	if ResourceLoader.exists(USER_DYNASTY_PATH):
		current_jarl = load(USER_DYNASTY_PATH)
		Loggie.msg("DynastyManager: Loaded Jarl from User Save.").domain(LogDomains.DYNASTY).info()
	elif ResourceLoader.exists(DEFAULT_JARL_PATH):
		current_jarl = load(DEFAULT_JARL_PATH).duplicate(true)
		Loggie.msg("DynastyManager: Loaded Default Template Jarl.").domain(LogDomains.DYNASTY).info()
	else:
		Loggie.msg("DynastyManager: No Jarl data found. Generating fallback.").domain(LogDomains.DYNASTY).warn()
		current_jarl = JarlData.new()
		current_jarl.display_name = "Fallback Jarl"
		
	jarl_stats_updated.emit(current_jarl)
	
	current_season = Season.SPRING
	EventBus.season_changed.emit("Spring")

func start_new_campaign() -> void:
	Loggie.msg("DynastyManager: Starting NEW CAMPAIGN...").domain(LogDomains.DYNASTY).warn()
	
	current_jarl = DynastyGenerator.generate_random_dynasty()
	current_jarl.resource_path = USER_DYNASTY_PATH 
	
	RaidManager.reset_raid_state()
	active_year_modifiers.clear()
	_load_legacy_upgrades_from_disk() 
	_save_jarl_data()
	
	current_season = Season.SPRING
	
	jarl_stats_updated.emit(current_jarl)

func _load_legacy_upgrades_from_disk() -> void:
	loaded_legacy_upgrades.clear()
	if not DirAccess.dir_exists_absolute("res://data/legacy/"): return

	var dir = DirAccess.open("res://data/legacy/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var path = "res://data/legacy/" + file_name
				var upgrade_data = load(path) as LegacyUpgradeData
				if upgrade_data:
					var unique_upgrade = upgrade_data.duplicate()
					if has_purchased_upgrade(unique_upgrade.effect_key):
						unique_upgrade.current_progress = unique_upgrade.required_progress
					loaded_legacy_upgrades.append(unique_upgrade)
			file_name = dir.get_next()

func get_current_jarl() -> JarlData:
	if not current_jarl: _load_game_data()
	return current_jarl

# --- AUTHORITY & LEGACY LOGIC ---

func can_spend_authority(cost: int) -> bool:
	if not current_jarl: return false
	return current_jarl.can_take_action(cost)

func spend_authority(cost: int) -> bool:
	if not current_jarl: return false
	if current_jarl.spend_authority(cost):
		_save_jarl_data()
		jarl_stats_updated.emit(current_jarl)
		return true
	return false

func can_spend_renown(cost: int) -> bool:
	if not current_jarl: return false
	return current_jarl.renown >= cost

func spend_renown(cost: int) -> bool:
	if not can_spend_renown(cost): return false
	current_jarl.renown -= cost
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	return true

func award_renown(amount: int) -> void:
	if not current_jarl: return
	current_jarl.award_renown(amount)
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)

func purchase_legacy_upgrade(upgrade_key: String) -> void:
	if not current_jarl: return
	if not upgrade_key in current_jarl.purchased_legacy_upgrades:
		current_jarl.purchased_legacy_upgrades.append(upgrade_key)
		_save_jarl_data()

func has_purchased_upgrade(upgrade_key: String) -> bool:
	if not current_jarl: return false
	return upgrade_key in current_jarl.purchased_legacy_upgrades

func add_conquered_region(region_path: String) -> void:
	if not current_jarl: return
	if not region_path in current_jarl.conquered_regions:
		current_jarl.conquered_regions.append(region_path)
		_save_jarl_data()

func has_conquered_region(region_path: String) -> bool:
	if not current_jarl: return false
	return region_path in current_jarl.conquered_regions

# --- HEIR MANAGEMENT ---

func get_available_heir_count() -> int:
	if not current_jarl: return 0
	return current_jarl.get_available_heir_count()

func designate_heir(target_heir: JarlHeirData) -> void:
	if not current_jarl or not target_heir: return
	if not can_spend_authority(1): return
		
	spend_authority(1)
	for heir in current_jarl.heirs:
		heir.is_designated_heir = false
	target_heir.is_designated_heir = true
	
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)

func start_heir_expedition(heir: JarlHeirData, expedition_duration: int = 3) -> void:
	if not current_jarl or not heir in current_jarl.heirs: return
	heir.status = JarlHeirData.HeirStatus.OnExpedition
	heir.expedition_years_remaining = expedition_duration
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)

func marry_heir_for_alliance(region_path: String) -> bool:
	if not current_jarl: return false
	var heir_to_marry = current_jarl.get_first_available_heir()
	if not heir_to_marry: return false
	
	heir_to_marry.status = JarlHeirData.HeirStatus.MarriedOff
	if not region_path in current_jarl.allied_regions:
		current_jarl.allied_regions.append(region_path)
	
	current_jarl.legitimacy = min(100, current_jarl.legitimacy + 10)
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	return true

func is_allied_region(region_path: String) -> bool:
	if not current_jarl: return false
	return region_path in current_jarl.allied_regions

func add_trait_to_heir(heir: JarlHeirData, trait_data: JarlTraitData) -> void:
	if not heir: return
	heir.traits.append(trait_data)

func find_heir_by_name(h_name: String) -> JarlHeirData:
	if not current_jarl: return null
	for heir in current_jarl.heirs:
		if heir.display_name == h_name: return heir
	return null

func kill_heir_by_name(h_name: String, reason: String) -> void:
	var heir = find_heir_by_name(h_name)
	if heir:
		heir.status = JarlHeirData.HeirStatus.Deceased
		current_jarl.remove_heir(heir)
		jarl_stats_updated.emit(current_jarl)
		_save_jarl_data()

# --- WINTER CYCLE ORCHESTRATION ---

func start_winter_cycle() -> void:
	if not current_jarl: return
	
	current_jarl.calculate_hall_actions()
	Loggie.msg("Winter Cycle Started. Hall Actions: %d" % current_jarl.current_hall_actions).domain(LogDomains.DYNASTY).info()
	
	RaidManager.reset_raid_state()
	WinterManager.start_winter_phase()

func end_winter_cycle_complete() -> void:
	if not current_jarl: return
	
	Loggie.msg("Winter Ended. Advancing to Spring...").domain(LogDomains.DYNASTY).info()
	
	current_jarl.age_jarl(1)
	current_year += 1 
	_process_heir_simulation()
	
	if _check_for_jarl_death(): return 
	
	current_jarl.reset_authority()
	active_year_modifiers.clear()
	
	# Calculate Economy
	var payout_report = EconomyManager.calculate_seasonal_payout("Winter")
	
	# Winter specific feedback
	_display_seasonal_feedback("Winter", payout_report)
	
	SettlementManager.commit_seasonal_recruits()
	if SettlementManager.has_method("save_settlement"):
		SettlementManager.save_settlement()
	
	_save_jarl_data()
	
	_transition_to_season(Season.SPRING)
	
	jarl_stats_updated.emit(current_jarl)
	
	Loggie.msg("Year ended. Jarl is now %d." % current_jarl.age).domain("DYNASTY").info()
	year_ended.emit()
	EventBus.scene_change_requested.emit("settlement")

func get_current_year(): 
	return current_year

# --- JARL SIMULATION & DEATH ---

func _process_heir_simulation() -> void:
	var heirs_to_remove: Array[JarlHeirData] = []
	for heir in current_jarl.heirs:
		heir.age += 1
		if heir.status == JarlHeirData.HeirStatus.OnExpedition:
			heir.expedition_years_remaining -= 1
			if heir.expedition_years_remaining <= 0:
				_resolve_expedition(heir)
		if heir.age > 50 and randf() < 0.05: 
			heirs_to_remove.append(heir)
	for dead_heir in heirs_to_remove:
		current_jarl.remove_heir(dead_heir)
	_try_birth_event()

func _resolve_expedition(heir: JarlHeirData) -> void:
	var roll = randf()
	if roll > 0.3:
		heir.status = JarlHeirData.HeirStatus.Available
		var renown_gain = randi_range(100, 300)
		award_renown(renown_gain)
	else:
		heir.status = JarlHeirData.HeirStatus.LostAtSea

func _try_birth_event() -> void:
	if current_jarl.heirs.size() >= 6: return
	var base_chance = 0.30
	
	if active_year_modifiers.has("BLOT_FREYR"):
		base_chance += 0.50 
		Loggie.msg("Freyr's Blessing is active! Birth chance increased.").domain(LogDomains.DYNASTY).info()
	
	if current_jarl.age > 50: base_chance -= 0.20
	if current_jarl.age > 60: base_chance = 0.0
	
	if randf() < base_chance:
		_generate_new_baby()

func _generate_new_baby() -> void:
	var baby = DynastyGenerator.generate_newborn()
	current_jarl.heirs.append(baby)
	Loggie.msg("A new child, %s, was born to the Dynasty!" % baby.display_name).domain("DYNASTY").info()
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)

func _save_jarl_data() -> void:
	if not current_jarl: return
	if current_jarl.resource_path.is_empty():
		current_jarl.resource_path = USER_DYNASTY_PATH 
	var error = ResourceSaver.save(current_jarl, current_jarl.resource_path)
	if error != OK:
		Loggie.msg("Failed to save Jarl data. Error: %s" % error).domain("DYNASTY").error()

func debug_kill_jarl() -> void:
	_trigger_succession()

func _check_for_jarl_death() -> bool:
	var jarl = get_current_jarl()
	var death_chance = 0.0
	if jarl.age > 80: death_chance = 0.5
	elif jarl.age > 65: death_chance = 0.25
	elif jarl.age > 50: death_chance = 0.1
	
	if randf() < death_chance:
		_trigger_succession()
		return true
	return false

func _trigger_succession() -> void:
	var old_jarl = current_jarl
	var heir = null
	for h in current_jarl.heirs:
		if h.is_designated_heir and h.status == JarlHeirData.HeirStatus.Available:
			heir = h
			break
	if not heir: heir = current_jarl.get_first_available_heir()
	
	if not heir:
		Loggie.msg("GAME OVER: The Jarl died with no available heir!").domain("DYNASTY").error()
		return
	
	var new_jarl = _promote_heir_to_jarl(heir, old_jarl)
	var ancestor_entry = {
		"name": old_jarl.display_name,
		"portrait": old_jarl.portrait,
		"final_renown": old_jarl.renown,
		"death_reason": "Died of old age"
	}
	new_jarl.ancestors.append(ancestor_entry)
	new_jarl.heirs.erase(heir) 
	current_jarl = new_jarl
	
	var succession_event_data = EventData.new() 
	succession_event_data.event_id = "succession_crisis"
	EventManager._trigger_event(succession_event_data)

func _promote_heir_to_jarl(heir: JarlHeirData, predecessor: JarlData) -> JarlData:
	var new_jarl = JarlData.new()
	new_jarl.display_name = heir.display_name
	new_jarl.age = heir.age
	new_jarl.gender = heir.gender
	new_jarl.portrait = heir.portrait
	new_jarl.command = heir.command
	new_jarl.stewardship = heir.stewardship
	new_jarl.learning = heir.learning
	new_jarl.prowess = heir.prowess
	new_jarl.traits = heir.traits
	new_jarl.ancestors = predecessor.ancestors.duplicate()
	new_jarl.heirs = predecessor.heirs.duplicate()
	
	var new_legit = int(predecessor.legitimacy * 0.8)
	if heir.is_designated_heir: new_legit += 20
	new_legit = max(new_legit, minimum_inherited_legitimacy)
	
	new_jarl.legitimacy = new_legit
	new_jarl.succession_debuff_years_remaining = 3 
	new_jarl.take_over_path(USER_DYNASTY_PATH)
	return new_jarl

func _on_succession_choices_made(renown_choice: String, gold_choice: String) -> void:
	if renown_choice == "refuse":
		for upgrade in loaded_legacy_upgrades:
			if not upgrade.is_purchased and upgrade.current_progress > 0:
				upgrade.current_progress = max(0, upgrade.current_progress - 2)
				break
	if gold_choice == "refuse":
		if SettlementManager.current_settlement:
			SettlementManager.current_settlement.has_stability_debuff = true
	EventBus.event_system_finished.emit()

func perform_hall_action(cost: int = 1) -> bool:
	if not current_jarl or current_jarl.current_hall_actions < cost: return false
	current_jarl.current_hall_actions -= cost
	jarl_stats_updated.emit(current_jarl)
	return true

func apply_year_modifier(key: String) -> void:
	if key == "":
		return
		
	active_year_modifiers[key] = true
	
	Loggie.msg("Year Modifier Applied").domain(LogDomains.GAMEPLAY).data("key", key).info()
	
	# Optional: Emit update if UI needs to show icons elsewhere
	#EventBus.modifiers_updated.emit(active_year_modifiers)

func _generate_oath_name() -> String:
	var names = ["Red", "Bold", "Young", "Wild", "Sworn", "Lucky"]
	return "The %s" % names.pick_random()


--------------------------------------------------
FILE: res:///autoload/EconomyManager.gd
--------------------------------------------------
extends Node

# --- EFFICIENCY CONSTANTS ---
const BUILDER_EFFICIENCY: int = 6 
const GATHERER_EFFICIENCY: int = 10 
const BASE_GATHERING_CAPACITY: int = 2

# --- POPULATION CONSTANTS ---
const FOOD_PER_PERSON_PER_YEAR: int = 10
const WINTER_FOOD_BASE: int = 1 # NEW: Unifies WinterManager's legacy math
const WINTER_WARBAND_FOOD: int = 5 # NEW: Unifies WinterManager's legacy math
const BASE_GROWTH_RATE: float = 0.02 
const STARVATION_PENALTY: float = -0.15 
const UNREST_PER_LANDLESS_PEASANT: int = 2
const FERTILITY_BONUS: float = 0.01
const BASE_LAND_CAPACITY: int = 5

# --- LOGIC CONSTANTS ---
const BASE_STEWARDSHIP_THRESHOLD: int = 10
const STEWARDSHIP_SCALAR: float = 0.05
const TRAIT_FERTILE: String = "Fertile"
const SEASON_AUTUMN: String = "Autumn"
const SEASON_WINTER: String = "Winter"
const WINTER_WOOD_DEMAND: int = 20 # Base fireplace cost

# --- STORAGE CONSTANTS ---
const BASE_STORAGE_CAPACITY: int = 200 
const BASE_GOLD_CAPACITY: int = 500

# --- RAID CONSTANTS ---
const RAID_LOSS_RATIO_MIN: float = 0.2
const RAID_LOSS_RATIO_MAX: float = 0.4
const RAID_BUILDING_DMG_MIN: int = 50
const RAID_BUILDING_DMG_MAX: int = 150

# --- PUBLIC QUERIES ---

func get_resource_cap(resource_type: String) -> int:
	var settlement = SettlementManager.current_settlement
	if not settlement: return BASE_STORAGE_CAPACITY
	
	var key = resource_type.to_lower()
	var cap = BASE_STORAGE_CAPACITY
	if key == "gold": cap = BASE_GOLD_CAPACITY
	
	for entry in settlement.placed_buildings:
		if entry.get("resource_path"):
			var data = load(entry["resource_path"])
			if data is EconomicBuildingData:
				var bonus = data.get("storage_capacity_bonus")
				if bonus == null: bonus = 0
				
				if bonus > 0:
					var b_type = data.resource_type.to_lower()
					if b_type == "generic" or b_type == key:
						cap += bonus
						
	return cap

func is_storage_full(resource_type: String) -> bool:
	var settlement = SettlementManager.current_settlement
	if not settlement: return true
	
	var key = resource_type.to_lower()
	var current = settlement.treasury.get(key, 0)
	var cap = get_resource_cap(key)
	return current >= cap

func get_projected_income() -> Dictionary[String, int]:
	var settlement = SettlementManager.current_settlement
	if not settlement: return {}
	
	var projection: Dictionary[String, int] = {}
	
	var stewardship_bonus := 1.0
	var jarl = DynastyManager.get_current_jarl()
	if jarl:
		var skill = jarl.get_effective_skill("stewardship")
		stewardship_bonus = 1.0 + (skill - BASE_STEWARDSHIP_THRESHOLD) * STEWARDSHIP_SCALAR
		stewardship_bonus = max(0.5, stewardship_bonus)

	for entry in settlement.placed_buildings:
		var b_data = load(entry["resource_path"])
		if b_data is EconomicBuildingData:
			var type = b_data.resource_type.to_lower()
			if type == "generic": continue 
			
			if not projection.has(type): projection[type] = 0
			var p_count = entry.get("peasant_count", 0)
			var p_out = p_count * b_data.base_passive_output
			var t_count = entry.get("thrall_count", 0)
			var t_out = t_count * b_data.output_per_thrall
			var production = int((p_out + t_out) * stewardship_bonus)
			
			projection[type] += production

	if jarl:
		for region_path in jarl.conquered_regions:
			var r_data = load(region_path)
			if r_data:
				for res in r_data.yearly_income:
					var key = res.to_lower()
					if not projection.has(key): projection[key] = 0
					projection[key] += int(r_data.yearly_income[res] * stewardship_bonus)
					
	return projection

## NEW: Centralized Winter Forecast Logic
## Returns anticipated demand for Food and Wood based on population.
## UPDATED: Uses authoritative Winter constants to prevent UI drift
func get_winter_forecast() -> Dictionary:
	var settlement = SettlementManager.current_settlement
	if not settlement: return {GameResources.FOOD: 0, GameResources.WOOD: 0}
	
	# Calculate based on Normal severity (1.0)
	return calculate_winter_consumption_costs(1.0)

## NEW: Authoritative math for winter demand
func calculate_winter_consumption_costs(severity_mult: float) -> Dictionary:
	var settlement = SettlementManager.current_settlement
	if not settlement: return {GameResources.FOOD: 0, GameResources.WOOD: 0}

	var pop = settlement.population_peasants
	var warbands = settlement.warbands.size()
	
	var base_food = (pop * WINTER_FOOD_BASE) + (warbands * WINTER_WARBAND_FOOD)
	var base_wood = WINTER_WOOD_DEMAND
	
	return {
		GameResources.FOOD: int(base_food * severity_mult),
		GameResources.WOOD: int(base_wood * severity_mult)
	}

# --- TURN LOGIC (SEASONAL) ---

func apply_winter_consumption(costs: Dictionary) -> void:
	var settlement = SettlementManager.current_settlement
	if not settlement: return

	var f_cost = costs.get(GameResources.FOOD, 0)
	var w_cost = costs.get(GameResources.WOOD, 0)
	
	# Mutate Treasury
	var current_food = settlement.treasury.get(GameResources.FOOD, 0)
	var current_wood = settlement.treasury.get(GameResources.WOOD, 0)
	
	settlement.treasury[GameResources.FOOD] = max(0, current_food - f_cost)
	settlement.treasury[GameResources.WOOD] = max(0, current_wood - w_cost)
	
	Loggie.msg("EconomyManager: Applied Winter Consumption: %s" % costs).domain(LogDomains.ECONOMY).info()
	EventBus.treasury_updated.emit(settlement.treasury)

## NEW: Centralized Crisis Resolution (Sacrifices)
func resolve_winter_crisis_sacrifice(sacrifice_type: String, deficit_data: Dictionary) -> void:
	var settlement = SettlementManager.current_settlement
	if not settlement: return
	
	match sacrifice_type:
		"starve_peasants":
			# Use constant string for deficit key for safety
			var deaths = max(1, int(deficit_data.get("food_deficit", 0) / 5))
			settlement.population_peasants = max(0, settlement.population_peasants - deaths)
			Loggie.msg("EconomyManager: Sacrificed %d Peasants" % deaths).domain(LogDomains.ECONOMY).warn()
			
		"disband_warband":
			if not settlement.warbands.is_empty(): 
				settlement.warbands.pop_back()
				Loggie.msg("EconomyManager: Disbanded Warband").domain(LogDomains.ECONOMY).warn()
				
		"burn_ships":
			settlement.fleet_readiness = 0.0
			Loggie.msg("EconomyManager: Burned Ships").domain(LogDomains.ECONOMY).warn()
	
	EventBus.treasury_updated.emit(settlement.treasury)

## NEW: Professional Recruitment (Population Neutral)
func recruit_professional_unit(unit_cost: Dictionary, unit_data: Variant) -> bool:
	if attempt_purchase(unit_cost):
		var settlement = SettlementManager.current_settlement
		settlement.warbands.append(unit_data)
		Loggie.msg("EconomyManager: Recruited Professional Unit").domain(LogDomains.ECONOMY).info()
		return true
	return false

func calculate_seasonal_payout(season_name: String) -> Dictionary:
	var settlement = SettlementManager.current_settlement
	if not settlement: return {}
	
	# Typed as Variant because it holds both ints (resources) and Array (messages)
	var total_payout: Dictionary[String, Variant] = { "_messages": [] }
	
	# 1. Calculate Payouts
	var yearly_projection = get_projected_income()
	
	for res in yearly_projection:
		var yearly_amount = yearly_projection[res]
		var seasonal_amount = 0
		
		# Resource Distribution Rules
		if res == "food":
			if season_name == SEASON_AUTUMN:
				seasonal_amount = yearly_amount
				var msg_list: Array = total_payout["_messages"]
				msg_list.append("[color=green]Harvest Complete: +%d Food[/color]" % seasonal_amount)
			else:
				seasonal_amount = 0
		else:
			seasonal_amount = int(yearly_amount / 4.0)
		
		if seasonal_amount > 0:
			total_payout[res] = seasonal_amount

	# 2. Apply to Treasury
	_apply_payout_to_treasury(settlement, total_payout)
	
	# 3. Winter Consequences
	if season_name == SEASON_WINTER:
		var jarl = DynastyManager.get_current_jarl()
		_calculate_demographics(settlement, total_payout, jarl)
		# Note: Hunger logic handled by Orchestrator
	
	var log_report = total_payout.duplicate()
	log_report.erase("_messages") # Remove UI clutter from console log
	
	if log_report.is_empty():
		Loggie.msg("Seasonal Payout: None").domain(LogDomains.ECONOMY).info()
	else:
		Loggie.msg("Seasonal Payout: %s" % log_report).domain(LogDomains.ECONOMY).info()
	# -------------------.ECONOMY).info()
	EventBus.treasury_updated.emit(settlement.treasury)
	return total_payout

func _apply_payout_to_treasury(settlement: SettlementData, payout: Dictionary) -> void:
	for res in payout:
		if res == "_messages": continue 
		
		var key = res.to_lower()
		var amount = payout[res]
		
		var cap = get_resource_cap(key)
		var current = settlement.treasury.get(key, 0)
		var space_left = cap - current
		var amount_to_add = clampi(amount, 0, max(0, space_left))
		
		if settlement.treasury.has(key):
			settlement.treasury[key] += amount_to_add
		else:
			settlement.treasury[key] = amount_to_add

func _calculate_demographics(settlement: SettlementData, payout_report: Dictionary, jarl: JarlData) -> void:
	var pop = settlement.population_peasants
	var current_food = settlement.treasury.get("food", 0)
	var total_food_available = current_food 
	var food_required = pop * FOOD_PER_PERSON_PER_YEAR
	
	var growth_rate = BASE_GROWTH_RATE
	var event_msg = ""
	
	if total_food_available < food_required:
		growth_rate = STARVATION_PENALTY
		event_msg = "[color=red]FAMINE: Food shortage caused deaths![/color]"
		settlement.treasury["food"] = 0
	else:
		var food_consumed = food_required
		settlement.treasury["food"] -= food_consumed
		if total_food_available > (food_required * 1.5): growth_rate += FERTILITY_BONUS
		if jarl and jarl.has_trait(TRAIT_FERTILE): growth_rate += FERTILITY_BONUS
			
	var net_change = int(pop * growth_rate)
	if growth_rate > 0 and net_change == 0: net_change = 1
	settlement.population_peasants = max(0, pop + net_change)
	
	var pop_change_str = ""
	if net_change > 0: pop_change_str = "+%d Peasants" % net_change
	elif net_change < 0: pop_change_str = "%d Peasants (Died)" % net_change
	else: pop_change_str = "No population change"
	
	var msg_list: Array = payout_report["_messages"]
	if event_msg != "": msg_list.append(event_msg)
	payout_report["population_growth"] = pop_change_str
	
	var land_capacity = _calculate_total_land_capacity(settlement)
	if settlement.population_peasants > land_capacity:
		var excess_men = settlement.population_peasants - land_capacity
		var unrest_gain = excess_men * UNREST_PER_LANDLESS_PEASANT
		settlement.unrest = min(100, settlement.unrest + unrest_gain)
		msg_list.append("[color=orange]LAND HUNGER: +%d Unrest![/color]" % unrest_gain)
	elif settlement.unrest > 0:
		settlement.unrest = max(0, settlement.unrest - 5)
		msg_list.append("[color=green]Stability returns (Unrest -5)[/color]")

func _calculate_total_land_capacity(settlement: SettlementData) -> int:
	var total_cap = BASE_LAND_CAPACITY
	for entry in settlement.placed_buildings:
		var data = load(entry["resource_path"]) as BuildingData
		if data:
			total_cap += data.arable_land_capacity
	return total_cap

# --- DELEGATED FUNCTIONS ---
## Returns a snapshot of the current population state (Total vs Idle)
func get_population_census() -> Dictionary:
	var settlement = SettlementManager.current_settlement
	if not settlement: 
		return {
			"peasants": {"total": 0, "idle": 0},
			"thralls": {"total": 0, "idle": 0},
			"warbands": 0
		}
	
	# 1. Calculate Assigned Workers by iterating buildings
	var assigned_peasants = 0
	var assigned_thralls = 0
	
	for b_entry in settlement.placed_buildings:
		assigned_peasants += b_entry.get("peasant_count", 0)
		assigned_thralls += b_entry.get("thrall_count", 0)
		
	# 2. Calculate Totals
	var total_peasants = settlement.population_peasants
	var total_thralls = settlement.population_thralls
	var warband_count = settlement.warbands.size()
	
	# 3. Return Snapshot
	return {
		"peasants": {
			"total": total_peasants,
			"idle": max(0, total_peasants - assigned_peasants)
		},
		"thralls": {
			"total": total_thralls,
			"idle": max(0, total_thralls - assigned_thralls)
		},
		"warbands": warband_count
	}

## Checks if the settlement can afford the cost without deducting resources.
func can_afford(cost: Dictionary) -> bool:
	var settlement = SettlementManager.current_settlement
	if not settlement: return false
	
	for res in cost:
		var key = res.to_lower()
		if not settlement.treasury.has(key) or settlement.treasury[key] < cost[res]:
			return false
	return true

func deposit_resources(loot: Dictionary) -> void:
	var settlement = SettlementManager.current_settlement
	if not settlement: return
	
	Loggie.msg("Depositing resources: %s" % loot).domain(LogDomains.ECONOMY).info()
	
	for res in loot:
		var amount = loot[res]
		var key = res.to_lower()
		
		if key == "population" or key == "thralls":
			settlement.population_thralls += amount
		else:
			var cap = get_resource_cap(key)
			var current = settlement.treasury.get(key, 0)
			var space = cap - current
			var to_add = min(amount, max(0, space))
			
			if settlement.treasury.has(key):
				settlement.treasury[key] += to_add
			else:
				settlement.treasury[key] = to_add
			
	EventBus.treasury_updated.emit(settlement.treasury)
	# NOTE: Caller must save_settlement() if needed.

# Relaxed typing to accept generic Dictionaries from UI/Resources
func attempt_purchase(item_cost: Dictionary) -> bool:
	var settlement = SettlementManager.current_settlement
	if not settlement: return false
	
	for res in item_cost:
		var key = res.to_lower()
		if not settlement.treasury.has(key) or settlement.treasury[key] < item_cost[res]:
			EventBus.purchase_failed.emit("Insufficient %s" % res.capitalize())
			Loggie.msg("Purchase failed (Insufficient %s). Cost: %s" % [res, item_cost]).domain(LogDomains.ECONOMY).debug()
			return false
			
	for res in item_cost:
		var key = res.to_lower()
		settlement.treasury[key] -= item_cost[res]
		
	Loggie.msg("Purchase successful: %s" % item_cost).domain(LogDomains.ECONOMY).info()
	EventBus.treasury_updated.emit(settlement.treasury)
	return true

func apply_raid_damages() -> Dictionary:
	var settlement = SettlementManager.current_settlement
	if not settlement: return {}
	
	var report = { "gold_lost": 0, "wood_lost": 0, "buildings_damaged": 0, "buildings_destroyed": 0 }
	var loss_ratio = randf_range(RAID_LOSS_RATIO_MIN, RAID_LOSS_RATIO_MAX)
	
	var g_loss = int(settlement.treasury.get("gold", 0) * loss_ratio)
	settlement.treasury["gold"] -= g_loss
	report["gold_lost"] = g_loss
	
	var w_loss = int(settlement.treasury.get("wood", 0) * loss_ratio)
	settlement.treasury["wood"] -= w_loss
	report["wood_lost"] = w_loss
	
	var indices_to_remove: Array[int] = []
	for i in range(settlement.pending_construction_buildings.size()):
		var entry = settlement.pending_construction_buildings[i]
		if entry.get("progress", 0) > 0:
			var dmg = randi_range(RAID_BUILDING_DMG_MIN, RAID_BUILDING_DMG_MAX)
			entry["progress"] -= dmg
			report["buildings_damaged"] += 1
			if entry["progress"] <= 0:
				indices_to_remove.append(i)
				report["buildings_destroyed"] += 1
	
	indices_to_remove.sort()
	indices_to_remove.reverse()
	for i in indices_to_remove: settlement.pending_construction_buildings.remove_at(i)
	
	settlement.has_stability_debuff = true
	
	Loggie.msg("Raid damages applied: %s" % report).domain(LogDomains.ECONOMY).warn()
	EventBus.treasury_updated.emit(settlement.treasury)
	return report

func add_resources(resources: Dictionary) -> void:
	deposit_resources(resources)
	
# --- ALLOCATION & PROJECTION API (NEW) ---

## NEW: Authoritative Peasant Drafting (Conservation of Mass)
## NEW: Authoritative Peasant Drafting (Conservation of Mass)
## Converts Peasants -> Warbands. Handles state mutation and RaidManager integration.
func draft_peasants_to_raiders(count: int, template: UnitData) -> void:
	var settlement = SettlementManager.current_settlement
	if not settlement: return
	if count <= 0: return

	# 1. Deduct Peasants (State Mutation)
	var available = settlement.population_peasants
	var actual_draft = min(available, count)
	
	if actual_draft < count:
		Loggie.msg("EconomyManager: Draft request reduced (Req: %d, Avail: %d)" % [count, available]).domain(LogDomains.ECONOMY).warn()
	
	settlement.population_peasants -= actual_draft
	
	# 2. Create Warbands
	var new_warbands: Array[WarbandData] = []
	var remaining = actual_draft
	
	while remaining > 0:
		var batch_size = min(remaining, 10) # 10 men per band default
		
		# Calls _init(template), which sets name, max manpower, and loyalty automatically
		var bondi_band = WarbandData.new(template)
		
		# Overwrite only what differs from default (Peasant bands are rarely full strength initially)
		bondi_band.is_bondi = true
		bondi_band.current_manpower = batch_size 
		# Note: We keep the auto-generated name from _init unless you specifically want "The Bondi"
		bondi_band.custom_name = "The Bondi" 
		
		new_warbands.append(bondi_band)
		remaining -= batch_size
		
	if RaidManager:
		RaidManager.outbound_raid_force.append_array(new_warbands)
		
	Loggie.msg("EconomyManager: Drafted %d Peasants into %d Warbands" % [actual_draft, new_warbands.size()]).domain(LogDomains.ECONOMY).info()
	EventBus.population_changed.emit()

## NEW: Authoritative Yield Projection
## Returns estimated output based on a theoretical distribution of labor
func calculate_hypothetical_yields(farmer_count: int) -> Dictionary:
	var settlement = SettlementManager.current_settlement
	if not settlement: return {}
	
	var yields = {}
	var remaining_farmers = farmer_count
	var placed = settlement.placed_buildings
	
	# Sort buildings to prioritize Food (Logic moved from UI)
	var food_buildings = []
	var other_buildings = []
	
	for entry in placed:
		if "resource_path" in entry:
			var b_data = load(entry["resource_path"])
			if b_data is EconomicBuildingData:
				var item = {"data": b_data, "cap": b_data.peasant_capacity}
				if b_data.resource_type == GameResources.FOOD:
					food_buildings.append(item)
				else:
					other_buildings.append(item)
	
	# Calculate Output
	var total_assigned = 0
	
	# 1. Fill Food First
	for item in food_buildings:
		if remaining_farmers <= 0: break
		var assign = min(remaining_farmers, item.cap)
		var out = assign * item.data.base_passive_output
		
		var type = item.data.resource_type
		yields[type] = yields.get(type, 0) + out
		remaining_farmers -= assign
		total_assigned += assign
		
	# 2. Fill Others
	for item in other_buildings:
		if remaining_farmers <= 0: break
		var assign = min(remaining_farmers, item.cap)
		var out = assign * item.data.base_passive_output
		var type = item.data.resource_type
		yields[type] = yields.get(type, 0) + out
		remaining_farmers -= assign
		total_assigned += assign
		
	return yields
	
	
# ... [Previous Phase 2 Code] ...

# --- RAID OUTCOME API (NEW) ---

## NEW: Centralized Raid Return Logic
## Handles Wergild, XP, Disbanding, Jarl Stats, and Treasury updates.
## Returns a 'Receipt' dictionary for the UI to display.
func process_raid_return(result: RaidResultData) -> Dictionary:
	var settlement = SettlementManager.current_settlement
	if not settlement: return {}

	var outcome = result.outcome
	var grade = result.victory_grade
	
	# 1. Calculate Wergild (Death Taxes)
	var raw_gold = result.loot.get(GameResources.GOLD, 0)
	var total_wergild = 0
	var dead_count = 0
	
	for u_data in result.casualties:
		if u_data:
			total_wergild += u_data.wergild_cost
			dead_count += 1
			
	var net_gold = max(0, raw_gold - total_wergild)
	
	# 2. Handle Disbanding (Bondi return to fields) & XP
	var xp_gain = _calculate_raid_xp(outcome, grade)
	var warbands_to_remove: Array[WarbandData] = []
	
	for warband in settlement.warbands:
		# Disbanding Logic
		if warband.is_bondi or warband.is_seasonal:
			if warband.is_bondi and warband.current_manpower > 0:
				settlement.population_peasants += warband.current_manpower
			
			warbands_to_remove.append(warband)
			
		# XP Logic (Only for survivors)
		if not warband.is_wounded and xp_gain > 0:
			warband.experience += xp_gain
			
	# Apply Removals
	for wb in warbands_to_remove:
		settlement.warbands.erase(wb)
		
	Loggie.msg("EconomyManager: Disbanded %d seasonal warbands." % warbands_to_remove.size()).domain(LogDomains.ECONOMY).info()
	EventBus.population_changed.emit() # Notify UI that peasants returned
	
	# 3. Calculate Final Loot & Bonuses
	var final_report = result.loot.duplicate()
	
	# Victory Bonus Logic
	if outcome == "victory":
		var difficulty = 1 # Default
		if RaidManager: difficulty = RaidManager.current_raid_difficulty
		
		var bonus = 200 + (difficulty * 50)
		if grade == "Decisive": bonus += 100
		
		net_gold += bonus
		
		# Thrall Logic (Preserving logic: "population" key used in loot summary)
		if not final_report.has("population") and not final_report.has(GameResources.POP_THRALL):
			 # Logic from snippet: randi_range(2, 4) * difficulty
			var thralls = randi_range(2, 4) * difficulty
			final_report["population"] = thralls # Using string literal to match UI expectation
			 
		_update_jarl_stats(grade)
		
	final_report[GameResources.GOLD] = net_gold
	if result.renown_earned != 0:
		final_report["renown"] = result.renown_earned
		
	# 4. Apply to Treasury (State Mutation)
	deposit_resources(final_report)
	
	# 5. Return Receipt for UI
	return {
		"outcome": outcome,
		"grade": grade,
		"net_gold": net_gold,
		"wergild_paid": total_wergild,
		"dead_count": dead_count,
		"loot_summary": final_report
	}

func _calculate_raid_xp(outcome: String, grade: String) -> int:
	var xp = 0
	if outcome == "victory": 
		xp = 50
		if grade == "Decisive": xp = 75
		elif grade == "Pyrrhic": xp = 25
	elif outcome == "retreat": 
		xp = 20
		
	var xp_bonus = DynastyManager.active_year_stats.get("mod_raid_xp", 0.0)
	xp = int(xp * (1.0 + xp_bonus))
		
	return xp

func _update_jarl_stats(grade: String) -> void:
	var jarl = DynastyManager.get_current_jarl()
	if jarl:
		jarl.offensive_wins += 1
		jarl.battles_won += 1
		jarl.successful_raids += 1
		if jarl.has_trait("Warlord") and grade == "Decisive":
			jarl.current_authority += 1
		DynastyManager.jarl_stats_updated.emit(jarl)
		
# --- CONSTRUCTION API (NEW) ---

## NEW: Authoritative Construction Progress
## Iterates all pending buildings, applies worker progress, and returns a list of 
## building entries that have completed construction this turn.
func advance_construction_progress() -> Array[Dictionary]:
	var settlement = SettlementManager.current_settlement
	if not settlement: return []
	
	var completed_buildings: Array[Dictionary] = []
	var indices_to_remove: Array[int] = []
	
	# Iterate backwards to safely track removals if needed, 
	# though we usually remove after the loop.
	for i in range(settlement.pending_construction_buildings.size()):
		var entry = settlement.pending_construction_buildings[i]
		
		# 1. Get Workers
		var workers = entry.get("peasant_count", 0)
		if workers <= 0: continue
		
		# 2. Load Data for Requirements
		var b_path = entry.get("resource_path", "")
		if b_path == "": continue
		
		var b_data = load(b_path) as BuildingData
		if not b_data: continue
		
		var effort_required = 100 # Default fallback
		if "construction_effort_required" in b_data:
			effort_required = b_data.construction_effort_required
			
		# 3. Apply Progress (Math Source of Truth)
		var progress_gain = workers * BUILDER_EFFICIENCY
		var current_progress = entry.get("progress", 0)
		var new_progress = current_progress + progress_gain
		
		entry["progress"] = new_progress
		
		# 4. Check Completion
		if new_progress >= effort_required:
			completed_buildings.append(entry)
			indices_to_remove.append(i)
	
	# Clean up pending list (State Mutation)
	# Sort descending to remove from end first to preserve indices
	indices_to_remove.sort()
	indices_to_remove.reverse()
	
	for i in indices_to_remove:
		settlement.pending_construction_buildings.remove_at(i)
		
	if not completed_buildings.is_empty():
		Loggie.msg("EconomyManager: %d buildings completed construction." % completed_buildings.size()).domain(LogDomains.ECONOMY).info()
		
	return completed_buildings


--------------------------------------------------
FILE: res:///autoload/EventBus.gd
--------------------------------------------------
# res://autoload/EventBus.gd
extends Node

# --- Build System Signals ---
signal building_right_clicked(building: Node2D)
signal building_state_changed(building: BaseBuilding, new_state: int)
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)
signal building_ready_for_placement(building_data: BuildingData)
signal building_placement_cancelled(building_data: BuildingData)
signal building_construction_completed(building_entry: Dictionary)
# --- Inspector Signals ---
signal building_selected(building: BaseBuilding)
signal building_deselected()
signal request_worker_assignment(target_building: BaseBuilding)
signal request_worker_removal(target_building: BaseBuilding)
signal floating_text_requested(text: String, world_position: Vector2, color: Color)

# --- Pathfinding Signals ---
signal pathfinding_grid_updated(grid_position: Vector2i)

# --- Treasury & Economy Signals ---
signal treasury_updated(new_treasury: Dictionary)
signal purchase_successful(item_name: String)
signal purchase_failed(reason: String)
signal raid_loot_secured(type: String, amount: int)
signal population_changed()
# --- Navigation Signals ---
signal scene_change_requested(scene_key: String)
signal world_map_opened()
signal raid_mission_started(target_type: String)

# --- Settlement Management Signals ---
signal settlement_loaded(settlement_data: SettlementData)

# --- Unit Management Signals ---
signal player_unit_died(unit: Node2D)
signal player_unit_spawned(unit: Node2D)
signal worker_management_toggled()
signal dynasty_view_requested()

# --- RTS Command Signals ---
signal select_command(select_rect: Rect2, is_box_select: bool)
signal units_selected(units: Array) 
signal move_command(target_position: Vector2)
signal attack_command(target_node: Node2D)
signal formation_move_command(target_position: Vector2, direction_vector: Vector2)
signal interact_command(target: Node2D)
signal pillage_command(target_node: Node2D)

# --- Keyboard Commands ---
signal control_group_command(group_index: int, is_assigning: bool)
signal formation_change_command(formation_type: int)

# --- Event System ---
signal event_system_finished()
signal succession_choices_made(renown_choice: String, gold_choice: String)

# --- Camera Control ---
signal camera_input_lock_requested(is_locked: bool)

# --- Game Loop & Time Signals ---
signal end_year_requested() # Legacy (Keep for now to avoid crashes)
signal advance_season_requested() # NEW: The primary time driver
signal season_changed(season_name: String) # NEW: Feedback for UI/World

# --- NEW: Seasonal UI System Signals ---
signal hall_action_updated
## Emitted when the UI selects a card but hasn't committed (for tooltips/previews).
signal seasonal_card_hovered(card: SeasonalCardResource)

## Emitted when the Player clicks a card in Spring/Winter UI.
## The System listening (SpringCouncil or WinterManager) will decide if it's valid.
signal seasonal_card_selected(card: SeasonalCardResource)

## Emitted when the UI requests to end the current phase (e.g. "Lock Autumn Accounts").
## Payload contains any data needed for the transition.
signal ui_request_phase_commit(phase_name: String, data: Dictionary)

## Emitted by Managers when the specific Seasonal UI needs to open.
## Example: DynastyManager emits this when Spring starts.
signal ui_open_seasonal_screen(screen_type: String) # "spring", "summer", "autumn", "winter"
## Emitted when a Raid is fully committed from the Summer UI.
signal raid_launched(target_region: Resource, force_size: int)
## Emitted when Autumn accounting is finalized.
signal autumn_resolved()
## Emitted when Winter ends and the year rolls over.
signal winter_ended()
signal raid_committed(count: int)


--------------------------------------------------
FILE: res:///autoload/EventManager.gd
--------------------------------------------------
# res://autoload/EventManager.gd
extends Node

@export var event_ui_scene: PackedScene
@export var succession_crisis_scene: PackedScene

var event_ui: EventUI
var available_events: Array[EventData] = []
# CHANGE: Added specific storage for disputes as they are a distinct Resource type from EventData
var available_disputes: Array[DisputeEventData] = []
var fired_unique_events: Array[String] = []

const TRAIT_RIVAL = preload("res://data/traits/Trait_Rival.tres")

func _ready() -> void:
	call_deferred("initialize_event_system")

func initialize_event_system() -> void:
	if not event_ui_scene:
		Loggie.msg("'event_ui_scene' is not set!").domain("EVENT").error()
		return
	
	event_ui = event_ui_scene.instantiate()
	add_child(event_ui)
	event_ui.choice_made.connect(_on_choice_made)
	
	_load_events_from_disk()
	
	if DynastyManager:
		DynastyManager.year_ended.connect(_on_year_ended)
	else:
		Loggie.msg("DynastyManager Autoload not found!").domain("EVENT").error()

func _load_events_from_disk() -> void:
	available_events.clear()
	available_disputes.clear() # CHANGE: Clear dispute list on reload
	var dir = DirAccess.open("res://data/events/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var path = "res://data/events/" + file_name
				# CHANGE: Load as generic Resource first to check type, solving the casting error
				var resource = load(path)
				if resource is EventData:
					available_events.append(resource)
				elif resource is DisputeEventData:
					available_disputes.append(resource)
				else:
					Loggie.msg("Loaded resource is neither EventData nor DisputeEventData: %s" % path).domain("EVENT").warn()
			file_name = dir.get_next()
	# CHANGE: Updated log to reflect both types
	Loggie.msg("Loaded %d events and %d disputes from disk." % [available_events.size(), available_disputes.size()]).domain("EVENT").info()

func _on_year_ended() -> void:
	Loggie.msg("Checking event triggers for end of year...").domain("EVENT").info()
	var event_was_triggered: bool = _check_event_triggers()
	if not event_was_triggered:
		EventBus.event_system_finished.emit()

func _check_event_triggers() -> bool:
	var jarl = DynastyManager.get_current_jarl()
	if not jarl:
		Loggie.msg("Cannot check events, Jarl data is null.").domain("EVENT").error()
		return false

	for event in available_events:
		if _check_conditions(event, jarl):
			_trigger_event(event)
			return true 
	return false

func _check_conditions(event: EventData, jarl: JarlData) -> bool:
	if event.is_unique and event.event_id in fired_unique_events: return false
	for pre_id in event.prerequisites:
		if not pre_id in fired_unique_events: return false 
	
	if event.min_renown > -1 and jarl.renown < event.min_renown: return false
	if event.min_stewardship > -1 and jarl.get_effective_skill("stewardship") < event.min_stewardship: return false
	if not event.must_have_trait.is_empty() and not jarl.has_trait(event.must_have_trait): return false
	if not event.must_not_have_trait.is_empty() and jarl.has_trait(event.must_not_have_trait): return false
	if event.min_available_heirs > -1 and jarl.get_available_heir_count() < event.min_available_heirs: return false
	if event.min_conquered_regions > -1 and jarl.conquered_regions.size() < event.min_conquered_regions: return false
	if randf() > event.base_chance: return false
	
	Loggie.msg("Conditions MET for event '%s'" % event.event_id).domain("EVENT").info()
	return true

func _trigger_event(event_data: EventData) -> void:
	# Implementation depends on your existing EventManager, 
	# assuming it emits a signal or opens a UI.
	# For this refactor, we just ensure this file exists and works.
	Loggie.msg("Event Triggered: %s" % event_data.event_id).domain("EVENT").info()
	# Example: EventBus.event_triggered.emit(event_data)

## Returns a list of disputes available for the current winter.
func get_available_disputes() -> Array[DisputeEventData]:
	# CHANGE: Return the distinct array populated during load
	if available_disputes.is_empty():
		return [draw_dispute_card()]
	return available_disputes

func draw_dispute_card() -> DisputeEventData:
	var card = DisputeEventData.new()
	card.title = "Stolen Cattle"
	card.description = "A Bondi accuses a Huscarl of theft."
	card.gold_cost = 50
	card.renown_cost = 10
	card.penalty_modifier_key = "angry_bondi"
	card.penalty_description = "Recruitment halted."
	return card

func _on_choice_made(event: EventData, choice: EventChoice) -> void:
	if choice:
		Loggie.msg("Player chose '%s' (%s) for event '%s'" % [choice.choice_text, choice.effect_key, event.event_id]).domain("EVENT").info()
		_apply_event_consequences(event, choice)
	else:
		Loggie.msg("Event '%s' closed with no choice." % event.event_id).domain("EVENT").info()
		
	get_tree().paused = false
	EventBus.event_system_finished.emit()

func _apply_event_consequences(event: EventData, choice: EventChoice) -> void:
	if event.event_id == "ambitious_heir_1":
		if choice.effect_key == "accept":
			if not DynastyManager.spend_renown(100):
				Loggie.msg("Tried to spend 100 Renown for event, but failed.").domain("EVENT").warn()
		elif choice.effect_key == "decline":
			var heir = DynastyManager.get_current_jarl().get_first_available_heir()
			if heir and TRAIT_RIVAL:
				DynastyManager.add_trait_to_heir(heir, TRAIT_RIVAL)
			else:
				Loggie.msg("Could not apply 'Rival' trait.").domain("EVENT").warn()


--------------------------------------------------
FILE: res:///autoload/EventManager.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://cq2g5hvpthjwi"]

[ext_resource type="Script" uid="uid://c2t14tumhq5xl" path="res://autoload/EventManager.gd" id="1_vx76l"]
[ext_resource type="PackedScene" uid="uid://ih62qkde7dru" path="res://ui/Event_UI.tscn" id="2_qahc7"]
[ext_resource type="PackedScene" uid="uid://c4itkcu7ufe5j" path="res://ui/Succession_Crisis_UI.tscn" id="3_qahc7"]

[node name="EventManager" type="Node"]
script = ExtResource("1_vx76l")
event_ui_scene = ExtResource("2_qahc7")
succession_crisis_scene = ExtResource("3_qahc7")


--------------------------------------------------
FILE: res:///autoload/LogDomains.gd
--------------------------------------------------
# res://autoload/LogDomains.gd
class_name LogDomains

# Core Systems
const DYNASTY = "DYNASTY"
const SETTLEMENT = "SETTLEMENT"
const ECONOMY = "ECONOMY"
const EVENT = "EVENT"
const SCENE = "SCENE"

# RTS / Combat
const RTS = "RTS"
const UNIT = "UNIT"
const AI = "AI"
const RAID = "RAID"

# World & Map
const MAP = "MAP"
const NAVIGATION = "NAVIGATION"

# Interface
const UI = "UI"

# Technical
const SYSTEM = "SYSTEM"
const BUILD = "BUILD"
const GAMEPLAY = "GAMEPLAY"


--------------------------------------------------
FILE: res:///autoload/NavigationManager.gd
--------------------------------------------------
extends Node

## Singleton handling AStarGrid2D pathfinding and Coordinate Conversions.
## Accessed via NavigationManager.function()

signal navigation_grid_ready

# --- Configuration ---
const TILE_WIDTH = 64
const TILE_HEIGHT = 32
const TILE_HALF_SIZE = Vector2(32, 16)
# CRITICAL: Match TileMap layout. Standard Isometric usually needs DIAGONAL_MODE_ALWAYS.
const DIAGONAL_MODE = AStarGrid2D.DIAGONAL_MODE_ALWAYS 
const HEURISTIC = AStarGrid2D.HEURISTIC_EUCLIDEAN

# --- Tuning ---
const SMOOTHING_CHECK_RADIUS: float = 24.0 
const WALL_NUDGE_AMOUNT: float = 14.0 

# --- State ---
var active_astar_grid: AStarGrid2D
var active_tilemap_layer: TileMapLayer
var _grid_rect: Rect2i

func _ready() -> void:
	Loggie.msg("NavigationManager Initialized").domain(LogDomains.SYSTEM).info()
	# Pre-allocate generic grid, though it will be overwritten by initialize/register
	_setup_base_grid()

func _setup_base_grid() -> void:
	active_astar_grid = AStarGrid2D.new()
	active_astar_grid.cell_shape = AStarGrid2D.CELL_SHAPE_ISOMETRIC_DOWN
	active_astar_grid.default_compute_heuristic = HEURISTIC
	active_astar_grid.default_estimate_heuristic = HEURISTIC
	active_astar_grid.diagonal_mode = DIAGONAL_MODE
	active_astar_grid.cell_size = Vector2(TILE_WIDTH, TILE_HEIGHT)

# --- MAP REGISTRATION (Legacy Support + New API) ---

## Legacy compatibility for LevelBase.gd
func initialize_grid_from_tilemap(tilemap: TileMapLayer, map_size: Vector2i, tile_shape: Vector2i) -> void:
	# Forward to the robust registration logic
	# We interpret map_size as the region size starting from 0,0
	var manual_rect = Rect2i(0, 0, map_size.x, map_size.y)
	register_map(tilemap, manual_rect)

## Robust registration
func register_map(map_layer: TileMapLayer, manual_rect: Rect2i = Rect2i()) -> void:
	active_tilemap_layer = map_layer
	
	# Determine bounds: Use manual if provided, otherwise detect from map
	var used_rect = manual_rect
	if used_rect == Rect2i():
		used_rect = map_layer.get_used_rect()
		# Add padding to allow moving slightly off-map if needed
		used_rect = used_rect.grow(2)
	
	_grid_rect = used_rect
	
	# Re-init grid with specific region
	_setup_base_grid()
	active_astar_grid.region = used_rect
	active_astar_grid.update()
	
	# Sync Obstacles (Solid tiles)
	_sync_solids_from_map(map_layer)
	
	# FIX: formatting context into string instead of using .ctx()
	Loggie.msg("Navigation Grid Registered: Rect=%s, CellSize=%s" % [used_rect, active_astar_grid.cell_size]).domain(LogDomains.GAMEPLAY).info()
	
	emit_signal("navigation_grid_ready")

func _sync_solids_from_map(map: TileMapLayer) -> void:
	var rect = active_astar_grid.region
	for x in range(rect.position.x, rect.end.x):
		for y in range(rect.position.y, rect.end.y):
			var coords = Vector2i(x, y)
			var tile_data = map.get_cell_tile_data(coords)
			if tile_data:
				# Custom Data "is_unwalkable" (Negative Logic)
				var is_unwalkable = tile_data.get_custom_data("is_unwalkable")
				if is_unwalkable:
					active_astar_grid.set_point_solid(coords, true)
			else:
				# Void tiles (no visual) are usually solid in isometric games
				# unless strictly using a background layer.
				# Uncomment the line below if "empty space" = "cliff/void"
				active_astar_grid.set_point_solid(coords, true)
				pass

func unregister_grid() -> void:
	active_astar_grid = null
	active_tilemap_layer = null

# --- PATHFINDING ---

## Returns a world-space path from Start to End.
func get_astar_path(start_world: Vector2, end_world: Vector2, allow_partial: bool = true) -> PackedVector2Array:
	if not active_astar_grid:
		Loggie.msg("Path requested but Grid not ready").domain(LogDomains.GAMEPLAY).warn()
		return PackedVector2Array()

	var start_grid = _world_to_grid(start_world)
	var end_grid = _world_to_grid(end_world)

	# Boundary check
	if not active_astar_grid.is_in_boundsv(start_grid) or not active_astar_grid.is_in_boundsv(end_grid):
		# Optional: Clamp end grid to bounds if user clicked outside
		# end_grid.x = clampi(end_grid.x, _grid_rect.position.x, _grid_rect.end.x - 1)
		# end_grid.y = clampi(end_grid.y, _grid_rect.position.y, _grid_rect.end.y - 1)
		# For now, return empty if out of bounds to be safe
		# FIX: formatting context into string instead of using .ctx()
		Loggie.msg("Path request out of bounds: Start%s End%s" % [start_grid, end_grid]).domain(LogDomains.GAMEPLAY).debug()
		return PackedVector2Array()

	# Get ID path (Grid Coords) first to verify connectivity
	var path = active_astar_grid.get_point_path(start_grid, end_grid, allow_partial)
	
	if path.size() > 0:
		# Fix start point to be exact actor position, not tile center
		path[0] = start_world
		
		# Pruning: If the first point (center of current tile) is "behind" us or extremely close
		if path.size() > 1 and start_world.distance_to(path[1]) < start_world.distance_to(path[0]):
			# We are closer to point 1 than point 0 (backtracking), so skip 0
			path.remove_at(0)
	
	# Apply Post-Processing
	var smoothed = _smooth_path(path)
	var nudged = _apply_wall_nudging(smoothed)
	
	return nudged

# --- COORDINATE MATH (ISOMETRIC) ---

## Converts World Position (Pixels) to Grid Coordinate (Vector2i)
func _world_to_grid(pos: Vector2) -> Vector2i:
	# Prefer TileMap Logic if available (Source of Truth)
	if is_instance_valid(active_tilemap_layer):
		var local = active_tilemap_layer.to_local(pos)
		return active_tilemap_layer.local_to_map(local)

	# Fallback Math (Standard Isometric Down)
	var x_part = pos.x / TILE_HALF_SIZE.x
	var y_part = pos.y / TILE_HALF_SIZE.y
	
	var grid_x = floor((x_part + y_part) * 0.5)
	var grid_y = floor((y_part - x_part) * 0.5)
	
	return Vector2i(grid_x, grid_y)

## Converts Grid Coordinate to World Position (Top-Left of tile usually)
func _grid_to_world(grid: Vector2i) -> Vector2:
	# Prefer TileMap Logic
	if is_instance_valid(active_tilemap_layer):
		var local = active_tilemap_layer.map_to_local(grid)
		return active_tilemap_layer.to_global(local)

	# Fallback Math
	var x = (grid.x - grid.y) * TILE_HALF_SIZE.x
	var y = (grid.x + grid.y) * TILE_HALF_SIZE.y
	return Vector2(x, y)

# --- SPATIAL QUERY ---

func request_valid_spawn_point(target_world_pos: Vector2, max_radius: int = 5) -> Vector2:
	var start_cell = _world_to_grid(target_world_pos)
	
	if not is_point_solid(start_cell):
		return target_world_pos
		
	for r in range(1, max_radius + 1):
		for x in range(-r, r + 1):
			for y in range(-r, r + 1):
				var check = start_cell + Vector2i(x, y)
				if _is_cell_within_bounds(check) and not is_point_solid(check):
					# Return CENTER of the valid tile
					return snap_to_grid_center(_grid_to_world(check))
					
	return Vector2.INF

# --- HELPERS & POST-PROCESSING ---

func is_point_solid(grid_pos: Vector2i) -> bool:
	if not active_astar_grid: return false
	if not active_astar_grid.is_in_boundsv(grid_pos): return true
	return active_astar_grid.is_point_solid(grid_pos)

func set_point_solid(grid_pos: Vector2i, is_solid: bool) -> void:
	if not active_astar_grid: return
	if active_astar_grid.is_in_boundsv(grid_pos):
		active_astar_grid.set_point_solid(grid_pos, is_solid)

func snap_to_grid_center(world_pos: Vector2) -> Vector2:
	var grid = _world_to_grid(world_pos)
	var top_left = _grid_to_world(grid)
	# Add half-height offset to hit visual center of the diamond
	return top_left + Vector2(0, TILE_HALF_SIZE.y) # Removed vertical offset for consistency with TileMap logic

func _is_cell_within_bounds(grid_pos: Vector2i) -> bool:
	if not is_instance_valid(active_astar_grid): return false
	return active_astar_grid.region.has_point(grid_pos)

func _is_point_solid_world(world_pos: Vector2) -> bool:
	var cell = _world_to_grid(world_pos)
	if not _is_cell_within_bounds(cell): return true 
	return active_astar_grid.is_point_solid(cell)

func _smooth_path(path: PackedVector2Array) -> PackedVector2Array:
	if path.size() <= 2: return path
	var smoothed: PackedVector2Array = []
	smoothed.append(path[0])
	var current_idx = 0
	
	while current_idx < path.size() - 1:
		var lookahead_limit = min(path.size() - 1, current_idx + 18)
		var check_idx = lookahead_limit
		var found_shortcut = false
		
		while check_idx > current_idx + 1:
			if _has_thick_line_of_sight(path[current_idx], path[check_idx], SMOOTHING_CHECK_RADIUS):
				current_idx = check_idx
				smoothed.append(path[current_idx])
				found_shortcut = true
				break
			check_idx -= 1
			
		if not found_shortcut:
			current_idx += 1
			smoothed.append(path[current_idx])
			
	return smoothed

func _has_thick_line_of_sight(from: Vector2, to: Vector2, radius: float) -> bool:
	if not is_instance_valid(active_astar_grid): return false
	var cell_size = active_astar_grid.cell_size
	var dist = from.distance_to(to)
	if dist < 1.0: return true
	
	var step_size = min(cell_size.x, cell_size.y) / 2.0 
	var steps = ceil(dist / step_size)
	var direction = (to - from).normalized()
	
	# Check perpendicular vectors for thickness
	var side_vector = Vector2(-direction.y, direction.x) * radius
	
	for i in range(1, int(steps)):
		var center_pos = from + (direction * (i * step_size))
		if _is_point_solid_world(center_pos): return false
		if _is_point_solid_world(center_pos + side_vector): return false
		if _is_point_solid_world(center_pos - side_vector): return false
		
	return true

func _apply_wall_nudging(path: PackedVector2Array) -> PackedVector2Array:
	if path.size() <= 2: return path
	var nudged_path = path.duplicate()
	
	for i in range(1, path.size() - 1):
		var point = path[i]
		var grid_pos = _world_to_grid(point)
		var repulsion = Vector2.ZERO
		
		for x in range(-1, 2):
			for y in range(-1, 2):
				if x == 0 and y == 0: continue
				var neighbor_cell = grid_pos + Vector2i(x, y)
				if is_point_solid(neighbor_cell):
					# Push away from solid wall
					var push_dir = -Vector2(x, y).normalized() 
					# Note: In iso, normalized vector might feel skewed, but sufficient for nudge
					repulsion += push_dir
					
		if repulsion != Vector2.ZERO:
			nudged_path[i] += repulsion.normalized() * WALL_NUDGE_AMOUNT
			
	return nudged_path


--------------------------------------------------
FILE: res:///autoload/PauseManager.gd
--------------------------------------------------
# res://autoload/PauseManager.gd
#
# This is a global autoload script that listens for the 'ui_pause'
# input to pause the game.
# It is only responsible for *pausing* and instancing the menu.
# The menu itself is responsible for unpausing.

extends Node

# We will assign this scene in the Project Settings Autoload menu
@export var pause_menu_scene: PackedScene

func _ready() -> void:
	Loggie.info("PauseManager initialized", "PauseManager")
	if pause_menu_scene:
		Loggie.debug("Pause menu scene loaded: %s" % pause_menu_scene.resource_path, "PauseManager")
	else:
		Loggie.warn("Pause menu scene not assigned in PauseManager", "PauseManager")

func _unhandled_input(event: InputEvent) -> void:
	# We only listen for the pause input
	# We only pause if the game is NOT already paused
	if event.is_action_pressed("ui_pause"):
		Loggie.debug("Pause input detected (ui_pause pressed)", "PauseManager")
		
		var current_pause_state := get_tree().paused
		Loggie.debug("Current pause state: %s" % ("PAUSED" if current_pause_state else "UNPAUSED"), "PauseManager")
		
		if not current_pause_state:
			Loggie.info("Attempting to pause game", "PauseManager")
			_pause_game()
		else:
			Loggie.debug("Game already paused - ignoring pause input", "PauseManager")
	
func _pause_game() -> void:
	if not pause_menu_scene:
		var error_msg := "PauseManager: 'pause_menu_scene' is not set in Project Settings!"
		Loggie.error(error_msg, "PauseManager")
		push_error(error_msg)
		return
	
	Loggie.debug("Pause menu scene validated: %s" % pause_menu_scene.resource_path, "PauseManager")
	
	# Consume the event so nothing else (like the menu) can use it
	get_viewport().set_input_as_handled()
	Loggie.debug("Input event consumed to prevent propagation", "PauseManager")
	
	# Pause the game
	get_tree().paused = true
	Loggie.info("Game paused - SceneTree.paused = true", "PauseManager")
	
	# Create the menu
	Loggie.debug("Instantiating pause menu from scene", "PauseManager")
	var menu := pause_menu_scene.instantiate()
	
	if menu:
		get_tree().root.add_child(menu)
		Loggie.info("Pause menu instantiated and added to scene tree", "PauseManager")
		Loggie.debug("Pause menu node name: %s, type: %s" % [menu.name, menu.get_class()], "PauseManager")
		
		# Log the current children count for debugging
		var root_children := get_tree().root.get_children()
		Loggie.debug("Root node now has %d children" % root_children.size(), "PauseManager")
	else:
		Loggie.error("Failed to instantiate pause menu scene", "PauseManager")

# Public method for external pause requests (e.g., from other systems)
func request_pause() -> void:
	Loggie.info("External pause request received", "PauseManager")
	if not get_tree().paused:
		_pause_game()
	else:
		Loggie.warn("External pause request ignored - game already paused", "PauseManager")

# Public method to check pause state
func is_game_paused() -> bool:
	var paused := get_tree().paused
	Loggie.debug("Pause state query: %s" % ("PAUSED" if paused else "UNPAUSED"), "PauseManager")
	return paused

# Called when pause menu unpauses the game
func on_game_unpaused() -> void:
	Loggie.info("Game unpaused notification received", "PauseManager")
	if get_tree().paused:
		Loggie.warn("Game reported as unpaused but SceneTree.paused is still true", "PauseManager")
	else:
		Loggie.debug("Game successfully unpaused - SceneTree.paused = false", "PauseManager")


--------------------------------------------------
FILE: res:///autoload/PauseManager.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://3uwnyn7rs2lw"]

[ext_resource type="Script" uid="uid://c5dtgqsq0pax" path="res://autoload/PauseManager.gd" id="1_pdom1"]
[ext_resource type="PackedScene" uid="uid://bchdch4f1tcym" path="res://scripts/ui/PauseMenu.tscn" id="2_f5juk"]

[node name="PauseManager" type="Node"]
script = ExtResource("1_pdom1")
pause_menu_scene = ExtResource("2_f5juk")


--------------------------------------------------
FILE: res:///autoload/ProjectilePoolManager.gd
--------------------------------------------------
# res://autoload/ProjectilePoolManager.gd
#
# Manages an object pool of projectiles to avoid the performance
# cost of instantiating and freeing them during gameplay.

extends Node

# Set this to the scene your game uses for projectiles.
@export var projectile_scene: PackedScene = preload("res://scenes/effects/Projectile.tscn")
@export var initial_pool_size: int = 50

# This array holds the projectiles that are "on the shelf" and ready to be used.
var available_projectiles: Array[Projectile] = []

# This node just holds all projectiles so they exist in the scene tree.
var projectile_container: Node

func _ready() -> void:
	projectile_container = Node.new()
	projectile_container.name = "ProjectileContainer"
	add_child(projectile_container)
	
	# Pre-load the pool with an initial batch of projectiles
	for i in range(initial_pool_size):
		var p = projectile_scene.instantiate() as Projectile
		projectile_container.add_child(p)
		p.return_to_pool() # Deactivate it and move it off-screen
		available_projectiles.append(p)
	
	Loggie.msg("ProjectilePoolManager: Initialized with %d projectiles." % initial_pool_size).domain("RTS").info()

func get_projectile() -> Projectile:
	"""
	Retrieves an available projectile from the pool.
	If the pool is empty, it creates a new one.
	"""
	if not available_projectiles.is_empty():
		# Get a projectile from the "shelf"
		return available_projectiles.pop_front()
	else:
		# The "shelf" is empty. This isn't ideal, but we can
		# create a new one on-the-fly to prevent errors.
		push_warning("ProjectilePoolManager: Pool depleted! Creating a new projectile.")
		var p = projectile_scene.instantiate() as Projectile
		projectile_container.add_child(p)
		return p

func return_projectile(projectile: Projectile) -> void:
	"""
	Returns a projectile to the pool, making it available again.
	"""
	projectile.return_to_pool()
	available_projectiles.append(projectile)


--------------------------------------------------
FILE: res:///autoload/RaidManager.gd
--------------------------------------------------
extends Node

# Signal emitted when a raid calculation completes or state changes
signal raid_state_updated

# --- DATA ---
var current_raid_target: SettlementData
var is_defensive_raid: bool = false
var current_raid_difficulty: int = 1
var pending_raid_result: RaidResultData = null

# --- STAGING & LOGISTICS ---
var outbound_raid_force: Array[WarbandData] = []
var raid_provisions_level: int = 1
var raid_health_modifier: float = 1.0

# "neutral", "victory", "defeat"
var last_raid_outcome: String = "neutral"

func reset_raid_state() -> void:
	outbound_raid_force.clear()
	raid_provisions_level = 1
	raid_health_modifier = 1.0
	current_raid_target = null
	pending_raid_result = null
	is_defensive_raid = false
	raid_state_updated.emit()

func prepare_raid_force(warbands: Array[WarbandData], provisions: int) -> void:
	if warbands.is_empty():
		Loggie.msg("RaidManager: Warning - Raid force prepared with 0 units.").domain("RAID").warn()
	
	outbound_raid_force = warbands.duplicate()
	raid_provisions_level = provisions
	
	Loggie.msg("Raid Force Prepared: %d Warbands, Provision Level %d" % [outbound_raid_force.size(), provisions]).domain("RAID").info()
	raid_state_updated.emit()

func set_current_raid_target(data: SettlementData) -> void:
	current_raid_target = data

func get_current_raid_target() -> SettlementData:
	var target = current_raid_target
	# We generally don't clear it immediately on get, keeping state stable until reset_raid_state()
	return target

# --- CORE LOGIC: MIGRATED FROM DYNASTYMANAGER ---

func calculate_journey_attrition(target_distance: float) -> Dictionary:
	# Runtime Dependency Check
	if not DynastyManager.current_jarl:
		Loggie.msg("RaidManager: Cannot calculate attrition, no Current Jarl.").domain("RAID").error()
		return {}
		
	if target_distance < 0: target_distance = 0.0
	
	var jarl = DynastyManager.current_jarl
	var safe_range = jarl.get_safe_range()
	
	var report = {
		"title": "Uneventful Journey",
		"description": "The seas were calm. The fleet arrived intact.",
		"modifier": 1.0
	}
	
	var base_risk = 0.02
	if target_distance > safe_range:
		# Calculate risk based on Jarl's attrition stats
		base_risk = ((target_distance - safe_range) / 100.0) * jarl.attrition_per_100px
	
	if raid_provisions_level == 2:
		base_risk -= 0.15 
		
	base_risk = clampf(base_risk, 0.05, 0.90) 
	
	var roll = randf()
	
	if roll < base_risk:
		report["title"] = "Rough Seas"
		var damage = 0.10 
		
		if roll < (base_risk * 0.5):
			damage = 0.25 
			report["description"] = "A terrible storm scattered the fleet! Supplies were lost and men are exhausted."
		else:
			report["description"] = "High waves and poor winds delayed the crossing. The men are seasick and tired."
			
		if raid_provisions_level == 2:
			damage *= 0.5 
			report["description"] += "\n(Well-Fed: Damage Reduced)"
			
		report["modifier"] = 1.0 - damage
		raid_health_modifier = report["modifier"]
	else:
		if raid_provisions_level == 2:
			report["title"] = "High Morale"
			report["description"] = "Excellent rations kept spirits high. The warriors are eager for battle!"
			report["modifier"] = 1.1 
			raid_health_modifier = 1.1
		else:
			raid_health_modifier = 1.0
			
	return report

func process_defensive_loss() -> Dictionary:
	# Runtime Dependency Check
	if not DynastyManager.current_jarl: 
		return {}
		
	var jarl = DynastyManager.current_jarl
	var aftermath_report = {
		"summary_text": "",
		"jarl_died": false,
		"heir_died": null 
	}
	
	# 1. Renown Loss
	var renown_loss = randi_range(50, 150)
	jarl.renown = max(0, jarl.renown - renown_loss)
	
	# 2. Material Loss (Delegated to EconomyManager)
	var material_losses = EconomyManager.apply_raid_damages()
	
	# 3. Heir Death Chance
	if jarl.heirs.size() > 0 and randf() < 0.15:
		var victim = jarl.heirs.pick_random()
		victim.status = JarlHeirData.HeirStatus.Deceased
		aftermath_report["heir_died"] = victim.display_name
		
		# We modify the Resource directly
		jarl.remove_heir(victim)
		
	# 4. Jarl Death Chance
	var death_chance = 0.10
	if jarl.age > 60: death_chance += 0.10
	
	if randf() < death_chance:
		aftermath_report["jarl_died"] = true
		# We use the debug method to trigger standard death flow
		# In Phase 4 we might make this a more formal API call
		DynastyManager.debug_kill_jarl()
	
	# 5. Commit Changes
	DynastyManager._save_jarl_data()
	DynastyManager.jarl_stats_updated.emit(jarl)
	
	var text = "Defeat! The settlement has been sacked.\n\n[color=salmon]Resources Lost:[/color]\n- %d Gold\n- %d Wood\n- %d Renown\n" % [material_losses.get("gold_lost", 0), material_losses.get("wood_lost", 0), renown_loss]
	aftermath_report["summary_text"] = text
	
	last_raid_outcome = "defeat"
	return aftermath_report


--------------------------------------------------
FILE: res:///autoload/SceneManager.gd
--------------------------------------------------
# res://autoload/SceneManager.gd
extends Node

@export var settlement_scene: PackedScene
@export var world_map_scene: PackedScene
@export var raid_mission_scene: PackedScene
@export var winter_court_scene: PackedScene

func _ready() -> void:
	EventBus.scene_change_requested.connect(_on_scene_change_requested)

func _on_scene_change_requested(scene_key: String) -> void:
	if scene_key.is_empty():
		Loggie.msg("scene_change_requested received an empty key.").domain("SCENE").error()
		return

	var target_scene: PackedScene = null
	match scene_key: # Removed to_lower() for strict exact matching
		GameScenes.SETTLEMENT: 
			target_scene = settlement_scene
		GameScenes.WORLD_MAP: 
			target_scene = world_map_scene
		GameScenes.RAID_MISSION: 
			target_scene = raid_mission_scene
		GameScenes.WINTER_COURT:
			target_scene = winter_court_scene
		_:
			Loggie.msg("Unknown scene key '%s'." % scene_key).domain("SCENE").error()
			return

	if not target_scene:
		Loggie.msg("Scene key '%s' is valid, but PackedScene is missing!" % scene_key).domain("SCENE").error()
		return

	Loggie.msg("Changing to scene: %s (Key: %s)" % [target_scene.resource_path, scene_key]).domain("SCENE").info()
	var error = get_tree().change_scene_to_packed(target_scene)
	if error != OK:
		Loggie.msg("Failed to change scene. Error code: %s" % error).domain("SCENE").error()


--------------------------------------------------
FILE: res:///autoload/SceneManager.tscn
--------------------------------------------------
[gd_scene load_steps=6 format=3 uid="uid://b5rr4e4bofld2"]

[ext_resource type="Script" uid="uid://c3h7atcwcwx1b" path="res://autoload/SceneManager.gd" id="1_q2yxj"]
[ext_resource type="PackedScene" uid="uid://c53k15q2w8c1a" path="res://scenes/levels/SettlementBridge.tscn" id="2_8867w"]
[ext_resource type="PackedScene" uid="uid://ba41qxyi1a30u" path="res://scenes/world_map/MacroMap.tscn" id="3_6h36k"]
[ext_resource type="PackedScene" uid="uid://d3ifdm0rvd5kl" path="res://scenes/missions/RaidMission.tscn" id="4_qjcdh"]
[ext_resource type="PackedScene" uid="uid://dnndecgdkcffm" path="res://ui/seasonal/WinterCourt_UI.tscn" id="5_8867w"]

[node name="SceneManager" type="Node"]
script = ExtResource("1_q2yxj")
settlement_scene = ExtResource("2_8867w")
world_map_scene = ExtResource("3_6h36k")
raid_mission_scene = ExtResource("4_qjcdh")
winter_court_scene = ExtResource("5_8867w")


--------------------------------------------------
FILE: res:///autoload/SettlementManager.gd
--------------------------------------------------
extends Node

# --- Constants ---
const USER_SAVE_PATH := "user://savegame.tres"
const MAP_SAVE_PATH := "user://campaign_map.tres"
const TILE_WIDTH = 64
const TILE_HEIGHT = 32
const TILE_HALF_SIZE = Vector2(TILE_WIDTH * 0.5, TILE_HEIGHT * 0.5)

# NEW: Terrain Validation Constants
const MAX_SEARCH_RADIUS: int = 10 # How far to search for valid ground
# CORRECTED: Uses Negative Logic based on NBLM Context ("is_unwalkable")
const UNWALKABLE_LAYER_NAME: String = "is_unwalkable" 
const GREAT_HALL_BUFFER: int = 4 # Tiles from water required for Great Hall

# --- Data State ---
var current_settlement: SettlementData 
var active_map_data: SettlementData      

# --- Scene Refs ---
var active_building_container: Node2D = null
var active_tilemap_layer: TileMapLayer = null # Critical for Custom Data lookups
var pending_seasonal_recruits: Array[UnitData] = []

# --- Signals ---
# (Assuming these exist based on previous context, inferred if not declared)
# signal settlement_loaded(data) 

func _ready() -> void:
	EventBus.player_unit_died.connect(_on_player_unit_died)
	Loggie.msg("SettlementManager Initialized").domain(LogDomains.GAMEPLAY).info()
	
# --- TERRAIN & COORDINATE VALIDATION (NEW) ---

## CHECKS TERRAIN DATA ONLY (Ignores Buildings/Units)
## Returns TRUE if the tile is valid land (not water/void).
func is_terrain_walkable(coords: Vector2i) -> bool:
	# 1. Check if we have a map to read from
	if not is_instance_valid(active_tilemap_layer):
		# Fallback: If no map, assume valid to prevent softlocks
		return true
	
	# 2. Check if the cell exists (is not empty/void)
	var tile_data: TileData = active_tilemap_layer.get_cell_tile_data(coords)
	if not tile_data:
		return false # Void/Empty space is invalid

	# 3. Check Unwalkability via Custom Data (NEGATIVE LOGIC)
	# "is_unwalkable" = true means WATER/OBSTACLE.
	# "is_unwalkable" = false (or null) means LAND.
	var is_unwalkable: bool = tile_data.get_custom_data(UNWALKABLE_LAYER_NAME)
	
	# Return valid if NOT unwalkable
	return not is_unwalkable

## CHECKS TILE DATA + DYNAMIC SOLIDS
## Returns TRUE if the tile is land AND empty of obstacles.
func is_tile_valid_for_placement(coords: Vector2i) -> bool:
	# 1. Check Static Terrain (Water/Cliffs)
	if not is_terrain_walkable(coords):
		return false
	
	# 2. Check Dynamic Solids (Buildings/Units via NavManager)
	if NavigationManager.is_point_solid(coords):
		return false
		
	return true

## Finds the nearest valid tile to the target coordinates.
## Useful if a unit tries to spawn on water; this moves them to the beach.
func get_nearest_valid_spawn_point(target_coords: Vector2i) -> Vector2i:
	# Optimistic check: if target is valid, return immediately
	if is_tile_valid_for_placement(target_coords):
		return target_coords
		
	Loggie.msg("Target invalid %s, searching for nearest land" % target_coords).domain(LogDomains.GAMEPLAY).debug()
	
	# BFS Flood Fill to find nearest valid tile
	var visited: Dictionary[Vector2i, bool] = {} # Typed dictionary for 4.4
	var queue: Array[Vector2i] = []
	
	queue.append(target_coords)
	visited[target_coords] = true
	
	while queue.size() > 0:
		var current: Vector2i = queue.pop_front()
		
		# Valid found?
		if is_tile_valid_for_placement(current):
			return current
			
		# Limit search depth roughly by checking distance
		if Vector2(current - target_coords).length() > MAX_SEARCH_RADIUS:
			continue
			
		# Add neighbors (4-way)
		var neighbors = [
			Vector2i(0, 1), Vector2i(0, -1), 
			Vector2i(1, 0), Vector2i(-1, 0)
		]
		
		for offset in neighbors:
			var next_cell = current + offset
			if not visited.has(next_cell):
				visited[next_cell] = true
				queue.append(next_cell)
	
	# Fallback if map is totally water or error
	Loggie.msg("No valid spawn point found within radius").ctx({"radius": MAX_SEARCH_RADIUS}).domain(LogDomains.GAMEPLAY).warn()
	return target_coords

# --- COORDINATE & SPATIAL DELEGATION ---

func grid_to_world(grid_pos: Vector2i) -> Vector2:
	if NavigationManager.has_method("_grid_to_world"):
		return NavigationManager._grid_to_world(grid_pos)
	
	var iso_x = (grid_pos.x - grid_pos.y) * 32.0 
	var iso_y = (grid_pos.x + grid_pos.y) * 16.0 
	return Vector2(iso_x, iso_y)

func get_tile_center(grid_pos: Vector2i) -> Vector2:
	if NavigationManager.has_method("_grid_to_world"):
		var top_left = NavigationManager._grid_to_world(grid_pos)
		return top_left + Vector2(0, 16.0) 
		
	return grid_to_world(grid_pos)

## NEW: Calculates the VISUAL CENTER of a multi-tile footprint.
## Fixes the "Heel vs Foot" issue where buildings were visually offset from their logic.
func get_footprint_center(grid_pos: Vector2i, grid_size: Vector2i) -> Vector2:
	# Convert grid coordinate + half size to world space
	# This aligns with SettlementBridge logic: Center = Pos + Size/2
	
	var center_x = float(grid_pos.x) + (float(grid_size.x) / 2.0)
	var center_y = float(grid_pos.y) + (float(grid_size.y) / 2.0)
	
	# Manual Isometric Conversion (matches grid_to_world but for floats)
	# Assuming Tile Width 64, Height 32 (Half 32, 16)
	var iso_x = (center_x - center_y) * 32.0
	var iso_y = (center_x + center_y) * 16.0
	
	return Vector2(iso_x, iso_y)

func world_to_grid(pos: Vector2) -> Vector2i:
	return NavigationManager._world_to_grid(pos)

## UPDATED: Checks direct tile data + navigation
func is_tile_buildable(grid_pos: Vector2i) -> bool:
	return is_tile_valid_for_placement(grid_pos)

func get_active_grid_cell_size() -> Vector2:
	if NavigationManager.active_astar_grid:
		return NavigationManager.active_astar_grid.cell_size
	return Vector2(64, 32) 

# --- BUILDING PLACEMENT ---

func _spawn_building_node(building_data: BuildingData, grid_pos: Vector2i) -> BaseBuilding:
	if not is_instance_valid(active_building_container): return null

	var new_building = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	new_building.grid_coordinate = grid_pos
	
	# CRITICAL FIX: Use Footprint Center instead of Tile Center
	# This ensures the sprite is centered over the entire MxN grid area.
	var center_pos = get_footprint_center(grid_pos, building_data.grid_size)
	new_building.global_position = center_pos 
	
	active_building_container.add_child(new_building)
	return new_building
	
func place_building(building_data: BuildingData, grid_position: Vector2i, is_new_construction: bool = false) -> BaseBuilding:
	if not is_instance_valid(active_building_container): return null
	
	# 1. Validation (Loops from Top-Left grid_position)
	if not is_placement_valid(grid_position, building_data.grid_size, building_data): 
		return null

	# 2. Spawn Visuals (Correctly centered now)
	var new_building = _spawn_building_node(building_data, grid_position)
	
	var entry = {
		"resource_path": building_data.resource_path,
		"grid_position": grid_position,
		"peasant_count": 0, "thrall_count": 0, "progress": 0
	}
	
	# 3. Update Data & Navigation Grid
	if active_map_data:
		if is_new_construction and building_data.construction_effort_required > 0:
			active_map_data.pending_construction_buildings.append(entry)
			new_building.set_state(BaseBuilding.BuildingState.BLUEPRINT)
			if active_map_data == current_settlement: save_settlement()
			_update_building_footprint_navigation(building_data, grid_position, true)
		else:
			active_map_data.placed_buildings.append(entry)
			new_building.set_state(BaseBuilding.BuildingState.ACTIVE)
			_update_building_footprint_navigation(building_data, grid_position, true)
			
	return new_building

func reconstruct_buildings_from_data() -> void:
	if active_building_container:
		for child in active_building_container.get_children():
			if child is BaseBuilding: child.queue_free()
			
	if not current_settlement: return
	
	for entry in current_settlement.placed_buildings:
		if ResourceLoader.exists(entry.resource_path):
			var data = load(entry.resource_path)
			var b = _spawn_building_node(data, entry.grid_position)
			if b: b.set_state(BaseBuilding.BuildingState.ACTIVE)
			_update_building_footprint_navigation(data, entry.grid_position, true)
			
	for entry in current_settlement.pending_construction_buildings:
		if ResourceLoader.exists(entry.resource_path):
			var data = load(entry.resource_path)
			var b = _spawn_building_node(data, entry.grid_position)
			if b: b.set_state(BaseBuilding.BuildingState.BLUEPRINT)
			_update_building_footprint_navigation(data, entry.grid_position, true)

func remove_building(building_instance: BaseBuilding) -> void:
	if not active_map_data or not is_instance_valid(building_instance): return
	
	var grid_pos = Vector2i.ZERO
	if "grid_coordinate" in building_instance and building_instance.grid_coordinate != Vector2i(-999, -999):
		grid_pos = building_instance.grid_coordinate
	else:
		grid_pos = NavigationManager._world_to_grid(building_instance.global_position)

	if building_instance.data:
		_update_building_footprint_navigation(building_instance.data, grid_pos, false)

	var removed_placed = _remove_from_list(active_map_data.placed_buildings, grid_pos)
	var removed_pending = _remove_from_list(active_map_data.pending_construction_buildings, grid_pos)
	
	if removed_placed or removed_pending:
		if active_map_data == current_settlement: save_settlement()
		
	building_instance.queue_free()

func _update_building_footprint_navigation(data: BuildingData, origin: Vector2i, is_solid: bool) -> void:
	for x in range(data.grid_size.x):
		for y in range(data.grid_size.y):
			var cell = origin + Vector2i(x, y)
			NavigationManager.set_point_solid(cell, is_solid)
	
	EventBus.pathfinding_grid_updated.emit(Vector2i.ZERO)

func _remove_from_list(list: Array, grid_pos: Vector2i) -> bool:
	for i in range(list.size()):
		var entry = list[i]
		var entry_pos = entry["grid_position"]
		if Vector2i(entry_pos.x, entry_pos.y) == grid_pos:
			list.remove_at(i)
			return true
	return false

# --- PLACEMENT VALIDATION & DIAGNOSTICS ---

func is_placement_valid(grid_position: Vector2i, building_size: Vector2i, building_data: BuildingData = null) -> bool:
	var error = get_placement_error(grid_position, building_size, building_data)
	return error == ""

## Returns an empty string if valid, or a reason string if invalid.
func get_placement_error(grid_position: Vector2i, building_size: Vector2i, building_data: BuildingData = null) -> String:
	# 1. Check Solids via STRICT Validation
	for x in range(building_size.x):
		for y in range(building_size.y):
			var check = grid_position + Vector2i(x, y)
			if not is_tile_valid_for_placement(check):
				return "Blocked / Invalid Terrain"

	# 2. Check Great Hall Buffer (Must be far from water)
	if building_data and _is_great_hall(building_data):
		if not _check_surrounding_terrain_buffer(grid_position, building_size, GREAT_HALL_BUFFER):
			return "Too Close to Water"

	# 3. Check District/Economic Logic
	if building_data and building_data is EconomicBuildingData:
		if not _is_within_district_range(grid_position, building_size, building_data):
			var res_name = building_data.resource_type.capitalize()
			return "Must be near %s" % res_name
			
	return ""

func _is_great_hall(data: BuildingData) -> bool:
	# Heuristic check for the Great Hall
	if "Great Hall" in data.display_name: return true
	if "GreatHall" in data.resource_path or "Great_Hall" in data.resource_path: return true
	return false

func _check_surrounding_terrain_buffer(origin: Vector2i, size: Vector2i, buffer: int) -> bool:
	# Loop through the padded rectangle
	var start_x = origin.x - buffer
	var end_x = origin.x + size.x + buffer
	var start_y = origin.y - buffer
	var end_y = origin.y + size.y + buffer
	
	for x in range(start_x, end_x):
		for y in range(start_y, end_y):
			# We only care about TERRAIN validation here (is it water?)
			# We do NOT care if there is a tree or another building in the buffer zone.
			if not is_terrain_walkable(Vector2i(x, y)):
				return false
	return true

func _is_within_district_range(grid_pos: Vector2i, size: Vector2i, data: EconomicBuildingData) -> bool:
	var cell = get_active_grid_cell_size()
	# FIX: Use Isometric Center calculation instead of Orthogonal
	var center = get_footprint_center(grid_pos, size)
	
	var nodes = get_tree().get_nodes_in_group("resource_nodes")
	for node in nodes:
		if "resource_type" in node and node.resource_type == data.resource_type:
			if node.has_method("is_depleted") and node.is_depleted(): continue
			
			if node.has_method("is_position_in_district"):
				if node.is_position_in_district(center): return true
			else:
				var dist = center.distance_to(node.global_position)
				var rad = node.get("district_radius") if "district_radius" in node else 300.0
				if dist <= rad: return true
				
	return false

# --- SCENE MANAGEMENT ---

func register_active_scene_nodes(container: Node2D) -> void:
	Loggie.msg("SettlementManager: Registering container: %s" % container.name).domain(LogDomains.SETTLEMENT).info()
	active_building_container = container
	
	# CRITICAL: Capture the TileMapLayer so is_tile_valid_for_placement can read Custom Data
	if container.get_parent() is TileMapLayer:
		active_tilemap_layer = container.get_parent()
		Loggie.msg("Active TileMapLayer captured for terrain validation.").domain(LogDomains.SETTLEMENT).info()
	elif container.get_parent().has_node("TileMapLayer"):
		# Fallback if structure is different
		active_tilemap_layer = container.get_parent().get_node("TileMapLayer")
	
	if current_settlement:
		reconstruct_buildings_from_data()

func unregister_active_scene_nodes() -> void:
	active_building_container = null
	active_tilemap_layer = null

# --- PERSISTENCE ---

func load_settlement(data: SettlementData) -> void:
	if ResourceLoader.exists(USER_SAVE_PATH):
		current_settlement = load(USER_SAVE_PATH)
	else:
		_load_fallback_data(data)
	active_map_data = current_settlement
	if active_building_container: reconstruct_buildings_from_data()
	EventBus.settlement_loaded.emit(current_settlement)
	
func _load_fallback_data(data: SettlementData) -> void:
	if data:
		current_settlement = data.duplicate(true)
		if current_settlement.warbands == null: current_settlement.warbands = []
		
		if current_settlement.map_seed == 0:
			randomize()
			current_settlement.map_seed = randi()
			Loggie.msg("New Campaign Initialized. Generated Seed: %d" % current_settlement.map_seed).domain(LogDomains.SETTLEMENT).info()
		
		save_settlement()
		Loggie.msg("Loaded default template and created new save file.").domain(LogDomains.SETTLEMENT).info()
	else:
		Loggie.msg("No data provided/found.").domain(LogDomains.SETTLEMENT).error()

func save_settlement() -> void:
	if not current_settlement: return
	var error = ResourceSaver.save(current_settlement, USER_SAVE_PATH)
	if error != OK:
		Loggie.msg("Save Failed: %s" % error).domain(LogDomains.SETTLEMENT).error()

func delete_save_file() -> void:
	if FileAccess.file_exists(USER_SAVE_PATH):
		DirAccess.remove_absolute(USER_SAVE_PATH)
	if FileAccess.file_exists(MAP_SAVE_PATH):
		DirAccess.remove_absolute(MAP_SAVE_PATH)
	reset_manager_state()
	Loggie.msg("Save files deleted.").domain(LogDomains.SYSTEM).info()

func reset_manager_state() -> void:
	current_settlement = null
	active_map_data = null
	active_building_container = null

func has_current_settlement() -> bool:
	return current_settlement != null

# --- ECONOMY & WORKERS ---

# FIX: Add Backward Compatibility for SettlementBridge.gd (Prevents crash, prevents double-refund)
func deposit_resources(_resources: Dictionary) -> void:
	Loggie.msg("SettlementBridge tried to refund via deprecated 'deposit_resources'. Ignored to prevent double-refund (StorefrontUI handles this now).").domain(LogDomains.ECONOMY).warn()

# FIX: Proxy for WinterManager and other legacy systems.
# Forwards the purchase request to the new EconomyManager.
func attempt_purchase(cost: Dictionary) -> bool:
	return EconomyManager.attempt_purchase(cost)

func get_total_ship_capacity_squads() -> int:
	var total_capacity = 3
	if not current_settlement: return total_capacity
	for entry in current_settlement.placed_buildings:
		var data = load(entry["resource_path"]) as BuildingData
		if data: total_capacity += data.fleet_capacity_bonus
	return total_capacity

func get_idle_peasants() -> int:
	if not current_settlement: return 0
	
	var employed = 0
	for entry in current_settlement.placed_buildings:
		employed += entry.get("peasant_count", 0)
	for entry in current_settlement.pending_construction_buildings:
		employed += entry.get("peasant_count", 0)
	
	var idle = current_settlement.population_peasants - employed
	
	if idle < 0:
		Loggie.msg("Negative Idle Peasants detected (%d). Triggering layoffs." % idle).domain(LogDomains.SETTLEMENT).warn()
		_validate_employment_levels()
		return 0 
	
	return idle

func get_idle_thralls() -> int:
	if not current_settlement: return 0
	
	var employed = 0
	for entry in current_settlement.placed_buildings:
		employed += entry.get("thrall_count", 0)
	for entry in current_settlement.pending_construction_buildings:
		employed += entry.get("thrall_count", 0)
		
	var idle = current_settlement.population_thralls - employed
	
	if idle < 0:
		Loggie.msg("Negative Idle Thralls detected (%d). Triggering layoffs." % idle).domain(LogDomains.SETTLEMENT).warn()
		_validate_employment_levels()
		return 0
	
	return idle

func assign_worker(building_index: int, type: String, amount: int) -> void:
	if not current_settlement: return
	var entry = current_settlement.placed_buildings[building_index]
	var data = load(entry["resource_path"]) as EconomicBuildingData
	if not data: return
	var key = "peasant_count" if type == "peasant" else "thrall_count"
	var cap = data.peasant_capacity if type == "peasant" else data.thrall_capacity
	var current = entry.get(key, 0)
	var new_val = clampi(current + amount, 0, cap)
	if amount > 0:
		var idle = get_idle_peasants() if type == "peasant" else get_idle_thralls()
		if amount > idle:
			EventBus.purchase_failed.emit("Not enough idle %ss!" % type.capitalize())
			return
	entry[key] = new_val
	save_settlement()
	EventBus.settlement_loaded.emit(current_settlement)

func assign_construction_worker(index: int, type: String, amount: int) -> void:
	if not current_settlement: return
	var entry = current_settlement.pending_construction_buildings[index]
	var data = load(entry["resource_path"]) as BuildingData
	if not data: return
	var key = "peasant_count" if type == "peasant" else "thrall_count"
	var cap = data.base_labor_capacity 
	var current = entry.get(key, 0)
	var new_val = clampi(current + amount, 0, cap)
	if amount > 0:
		var idle = get_idle_peasants() if type == "peasant" else get_idle_thralls()
		if amount > idle:
			EventBus.purchase_failed.emit("Not enough %ss!" % type.capitalize())
			return
	entry[key] = new_val
	save_settlement()
	EventBus.settlement_loaded.emit(current_settlement)

func _validate_employment_levels() -> void:
	if not current_settlement: return
	
	# 1. Validate Peasants
	var total_peasants = current_settlement.population_peasants
	var employed_peasants = 0
	for entry in current_settlement.placed_buildings:
		employed_peasants += entry.get("peasant_count", 0)
	
	if employed_peasants > total_peasants:
		var deficit = employed_peasants - total_peasants
		_force_layoffs("peasant", deficit)
		
	# 2. Validate Thralls
	var total_thralls = current_settlement.population_thralls
	var employed_thralls = 0
	for entry in current_settlement.placed_buildings:
		employed_thralls += entry.get("thrall_count", 0)
		
	if employed_thralls > total_thralls:
		var deficit = employed_thralls - total_thralls
		_force_layoffs("thrall", deficit)

func _force_layoffs(type: String, amount_to_remove: int) -> void:
	var removed_count = 0
	var key = "peasant_count" if type == "peasant" else "thrall_count"
	
	var buildings = current_settlement.placed_buildings
	for i in range(buildings.size() - 1, -1, -1):
		if removed_count >= amount_to_remove: 
			break
		
		var entry = buildings[i]
		var current_workers = entry.get(key, 0)
		
		if current_workers > 0:
			var take = min(current_workers, amount_to_remove - removed_count)
			entry[key] = current_workers - take
			removed_count += take
			
	Loggie.msg("Force Layoff Complete. Removed %d %ss due to population deficit." % [removed_count, type]).domain(LogDomains.SETTLEMENT).info()
	EventBus.settlement_loaded.emit(current_settlement)

func process_construction_labor() -> void:
	if not current_settlement: return
	
	# 1. Delegate Math to EconomyManager
	var finished_buildings = EconomyManager.advance_construction_progress()
	
	# 2. Handle Completion (Scene/Gameplay Logic)
	for entry in finished_buildings:
		_finalize_construction(entry)
		
	# Save state if any progress happened
	save_settlement()
	
func _finalize_construction(entry: Dictionary) -> void:
	# Add to authoritative "Placed" list
	# (Ensure we reset transient data like progress/workers)
	entry.erase("progress")
	entry.erase("peasant_count")
	
	current_settlement.placed_buildings.append(entry)
	
	Loggie.msg("Construction Finalized: %s" % entry.get("resource_path")).domain(LogDomains.SETTLEMENT).info()
	
	# Trigger Scene Updates (e.g., spawn the actual node)
	# This signal is likely listened to by your BuildingManager or SceneController
	EventBus.building_construction_completed.emit(entry)
# --- RECRUITMENT & WARBANDS ---

func recruit_unit(unit_data: UnitData) -> void:
	if not current_settlement or not unit_data:
		return
	
	var current_squads = current_settlement.warbands.size()
	var max_squads = get_total_ship_capacity_squads()
	
	if current_squads >= max_squads:
		Loggie.msg("Recruitment blocked: Fleet at capacity (%d/%d)" % [current_squads, max_squads]).domain(LogDomains.SETTLEMENT).info()
		EventBus.purchase_failed.emit("Fleet capacity reached! Build more Nausts.")
		return

	var new_warband = WarbandData.new(unit_data)
	
	if DynastyManager.has_purchased_upgrade("UPG_TRAINING_GROUNDS"):
		new_warband.experience = 200
		new_warband.add_history("Recruited as Hardened Veterans")
	else:
		new_warband.add_history("Recruited")
		
	current_settlement.warbands.append(new_warband)
	save_settlement()
	
	EventBus.purchase_successful.emit(unit_data.display_name)
	EventBus.settlement_loaded.emit(current_settlement)

func upgrade_warband_gear(warband: WarbandData) -> bool:
	if not current_settlement: return false
	if warband.gear_tier >= WarbandData.MAX_GEAR_TIER: return false
	var cost = warband.get_gear_cost()
	
	if EconomyManager.attempt_purchase({"gold": cost}):
		warband.gear_tier += 1
		warband.add_history("Upgraded to %s" % warband.get_gear_name())
		save_settlement()
		EventBus.purchase_successful.emit("Gear Upgrade")
		return true
	return false

func toggle_hearth_guard(warband: WarbandData) -> void:
	if not current_settlement: return
	warband.is_hearth_guard = !warband.is_hearth_guard
	if warband.is_hearth_guard:
		warband.add_history("Assigned to Hearth Guard")
	else:
		warband.add_history("Relieved from Hearth Guard")
	save_settlement()
	EventBus.purchase_successful.emit("Guard Toggle")

func process_warband_hunger() -> Array[String]:
	if not current_settlement: return []
	var deserters: Array[WarbandData] = []
	var warnings: Array[String] = []
	for warband in current_settlement.warbands:
		if warband.is_hearth_guard: continue
		var decay = 25
		warband.modify_loyalty(-decay)
		warband.turns_idle += 1
		if warband.loyalty <= 0:
			if randf() < 0.5:
				deserters.append(warband)
				warnings.append("DESERTION: The %s have left!" % warband.custom_name)
			else:
				warnings.append("MUTINY: The %s refuse to obey!" % warband.custom_name)
		elif warband.loyalty <= 25:
			warnings.append("UNREST: The %s are growing restless." % warband.custom_name)
	for bad_apple in deserters: current_settlement.warbands.erase(bad_apple)
	if not deserters.is_empty() or not warnings.is_empty(): save_settlement()
	return warnings

func _on_player_unit_died(unit: Node2D) -> void:
	if not current_settlement: return
	var warband = unit.get("warband_ref")
	if not warband: return 
	if warband in current_settlement.warbands:
		warband.current_manpower -= 1
		if warband.current_manpower <= 0:
			if warband.assigned_heir_name != "":
				DynastyManager.kill_heir_by_name(warband.assigned_heir_name, "Slain in battle")
			current_settlement.warbands.erase(warband)
		save_settlement()

func assign_worker_from_unit(building: BaseBuilding, type: String) -> bool:
	if not current_settlement: return false
	var entry = _find_entry_for_building(building)
	if entry.is_empty(): return false
	var data = building.data
	var cap = 0
	var current = 0
	if building.current_state == BaseBuilding.BuildingState.ACTIVE:
		if data is EconomicBuildingData:
			cap = data.peasant_capacity
			current = entry.get("peasant_count", 0)
	else:
		cap = data.base_labor_capacity
		current = entry.get("peasant_count", 0)
	if current >= cap:
		EventBus.purchase_failed.emit("Building is full!")
		return false
	entry["peasant_count"] = current + 1
	save_settlement()
	EventBus.settlement_loaded.emit(current_settlement)
	return true
	
func _find_entry_for_building(building: BaseBuilding) -> Dictionary:
	if "grid_coordinate" in building:
		var tagged_pos = building.grid_coordinate
		if tagged_pos != Vector2i(-999, -999):
			for entry in current_settlement.placed_buildings:
				if Vector2i(entry["grid_position"].x, entry["grid_position"].y) == tagged_pos: return entry
			for entry in current_settlement.pending_construction_buildings:
				if Vector2i(entry["grid_position"].x, entry["grid_position"].y) == tagged_pos: return entry
	
	# Fallback if grid_coordinate not found
	var grid_pos = NavigationManager._world_to_grid(building.global_position)
	
	for entry in current_settlement.placed_buildings:
		if Vector2i(entry["grid_position"].x, entry["grid_position"].y) == grid_pos: 
			building.grid_coordinate = grid_pos
			return entry
	for entry in current_settlement.pending_construction_buildings:
		if Vector2i(entry["grid_position"].x, entry["grid_position"].y) == grid_pos: 
			building.grid_coordinate = grid_pos
			return entry
	return {}

func unassign_worker_from_building(building: BaseBuilding, type: String) -> bool:
	if not current_settlement: return false
	var entry = _find_entry_for_building(building)
	if entry.is_empty(): return false
	var key = "peasant_count" if type == "peasant" else "thrall_count"
	var current = entry.get(key, 0)
	if current <= 0: return false
	entry[key] = current - 1
	save_settlement()
	EventBus.settlement_loaded.emit(current_settlement)
	return true

func get_building_index(building_instance: Node2D) -> int:
	var data_to_search = active_map_data if active_map_data else current_settlement
	if not data_to_search: return -1
	var search_placed = true
	if "current_state" in building_instance:
		if building_instance.current_state != BaseBuilding.BuildingState.ACTIVE:
			search_placed = false
	var target_list = data_to_search.placed_buildings if search_placed else data_to_search.pending_construction_buildings
	if "grid_coordinate" in building_instance:
		var tagged_pos = building_instance.get("grid_coordinate")
		if tagged_pos != Vector2i(-999, -999):
			for i in range(target_list.size()):
				var entry = target_list[i]
				var pos = entry["grid_position"]
				if Vector2i(pos.x, pos.y) == tagged_pos: return i
				
	# Fallback
	var grid_pos = NavigationManager._world_to_grid(building_instance.global_position)
	for i in range(target_list.size()):
		var entry = target_list[i]
		var pos = entry["grid_position"]
		if Vector2i(pos.x, pos.y) == grid_pos: return i
	return -1

func queue_seasonal_recruit(unit_data: UnitData, count: int) -> void:
	for i in range(count): pending_seasonal_recruits.append(unit_data)

func commit_seasonal_recruits() -> void:
	if pending_seasonal_recruits.is_empty(): return
	if not current_settlement: return
	var new_warbands: Array[WarbandData] = []
	var current_batch_wb: WarbandData = null
	for u_data in pending_seasonal_recruits:
		if current_batch_wb == null or current_batch_wb.current_manpower >= WarbandData.MAX_MANPOWER or current_batch_wb.unit_type != u_data:
			current_batch_wb = WarbandData.new(u_data)
			current_batch_wb.is_seasonal = true
			current_batch_wb.current_manpower = 0 
			current_batch_wb.custom_name = "Drengir (%s)" % _generate_oath_name()
			current_batch_wb.add_history("Swore the oath at Yule")
			current_settlement.warbands.append(current_batch_wb)
			new_warbands.append(current_batch_wb)
		current_batch_wb.current_manpower += 1
	Loggie.msg("Spring Arrival: %d men organized into %d Warbands." % [pending_seasonal_recruits.size(), new_warbands.size()]).domain(LogDomains.SETTLEMENT).info()
	pending_seasonal_recruits.clear()
	save_settlement()
	EventBus.settlement_loaded.emit(current_settlement)

func _generate_oath_name() -> String:
	var names = ["Red", "Bold", "Young", "Wild", "Sworn", "Lucky"]
	return "The %s" % names.pick_random()

# --- FORMATION SAFETY ---

func validate_formation_point(target_pos: Vector2, taken_grid_points: Array[Vector2i] = []) -> Vector2:
	var grid_pos = world_to_grid(target_pos)
	
	# Use new safe function first
	if is_tile_valid_for_placement(grid_pos) and not grid_pos in taken_grid_points:
		return target_pos
		
	# Search using NavManager logic via wrapper
	var safe_grid_pos = _get_closest_walkable_point_exclusive(grid_pos, 4, taken_grid_points)
	
	return get_tile_center(safe_grid_pos)

func _get_closest_walkable_point_exclusive(origin: Vector2i, max_radius: int, exclusions: Array[Vector2i]) -> Vector2i:
	if is_tile_valid_for_placement(origin) and not origin in exclusions: return origin
	
	for r in range(1, max_radius + 1):
		for x in range(-r, r + 1):
			for y in range(-r, r + 1):
				if abs(x) != r and abs(y) != r: continue
				
				var candidate = origin + Vector2i(x, y)
				if is_tile_valid_for_placement(candidate) and not candidate in exclusions:
					return candidate
	
	return origin


--------------------------------------------------
FILE: res:///autoload/WinterManager.gd
--------------------------------------------------
# res://autoload/WinterManager.gd
extends Node

signal winter_started
signal winter_ended

# --- Severity Definitions ---
enum WinterSeverity { MILD, NORMAL, HARSH }

# --- Configuration ---
@export_group("Probabilities")
@export_range(0.0, 1.0) var harsh_chance: float = 0.20
@export_range(0.0, 1.0) var mild_chance: float = 0.05

@export_group("Multipliers")
@export var harsh_multiplier: float = 1.5
@export var mild_multiplier: float = 0.75

# --- Internal State ---
var current_severity: WinterSeverity = WinterSeverity.NORMAL
var winter_consumption_report: Dictionary = {}
var winter_upkeep_report: Dictionary = {} 
var winter_crisis_active: bool = false

func start_winter_phase() -> void:
	Loggie.msg("WinterManager: Starting Winter Phase...").domain(LogDomains.SYSTEM).info()
	
	# 1. Decay Fleet Readiness (Environment Effect)
	_apply_environmental_decay()
	
	# 2. Calculate Needs
	_calculate_winter_needs()
	
	winter_started.emit()
	

func end_winter_phase() -> void:
	winter_crisis_active = false
	winter_consumption_report.clear()
	winter_ended.emit()
	
	# Delegate the "End of Year" aging/saving back to DynastyManager
	# But we call it from here to ensure linear flow
	DynastyManager.end_winter_cycle_complete()

# --- CORE LOGIC ---

func calculate_winter_demand(settlement: SettlementData) -> Dictionary:
	if not settlement: return _get_empty_report()

	_roll_severity()
	
	var mult: float = 1.0
	match current_severity:
		WinterSeverity.HARSH: mult = harsh_multiplier
		WinterSeverity.MILD: mult = mild_multiplier
		_: mult = 1.0
		
	var base_food = (settlement.population_peasants * 1) + (settlement.warbands.size() * 5)
	var base_wood = 20
	
	var final_food = int(base_food * mult)
	var final_wood = int(base_wood * mult)
	
	return {
		"severity_enum": current_severity,
		"severity_name": WinterSeverity.keys()[current_severity],
		"multiplier": mult,
		"food_demand": final_food,
		"wood_demand": final_wood
	}

func _calculate_winter_needs() -> void:
	var settlement = SettlementManager.current_settlement
	if not settlement: return
	
	_roll_severity()
	
	var mult: float = 1.0
	match current_severity:
		WinterSeverity.HARSH: mult = harsh_multiplier
		WinterSeverity.MILD: mult = mild_multiplier
		_: mult = 1.0
	
	# Ask EconomyManager (Returns dict with GameResources keys)
	var costs = EconomyManager.calculate_winter_consumption_costs(mult)
	var food_cost = costs.get(GameResources.FOOD, 0)
	var wood_cost = costs.get(GameResources.WOOD, 0)
	
	var food_stock = settlement.treasury.get(GameResources.FOOD, 0)
	var wood_stock = settlement.treasury.get(GameResources.WOOD, 0)
	
	var food_deficit = max(0, food_cost - food_stock)
	var wood_deficit = max(0, wood_cost - wood_stock)
	
	winter_consumption_report = {
		"severity_name": WinterSeverity.keys()[current_severity],
		"multiplier": mult,
		# We keep report keys distinct for UI, or we could use GameResources keys here too 
		# depending on how your UI reads this report. 
		# For safety inside this file, I am using explicit keys for the report structure.
		"food_cost": food_cost,
		"wood_cost": wood_cost,
		"food_deficit": food_deficit,
		"wood_deficit": wood_deficit
	}
	
	if food_deficit > 0 or wood_deficit > 0:
		winter_crisis_active = true
		Loggie.msg("Winter Crisis Active! Deficit: %s" % winter_consumption_report).domain(LogDomains.SYSTEM).warn()
	else:
		winter_crisis_active = false
		_apply_winter_consumption()

func _apply_winter_consumption() -> void:
	# Convert local report back to GameResources dict for the API
	var costs = {
		GameResources.FOOD: winter_consumption_report.get("food_cost", 0),
		GameResources.WOOD: winter_consumption_report.get("wood_cost", 0)
	}
	EconomyManager.apply_winter_consumption(costs)
	
	winter_upkeep_report = {
		"food_consumed": costs[GameResources.FOOD],
		"wood_consumed": costs[GameResources.WOOD]
		}

func _apply_environmental_decay() -> void:
	var decay = 0.2
	if current_severity == WinterSeverity.HARSH: decay = 0.4
	
	if SettlementManager.current_settlement:
		var current = SettlementManager.current_settlement.fleet_readiness
		SettlementManager.current_settlement.fleet_readiness = max(0.0, current - decay)

# --- CRISIS RESOLUTION ---

func resolve_crisis_with_gold() -> bool:
	# Calculate Gold Cost
	var total_gold_cost = (winter_consumption_report["food_deficit"] * 5) + (winter_consumption_report["wood_deficit"] * 5)
	
	if EconomyManager.attempt_purchase({GameResources.GOLD: total_gold_cost}):
		winter_crisis_active = false
		_apply_winter_consumption()
		return true
	return false

func play_seasonal_card(card: SeasonalCardResource) -> bool:
	# 1. Validate AP
	var jarl = DynastyManager.get_current_jarl()
	if not jarl or jarl.current_hall_actions < card.cost_ap:
		return false

	# 2. Validate Resources
	var cost_dict = {}
	if card.cost_gold > 0: cost_dict["gold"] = card.cost_gold
	if card.cost_food > 0: cost_dict["food"] = card.cost_food
	
	# Check affordability and Deduct
	if not EconomyManager.attempt_purchase(cost_dict):
		return false

	# 3. Deduct AP (DynastyManager owns this state)
	DynastyManager.perform_hall_action(card.cost_ap)

	# 4. Apply Rewards
	if card.grant_gold > 0:
		EconomyManager.deposit_resources({"gold": card.grant_gold})
	if card.grant_renown > 0:
		DynastyManager.award_renown(card.grant_renown)
	if card.grant_authority > 0:
		if jarl:
			# Add Authority directly to the Jarl data
			jarl.current_authority += card.grant_authority
			
			Loggie.msg("Granted %d Authority via card" % card.grant_authority).domain(LogDomains.DYNASTY).info()
			# CRITICAL: Emit signal so UI (DynastyUI/TopBar) updates immediately
			DynastyManager.jarl_stats_updated.emit(jarl)
	# [FIX] Apply Modifier (Missing in previous snippet)
	# 4. Apply Modifiers (The new aggregation logic you implemented)
	DynastyManager.aggregate_card_effects(card)
		
	return true

func resolve_crisis_with_sacrifice(sacrifice_type: String) -> bool:
	# Sacrifice costs 1 Action (paid to DynastyManager)
	if not DynastyManager.perform_hall_action(1): 
		return false
		
	var settlement = SettlementManager.current_settlement
	match sacrifice_type:
		"starve_peasants":
			var deaths = max(1, int(winter_consumption_report["food_deficit"] / 5))
			settlement.population_peasants = max(0, settlement.population_peasants - deaths)
			Loggie.msg("%d Peasants starved." % deaths).domain(LogDomains.SYSTEM).warn()
		"disband_warband":
			if not settlement.warbands.is_empty(): 
				settlement.warbands.pop_back()
				Loggie.msg("Warband disbanded.").domain(LogDomains.SYSTEM).warn()
		"burn_ships":
			settlement.fleet_readiness = 0.0
			Loggie.msg("Ships burned for wood.").domain(LogDomains.SYSTEM).warn()
			
	winter_crisis_active = false
	_apply_winter_consumption()
	return true

# --- HELPERS ---

func _roll_severity() -> void:
	var roll = randf()
	if roll < harsh_chance:
		current_severity = WinterSeverity.HARSH
	elif roll > (1.0 - mild_chance):
		current_severity = WinterSeverity.MILD
	else:
		current_severity = WinterSeverity.NORMAL
		
	Loggie.msg("WinterManager: Rolled %s (Val: %.2f)" % [WinterSeverity.keys()[current_severity], roll]).domain(LogDomains.SYSTEM).info()

func _get_empty_report() -> Dictionary:
	return {
		"severity_name": "NORMAL",
		"multiplier": 1.0,
		"food_demand": 0,
		"wood_demand": 0
	}


--------------------------------------------------
FILE: res:///autoload/WinterManager.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bi1u5m00ocqe1"]

[ext_resource type="Script" uid="uid://xlm4hw86iml1" path="res://autoload/WinterManager.gd" id="1_5afo2"]

[node name="WinterManager" type="Node"]
script = ExtResource("1_5afo2")


--------------------------------------------------
FILE: res:///data/buildings/Base_Building.gd
--------------------------------------------------
@tool
class_name BaseBuilding
extends StaticBody2D

signal building_destroyed(building: BaseBuilding)
signal construction_completed(building: BaseBuilding)
signal loot_stolen(type: String, amount: int)
signal loot_depleted(building: BaseBuilding)

# Defaults to a specific "Invalid" vector so we know if it wasn't set.
var grid_coordinate: Vector2i = Vector2i(-999, -999)

enum BuildingState { 
	BLUEPRINT, 
	UNDER_CONSTRUCTION, 
	ACTIVE 
}

@export var data: BuildingData:
	set(value):
		data = value
		if Engine.is_editor_hint():
			_apply_data_and_scale()
			queue_redraw()

var current_health: int = 100
var current_state: BuildingState = BuildingState.ACTIVE 
var construction_progress: int = 0

# --- Visual Components ---
var sprite: Sprite2D
var iso_placeholder: Node2D # Reference to the procedural shape
var hud: BuildingInfoHUD
const HUD_SCENE = preload("res://ui/components/BuildingInfoHUD.tscn")

# --- Physics Components ---
var collision_shape: CollisionShape2D
var hitbox_area: Area2D
var attack_ai: Node = null 

# --- Loot State ---
var available_loot: Dictionary = {}
var total_loot_value: int = 0

func _ready() -> void:
	if not data: return
	current_health = data.max_health
	
	# 1. Setup Physics/Collision
	if not collision_shape:
		collision_shape = CollisionShape2D.new()
		collision_shape.shape = RectangleShape2D.new()
		add_child(collision_shape)
	
	# 2. Setup Visuals (Sprite OR IsoPlaceholder)
	_setup_visual_style()
	
	# 3. Setup HUD (Visuals)
	if not hud:
		if HUD_SCENE:
			hud = HUD_SCENE.instantiate()
			add_child(hud)
	
	_apply_data_and_scale()
	
	# Stop here if Editor
	if Engine.is_editor_hint(): return
		
	# Gameplay Setup
	input_pickable = true
	_create_hitbox()
	_setup_defensive_ai()
	_initialize_loot()
		
	_update_visual_state()

func _setup_visual_style() -> void:
	# Clear existing to be safe
	if sprite: 
		sprite.queue_free()
		sprite = null
	if iso_placeholder: 
		iso_placeholder.queue_free()
		iso_placeholder = null

	# Decision: Texture vs Placeholder
	if data.building_texture != null:
		# Use Sprite
		sprite = Sprite2D.new()
		sprite.texture = data.building_texture
		# Y-Sort Offset: Center bottom of sprite should be at node origin
		sprite.centered = true 
		sprite.offset.y = -data.building_texture.get_height() / 2.0
		add_child(sprite)
	else:
		# Use Procedural Iso Placeholder
		# We attach a Node2D and add the script we wrote previously
		iso_placeholder = Node2D.new()
		iso_placeholder.name = "IsoPlaceholder"
		
		# Attach the script dynamically if not a scene
		var script = load("res://scripts/utility/IsoPlaceholder.gd")
		if script:
			iso_placeholder.set_script(script)
			iso_placeholder.set("data", data) # Pass data to it
			
		add_child(iso_placeholder)

func _initialize_loot() -> void:
	if not data is EconomicBuildingData: 
		available_loot = {"gold": 25} 
		total_loot_value = 25
		return
		
	var eco = data as EconomicBuildingData
	var type = eco.resource_type
	var amount = eco.base_passive_output * 3
	
	available_loot = {type: amount}
	total_loot_value = amount

func steal_resources(max_amount: int) -> int:
	if total_loot_value <= 0: return 0
		
	var target_res = ""
	for key in available_loot:
		if available_loot[key] > 0:
			target_res = key
			break
			
	if target_res == "": return 0
		
	var available = available_loot[target_res]
	var actual_steal = min(available, max_amount)
	
	available_loot[target_res] -= actual_steal
	total_loot_value -= actual_steal
	
	loot_stolen.emit(target_res, actual_steal)
	
	if total_loot_value <= 0:
		loot_depleted.emit(self)
		modulate = Color(0.5, 0.5, 0.5)
		
	return actual_steal

func _apply_data_and_scale() -> void:
	if not data: return
	
	# Determine logical size in pixels based on Grid
	# (Note: IsoPlaceholder handles its own drawing size, we just pass Data)
	if iso_placeholder:
		iso_placeholder.set("data", data)
		
	# Update Collision (Approximate box for clicking)
	# For Isometric, a box at (0,0) is "okay" for clicking, 
	# but technically it covers empty corners. 
	# For now, we size it to the total width/height of the diamond.
	if collision_shape and collision_shape.shape: 
		var cell_size = Vector2(64, 32) # Default
		if SettlementManager: cell_size = SettlementManager.get_active_grid_cell_size()
		
		# A 2x2 grid is 2 cells wide and 2 cells tall in Iso view
		# Total Width = (Rows + Cols) * HalfWidth
		# Total Height = (Rows + Cols) * HalfHeight
		var total_w = (data.grid_size.x + data.grid_size.y) * (cell_size.x * 0.5)
		var total_h = (data.grid_size.x + data.grid_size.y) * (cell_size.y * 0.5)
		
		collision_shape.shape.size = Vector2(total_w, total_h)
	
	# Update HUD Position
	if hud:
		hud.setup(data.display_name, Vector2(64, 64)) # Generic size
		# Raise HUD above the building visual
		hud.position = Vector2(0, -64) 

func set_state(new_state: BuildingState) -> void:
	var old_state = current_state
	current_state = new_state
	_update_visual_state()
	_update_logic_state()
	
	if current_state == BuildingState.ACTIVE and old_state != BuildingState.ACTIVE:
		construction_completed.emit(self)
		if SettlementManager and SettlementManager.has_method("complete_building_construction"):
			SettlementManager.complete_building_construction(self)

func _update_visual_state() -> void:
	if not hud: return

	match current_state:
		BuildingState.BLUEPRINT:
			hud.set_blueprint_mode()
			modulate = Color(0.4, 0.6, 1.0, 0.8)
			
		BuildingState.UNDER_CONSTRUCTION:
			hud.update_construction(construction_progress, data.construction_effort_required)
			modulate = Color(0.8, 0.8, 0.8, 1.0)
			
		BuildingState.ACTIVE:
			hud.set_active_mode(data.display_name)
			hud.update_health(current_health, data.max_health)
			modulate = Color.WHITE

func _update_logic_state() -> void:
	match current_state:
		BuildingState.BLUEPRINT, BuildingState.UNDER_CONSTRUCTION:
			if collision_shape: collision_shape.disabled = true
			if hitbox_area: 
				hitbox_area.monitorable = true
				hitbox_area.monitoring = true
			if attack_ai and attack_ai.has_method("stop_attacking"):
				attack_ai.stop_attacking()
				attack_ai.process_mode = Node.PROCESS_MODE_DISABLED
			
		BuildingState.ACTIVE:
			if collision_shape: collision_shape.disabled = false
			if hitbox_area: hitbox_area.monitorable = true
			if attack_ai: attack_ai.process_mode = Node.PROCESS_MODE_INHERIT

func add_construction_progress(amount: int) -> void:
	if current_state == BuildingState.ACTIVE: return
	
	if current_state == BuildingState.BLUEPRINT:
		set_state(BuildingState.UNDER_CONSTRUCTION)
		
	construction_progress += amount
	
	if hud:
		hud.update_construction(construction_progress, data.construction_effort_required)

func take_damage(amount: int, _attacker: Node2D = null) -> void:
	if current_state != BuildingState.ACTIVE: return
	current_health = max(0, current_health - amount)
	
	if hud:
		hud.update_health(current_health, data.max_health)
	
	if current_health == 0: die()

func die() -> void:
	building_destroyed.emit(self)
	queue_free()

func _input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_RIGHT:
			EventBus.building_right_clicked.emit(self)

func _create_hitbox() -> void:
	hitbox_area = Area2D.new()
	hitbox_area.name = "Hitbox"
	if self.collision_layer & 1: hitbox_area.collision_layer = 1
	else: hitbox_area.collision_layer = 8 
	hitbox_area.collision_mask = 0
	hitbox_area.monitorable = true
	var s = CollisionShape2D.new()
	s.shape = RectangleShape2D.new()
	if collision_shape and collision_shape.shape:
		s.shape.size = collision_shape.shape.size
	hitbox_area.add_child(s)
	add_child(hitbox_area)

func _setup_defensive_ai() -> void:
	if not data or not data.is_defensive_structure or not data.ai_component_scene: return
	attack_ai = data.ai_component_scene.instantiate()
	add_child(attack_ai)
	if attack_ai.has_method("configure_from_data"): attack_ai.configure_from_data(data)
	if attack_ai.has_method("set_target_mask"): attack_ai.set_target_mask(1 << 1)


--------------------------------------------------
FILE: res:///data/buildings/Bldg_Wall.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
build_cost = {
"stone": 25
}
dev_color = Color(0.050751396, 0.05072763, 0.06304378, 1)
is_player_buildable = true
extends_territory = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0


--------------------------------------------------
FILE: res:///data/buildings/BuildingData.gd
--------------------------------------------------
# res://data/buildings/BuildingData.gd
class_name BuildingData
extends Resource

@export var display_name: String = "New Building"
@export_multiline var description: String = "A useful structure."

@export var scene_to_spawn: PackedScene
@export var icon: Texture2D
@export var building_texture: Texture2D
@export var build_cost: Dictionary
@export var max_health: int = 100
@export var blocks_pathfinding: bool = true
@export var grid_size: Vector2i = Vector2i.ONE
@export var dev_color: Color = Color.GRAY
@export var is_player_buildable: bool = false

@export_group("Construction")
@export var construction_effort_required: int = 100
@export var base_labor_capacity: int = 3

@export_group("Territory & Expansion")
@export var is_territory_hub: bool = false
@export var extends_territory: bool = false
@export var territory_radius: int = 4

# --- RESTORED: FLEET CAPACITY ---
## How many Squads (not individual men) this building adds to your fleet capacity.
@export var fleet_capacity_bonus: int = 0
# --------------------------------

@export_group("Demographics")
@export var arable_land_capacity: int = 0 

@export_group("Defensive Stats")
@export var is_defensive_structure: bool = false
@export var attack_damage: int = 5
@export var attack_range: float = 200.0
@export var attack_speed: float = 1.0
@export var ai_component_scene: PackedScene
@export var projectile_scene: PackedScene
@export var projectile_speed: float = 400.0


--------------------------------------------------
FILE: res:///data/buildings/EconomicBuildingData.gd
--------------------------------------------------
# res://data/buildings/EconomicBuildingData.gd
class_name EconomicBuildingData
extends BuildingData

@export_group("Thrall Economy")
@export var resource_type: String = "wood"

## What this building produces automatically (Peasant labor).
@export var base_passive_output: int = 50

## Extra resource generated per assigned Thrall.
@export var output_per_thrall: int = 50

## Maximum number of Thralls this building can manage.
@export var thrall_capacity: int = 5

# --- Capacity definition ---
## Maximum number of Peasants/Citizens this building can employ.
@export var peasant_capacity: int = 5

## NEW: How much this building adds to the global resource cap.
@export var storage_capacity_bonus: int = 0


--------------------------------------------------
FILE: res:///data/buildings/GreatHall.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 100,
"wood": 250
}
grid_size = Vector2i(4, 4)
is_player_buildable = true
is_territory_hub = true
territory_radius = 8
arable_land_capacity = 5


--------------------------------------------------
FILE: res:///data/buildings/LumberYard.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://drx4sih8numo1"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
display_name = "Lumber Yard"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"wood": 50
}
max_health = 75
grid_size = Vector2i(2, 2)
is_player_buildable = true
territory_radius = 0


--------------------------------------------------
FILE: res:///data/buildings/Monastery_Chapel.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b7p70u4vm3uem"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
display_name = "Monastery Chapel"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 100,
"stone": 80,
"wood": 40
}
max_health = 120
grid_size = Vector2i(2, 2)


--------------------------------------------------
FILE: res:///data/buildings/Monastery_Granary.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bscr3flprg5ts"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "food"
display_name = "Monastery Granary"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 60,
"stone": 40,
"wood": 100
}
max_health = 90
grid_size = Vector2i(2, 3)


--------------------------------------------------
FILE: res:///data/buildings/Monastery_Library.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bfb0hbf1m2lgf"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 35
storage_cap = 250
display_name = "Monastery Library"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 150,
"stone": 60,
"wood": 80
}
max_health = 80
grid_size = Vector2i(3, 2)


--------------------------------------------------
FILE: res:///data/buildings/Monastery_Scriptorium.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b6dkpjrewc1q6"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 30
storage_cap = 180
display_name = "Monastery Scriptorium"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 120,
"stone": 30,
"wood": 90
}
max_health = 70
grid_size = Vector2i(2, 2)


--------------------------------------------------
FILE: res:///data/buildings/Monastery_Watchtower.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="BuildingData" load_steps=5 format=3 uid="uid://ckedcnw210a8k"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]
[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="3_ai"]
[ext_resource type="PackedScene" uid="uid://d10havsaesr6i" path="res://scenes/effects/Projectile.tscn" id="4_proj"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Monastery Watchtower"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 80,
"stone": 120,
"wood": 60
}
max_health = 150
dev_color = Color(0.8, 0.2, 0.2, 1)
is_defensive_structure = true
attack_damage = 10
attack_range = 250.0
ai_component_scene = ExtResource("3_ai")
projectile_scene = ExtResource("4_proj")
projectile_speed = 200.0


--------------------------------------------------
FILE: res:///data/buildings/Player_Farm.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://y7xhmemltm28"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_mixjq"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="3_svyis"]

[resource]
script = ExtResource("3_svyis")
resource_type = "food"
display_name = "Farm"
scene_to_spawn = ExtResource("2_mixjq")
build_cost = {
"wood": 75
}
max_health = 75
grid_size = Vector2i(2, 2)
dev_color = Color(0.85490197, 0.8, 0.2, 1)
is_player_buildable = true
territory_radius = 0
arable_land_capacity = 5


--------------------------------------------------
FILE: res:///data/buildings/generated/Bldg_Naust.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bwxc10py7rj4c"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_qun0b"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_p40ji"]

[resource]
script = ExtResource("2_p40ji")
display_name = "Naust"
description = "A shelter for a Longship. Increases Raid Capacity by 1 Ship (3 Squads)."
scene_to_spawn = ExtResource("1_qun0b")
build_cost = {
"gold": 500,
"wood": 250
}
max_health = 150
is_player_buildable = true
construction_effort_required = 150
fleet_capacity_bonus = 3


--------------------------------------------------
FILE: res:///data/buildings/generated/Eco_Farm.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://nh6veu8nwt2y"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_a3qf5"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_dy4o3"]

[resource]
script = ExtResource("2_dy4o3")
display_name = "Farmstead"
description = "A cluster of crops and livestock. Yields FOOD when raided."
scene_to_spawn = ExtResource("1_a3qf5")
build_cost = {
"wood": 50
}
max_health = 50
is_player_buildable = true
construction_effort_required = 50


--------------------------------------------------
FILE: res:///data/buildings/generated/Eco_Market.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://po8k2grtnqk3"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_ugvmv"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_m6nbf"]

[resource]
script = ExtResource("2_m6nbf")
display_name = "Trade Stall"
description = "A merchant's stall. Yields GOLD and GOODS when raided."
scene_to_spawn = ExtResource("1_ugvmv")
build_cost = {
"wood": 100
}
max_health = 80
is_player_buildable = true
construction_effort_required = 80


--------------------------------------------------
FILE: res:///data/buildings/generated/Eco_Reliquary.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://d2thv41oy0ta"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_7bmr7"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_h4xfr"]

[resource]
script = ExtResource("2_h4xfr")
resource_type = "gold"
display_name = "Reliquary"
description = "A holy shrine containing silver and relics. Yields HIGH GOLD."
scene_to_spawn = ExtResource("1_7bmr7")
build_cost = {
"gold": 100,
"stone": 100
}
max_health = 60
is_player_buildable = true
construction_effort_required = 120


--------------------------------------------------
FILE: res:///data/buildings/player_economy/Bld_Hof.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://de7upd61q7acb"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_k01sw"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_nl7oe"]
[ext_resource type="Texture2D" path="res://textures/building_icons/bld_hof_icon.png" id="3_icon"]

[resource]
script = ExtResource("2_nl7oe")
display_name = "Hof"
description = "A sacred wooden structure dedicated to the gods. Generates Piety passively and reduces local civil unrest."
scene_to_spawn = ExtResource("1_k01sw")
icon = ExtResource("3_icon")
build_cost = {
"gold": 50,
"stone": 20,
"wood": 150
}
max_health = 500
is_player_buildable = true
construction_effort_required = 250


--------------------------------------------------
FILE: res:///data/buildings/player_economy/Bld_Langhus.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://cqp5ethcro4wy"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_gc777"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_thncc"]
[ext_resource type="Texture2D" path="res://textures/building_icons/bld_langhus_icon.png" id="3_icon"]

[resource]
script = ExtResource("2_thncc")
display_name = "Langhs"
description = "The fundamental unit of Norse society. A long turf dwelling where extended families live together. Increases max population."
scene_to_spawn = ExtResource("1_gc777")
icon = ExtResource("3_icon")
build_cost = {
"stone": 20,
"wood": 100
}
max_health = 800
is_player_buildable = true
construction_effort_required = 150


--------------------------------------------------
FILE: res:///data/buildings/player_economy/Bld_Naust.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://brbkpe7xkott4"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_hcjhq"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_04eph"]
[ext_resource type="Texture2D" path="res://textures/building_icons/bld_naust_icon.png" id="3_icon"]

[resource]
script = ExtResource("2_04eph")
display_name = "Naust"
description = "A stone-walled slipway for protecting ships. Ships docked here in winter are safe from ice damage and are repaired."
scene_to_spawn = ExtResource("1_hcjhq")
icon = ExtResource("3_icon")
build_cost = {
"stone": 50,
"wood": 200
}
max_health = 1000
is_player_buildable = true
construction_effort_required = 300


--------------------------------------------------
FILE: res:///data/buildings/player_economy/Bld_Reykhus.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://couja0jua1f6q"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_17evo"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_xc2hg"]
[ext_resource type="Texture2D" path="res://textures/building_icons/bld_reykhus_icon.png" id="3_icon"]

[resource]
script = ExtResource("2_xc2hg")
display_name = "Reykhs"
description = "A specialized smokehouse. Converts raw food into non-perishable provisions necessary for long sea voyages."
scene_to_spawn = ExtResource("1_17evo")
icon = ExtResource("3_icon")
build_cost = {
"stone": 40,
"wood": 80
}
max_health = 400
is_player_buildable = true


--------------------------------------------------
FILE: res:///data/buildings/player_economy/Bld_Skali.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://c5a1swv6vsqg5"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_cltt7"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_mqd4q"]
[ext_resource type="Texture2D" path="res://textures/building_icons/bld_skali_icon.png" id="3_icon"]

[resource]
script = ExtResource("2_mqd4q")
display_name = "Skli"
description = "A grand feasting hall for the Jarl's court. Allows you to maintain a larger retinue of elite warriors through the winter."
scene_to_spawn = ExtResource("1_cltt7")
icon = ExtResource("3_icon")
build_cost = {
"gold": 100,
"stone": 100,
"wood": 400
}
max_health = 2500
is_player_buildable = true
construction_effort_required = 600


--------------------------------------------------
FILE: res:///data/buildings/player_economy/Bld_Skemma.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://b2017pygd4lr6"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_dl65s"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_sk1v1"]
[ext_resource type="Texture2D" path="res://textures/building_icons/bld_skemma_icon.png" id="3_icon"]

[resource]
script = ExtResource("2_sk1v1")
display_name = "Skemma"
description = "A raised timber storehouse used to keep supplies dry. Increases food storage capacity and reduces spoilage during winter."
scene_to_spawn = ExtResource("1_dl65s")
icon = ExtResource("3_icon")
build_cost = {
"wood": 60
}
max_health = 300
is_player_buildable = true
construction_effort_required = 80


--------------------------------------------------
FILE: res:///data/buildings/player_economy/Bld_Smidja.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://cj3ex7ealapyy"]

[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_u681b"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="2_3i0n5"]
[ext_resource type="Texture2D" path="res://textures/building_icons/bld_smidja_icon.png" id="3_icon"]

[resource]
script = ExtResource("2_3i0n5")
display_name = "Smija"
description = "A hot, dark workshop for working bog iron. Unlocks the recruitment of armored Huscarls and weapon upgrades."
scene_to_spawn = ExtResource("1_u681b")
icon = ExtResource("3_icon")
build_cost = {
"stone": 50,
"wood": 120
}
max_health = 600
is_player_buildable = true
construction_effort_required = 200


--------------------------------------------------
FILE: res:///data/characters/JarlData.gd
--------------------------------------------------
# res://data/characters/JarlData.gd
class_name JarlData
extends Resource

## The Jarl's name displayed in the UI
@export var display_name: String = "New Jarl"

## The Jarl's portrait/icon for the UI
@export var portrait: Texture2D

## The Jarl's age in years
@export var age: int = 25

## The Jarl's gender
@export var gender: String = "Male" # "Male", "Female"

@export_group("Dynasty & Authority")
## Total Renown accumulated by this Jarl
@export var renown: int = 0

## Current Renown Tier (0-3)
@export var renown_tier: int = 0

## Authority remaining for this year
@export var current_authority: int = 3

## Maximum Authority this Jarl can generate per year
@export var max_authority: int = 3

## Years since last offensive action
@export var years_since_action: int = 0

## Legitimacy score (0-100)
@export var legitimacy: int = 20

## Years remaining in succession debuff
@export var succession_debuff_years_remaining: int = 0

# --- NEW: Lineage History ---
@export_group("Lineage History")
## Stores dictionaries of past rulers: { "name": String, "portrait": Texture2D, "final_renown": int, "death_reason": String }
@export var ancestors: Array[Dictionary] = []
# ----------------------------

# --- Builder Pillar ---
@export var heir_starting_renown_bonus: int = 0
@export var purchased_legacy_upgrades: Array[String] = []

# --- Unifier Pillar ---
@export var conquered_regions: Array[String] = []

# --- Progenitor Pillar ---
@export var allied_regions: Array[String] = []

@export_group("Naval Logistics")
@export var safe_naval_range: float = 600.0
@export var attrition_per_100px: float = 0.10

@export_group("Base Skills")
@export var command: int = 10
@export var diplomacy: int = 10
@export var stewardship: int = 10
@export var learning: int = 10
@export var prowess: int = 10
@export var charisma: int = 10

@export_group("Traits")
@export var traits: Array[JarlTraitData] = []
@export var legacy_trait_names: Array[String] = []
@export var is_wounded: bool = false
@export var wound_recovery_turns: int = 0

@export_group("Family & Succession")
@export var spouse_name: String = ""
## Array of JarlHeirData resources
@export var heirs: Array[JarlHeirData] = []

@export_group("Political Status")
@export var title: String = "Jarl"
@export var vassal_count: int = 0
@export var reputation: int = 0
@export var is_in_exile: bool = false

@export_group("Combat & Mission State")
@export var is_on_mission: bool = false
@export var battles_fought: int = 0
@export var battles_won: int = 0
@export var successful_raids: int = 0
## Tracks progress towards Warlord trait
@export var offensive_wins: int = 0 

@export_group("Winter Court")
var current_hall_actions: int = 0
var max_hall_actions: int = 0
# --- HELPER FUNCTIONS ---

func calculate_hall_actions() -> void:
	# Formula: (Stewardship + Diplomacy) / 5, clamped 2 to 5.
	# Note: Using 'charisma' as proxy for Diplomacy if Diplomacy isn't explicitly defined yet.
	var score = stewardship + charisma 
	max_hall_actions = clampi(score / 5, 2, 5)
	current_hall_actions = max_hall_actions

func get_safe_range() -> float:
	return safe_naval_range

func get_available_heir_count() -> int:
	var count = 0
	for heir in heirs:
		if heir and heir.status == JarlHeirData.HeirStatus.Available:
			count += 1
	return count

func get_first_available_heir() -> JarlHeirData:
	for heir in heirs:
		if heir and heir.status == JarlHeirData.HeirStatus.Available:
			return heir
	return null

func remove_heir(heir_to_remove: JarlHeirData) -> bool:
	if heir_to_remove in heirs:
		heirs.erase(heir_to_remove)
		return true
	
	# LOGGIE: Warning if trying to remove non-existent heir
	if Engine.is_editor_hint() == false: # Prevent tool script spam
		Loggie.msg("JarlData: Attempted to remove heir '%s', but they were not in the list." % heir_to_remove.display_name).domain(LogDomains.DYNASTY).warn()
	return false

func check_has_valid_heir() -> bool:
	return get_first_available_heir() != null

func get_effective_skill(skill_name: String) -> int:
	var base_value: int = 0
	match skill_name.to_lower():
		"command": base_value = command
		"diplomacy": base_value = diplomacy
		"stewardship": base_value = stewardship
		"learning": base_value = learning
		"prowess": base_value = prowess
		"charisma": base_value = charisma
		_: return 0
	
	var trait_modifier: int = 0
	for jarl_trait in traits:
		if jarl_trait == null: continue
		match skill_name.to_lower():
			"command": trait_modifier += jarl_trait.command_modifier
			"stewardship": trait_modifier += jarl_trait.stewardship_modifier
			"intrigue": trait_modifier += jarl_trait.intrigue_modifier
	
	return base_value + trait_modifier

func add_trait(trait_data: JarlTraitData) -> void:
	if trait_data == null: return
	for existing_trait in traits:
		if existing_trait != null and existing_trait.display_name == trait_data.display_name:
			return
	traits.append(trait_data)

func has_trait(trait_name: String) -> bool:
	for jarl_trait in traits:
		if jarl_trait != null and jarl_trait.display_name == trait_name:
			return true
	return false

func get_authority_cap() -> int:
	match renown_tier:
		0: return 3
		1: return 5
		2: return 7
		_: return 3 + renown_tier

func can_take_action(authority_cost: int = 1) -> bool:
	return current_authority >= authority_cost

func spend_authority(cost: int = 1) -> bool:
	if can_take_action(cost):
		current_authority -= cost
		return true
	
	# LOGGIE: Logic error catching
	if Engine.is_editor_hint() == false:
		Loggie.msg("JarlData: Insufficient Authority. Needed %d, had %d." % [cost, current_authority]).domain(LogDomains.DYNASTY).debug()
	return false

func award_renown(amount: int) -> void:
	renown += amount
	years_since_action = 0
	_update_renown_tier()

func _update_renown_tier() -> void:
	if renown >= 1000: renown_tier = 3
	elif renown >= 500: renown_tier = 2
	elif renown >= 200: renown_tier = 1
	else: renown_tier = 0

func reset_authority() -> void:
	max_authority = get_authority_cap()
	if succession_debuff_years_remaining > 0:
		var legit_multiplier = legitimacy / 100.0
		var authority_gained = int(round(max_authority * legit_multiplier))
		current_authority = max(1, authority_gained)
		succession_debuff_years_remaining -= 1
	else:
		current_authority = max_authority

func age_jarl(years: int = 1) -> void:
	age += years
	years_since_action += years
	if age > 60:
		prowess = max(1, prowess - 1)
		learning = min(20, learning + 1)

func remove_trait(trait_name: String) -> bool:
	for i in range(traits.size()):
		if traits[i] != null and traits[i].display_name == trait_name:
			traits.remove_at(i)
			return true
	return false


--------------------------------------------------
FILE: res:///data/characters/JarlHeirData.gd
--------------------------------------------------
# res://data/characters/JarlHeirData.gd
class_name JarlHeirData
extends Resource

enum HeirStatus {
	Available,
	OnExpedition,
	MarriedOff,
	LostAtSea,
	Deceased,
	Maimed # Added Maimed status per design doc
}

@export_group("Identity")
@export var display_name: String = "New Heir"
@export var age: int = 16
@export var gender: String = "Male" # "Male", "Female"
@export var portrait: Texture2D
@export var is_designated_heir: bool = false

@export_group("Status")
@export var status: HeirStatus = HeirStatus.Available
@export var expedition_years_remaining: int = 0

@export_group("Skills & Traits")
@export var command: int = 8
@export var stewardship: int = 8
@export var learning: int = 8
@export var prowess: int = 8
@export var traits: Array[JarlTraitData] = []
## The innate genetic trait (e.g., Strong, Frail) separate from learned traits
@export var genetic_trait: JarlTraitData


--------------------------------------------------
FILE: res:///data/characters/PlayerJarl.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlData" load_steps=4 format=3]

[ext_resource type="Script" path="res://data/characters/JarlHeirData.gd" id="1_4gouw"]
[ext_resource type="Script" path="res://data/characters/JarlData.gd" id="1_jarl_data"]
[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="3_0bn2j"]

[resource]
script = ExtResource("1_jarl_data")
display_name = "Lagertha"
age = 33
gender = "Female"
renown_tier = 2
current_authority = 7
max_authority = 7
years_since_action = 3
legitimacy = 0


--------------------------------------------------
FILE: res:///data/characters/heirs/Ragnar.tres
--------------------------------------------------
[gd_resource type="Resource" format=3 uid="uid://c2ilgcmlp12pb"]

[resource]
metadata/_custom_type_script = "uid://cql5qpafvywy1"


--------------------------------------------------
FILE: res:///data/characters/heirs/TestHeir.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlHeirData" load_steps=2 format=3 uid="uid://dgxbmto5mqee5"]

[ext_resource type="Script" uid="uid://cql5qpafvywy1" path="res://data/characters/JarlHeirData.gd" id="1_iui4g"]

[resource]
script = ExtResource("1_iui4g")
display_name = "Ragnar (Test)"
metadata/_custom_type_script = "uid://cql5qpafvywy1"


--------------------------------------------------
FILE: res:///data/events/DisputeEventData.gd
--------------------------------------------------
class_name DisputeEventData
extends Resource

@export_group("Narrative")
@export var title: String = "Dispute Title"
@export_multiline var description: String = "Description of the conflict."

@export_group("Costs")
## Gold cost to settle peacefully (Wergild).
@export var gold_cost: int = 100
## Renown cost to settle by force.
@export var renown_cost: int = 25
## If true, "Force" removes a random unit instead of costing Renown (Banishment).
@export var bans_unit: bool = false
## How many Action Points (Hall Actions) this costs the Jarl.
@export var action_point_cost: int = 1

@export_group("Consequences")
## The key for the modifier applied next year if ignored (e.g., "angry_bondi").
@export var penalty_modifier_key: String = ""
## Text description of the penalty (for the tooltip).
@export var penalty_description: String = "Recruitment costs double next year."


--------------------------------------------------
FILE: res:///data/events/EventChoice.gd
--------------------------------------------------
# res://data/events/EventChoice.gd
#
# Defines a single choice for a story event.
# This resource is designed to be embedded within an EventData resource.
class_name EventChoice
extends Resource

## The text displayed on the button for this choice.
@export var choice_text: String = "Choice Text"

## A tooltip to show what the likely (or guaranteed) outcome is.
@export var tooltip_text: String = "Tooltip"

## A unique key (e.g., "CHOICE_ACCEPT", "CHOICE_DECLINE")
## The EventManager will use this key to apply the correct consequence.
@export var effect_key: String = ""


--------------------------------------------------
FILE: res:///data/events/EventData.gd
--------------------------------------------------
# res://data/events/EventData.gd
#
# Defines a single, self-contained story event.
# This resource is the core of the "Full Event System" (Phase 3b).
# It is designed to be created and edited by designers in the Inspector.
class_name EventData
extends Resource

# --- The nested "class EventChoice" definition has been REMOVED ---

@export_group("Event Display")
## The title of the event window.
@export var title: String = "An Event Occurs"
## The main story text for the event.
@export_multiline var description: String = "Event description..."
## An optional icon or portrait for the event.
@export var portrait: Texture2D

@export_group("Event Triggering")
## The unique ID for this event.
@export var event_id: String = "unique_event_id"
## If true, this event can only fire once per campaign.
@export var is_unique: bool = true
## The base chance (0.0 to 1.0) for this event to fire when its
## conditions are met.
@export var base_chance: float = 0.5
## An array of prerequisite event_ids that must have fired
## *before* this event can be considered.
@export var prerequisites: Array[String] = []

@export_group("Event Conditions")
## Conditions related to the Jarl's stats.
@export var min_stewardship: int = -1
@export var min_command: int = -1
@export var min_prowess: int = -1
@export var min_renown: int = -1
## Conditions related to the Jarl's traits.
@export var must_have_trait: String = ""
@export var must_not_have_trait: String = ""
## Conditions related to the dynasty.
@export var min_available_heirs: int = -1
## Conditions related to the game world.
@export var min_conquered_regions: int = -1

@export_group("Event Choices")
## The array of choices to present to the player.
## This now correctly references the external EventChoice resource.
@export var choices: Array[EventChoice] = []


--------------------------------------------------
FILE: res:///data/events/ambitious_heir.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="EventData" load_steps=5 format=3 uid="uid://ddjwe73h3diq5"]

[ext_resource type="Script" uid="uid://c7lxr02yr1fn6" path="res://data/events/EventData.gd" id="1_event_data"]
[ext_resource type="Script" uid="uid://dvc7gumtvwaal" path="res://data/events/EventChoice.gd" id="2_event_choice"]

[sub_resource type="Resource" id="EventChoice_accept"]
script = ExtResource("2_event_choice")
choice_text = "Here is 100 Renown. Bring us glory!"
tooltip_text = "Spend 100 Renown."
effect_key = "accept"

[sub_resource type="Resource" id="EventChoice_decline"]
script = ExtResource("2_event_choice")
choice_text = "We cannot spare it. Be patient."
tooltip_text = "Your heir will be displeased and gain the 'Rival' trait."
effect_key = "decline"

[resource]
script = ExtResource("1_event_data")
title = "An Ambitious Heir"
description = "Your heir, Ragnar, approaches you. \"My Jarl, I am bored! I wish to lead an expedition to prove my worth. Please fund it so I may bring glory to our dynasty!\""
event_id = "ambitious_heir_1"
base_chance = 1.0
must_have_trait = "Ambitious"
min_available_heirs = 1
choices = Array[ExtResource("2_event_choice")]([SubResource("EventChoice_accept"), SubResource("EventChoice_decline")])
metadata/_custom_type_script = "uid://c7lxr02yr1fn6"


--------------------------------------------------
FILE: res:///data/legacy/JellingStone.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_jelling"]

[resource]
script = ExtResource("1_jelling")
display_name = "Erect Jelling Stone"
description = "Commission a great rune stone to proclaim your dynasty's glory. All future heirs will begin their rule with bonus Renown."
renown_cost = 200
authority_cost = 2
effect_key = "UPG_JELLING_STONE"
prerequisite_key = ""

--------------------------------------------------
FILE: res:///data/legacy/LegacyUpgradeData.gd
--------------------------------------------------
# res://data/legacy/LegacyUpgradeData.gd
#
# Defines a permanent, one-time dynasty upgrade.
# These are purchased in the "Legacy" tab of the Storefront
# and cost Renown and Authority.
class_name LegacyUpgradeData
extends Resource

## The name displayed in the Storefront UI.
@export var display_name: String = "New Legacy Upgrade"

## The icon shown next to the upgrade name in the UI.
@export var icon: Texture2D

## The description shown in a tooltip or in the UI.
@export_multiline var description: String = "A permanent dynasty upgrade."

## The cost in Jarl's Renown.
@export var renown_cost: int = 100

## The cost in Jarl's Authority.
@export var authority_cost: int = 1

# --- NEW: Progress System ---
@export_group("Progress")
@export var required_progress: int = 1
@export var current_progress: int = 0
# --- END NEW ---

## A unique key to identify this upgrade's effect in code.
## e.g., "UPG_TRELLEBORG", "UPG_JELLING_STONE"
@export var effect_key: String = ""

## A key to check if a prerequisite upgrade has been purchased.
@export var prerequisite_key: String = ""

## 'is_purchased' is now a calculated variable, not stored.
var is_purchased: bool:
	get:
		return current_progress >= required_progress


--------------------------------------------------
FILE: res:///data/legacy/TrainingGrounds.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3 uid="uid://ckxjlif8kchlu"]

[ext_resource type="Script" uid="uid://bot3rirdcml6f" path="res://data/legacy/LegacyUpgradeData.gd" id="1_et52o"]

[resource]
script = ExtResource("1_et52o")
display_name = "Training Regime"
description = "New recruits start with extensive drill (level 3)"
renown_cost = 500
authority_cost = 3
effect_key = "UPG_TRAINING_GROUNDS"
metadata/_custom_type_script = "uid://bot3rirdcml6f"


--------------------------------------------------
FILE: res:///data/legacy/TrelleborgFortress.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_trelleborg"]

[resource]
script = ExtResource("1_trelleborg")
display_name = "Upgrade Trelleborg"
description = "Invest in the Trelleborg's defenses, permanently increasing the max garrison size for your home settlement."
renown_cost = 100
authority_cost = 3
effect_key = "UPG_TRELLEBORG"
prerequisite_key = ""

--------------------------------------------------
FILE: res:///data/legacy/Upg_BuildChapel.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3 uid="uid://c4qpn4hvsgkvh"]

[ext_resource type="Script" uid="uid://bot3rirdcml6f" path="res://data/legacy/LegacyUpgradeData.gd" id="1_chapel"]

[resource]
script = ExtResource("1_chapel")
display_name = "Build Chapel"
description = "Erect a small chapel, honoring the gods and securing their favor for your dynasty."
renown_cost = 50
effect_key = "UPG_BUILD_CHAPEL"
metadata/_custom_type_script = "uid://bot3rirdcml6f"


--------------------------------------------------
FILE: res:///data/legacy/VikingLongships.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_longships"]

[resource]
script = ExtResource("1_longships")
display_name = "Viking Longships"
description = "Improve shipbuilding techniques, allowing for faster raids and more loot."
renown_cost = 150
authority_cost = 1
effect_key = "UPG_LONGSHIPS"
prerequisite_key = ""

--------------------------------------------------
FILE: res:///data/missions/RaidLootData.gd
--------------------------------------------------
# res://data/missions/RaidLootData.gd
extends Resource
class_name RaidLootData

@export var collected_loot: Dictionary = {}

func _init() -> void:
	collected_loot = {
		GameResources.GOLD: 0,
		GameResources.WOOD: 0,
		GameResources.FOOD: 0,
		GameResources.STONE: 0
	}

func add_loot(resource_type: String, amount: int) -> void:
	if collected_loot.has(resource_type):
		collected_loot[resource_type] += amount
	else:
		collected_loot[resource_type] = amount
	
	Loggie.msg("Loot added: %d %s (Total: %d)" % [amount, resource_type, collected_loot[resource_type]]).domain("MAP").info()

func add_loot_from_building(building_data: BuildingData) -> void:
	if not building_data:
		return
	
	if building_data is EconomicBuildingData:
		var eco_data: EconomicBuildingData = building_data
		
		# --- FIX: Updated property name from 'fixed_payout_amount' to 'base_passive_output' ---
		# We multiply the passive output by 3 to represent "looting the stockpile"
		var loot_amount = eco_data.base_passive_output * 3
		
		add_loot(eco_data.resource_type, loot_amount)
	else:
		# Non-economic buildings (Walls, Watchtowers) yield a small amount of Gold/Materials
		# Checking if it has a cost to refund some of it, or just flat gold
		add_loot(GameResources.GOLD, 50)

func get_total_loot() -> Dictionary:
	return collected_loot.duplicate()

func clear_loot() -> void:
	for resource_type in collected_loot:
		collected_loot[resource_type] = 0

func get_loot_summary() -> String:
	var summary_parts: Array[String] = []
	for resource_type in GameResources.ALL_CURRENCIES:
		if collected_loot.has(resource_type) and collected_loot[resource_type] > 0:
			var display_name = GameResources.get_display_name(resource_type)
			summary_parts.append("%d %s" % [collected_loot[resource_type], display_name])
	
	if summary_parts.is_empty():
		return "No loot collected"
	else:
		return "Loot: " + ", ".join(summary_parts)


--------------------------------------------------
FILE: res:///data/missions/RaidResultData.gd
--------------------------------------------------
### FILE: res://data/missions/RaidResultData.gd ###
class_name RaidResultData
extends Resource

## Stores loot collected, using GameResources keys (e.g., "gold", "food").
@export var loot: Dictionary = {}

## List of UnitData resources representing casualties taken by the player.
@export var casualties: Array[UnitData] = []

## "victory", "retreat", or "defeat"
@export var outcome: String = "neutral" 

## "Standard", "Decisive", "Pyrrhic"
@export var victory_grade: String = "Standard"

## Renown specifically earned or lost due to mission bonuses/penalties.
@export var renown_earned: int = 0


--------------------------------------------------
FILE: res:///data/resources/Card_Focus_Raid.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SeasonalCardResource" load_steps=2 format=3 uid="uid://du2gsa2xinlrm"]

[ext_resource type="Script" uid="uid://cni5gdnpbb1v2" path="res://data/resources/SeasonalCardResource.gd" id="1_r2a8h"]

[resource]
script = ExtResource("1_r2a8h")
title = "Viking Focus"
description = "Boost Authority for multiple raids. Increases amount of time needed to complete buildings"
metadata/_custom_type_script = "uid://cni5gdnpbb1v2"


--------------------------------------------------
FILE: res:///data/resources/Card_Spring_Expansion.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SeasonalCardResource" load_steps=2 format=3 uid="uid://dt38bx8jkvrno"]

[ext_resource type="Script" uid="uid://cni5gdnpbb1v2" path="res://data/resources/SeasonalCardResource.gd" id="1_sbleo"]

[resource]
script = ExtResource("1_sbleo")
description = "Boosts building construction time. Decreases authority for raids."
metadata/_custom_type_script = "uid://cni5gdnpbb1v2"


--------------------------------------------------
FILE: res:///data/resources/SeasonalCardResource.gd
--------------------------------------------------
class_name SeasonalCardResource
extends Resource

enum SeasonType { SPRING, WINTER }

## The name displayed on the card
@export var display_name: String = "Card Name"

## The description text (supports BBCode)
@export_multiline var description: String = "Card Description"

## Icon for the card
@export var icon: Texture2D

@export var season: SeasonType

@export_group("Costs")
## Action Points required to play this card
@export var cost_ap: int = 1
## Gold cost (if any)
@export var cost_gold: int = 0
## Food cost (if any)
@export var cost_food: int = 0

@export_group("Immediate Rewards")
## Gold granted immediately
@export var grant_gold: int = 0
## Renown granted immediately
@export var grant_renown: int = 0
##Authority granted
@export var grant_authority: int = 0

@export_group("Seasonal Modifiers")
## Dictionary for arbitrary modifiers not covered by explicit variables.
## Format: { "custom_key": float_value }
@export var modifiers: Dictionary = {} 
## Percentage bonus to unit combat damage (e.g., 0.10 = +10%)
@export_range(-1.0, 5.0, 0.05) var mod_unit_damage: float = 0.0

## Percentage bonus to Raid XP gain (e.g., 0.20 = +20%)
@export_range(-1.0, 5.0, 0.05) var mod_raid_xp: float = 0.0

## Flat increase to birth probability (e.g., 0.05 = +5% chance)
@export_range(-1.0, 1.0, 0.01) var mod_birth_chance: float = 0.0

## Multiplier for harvest yield next season (e.g. 0.10 = +10%)
@export_range(-1.0, 5.0, 0.05) var mod_harvest_yield: float = 0.0


--------------------------------------------------
FILE: res:///data/resources/Winter Cards/Card_Winter_Feast.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SeasonalCardResource" load_steps=2 format=3 uid="uid://dg10eqygin8xg"]

[ext_resource type="Script" uid="uid://cni5gdnpbb1v2" path="res://data/resources/SeasonalCardResource.gd" id="1_ieg62"]

[resource]
script = ExtResource("1_ieg62")
season = 1
title = "Host a Grand Feast"
description = "Display your prosperity and invite local lords to your hall. 

- 100 food
+ 50 renown
"
cost_ap = 1
cost_food = 100
grant_renown = 50
metadata/_custom_type_script = "uid://cni5gdnpbb1v2"


--------------------------------------------------
FILE: res:///data/resources/Winter Cards/Card_Winter_Recruit.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SeasonalCardResource" load_steps=2 format=3 uid="uid://dcppndmvmf63e"]

[ext_resource type="Script" uid="uid://cni5gdnpbb1v2" path="res://data/resources/SeasonalCardResource.gd" id="1_vhnwa"]

[resource]
script = ExtResource("1_vhnwa")
season = 1
title = "Invite Vikings"
description = "You spread the word that you plan to go viking in the summer. 
- 100 renown
+ 3 AP
- Chance of a warband joining your this summer
- Must collect at least 150 byt the end of Autumn"
cost_ap = 2
metadata/_custom_type_script = "uid://cni5gdnpbb1v2"


--------------------------------------------------
FILE: res:///data/settlements/SettlementData.gd
--------------------------------------------------
# res://data/settlements/SettlementData.gd
extends Resource
class_name SettlementData

@export var treasury: Dictionary = {
	GameResources.GOLD: 0, 
	GameResources.WOOD: 0, 
	GameResources.FOOD: 0, 
	GameResources.STONE: 0
}

@export var placed_buildings: Array[Dictionary] = []
@export var pending_construction_buildings: Array = []
@export var warbands: Array[WarbandData] = []
@export var max_garrison_bonus: int = 0
@export var map_seed: int = 0
# --- Population ---
@export var population_peasants: int = 10 # Free Peasants
@export var population_thralls: int = 5 # Captive Workers
@export var worker_assignments: Dictionary = {}

# --- Stability ---
@export var has_stability_debuff: bool = false
@export var unrest: int = 0 # 0-100 scale. 100 = Rebellion.

# --- Naval State (New) ---
@export_group("Naval State")
## 0.0 (Rotting) to 1.0 (Pristine). Affects journey attrition.
@export var fleet_readiness: float = 1.0 


# --- Helper Functions ---
func get_fleet_capacity() -> int:
	var capacity = 2 # Base capacity (2 Warbands)
	
	for entry in placed_buildings:
		if not entry.has("resource_path"): continue
		var res_path = entry["resource_path"]
		
		# Check for Docks/Harbors (String check for now)
		if "dock" in res_path.to_lower() or "harbor" in res_path.to_lower():
			capacity += 2
			
	return capacity


--------------------------------------------------
FILE: res:///data/settlements/economic_base.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://chtd3i4qtdv31"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_e06fl"]

[resource]
script = ExtResource("1_e06fl")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 8),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(8, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}


--------------------------------------------------
FILE: res:///data/settlements/fortress_layout.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c2nrib7nroeas"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 150,
"gold": 1200,
"stone": 500,
"wood": 600
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 8
}


--------------------------------------------------
FILE: res:///data/settlements/generated/raid_rich_hub_01.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SettlementData" load_steps=3 format=3 uid="uid://dar76dyrtu8ts"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_0cqgt"]
[ext_resource type="Script" uid="uid://koj0vo5eoaum" path="res://data/units/WarbandData.gd" id="2_afm35"]

[resource]
script = ExtResource("1_0cqgt")
treasury = {
"food": 800,
"gold": 2000,
"stone": 500,
"wood": 1000
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(56, 25),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(47, 21),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(47, 22),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(47, 28),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(47, 29),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(48, 19),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(48, 20),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(48, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(48, 22),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(48, 28),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(48, 29),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(48, 30),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(48, 31),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(49, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(49, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(49, 20),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(49, 30),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(49, 31),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(49, 32),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(50, 17),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(50, 18),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(50, 32),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(50, 33),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(51, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(51, 18),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(51, 32),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(51, 33),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(52, 16),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(52, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(52, 33),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(52, 34),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(53, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(53, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(53, 33),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(53, 34),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(54, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(54, 34),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(55, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(55, 34),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(56, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(56, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(56, 34),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(56, 35),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(57, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(57, 34),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(58, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(58, 34),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(59, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(59, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(59, 33),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(59, 34),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(60, 16),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(60, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(60, 33),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(60, 34),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(61, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(61, 18),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(61, 32),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(61, 33),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(62, 17),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(62, 18),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(62, 32),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(62, 33),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(63, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(63, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(63, 20),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(63, 30),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(63, 31),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(63, 32),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(64, 19),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(64, 20),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(64, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(64, 22),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(64, 28),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(64, 29),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(64, 30),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(64, 31),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(65, 21),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(65, 22),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(65, 23),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(65, 24),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(65, 25),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(65, 26),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(65, 27),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(65, 28),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(65, 29),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(66, 25),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(62, 27),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(61, 21),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(50, 26),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(53, 20),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(56, 32),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(56, 18),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(62, 25),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(50, 21),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(62, 23),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(53, 31),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(39, 26),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(42, 28),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(43, 32),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(43, 35),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(46, 10),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(48, 8),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(48, 40),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(49, 35),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(50, 7),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(50, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(50, 40),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(51, 44),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(55, 37),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(56, 10),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(56, 42),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(58, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(59, 12),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(61, 36),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(63, 40),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(64, 34),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(66, 32),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(66, 37),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(68, 12),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(68, 16),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(68, 33),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(70, 11),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(71, 37),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(72, 26),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(73, 17),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(73, 20),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(73, 31),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(23, 31),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(27, 43),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(28, 27),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(30, 9),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(31, 24),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(34, 23),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(37, 39),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(38, 5),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(38, 42),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(38, 44),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(39, 2),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(40, 4),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(42, 2),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(48, 1),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(48, 47),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(56, 2),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(60, 2),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(61, 47),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(66, 4),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(70, 44),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(72, 1),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(72, 9),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(74, 47),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(76, 1),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(76, 11),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(77, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(77, 46),
"resource_path": "res://data/buildings/Player_Farm.tres"
}])


--------------------------------------------------
FILE: res:///data/settlements/home_base_fixed.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://dsgbqyqqlvlwn"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 657,
"gold": 600,
"stone": 125,
"wood": 1547
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(33, 18),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(31, 18),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(29, 18),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(31, 16),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2(36, 13),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2(37, 13),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2(38, 13),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(42, 15),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(41, 9),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(52, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(40, 9),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(51, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(50, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(49, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(32, 9),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(48, 16),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
pending_construction_buildings = [{
"grid_position": Vector2i(43, 11),
"progress": 25,
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(36, 26),
"progress": 0,
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}]
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 16
}
worker_assignments = {
"construction": 1,
"food": 0,
"stone": 0,
"wood": 0
}
metadata/_custom_type_script = "uid://hlb8s5g0yp6k"


--------------------------------------------------
FILE: res:///data/settlements/monastery_base.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://okf2novkg804"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_pnvr3"]

[resource]
script = ExtResource("1_pnvr3")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}


--------------------------------------------------
FILE: res:///data/settlements/monastery_layout.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://6kk36f5nlwns"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 300,
"gold": 800,
"stone": 200,
"wood": 400
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--------------------------------------------------
FILE: res:///data/settlements/sample_fortress_gui.tres
--------------------------------------------------
[gd_resource type="SettlementData" script_class="SettlementData" load_steps=2 format=3 uid="uid://cl3pbg7tiqyng"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1"]

[resource]
resource_local_to_scene = false
resource_name = ""
script = ExtResource("1")
treasury = {
"food": 300,
"gold": 1000,
"stone": 400,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(30, 20),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(29, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(29, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(28, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(28, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(27, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(33, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 4,
"res://data/units/Unit_Raider.tres": 8
}


--------------------------------------------------
FILE: res:///data/settlements/small_defensive.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c5wkbqulshkqe"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_mtb34"]

[resource]
script = ExtResource("1_mtb34")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(11, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(4, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(14, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(6, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}


--------------------------------------------------
FILE: res:///data/traits/JarlTraitData.gd
--------------------------------------------------
# res://data/traits/JarlTraitData.gd
#
# This resource defines the statistical and diplomatic impact of a single trait.
# Renamed to JarlTraitData to avoid keyword conflict with Godot's internal 'Trait'.
class_name JarlTraitData
extends Resource

## General Information
@export var display_name: String = ""
@export var description: String = ""
@export var is_visible: bool = true # Should the player/AI know about this trait?

## Character Skill Modifiers (Permanent)
# Used to adjust the Jarl's base skills (Command, Stewardship, Intrigue)
@export_group("Skill Modifiers")
@export var command_modifier: int = 0
@export var stewardship_modifier: int = 0
@export var intrigue_modifier: int = 0

## Macro Layer Modifiers (Diplomacy/Renown)
@export_group("Macro Modifiers")
@export var renown_per_year_modifier: float = 0.0 # Used for passive Renown gain/loss
@export var vassal_opinion_modifier: int = 0  # Global change to vassal opinion of Jarl
@export var alliance_cost_modifier: float = 1.0 # Multiplier for alliance Authority cost

## Behavioral Flags (For AI and Event Triggers)
@export_group("Behavior Flags")
@export var is_wounded_trait: bool = false # e.g., Maimed, Crippled
@export var is_dishonorable_trait: bool = false # e.g., Betrayer, Cowardly


--------------------------------------------------
FILE: res:///data/traits/Trait_Ambitious.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://wo43cpcxhf4i"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Ambitious"
description = "This Jarl is driven by a burning desire for power and glory, and inspires the same in their children."
command_modifier = 2
stewardship_modifier = -1
intrigue_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"


--------------------------------------------------
FILE: res:///data/traits/Trait_Cowardly.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bivw1rejl06qi"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Cowardly"
description = "This character has shown cowardice in battle, losing the respect of their people."
is_visible = true
command_modifier = -3
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -2.0
vassal_opinion_modifier = -10
alliance_cost_modifier = 1.2
is_wounded_trait = false
is_dishonorable_trait = true

--------------------------------------------------
FILE: res:///data/traits/Trait_Legendary.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://c6a8qce5fgub0"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Legendary"
description = "This character has achieved legendary status through glorious deeds and successful raids."
is_visible = true
command_modifier = 5
stewardship_modifier = 2
intrigue_modifier = 3
renown_per_year_modifier = 5.0
vassal_opinion_modifier = 20
alliance_cost_modifier = 0.8
is_wounded_trait = false
is_dishonorable_trait = false

--------------------------------------------------
FILE: res:///data/traits/Trait_Maimed.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bbiwlkmmne5md"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Maimed"
description = "This character has suffered a permanent injury that affects their combat ability."
is_visible = true
command_modifier = -2
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -1.0
vassal_opinion_modifier = -5
alliance_cost_modifier = 1.1
is_wounded_trait = true
is_dishonorable_trait = false

--------------------------------------------------
FILE: res:///data/traits/Trait_Pious.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://y1xcw7hwydkx"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Pious"
description = "This Jarl is known for their devotion to the gods, making religious acts cheaper and sacrilege more costly."
stewardship_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"


--------------------------------------------------
FILE: res:///data/traits/Trait_Rival.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Rival"
description = "This character has developed a bitter rivalry with their liege."
is_visible = true
command_modifier = 1
stewardship_modifier = 0
intrigue_modifier = 2
vassal_opinion_modifier = -15

--------------------------------------------------
FILE: res:///data/traits/Trait_Seasoned.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bvgxc8k7j2rqp"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Seasoned"
description = "This character has experience from successful expeditions, granting improved combat and leadership abilities."
command_modifier = 2
stewardship_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"


--------------------------------------------------
FILE: res:///data/units/EnemyVikingRaider_Data.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="UnitData" load_steps=5 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="1_4g7rt"]
[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_script"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="3_6go6j"]
[ext_resource type="Texture2D" uid="uid://buwxqfjw7whon" path="res://textures/units/viking_raider_sprite.png" id="6_lv2v5"]

[resource]
script = ExtResource("1_script")
display_name = "Viking Raider"
scene_path = "uid://btlcifwc6ckux"
icon = ExtResource("3_6go6j")
spawn_cost = {
"food": 30,
"gold": 15
}
max_health = 45
move_speed = 100.0
attack_damage = 10
attack_range = 200.0
attack_speed = 0.5
visual_texture = ExtResource("6_lv2v5")
ai_component_scene = ExtResource("1_4g7rt")


--------------------------------------------------
FILE: res:///data/units/UnitData.gd
--------------------------------------------------
### FILE: res://data/units/UnitData.gd ###
class_name UnitData
extends Resource

@export var display_name: String = "New Unit"
@export_file("*.tscn") var scene_path: String = ""
@export var scene_to_spawn: PackedScene 
@export var icon: Texture2D
@export var spawn_cost: Dictionary = {"food": 25}

@export_group("Combat Stats")
@export var max_health: int = 50
@export var move_speed: float = 75.0
@export var attack_damage: int = 8
@export var attack_speed: float = 1.2
@export var attack_range: float = 15.0 
@export var building_attack_range: float = 45.0

@export_group("Inventory & Logistics")
## Maximum gold/resources this unit can carry before capping out.
@export var max_loot_capacity: int = 100 
## Percentage of speed lost when fully encumbered (0.0 - 1.0). 0.5 = 50% slower.
@export var encumbrance_speed_penalty: float = 0.5 # 50% slow at max load

@export_group("Visuals")
@export var visual_texture: Texture2D
@export var target_pixel_size: Vector2 = Vector2(32, 32)

@export_group("Movement Feel")
@export var acceleration: float = 10.0
@export var linear_damping: float = 5.0

@export_group("Raid Stats")
@export var pillage_speed: int = 10 
@export var burn_renown: int = 10
@export var ai_component_scene: PackedScene
@export var projectile_scene: PackedScene
@export var projectile_speed: float = 400.0

@export_group("Social Stats")
@export var wergild_cost: int = 50

func load_scene() -> PackedScene:
	if scene_to_spawn:
		return scene_to_spawn
	if scene_path != "":
		return load(scene_path)
	return null


--------------------------------------------------
FILE: res:///data/units/Unit_Bondi.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="UnitData" load_steps=5 format=3 uid="uid://dpe2acwvvxthl"]

[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="1_xgb1t"]
[ext_resource type="Texture2D" uid="uid://bqewu3c53xrvk" path="res://art/units/bondi_32x32.png" id="1_xjqxg"]
[ext_resource type="Texture2D" uid="uid://v1mpf4cy67hf" path="res://ui/assets/wax_seal.png" id="2_xgb1t"]
[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="2_xjqxg"]

[resource]
script = ExtResource("2_xjqxg")
display_name = "Bondi"
scene_path = "res://scenes/units/Bondi.tscn"
icon = ExtResource("2_xgb1t")
spawn_cost = {
"food": 0
}
max_health = 40
attack_damage = 15
attack_range = 30.0
visual_texture = ExtResource("1_xjqxg")
ai_component_scene = ExtResource("1_xgb1t")


--------------------------------------------------
FILE: res:///data/units/Unit_Civilian.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="UnitData" load_steps=3 format=3 uid="uid://iiho31ik0qvb"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_4oj7p"]
[ext_resource type="Texture2D" uid="uid://bf5iebrbljx12" path="res://art/units/Villager_Norse_Male_Libre.png" id="1_ca617"]

[resource]
script = ExtResource("1_4oj7p")
display_name = "Villager"
scene_path = "uid://c7powse34uuxc"
icon = ExtResource("1_ca617")
max_health = 20
move_speed = 120.0
attack_damage = 0
attack_range = 0.0
visual_texture = ExtResource("1_ca617")
target_pixel_size = Vector2(24, 24)
metadata/_custom_type_script = "uid://cq155t20ujb2j"


--------------------------------------------------
FILE: res:///data/units/Unit_Drengr.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="UnitData" load_steps=5 format=3 uid="uid://cg3bi0swsm6k4"]

[ext_resource type="Texture2D" uid="uid://buwxqfjw7whon" path="res://textures/units/viking_raider_sprite.png" id="1_15vom"]
[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="1_ty6b3"]
[ext_resource type="Texture2D" uid="uid://v1mpf4cy67hf" path="res://ui/assets/wax_seal.png" id="2_fuc7h"]
[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="2_ty6b3"]

[resource]
script = ExtResource("2_ty6b3")
display_name = "Drengr"
scene_path = "res://scenes/units/Drengr.tscn"
icon = ExtResource("2_fuc7h")
spawn_cost = {
"food": 0
}
max_health = 45
move_speed = 85.0
attack_damage = 12
attack_speed = 1.4
visual_texture = ExtResource("1_15vom")
ai_component_scene = ExtResource("1_ty6b3")
wergild_cost = 150


--------------------------------------------------
FILE: res:///data/units/Unit_PlayerRaider.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="UnitData" load_steps=4 format=3 uid="uid://ejxn3hg8xcu6"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_script"]
[ext_resource type="Texture2D" uid="uid://buwxqfjw7whon" path="res://textures/units/viking_raider_sprite.png" id="3_viking_sprite"]
[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="4_ai"]

[resource]
script = ExtResource("1_script")
display_name = "Viking Raider"
scene_path = "uid://cfanwutbtfcp2"
icon = ExtResource("3_viking_sprite")
spawn_cost = {
"food": 25,
"gold": 10
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 80.0
attack_speed = 0.6000000000058208
visual_texture = ExtResource("3_viking_sprite")
acceleration = 12.0
linear_damping = 6.0
ai_component_scene = ExtResource("4_ai")
projectile_speed = 399.6600000000035


--------------------------------------------------
FILE: res:///data/units/Unit_Thrall.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="UnitData" load_steps=4 format=3 uid="uid://dtgp7yi7grl6g"]

[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="1_ji81e"]
[ext_resource type="Texture2D" uid="uid://ignmy4ooj1v1" path="res://art/units/Thrall_Male_Libre.png" id="2_4x1q2"]
[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="3_tk336"]

[resource]
script = ExtResource("3_tk336")
display_name = "Thrall"
scene_path = "uid://c4id53apf1ynt"
icon = ExtResource("2_4x1q2")
max_health = 30
move_speed = 60.0
attack_damage = 0
max_loot_capacity = 300
encumbrance_speed_penalty = 0.3
visual_texture = ExtResource("2_4x1q2")
pillage_speed = 15
burn_renown = 0
ai_component_scene = ExtResource("1_ji81e")
wergild_cost = 15
metadata/_custom_type_script = "uid://cq155t20ujb2j"


--------------------------------------------------
FILE: res:///data/units/WarbandData.gd
--------------------------------------------------
# res://data/units/WarbandData.gd
class_name WarbandData
extends Resource

@export var custom_name: String = "New Warband"
@export var unit_type: UnitData

# --- PROGRESSION: DRILL (XP) ---
@export var experience: int = 0
const XP_PER_LEVEL: int = 100
const MAX_LEVEL: int = 5

# --- PROGRESSION: GEAR (GOLD) ---
@export var gear_tier: int = 0
const MAX_GEAR_TIER: int = 3

# --- LEADERSHIP ---
@export var assigned_heir_name: String = ""

# --- LOYALTY ---
@export var loyalty: int = 100
@export var turns_idle: int = 0

# --- MANPOWER ---
@export var current_manpower: int = 10
const MAX_MANPOWER: int = 10

# --- FLAGS ---
@export var is_hearth_guard: bool = false

# --- NEW: BONDI FLAG ---
@export var is_bondi: bool = false

# --- NEW: SEASONAL FLAG (The Fix) ---
## If true, this warband disbands automatically at the end of the raid season.
@export var is_seasonal: bool = false
# ------------------------------------

@export var is_wounded: bool = false
@export var battles_survived: int = 0
@export var history_log: Array[String] = []

func _init(p_unit_type: UnitData = null) -> void:
	if p_unit_type:
		unit_type = p_unit_type
		custom_name = _generate_warband_name(p_unit_type.display_name)
		current_manpower = MAX_MANPOWER
		loyalty = 100

func add_history(entry: String) -> void:
	history_log.append(entry)

func get_level() -> int:
	return min(1 + (experience / XP_PER_LEVEL), MAX_LEVEL)

func get_level_title() -> String:
	if is_bondi: return "Free Farmers" 
	
	var lvl = get_level()
	match lvl:
		1: return "Rookie"
		2: return "Trained"
		3: return "Hardened"
		4: return "Veteran"
		5: return "Elite"
		_: return "Warrior"

func get_stat_multiplier() -> float:
	var lvl = get_level()
	return 1.0 + ((lvl - 1) * 0.10)

func get_gear_cost() -> int:
	match gear_tier:
		0: return 100
		1: return 250
		2: return 500
		_: return 9999

func get_gear_name() -> String:
	match gear_tier:
		0: return "Wool Tunics"
		1: return "Leather Jerkins"
		2: return "Chainmail"
		3: return "Splint Armor"
		_: return "Godly Plate"

func get_gear_health_mult() -> float:
	return 1.0 + (gear_tier * 0.25)

func get_gear_damage_mult() -> float:
	return 1.0 + (gear_tier * 0.10)

func get_loyalty_description(jarl_name: String) -> String:
	if is_bondi: return "[color=gray]Mustered Bondi[/color]"
	
	# --- Update: Flavor text for Seasonal Units ---
	if is_seasonal: return "[color=cyan]Seasonal Raiders (Leaving in Winter)[/color]"
	# ----------------------------------------------
	
	if loyalty >= 90: return "[color=gold]Fanatically loyal to %s[/color]" % jarl_name
	elif loyalty >= 70: return "[color=green]Loyal to %s[/color]" % jarl_name
	elif loyalty >= 40: return "[color=white]Content[/color]"
	elif loyalty >= 20: return "[color=yellow]Restless[/color]"
	else: return "[color=red]Mutinous[/color]"

func modify_loyalty(amount: int) -> void:
	loyalty = clampi(loyalty + amount, 0, 100)

func _generate_warband_name(_base_name: String) -> String:
	if is_bondi: return "The Bondi"
	
	var prefixes = ["Iron", "Blood", "Storm", "Night", "Wolf", "Bear", "Raven"]
	var suffixes = ["Guard", "Raiders", "Blades", "Shields", "Hunters", "Fists"]
	return "%s %s" % [prefixes.pick_random(), suffixes.pick_random()]


--------------------------------------------------
FILE: res:///data/world_map/MapState.gd
--------------------------------------------------
# res://data/world_map/MapState.gd
class_name MapState
extends Resource

# Dictionary mapping Region Node Names to their Data
# Format: { "Region1": WorldRegionData, "Region2": WorldRegionData }
@export var region_data_map: Dictionary = {}

# We can track global map flags here too
@export var turns_elapsed: int = 0


--------------------------------------------------
FILE: res:///data/world_map/RaidTargetData.gd
--------------------------------------------------
# res://data/world_map/RaidTargetData.gd
class_name RaidTargetData
extends Resource

@export var display_name: String = "Monastery"
@export_multiline var description: String = "A small, undefended religious site."
@export var settlement_data: SettlementData

@export_group("Raid Costs")
## The base Authority cost. Set by generators or manually.
@export var raid_cost_authority: int = 1

## If -1, the system uses 'raid_cost_authority'. 
## If > -1, this value takes priority.
@export var authority_cost_override: int = -1

@export var difficulty_rating: int = 1 # 1-5 Stars

@export_group("Victory Conditions")
## Time in seconds to achieve a 'Fast' rating.
@export var par_time_seconds: int = 300 
## Maximum casualties allowed to achieve a 'Decisive' rating.
@export var decisive_casualty_limit: int = 2


--------------------------------------------------
FILE: res:///data/world_map/Region_Agdir.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="WorldRegionData" load_steps=2 format=3 uid="uid://rb575376gmgd"]

[ext_resource type="Script" uid="uid://dqlbgeegli821" path="res://data/world_map/WorldRegionData.gd" id="1_8hjpx"]

[resource]
script = ExtResource("1_8hjpx")
metadata/_custom_type_script = "uid://dqlbgeegli821"


--------------------------------------------------
FILE: res:///data/world_map/Region_Monastery.tres
--------------------------------------------------
[gd_resource type="Resource" script_class="WorldRegionData" load_steps=3 format=3 uid="uid://bk6wv22mknptc"]

[ext_resource type="Resource" uid="uid://okf2novkg804" path="res://data/settlements/monastery_base.tres" id="1_settlement"]
[ext_resource type="Script" uid="uid://dqlbgeegli821" path="res://data/world_map/WorldRegionData.gd" id="2_world_region"]

[resource]
script = ExtResource("2_world_region")
display_name = "Nearby Monastery"
description = "A wealthy but poorly-defended monastery. An easy target for a quick grab."
target_settlement_data = ExtResource("1_settlement")
region_type_tag = "Monastery"
yearly_income = {
"food": 10,
"gold": 25
}
metadata/_custom_type_script = "uid://dqlbgeegli821"


--------------------------------------------------
FILE: res:///data/world_map/WorldRegionData.gd
--------------------------------------------------
# res://data/world_map/WorldRegionData.gd
class_name WorldRegionData
extends Resource

@export var display_name: String = "New Region"
@export_multiline var description: String = "A description of this region."

# --- MODIFIED: Now a list of targets ---
@export var raid_targets: Array[RaidTargetData] = []
# --------------------------------------

@export var region_type_tag: String = "Province"
@export var yearly_income: Dictionary = {"gold": 10}

# Deprecated (Keep for temporary compatibility if needed, or delete)
# @export var target_settlement_data: SettlementData 
@export var base_authority_cost: int = 1


--------------------------------------------------
FILE: res:///player/RTSCamera.gd
--------------------------------------------------
# res://player/RTSCamera.gd
# Basic RTS-style camera controller for Phase 3
# Provides WASD movement, mouse edge panning, drag panning, and zooming.
# Keeps camera controls simple and focused on tactical gameplay.

extends Camera2D
class_name RTSCamera

# --- Movement Settings ---
@export_group("Movement")
@export var camera_speed: float = 400.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_wasd_movement: bool = true
@export var enable_drag_panning: bool = true

# --- Zoom Settings ---
@export_group("Zoom")
@export var min_zoom: float = 0.5  # Far away
@export var max_zoom: float = 2.0  # Close up
@export var zoom_speed: float = 0.25 # Clean snapping for pixel art
@export var zoom_smoothing: float = 10.0

# --- Bounds Settings ---
@export_group("Bounds")
@export var bounds_enabled: bool = true
@export var bounds_rect: Rect2 = Rect2(-1000, -1000, 3000, 2500)

# Internal State
var target_zoom: Vector2 = Vector2.ONE
var is_dragging: bool = false
var drag_start_mouse_pos: Vector2 = Vector2.ZERO
var drag_start_camera_pos: Vector2 = Vector2.ZERO
var input_locked: bool = false

func _ready() -> void:
	Loggie.msg("RTS Camera Initialized").domain("RTS").info() # Check your Output tab for this!
	# Initialize target zoom to current zoom
	target_zoom = zoom
	make_current()
	EventBus.camera_input_lock_requested.connect(_on_input_lock_requested)
	
func _unhandled_input(event: InputEvent) -> void:
	if input_locked:
		return
	# --- Zoom Control (Mouse Wheel) ---
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			_zoom_in()
			get_viewport().set_input_as_handled()
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			_zoom_out()
			get_viewport().set_input_as_handled()
			
		# --- Drag Panning (Middle Mouse) ---
		elif event.button_index == MOUSE_BUTTON_MIDDLE and enable_drag_panning:
			if event.is_pressed():
				is_dragging = true
				drag_start_mouse_pos = get_viewport().get_mouse_position()
				drag_start_camera_pos = global_position
				get_viewport().set_input_as_handled()
			else:
				is_dragging = false
				get_viewport().set_input_as_handled()

	# --- Handle Drag Motion ---
	if event is InputEventMouseMotion and is_dragging:
		var current_mouse_pos = get_viewport().get_mouse_position()
		var mouse_delta = drag_start_mouse_pos - current_mouse_pos
		
		# Scale delta by zoom so dragging feels consistent at all zoom levels
		global_position = drag_start_camera_pos + (mouse_delta / zoom.x)
		
		_clamp_position()
		get_viewport().set_input_as_handled()

func _process(delta: float) -> void:
	# 1. Apply Smooth Zoom
	zoom = zoom.lerp(target_zoom, zoom_smoothing * delta)
	
	# 2. Handle Keyboard/Edge Movement (Only if not dragging)
	if not is_dragging:
		_handle_keyboard_movement(delta)

	# 3. Clamp Bounds
	_clamp_position()

func _handle_keyboard_movement(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	var viewport_size = get_viewport().get_visible_rect().size
	var mouse_pos = get_viewport().get_mouse_position()
	
	# WASD Movement
	if enable_wasd_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Edge Panning
	if enable_edge_panning:
		# Check X axis
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
			
		# Check Y axis
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply Movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		# Adjust speed based on zoom level (faster when zoomed out)
		var zoom_multiplier = 1.0 / zoom.x
		global_position += movement_vector * camera_speed * zoom_multiplier * delta

func _zoom_in() -> void:
	target_zoom += Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _zoom_out() -> void:
	target_zoom -= Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _clamp_zoom() -> void:
	target_zoom.x = clamp(target_zoom.x, min_zoom, max_zoom)
	target_zoom.y = clamp(target_zoom.y, min_zoom, max_zoom)

func _clamp_position() -> void:
	if bounds_enabled:
		global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.end.x)
		global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.end.y)

func _on_input_lock_requested(locked: bool) -> void:
	input_locked = locked


--------------------------------------------------
FILE: res:///player/RTSController.gd
--------------------------------------------------
# res://player/RTSController.gd
extends Node
class_name RTSController

var selected_units: Array[BaseUnit] = []
var controllable_units: Array[BaseUnit] = []
var current_formation: SquadFormation.FormationType = SquadFormation.FormationType.LINE

# Control Group Storage
var control_groups: Dictionary = {
	1: [], 2: [], 3: [], 4: [], 5: [],
	6: [], 7: [], 8: [], 9: [], 0: [],
}

func _ready() -> void:
	print("DEBUG: RTSController Initialized.")
	
	# Mouse Commands
	EventBus.select_command.connect(_on_select_command)
	EventBus.move_command.connect(_on_move_command)
	EventBus.attack_command.connect(_on_attack_command)
	EventBus.formation_move_command.connect(_on_formation_move_command)
	EventBus.interact_command.connect(_on_interact_command)
	EventBus.pillage_command.connect(_on_pillage_command)
	# Keyboard Commands
	EventBus.control_group_command.connect(_on_control_group_command)
	EventBus.formation_change_command.connect(_on_formation_change_command)
	
	EventBus.player_unit_spawned.connect(add_unit_to_group)

# --- NEW: Helper to broadcast state ---
func _emit_selection_update() -> void:
	# Broadcast the new list so UI can update context buttons
	EventBus.units_selected.emit(selected_units)
# --------------------------------------

func _on_interact_command(target: Node2D) -> void:
	_validate_selection()
	if selected_units.is_empty(): return
		
	for unit in selected_units:
		if unit.is_in_group("civilians") and unit.has_method("command_interact"):
			unit.command_interact(target)
		else:
			# Soldiers move to guard the interaction point
			unit.command_move_to(target.global_position)

# --- MOVEMENT LOGIC REFACTOR ---

func _on_move_command(target_position: Vector2) -> void:
	_validate_selection()
	if selected_units.is_empty(): return
	
	_handle_movement_logic(target_position, Vector2.DOWN)

func _on_formation_move_command(target_position: Vector2, direction_vector: Vector2) -> void:
	_validate_selection()
	if selected_units.is_empty(): return
	
	_handle_movement_logic(target_position, direction_vector)

func _handle_movement_logic(target_pos: Vector2, direction: Vector2) -> void:
	# 1. Sort units by type
	var soldiers: Array[Node2D] = []
	var civilians: Array[Node2D] = []
	
	for unit in selected_units:
		if unit.is_in_group("civilians"):
			civilians.append(unit)
		else:
			soldiers.append(unit)
	
	# 2. Move Soldiers (Strict Formation)
	if not soldiers.is_empty():
		if soldiers.size() == 1:
			if soldiers[0].has_method("command_move_to"):
				soldiers[0].command_move_to(target_pos)
		else:
			_move_group_in_formation(soldiers, target_pos, direction)
			
	# 3. Move Civilians (Organic Mob)
	if not civilians.is_empty():
		_move_civilians_as_mob(civilians, target_pos)

func _move_group_in_formation(unit_list: Array[Node2D], target: Vector2, direction: Vector2) -> void:
	var formation = SquadFormation.new(unit_list)
	formation.formation_type = current_formation
	formation.unit_spacing = 45.0
	formation.move_to_position(target, direction)

func _move_civilians_as_mob(unit_list: Array[Node2D], target: Vector2) -> void:
	var unit_count = unit_list.size()
	var mob_radius = sqrt(unit_count) * 20.0 
	
	for unit in unit_list:
		if not is_instance_valid(unit): continue
		var angle = randf() * TAU
		var distance = randf() * mob_radius
		var offset = Vector2(cos(angle), sin(angle)) * distance
		var specific_dest = target + offset
		
		if unit.has_method("command_move_to"):
			unit.command_move_to(specific_dest)

# ---------------------------------------------------------

func add_unit_to_group(unit: Node2D) -> void:
	if not unit is BaseUnit: return
	if unit in controllable_units: return
	
	controllable_units.append(unit)
	
	if unit.is_selected and not unit in selected_units:
		selected_units.append(unit)
		# Update UI if we auto-selected a new spawn
		_emit_selection_update()
	
	if unit.has_signal("destroyed"):
		unit.destroyed.connect(remove_unit.bind(unit), CONNECT_DEFERRED)

func remove_unit(unit: BaseUnit) -> void:
	var was_selected = unit in selected_units
	
	if unit in selected_units:
		selected_units.erase(unit)
		if is_instance_valid(unit): unit.set_selected(false)
	if unit in controllable_units:
		controllable_units.erase(unit)
	var unit_id = unit.get_instance_id()
	for group_num in control_groups:
		if control_groups[group_num].has(unit_id):
			control_groups[group_num].erase(unit_id)
			
	if was_selected:
		_emit_selection_update()

func _on_select_command(select_rect: Rect2, is_box_select: bool) -> void:
	_prune_dead_units()
	_clear_selection() # Clears array
	
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	if not main_camera: 
		_emit_selection_update() # Emit empty if camera missing
		return
	
	if is_box_select:
		var camera_pos = main_camera.get_screen_center_position()
		var camera_zoom = main_camera.zoom
		var viewport_size = get_viewport().get_visible_rect().size
		var world_rect_min = camera_pos - (viewport_size / (2.0 * camera_zoom)) + (select_rect.position / camera_zoom)
		var world_rect_max = world_rect_min + (select_rect.size / camera_zoom)
		var world_rect = Rect2(world_rect_min, world_rect_max - world_rect_min)
		
		for unit in controllable_units:
			if _is_squad_in_rect(unit, world_rect):
				selected_units.append(unit)
				unit.set_selected(true)
	else:
		var click_world_pos := main_camera.get_global_mouse_position()
		var closest_leader: BaseUnit = null
		var min_dist_sq = INF
		var click_radius_sq = 40 * 40
		
		for unit in controllable_units:
			var dist_sq = _get_closest_distance_to_squad(unit, click_world_pos)
			
			if dist_sq < min_dist_sq and dist_sq < click_radius_sq:
				min_dist_sq = dist_sq
				closest_leader = unit
				
		if closest_leader:
			selected_units.append(closest_leader)
			closest_leader.set_selected(true)
			
	print("DEBUG: Selection Updated. Count: ", selected_units.size())
	_emit_selection_update() # BROADCAST THE RESULT

func _is_squad_in_rect(unit: BaseUnit, rect: Rect2) -> bool:
	if rect.has_point(unit.global_position):
		return true
	if unit is SquadLeader:
		for soldier in unit.squad_soldiers:
			if is_instance_valid(soldier) and rect.has_point(soldier.global_position):
				return true
	return false

func _get_closest_distance_to_squad(unit: BaseUnit, point: Vector2) -> float:
	var min_d = unit.global_position.distance_squared_to(point)
	if unit is SquadLeader:
		for soldier in unit.squad_soldiers:
			if is_instance_valid(soldier):
				var d = soldier.global_position.distance_squared_to(point)
				if d < min_d:
					min_d = d
	return min_d

func _on_attack_command(target_node: Node2D) -> void:
	_validate_selection()
	for unit in selected_units:
		unit.command_attack(target_node)

func command_scramble(target_position: Vector2) -> void:
	_clear_selection()
	_emit_selection_update() # Emit empty after scramble
	
	for unit in controllable_units:
		if not is_instance_valid(unit): continue
		var panic_offset = Vector2(randf_range(-80, 80), randf_range(-80, 80))
		var unique_dest = target_position + panic_offset
		if unit.fsm and unit.fsm.has_method("command_retreat"):
			unit.fsm.command_retreat(unique_dest)
		else:
			unit.command_move_to(unique_dest)

func _validate_selection() -> void:
	var valid_units: Array[BaseUnit] = []
	for unit in selected_units:
		if is_instance_valid(unit): valid_units.append(unit)
	selected_units = valid_units

func _clear_selection() -> void:
	for unit in selected_units:
		if is_instance_valid(unit): unit.set_selected(false)
	selected_units.clear()

func _on_control_group_command(group_index: int, is_assigning: bool) -> void:
	if is_assigning: _set_control_group(group_index)
	else: _select_control_group(group_index)

func _on_formation_change_command(formation_type: int) -> void:
	current_formation = formation_type as SquadFormation.FormationType

func _set_control_group(num: int) -> void:
	control_groups[num].clear()
	for unit in selected_units:
		control_groups[num].append(unit.get_instance_id())

func _select_control_group(num: int) -> void:
	_clear_selection()
	var new_group_ids = control_groups[num]
	for unit_id in new_group_ids:
		var unit = instance_from_id(unit_id) as BaseUnit
		if is_instance_valid(unit) and unit in controllable_units:
			selected_units.append(unit)
			unit.set_selected(true)
	
	_emit_selection_update() # BROADCAST GROUP SELECTION

func _prune_dead_units() -> void:
	var alive_units: Array[BaseUnit] = []
	for unit in controllable_units:
		if is_instance_valid(unit):
			alive_units.append(unit)
	controllable_units = alive_units

func _on_pillage_command(target_node: Node2D) -> void:
	_validate_selection()
	if selected_units.is_empty(): return
	
	Loggie.msg("RTSController: Ordering %d units to Pillage %s" % [selected_units.size(), target_node.name]).domain("RTS").info()
	
	for unit in selected_units:
		if unit.fsm and unit.fsm.has_method("command_pillage"):
			unit.fsm.command_pillage(target_node)
		else:
			unit.command_move_to(target_node.global_position)


--------------------------------------------------
FILE: res:///player/RTSController.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://cyp3t7gbdg0wx"]

[ext_resource type="Script" uid="uid://dfyoxn7wr5p5q" path="res://player/RTSController.gd" id="1_bmfgp"]

[node name="RTSController" type="Node"]
script = ExtResource("1_bmfgp")


--------------------------------------------------
FILE: res:///player/RTSInputHandler.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bvsuoj3irdvcs"]

[ext_resource type="Script" uid="uid://bm330jy5v6a7d" path="res://scripts/utility/RTSInputHandler.gd" id="1_ifvy5"]

[node name="RtsInputHandler" type="Node"]
script = ExtResource("1_ifvy5")


--------------------------------------------------
FILE: res:///resources/rectangleshape2d_879319.tres
--------------------------------------------------
[gd_resource type="RectangleShape2D" format=3 uid="uid://bvjkr2ny3hnvo"]

[resource]
size = Vector2(25, 3)


--------------------------------------------------
FILE: res:///resources/separation_circle_shape.tres
--------------------------------------------------
[gd_resource type="CircleShape2D" format=3 uid="uid://bda7xb0judu2h"]

[resource]
radius = 40.0


--------------------------------------------------
FILE: res:///scenes/LevelDesignTemplate.tscn
--------------------------------------------------
[gd_scene load_steps=10 format=3 uid="uid://c1j8x0a4xfyvg"]

[ext_resource type="Script" uid="uid://2iyfg3te1n3y" path="res://scripts/utility/GridVisualizer.gd" id="2_hrpxt"]
[ext_resource type="Script" uid="uid://bt4qo8hj2kpn0" path="res://tools/EditorOnly.gd" id="2_qdkuo"]
[ext_resource type="Script" uid="uid://cb2ldxc7vxxah" path="res://data/buildings/Base_Building.gd" id="3_qdkuo"]
[ext_resource type="Resource" uid="uid://bs1e1mgqnldwq" path="res://data/buildings/GreatHall.tres" id="4_c0j6e"]
[ext_resource type="Resource" uid="uid://b2356vlfukf14" path="res://data/buildings/Bldg_Wall.tres" id="5_04n8u"]
[ext_resource type="Resource" uid="uid://ckedcnw210a8k" path="res://data/buildings/Monastery_Watchtower.tres" id="6_0tmrt"]
[ext_resource type="Resource" uid="uid://drx4sih8numo1" path="res://data/buildings/LumberYard.tres" id="7_vy6il"]
[ext_resource type="Resource" uid="uid://y7xhmemltm28" path="res://data/buildings/Player_Farm.tres" id="8_48g0g"]
[ext_resource type="Resource" uid="uid://b7p70u4vm3uem" path="res://data/buildings/Monastery_Chapel.tres" id="9_dpnga"]

[node name="LevelDesignTemplate" type="Node2D"]

[node name="LevelDesignerTools" type="Node2D" parent="."]
script = ExtResource("2_qdkuo")

[node name="GridVisualizer" type="Node2D" parent="LevelDesignerTools"]
script = ExtResource("2_hrpxt")

[node name="ReferenceRect" type="ReferenceRect" parent="LevelDesignerTools/GridVisualizer"]
custom_minimum_size = Vector2(1920, 1280)
offset_right = 40.0
offset_bottom = 40.0
border_width = 4.0

[node name="Instructions (Won\'t be in final scene)" type="Label" parent="LevelDesignerTools"]
offset_right = 603.0
offset_bottom = 566.0
text = "--- LEVEL DESIGN WORKFLOW ---

1. SCENE SETUP:
   - Go to Scene > \"Save Scene As...\" immediately (e.g., designs/river_fort.tscn).
   - IMPORTANT: Your TERRAIN visuals are saved in this .tscn file.

2. TERRAIN (Visuals):
   - Select the 'TileMapLayer' node.
   - Use the TileMap editor to paint Ground, Water, and Decoration.
   - (Terrain does not export to the .tres file; it loads with the scene).

3. BUILDINGS (Data/Logic):
   - Expand the '_Palette' node (hidden by default).
   - Select a building -> Press Ctrl+D (Duplicate).
   - Drag the duplicate into 'BuildingContainer'.
   - Move it to the desired position on the grid.

4. EXPORT BUILDING DATA:
   - Open 'tools/LevelExporter.gd' in the Script Editor.
   - Update 'TARGET_SAVE_PATH' to your destination (e.g., res://data/settlements/river_fort.tres).
   - Run the script (File > Run or Ctrl+Shift+X).
   - This creates the data file used by the Raid System.

-----------------------------
(This label will disappear in-game)"

[node name="_Palette" type="Node2D" parent="LevelDesignerTools"]
visible = false

[node name="Civilian" type="Node2D" parent="LevelDesignerTools/_Palette"]

[node name="GreatHall_ref" type="StaticBody2D" parent="LevelDesignerTools/_Palette/Civilian"]
script = ExtResource("3_qdkuo")
data = ExtResource("4_c0j6e")

[node name="Lumber_ref" type="StaticBody2D" parent="LevelDesignerTools/_Palette/Civilian"]
script = ExtResource("3_qdkuo")
data = ExtResource("7_vy6il")

[node name="Farm_ref" type="StaticBody2D" parent="LevelDesignerTools/_Palette/Civilian"]
script = ExtResource("3_qdkuo")
data = ExtResource("8_48g0g")

[node name="Chapel_ref" type="StaticBody2D" parent="LevelDesignerTools/_Palette/Civilian"]
script = ExtResource("3_qdkuo")
data = ExtResource("9_dpnga")

[node name="Military" type="Node2D" parent="LevelDesignerTools/_Palette"]

[node name="Watchtower_ref" type="StaticBody2D" parent="LevelDesignerTools/_Palette/Military"]
script = ExtResource("3_qdkuo")
data = ExtResource("6_0tmrt")

[node name="Walls" type="Node2D" parent="LevelDesignerTools/_Palette"]

[node name="Wall_ref" type="StaticBody2D" parent="LevelDesignerTools/_Palette/Walls"]
script = ExtResource("3_qdkuo")
data = ExtResource("5_04n8u")

[node name="TileMapLayer" type="TileMapLayer" parent="."]

[node name="BuildingContainer" type="Node2D" parent="."]


--------------------------------------------------
FILE: res:///scenes/buildings/Base_Building.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://cws6xle5x52g4"]

[ext_resource type="Script" uid="uid://cb2ldxc7vxxah" path="res://data/buildings/Base_Building.gd" id="1_script"]

[node name="Base_Building" type="StaticBody2D"]
script = ExtResource("1_script")


--------------------------------------------------
FILE: res:///scenes/components/AttackAI.gd
--------------------------------------------------
# res://scenes/components/AttackAI.gd
class_name AttackAI
extends Node2D

signal attack_started(target: Node2D)
signal attack_stopped()
signal about_to_attack(target: Node2D, damage: int)

enum AI_Mode { DEFAULT, DEFENSIVE_SIEGE }
@export var ai_mode: AI_Mode = AI_Mode.DEFAULT
@export var great_hall_los_range: float = 600.0

@export var attack_damage: int = 10
@export var attack_range: float = 200.0
@export var attack_speed: float = 1.0 
@export var projectile_scene: PackedScene
# --- RESTORED ---
var building_attack_range: float = 45.0
# ----------------

var target_collision_mask: int = 0
var projectile_speed: float = 400.0

@onready var detection_area: Area2D = $DetectionArea
@onready var attack_timer: Timer = $AttackTimer

var parent_node: Node2D
var current_target: Node2D = null
var targets_in_range: Array[Node2D] = []
var is_attacking: bool = false

func _ready() -> void:
	parent_node = get_parent() as Node2D
	if not parent_node: return
	_setup_ai()

func _setup_ai() -> void:
	if detection_area:
		detection_area.collision_layer = 0
		detection_area.collision_mask = target_collision_mask
		if detection_area.get_child(0) is CollisionShape2D:
			var s = detection_area.get_child(0) as CollisionShape2D
			if s.shape is CircleShape2D: (s.shape as CircleShape2D).radius = attack_range
		detection_area.body_entered.connect(_on_target_entered)
		detection_area.area_entered.connect(_on_target_entered)
		detection_area.body_exited.connect(_on_target_exited)
		detection_area.area_exited.connect(_on_target_exited)
	
	if attack_timer:
		attack_timer.timeout.connect(_on_attack_timer_timeout)
		if attack_speed > 0: attack_timer.wait_time = 1.0 / attack_speed

func configure_from_data(data) -> void:
	if not data: return
	if "attack_damage" in data: attack_damage = data.attack_damage
	if "attack_range" in data: attack_range = data.attack_range
	# --- RESTORED ---
	
	if "building_attack_range" in data: 
		building_attack_range = data.building_attack_range
	else:
		building_attack_range = attack_range + 30.0 # Fallback
	
	if "attack_speed" in data: attack_speed = data.attack_speed
	if "projectile_scene" in data: projectile_scene = data.projectile_scene
	if "projectile_speed" in data: projectile_speed = data.projectile_speed
	
	if attack_timer and attack_speed > 0: attack_timer.wait_time = 1.0 / attack_speed

func set_target_mask(mask: int) -> void:
	target_collision_mask = mask
	if detection_area: detection_area.collision_mask = mask

func force_target(target: Node2D) -> void:
	print("DEBUG AI: force_target called for %s" % target.name)
	
	if not is_instance_valid(target): 
		print("DEBUG AI: force_target aborted (Invalid Target)")
		return
	
	var actual_target = target
	if target is BaseBuilding and target.has_node("Hitbox"): 
		actual_target = target.get_node("Hitbox")
	
	current_target = actual_target
	if current_target not in targets_in_range: 
		targets_in_range.append(current_target)
	
	_start_attacking()

func stop_attacking() -> void:
	current_target = null
	_stop_attacking()

func _on_target_entered(body: Node2D) -> void:
	#Ignore targets if Brain is disabled (Pillaging) ---
	if not is_processing(): return
	
	if body not in targets_in_range: targets_in_range.append(body)
	if not current_target: _select_target()

func _on_target_exited(body: Node2D) -> void:
	targets_in_range.erase(body)
	if current_target == body:
		current_target = null
		_select_target()

func _select_target() -> void:
	# --- FIX: Don't pick targets if disabled (Pillaging) ---
	if not is_processing(): return
	# -------------------------------------------
	
	match ai_mode:
		AI_Mode.DEFAULT:
			_select_target_default()
		AI_Mode.DEFENSIVE_SIEGE:
			_select_target_defensive_siege()
			

func _select_target_default() -> void:
	"""Select the closest valid target, prioritizing units over buildings."""
	if targets_in_range.is_empty():
		current_target = null
		_stop_attacking()
		return
	
	var unit_targets: Array[Node2D] = []
	var building_targets: Array[Node2D] = []

	for target in targets_in_range:
		if not is_instance_valid(target):
			targets_in_range.erase(target)
			continue
		
		# Enforce Collision Mask
		if not (target.collision_layer & target_collision_mask):
			continue

		# Determine type based on layer
		if target.collision_layer & 6: # Layer 2 or 3 (Units)
			unit_targets.append(target)
		elif target.collision_layer & 9: # Layer 1 or 4 (Buildings)
			building_targets.append(target)

	var closest_target: Node2D = null
	var closest_distance: float = INF
	
	# Priority: Units First
	var search_list = unit_targets if not unit_targets.is_empty() else building_targets
	
	for target in search_list:
		# Use Smart Range (Edge-to-Edge)
		var dist_center = parent_node.global_position.distance_to(target.global_position)
		var radius = _get_target_radius(target)
		var distance = max(0, dist_center - radius)
		
		if distance < closest_distance:
			closest_distance = distance
			closest_target = target
	
	current_target = closest_target
	
	if current_target:
		_start_attacking()
	else:
		_stop_attacking()

func _select_target_defensive_siege() -> void:
	"""
	Enemy AI logic: Prioritize Great Hall, then closest building.
	"""
	var unit_parent = parent_node as BaseUnit
	if not is_instance_valid(unit_parent) or not unit_parent.fsm:
		_stop_attacking()
		return

	# 1. Check for Great Hall (Priority 1)
	# The FSM holds the "Main Objective" target
	var great_hall = unit_parent.fsm.objective_target
	if is_instance_valid(great_hall):
		var hall_pos = great_hall.global_position
		var distance_to_hall = parent_node.global_position.distance_to(hall_pos)
		
		# If the Great Hall is within "Line of Sight", ignore everything else
		if distance_to_hall <= great_hall_los_range:
			current_target = great_hall
			_start_attacking()
			return

	# 2. Find Closest Building (Priority 2)
	# If we can't see the Hall, attack whatever building is closest
	var closest_building: Node2D = null
	var closest_distance: float = INF
	
	for target in targets_in_range:
		if not is_instance_valid(target):
			targets_in_range.erase(target)
			continue
			
		if not (target.collision_layer & target_collision_mask):
			continue
		
		# Check if it's a Building (Layer 1 or 4 typically)
		# 9 = Binary 1001 (Layer 1 + Layer 4)
		if target.collision_layer & 9: 
			# Use Smart Range (Edge-to-Edge)
			var dist_center = parent_node.global_position.distance_to(target.global_position)
			var radius = _get_target_radius(target)
			var distance = max(0, dist_center - radius)
			
			if distance < closest_distance:
				closest_distance = distance
				closest_building = target
	
	current_target = closest_building
	
	if current_target:
		_start_attacking()
	else:
		_stop_attacking()

# --- HELPER: Get Target Radius ---
func _get_target_radius(target: Node2D) -> float:
	"""
	Estimates the radius of the target for accurate distance checks.
	Crucial for large buildings.
	"""
	# 1. Check if it's a Building Hitbox
	if target.name == "Hitbox" and target.get_parent() is BaseBuilding:
		var building = target.get_parent() as BaseBuilding
		if building.data:
			# Approximate radius as half the smallest side of the building
			# (32 is standard cell size)
			var size = min(building.data.grid_size.x, building.data.grid_size.y)
			return (size * 32.0) / 2.0
			
	# 2. Check if it's a Unit (BaseUnit)
	if target is BaseUnit:
		return 15.0 # Standard unit radius
		
	# 3. Fallback: Check for CollisionShape
	var col = target.get_node_or_null("CollisionShape2D")
	if col:
		if col.shape is CircleShape2D:
			return col.shape.radius
		elif col.shape is RectangleShape2D:
			var extents = col.shape.size / 2.0
			return min(extents.x, extents.y)
			
	return 0.0

func _start_attacking() -> void:
	print("DEBUG AI: _start_attacking called.")
	
	if not is_attacking:
		is_attacking = true
		attack_started.emit(current_target)
	
	# Manually fire the first shot immediately
	print("DEBUG AI: Manually calling timeout (First Shot)...")
	_on_attack_timer_timeout()
	
	if attack_timer.is_stopped():
		print("DEBUG AI: Starting Timer.")
		attack_timer.start()
	else:
		print("DEBUG AI: Timer already running.")

func _stop_attacking() -> void:
	if is_attacking:
		is_attacking = false
		attack_stopped.emit()
	if attack_timer: attack_timer.stop()

func _on_attack_timer_timeout() -> void:
	# 1. Processing Check
	if not is_processing(): 
		# print("DEBUG AI: Abort - Not processing.")
		_stop_attacking()
		return
		
	# 2. Target Validity
	if not is_instance_valid(current_target):
		print("DEBUG AI: Abort - Invalid Target.")
		_stop_attacking()
		return
		
	# 3. Range Check
	var limit = attack_range
	if current_target is BaseBuilding or (current_target.name == "Hitbox" and current_target.get_parent() is BaseBuilding):
		limit = building_attack_range
		
	var dist = parent_node.global_position.distance_to(current_target.global_position)
	var r_target = _get_target_radius(current_target)
	var r_self = 15.0 
	var surface_dist = max(0, dist - r_target - r_self)
	
	# Tolerance buffer (10.0)
	if surface_dist > limit + 10.0:
		print("DEBUG AI: Abort - Out of Range! Current: %.1f > Limit: %.1f (Base: %.1f)" % [surface_dist, limit, attack_range])
		_stop_attacking()
		return

	# 4. Action
	about_to_attack.emit(current_target, attack_damage)
	
	if projectile_scene:
		_spawn_projectile(current_target.global_position)
	else:
		var t = current_target
		if t.name == "Hitbox": t = t.get_parent()
		if t.has_method("take_damage"): 
			print("DEBUG AI: HIT! Dealt %d damage to %s" % [attack_damage, t.name])
			t.take_damage(attack_damage, parent_node)
		else:
			print("DEBUG AI: Abort - Target %s has no take_damage method!" % t.name)
			
func _spawn_projectile(target_pos: Vector2) -> void:
	if not projectile_scene: return
	var p = ProjectilePoolManager.get_projectile()
	if p: 
		p.firer = parent_node
		p.setup(parent_node.global_position, target_pos, attack_damage, projectile_speed, target_collision_mask)


--------------------------------------------------
FILE: res:///scenes/components/AttackAI.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://de3nko6b1rqyg"]

[ext_resource type="Script" uid="uid://cf6j84umrg0id" path="res://scenes/components/AttackAI.gd" id="1_2a4el"]

[sub_resource type="CircleShape2D" id="CircleShape2D_2baay"]

[node name="AttackAI" type="Node2D"]
script = ExtResource("1_2a4el")

[node name="DetectionArea" type="Area2D" parent="."]

[node name="CollisionShape2D" type="CollisionShape2D" parent="DetectionArea"]
shape = SubResource("CircleShape2D_2baay")

[node name="AttackTimer" type="Timer" parent="."]


--------------------------------------------------
FILE: res:///scenes/effects/Projectile.gd
--------------------------------------------------
# res://scenes/effects/Projectile.gd
class_name Projectile
extends Area2D

# Projectile properties
var damage: int = 0
var speed: float = 400.0
var direction: Vector2 = Vector2.RIGHT
var firer: Node2D = null

@onready var lifetime_timer: Timer = $LifetimeTimer

func _ready() -> void:
	# Connect signals if not already connected (safety for pooling)
	if not area_entered.is_connected(_on_area_entered):
		area_entered.connect(_on_area_entered)
	if not body_entered.is_connected(_on_body_entered):
		body_entered.connect(_on_body_entered)
	
	# Default state - ensure "off" by default
	set_deferred("monitoring", false)
	set_deferred("monitorable", false)
	set_physics_process(false)
	
	if lifetime_timer:
		lifetime_timer.timeout.connect(_on_lifetime_timeout)

func _physics_process(delta: float) -> void:
	global_position += direction * speed * delta

func setup(start_position: Vector2, target_position: Vector2, projectile_damage: int, projectile_speed: float = 400.0, collision_mask_value: int = 0) -> void:
	global_position = start_position
	direction = (target_position - start_position).normalized()
	damage = projectile_damage
	speed = projectile_speed
	
	# Rotate visual
	if direction != Vector2.ZERO:
		rotation = direction.angle()
	
	# --- CRITICAL FIX: Defer ALL physics state changes ---
	# Because setup() often runs during a physics callback (e.g. _on_body_entered),
	# direct assignments to collision properties will fail silently.
	
	set_deferred("collision_mask", collision_mask_value)
	set_deferred("monitoring", true)
	set_deferred("monitorable", false)
	
	show()
	
	# We also defer enabling the process loop to keep it in sync with physics
	call_deferred("set_physics_process", true)
	
	if lifetime_timer:
		lifetime_timer.start()

func return_to_pool() -> void:
	"""Deactivates the projectile and hides it."""
	# Defer disabling physics to avoid locking errors
	set_deferred("monitoring", false)
	set_deferred("collision_mask", 0) # Reset mask to clean state
	call_deferred("set_physics_process", false)
	
	hide()
	if lifetime_timer:
		lifetime_timer.stop()
	
	# Move far away to ensure no lingering collisions while deferral processes
	global_position = Vector2(-5000, -5000) 

func _on_area_entered(area: Area2D) -> void:
	# Check collision mask manually as a fallback, though physics engine handles it
	if area.collision_layer & self.collision_mask:
		_handle_impact(area.get_parent())

func _on_body_entered(body: Node2D) -> void:
	if body.collision_layer & self.collision_mask:
		_handle_impact(body)

func _handle_impact(target: Node2D) -> void:
	if not target: return
	
	if target.has_method("take_damage"):
		if is_instance_valid(firer):
			target.take_damage(damage, firer)
		else:
			target.take_damage(damage, null)
	
	# Return to pool
	ProjectilePoolManager.return_projectile(self)

func _on_lifetime_timeout() -> void:
	ProjectilePoolManager.return_projectile(self)


--------------------------------------------------
FILE: res:///scenes/effects/Projectile.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://d10havsaesr6i"]

[ext_resource type="Script" uid="uid://d06h6sthr3hm7" path="res://scenes/effects/Projectile.gd" id="1_t405p"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="2_pkw06"]
[ext_resource type="Shape2D" uid="uid://bvjkr2ny3hnvo" path="res://resources/rectangleshape2d_879319.tres" id="3_pkw06"]

[node name="Projectile" type="Area2D"]
scale = Vector2(2, 2)
collision_layer = 1024
collision_mask = 0
monitorable = false
script = ExtResource("1_t405p")

[node name="Sprite2D" type="Sprite2D" parent="."]
scale = Vector2(0.02470703, 0.0029296877)
texture = ExtResource("2_pkw06")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = ExtResource("3_pkw06")

[node name="LifetimeTimer" type="Timer" parent="."]
wait_time = 3.0
one_shot = true
autostart = true


--------------------------------------------------
FILE: res:///scenes/levels/DefensiveMicro.tscn
--------------------------------------------------
[gd_scene load_steps=8 format=3 uid="uid://cpe46srqjmdh6"]

[ext_resource type="Texture2D" uid="uid://c6v2d1q8q7e3j" path="res://assets/placeholder_tile.tres" id="1_a64e3"]
[ext_resource type="Script" uid="uid://cuw68f180xbui" path="res://scenes/missions/RaidMission.gd" id="1_vwpxa"]
[ext_resource type="PackedScene" uid="uid://cyp3t7gbdg0wx" path="res://player/RTSController.tscn" id="3_mb7gn"]
[ext_resource type="Script" uid="uid://bxbqkyp1d6750" path="res://player/RTSCamera.gd" id="4_5s02u"]
[ext_resource type="Script" uid="uid://by77ij2ft60cp" path="res://scenes/missions/RaidObjectiveManager.gd" id="6_o6jak"]

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_vwpxa"]
texture = ExtResource("1_a64e3")
texture_region_size = Vector2i(32, 32)
0:0/0 = 0

[sub_resource type="TileSet" id="TileSet_m5xuc"]
tile_size = Vector2i(32, 32)
sources/0 = SubResource("TileSetAtlasSource_vwpxa")

[node name="DefensiveMicro" type="Node2D"]
script = ExtResource("1_vwpxa")
is_defensive_mission = true

[node name="TileMap" type="TileMap" parent="."]
tile_set = SubResource("TileSet_m5xuc")
format = 2

[node name="PlayerStartPosition" type="Marker2D" parent="."]
position = Vector2(100, 400)

[node name="RTSController" parent="." instance=ExtResource("3_mb7gn")]

[node name="RTSCamera" type="Camera2D" parent="."]
position = Vector2(400, 300)
script = ExtResource("4_5s02u")

[node name="BuildingContainer" type="Node2D" parent="."]

[node name="RaidObjectiveManager" type="Node" parent="."]
script = ExtResource("6_o6jak")

[node name="EnemySpawnPosition" type="Marker2D" parent="."]
position = Vector2(700, 100)


--------------------------------------------------
FILE: res:///scenes/levels/Isometric Tileset.tres
--------------------------------------------------
[gd_resource type="TileSet" load_steps=5 format=3 uid="uid://xoe70lhybj8l"]

[ext_resource type="Texture2D" uid="uid://b7c36hqcjw04i" path="res://assets/IsoTilesComboSheet_Manual.png" id="1_87bkp"]
[ext_resource type="Texture2D" uid="uid://cnngsjfri5htk" path="res://assets/Deep_Combo.png" id="2_r0ym5"]

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_fmib8"]
resource_name = "I"
texture = ExtResource("1_87bkp")
texture_region_size = Vector2i(64, 64)
0:1/0 = 0
0:1/0/texture_origin = Vector2i(0, 16)
0:1/0/terrain_set = 0
0:1/0/terrain = 2
0:1/0/terrains_peering_bit/right_corner = 1
0:1/0/terrains_peering_bit/bottom_right_side = 1
0:1/0/terrains_peering_bit/bottom_corner = 2
0:1/0/terrains_peering_bit/bottom_left_side = 2
0:1/0/terrains_peering_bit/left_corner = 2
0:1/0/terrains_peering_bit/top_left_side = 2
0:1/0/terrains_peering_bit/top_corner = 2
0:1/0/terrains_peering_bit/top_right_side = 1
0:1/0/custom_data_0 = true
1:1/0 = 0
1:1/0/texture_origin = Vector2i(0, 16)
1:1/0/terrain_set = 0
1:1/0/terrain = 2
1:1/0/terrains_peering_bit/right_corner = 2
1:1/0/terrains_peering_bit/bottom_right_side = 2
1:1/0/terrains_peering_bit/bottom_corner = 2
1:1/0/terrains_peering_bit/bottom_left_side = 2
1:1/0/terrains_peering_bit/left_corner = 2
1:1/0/terrains_peering_bit/top_left_side = 1
1:1/0/terrains_peering_bit/top_corner = 1
1:1/0/terrains_peering_bit/top_right_side = 1
1:1/0/custom_data_0 = true
2:1/0 = 0
2:1/0/texture_origin = Vector2i(0, 16)
2:1/0/terrain_set = 0
2:1/0/terrain = 2
2:1/0/terrains_peering_bit/right_corner = 2
2:1/0/terrains_peering_bit/bottom_right_side = 2
2:1/0/terrains_peering_bit/bottom_corner = 2
2:1/0/terrains_peering_bit/bottom_left_side = 1
2:1/0/terrains_peering_bit/left_corner = 1
2:1/0/terrains_peering_bit/top_left_side = 1
2:1/0/terrains_peering_bit/top_corner = 2
2:1/0/terrains_peering_bit/top_right_side = 2
2:1/0/custom_data_0 = true
3:1/0 = 0
3:1/0/texture_origin = Vector2i(0, 16)
3:1/0/terrain_set = 0
3:1/0/terrain = 2
3:1/0/terrains_peering_bit/right_corner = 2
3:1/0/terrains_peering_bit/bottom_right_side = 1
3:1/0/terrains_peering_bit/bottom_corner = 1
3:1/0/terrains_peering_bit/bottom_left_side = 1
3:1/0/terrains_peering_bit/left_corner = 2
3:1/0/terrains_peering_bit/top_left_side = 2
3:1/0/terrains_peering_bit/top_corner = 2
3:1/0/terrains_peering_bit/top_right_side = 2
3:1/0/custom_data_0 = true
4:1/0 = 0
4:1/0/texture_origin = Vector2i(0, 16)
4:1/0/terrain_set = 0
4:1/0/terrain = 3
4:1/0/terrains_peering_bit/right_corner = 3
4:1/0/terrains_peering_bit/bottom_right_side = 3
4:1/0/terrains_peering_bit/bottom_corner = 3
4:1/0/terrains_peering_bit/bottom_left_side = 3
4:1/0/terrains_peering_bit/left_corner = 3
4:1/0/terrains_peering_bit/top_left_side = 3
4:1/0/terrains_peering_bit/top_corner = 3
4:1/0/terrains_peering_bit/top_right_side = 3
5:1/0 = 0
5:1/0/texture_origin = Vector2i(0, 16)
5:1/0/terrain_set = 0
5:1/0/terrain = 3
5:1/0/terrains_peering_bit/right_corner = 3
5:1/0/terrains_peering_bit/bottom_right_side = 3
5:1/0/terrains_peering_bit/bottom_corner = 3
5:1/0/terrains_peering_bit/bottom_left_side = 3
5:1/0/terrains_peering_bit/left_corner = 3
5:1/0/terrains_peering_bit/top_left_side = 3
5:1/0/terrains_peering_bit/top_corner = 3
5:1/0/terrains_peering_bit/top_right_side = 3
6:1/0 = 0
6:1/0/texture_origin = Vector2i(0, 16)
6:1/0/terrain_set = 0
6:1/0/terrain = 3
6:1/0/terrains_peering_bit/right_corner = 3
6:1/0/terrains_peering_bit/bottom_right_side = 3
6:1/0/terrains_peering_bit/bottom_corner = 3
6:1/0/terrains_peering_bit/bottom_left_side = 3
6:1/0/terrains_peering_bit/left_corner = 3
6:1/0/terrains_peering_bit/top_left_side = 3
6:1/0/terrains_peering_bit/top_corner = 3
6:1/0/terrains_peering_bit/top_right_side = 3
7:1/0 = 0
7:1/0/texture_origin = Vector2i(0, 16)
7:1/0/terrain_set = 0
7:1/0/terrain = 3
7:1/0/terrains_peering_bit/right_corner = 3
7:1/0/terrains_peering_bit/bottom_right_side = 3
7:1/0/terrains_peering_bit/bottom_corner = 3
7:1/0/terrains_peering_bit/bottom_left_side = 3
7:1/0/terrains_peering_bit/left_corner = 3
7:1/0/terrains_peering_bit/top_left_side = 3
7:1/0/terrains_peering_bit/top_corner = 3
7:1/0/terrains_peering_bit/top_right_side = 3
0:2/0 = 0
0:2/0/texture_origin = Vector2i(0, 16)
0:2/0/terrain_set = 0
0:2/0/terrain = 1
0:2/0/terrains_peering_bit/right_corner = 1
0:2/0/terrains_peering_bit/bottom_right_side = 1
0:2/0/terrains_peering_bit/bottom_corner = 1
0:2/0/terrains_peering_bit/bottom_left_side = 2
0:2/0/terrains_peering_bit/left_corner = 2
0:2/0/terrains_peering_bit/top_left_side = 2
0:2/0/terrains_peering_bit/top_corner = 1
0:2/0/terrains_peering_bit/top_right_side = 1
0:2/0/custom_data_0 = true
1:2/0 = 0
1:2/0/texture_origin = Vector2i(0, 16)
1:2/0/terrain_set = 0
1:2/0/terrain = 1
1:2/0/terrains_peering_bit/right_corner = 1
1:2/0/terrains_peering_bit/bottom_right_side = 2
1:2/0/terrains_peering_bit/bottom_corner = 2
1:2/0/terrains_peering_bit/bottom_left_side = 2
1:2/0/terrains_peering_bit/left_corner = 1
1:2/0/terrains_peering_bit/top_left_side = 1
1:2/0/terrains_peering_bit/top_corner = 1
1:2/0/terrains_peering_bit/top_right_side = 1
1:2/0/custom_data_0 = true
2:2/0 = 0
2:2/0/texture_origin = Vector2i(0, 16)
2:2/0/terrain_set = 0
2:2/0/terrain = 1
2:2/0/terrains_peering_bit/right_corner = 2
2:2/0/terrains_peering_bit/bottom_right_side = 2
2:2/0/terrains_peering_bit/bottom_corner = 1
2:2/0/terrains_peering_bit/bottom_left_side = 1
2:2/0/terrains_peering_bit/left_corner = 1
2:2/0/terrains_peering_bit/top_left_side = 1
2:2/0/terrains_peering_bit/top_corner = 1
2:2/0/terrains_peering_bit/top_right_side = 2
2:2/0/custom_data_0 = true
3:2/0 = 0
3:2/0/texture_origin = Vector2i(0, 16)
3:2/0/terrain_set = 0
3:2/0/terrain = 1
3:2/0/terrains_peering_bit/right_corner = 1
3:2/0/terrains_peering_bit/bottom_right_side = 1
3:2/0/terrains_peering_bit/bottom_corner = 1
3:2/0/terrains_peering_bit/bottom_left_side = 1
3:2/0/terrains_peering_bit/left_corner = 1
3:2/0/terrains_peering_bit/top_left_side = 2
3:2/0/terrains_peering_bit/top_corner = 2
3:2/0/terrains_peering_bit/top_right_side = 2
3:2/0/custom_data_0 = true
4:2/0 = 0
4:2/0/texture_origin = Vector2i(0, 16)
4:2/0/terrain_set = 0
4:2/0/terrain = 3
4:2/0/terrains_peering_bit/right_corner = 3
4:2/0/terrains_peering_bit/bottom_right_side = 3
4:2/0/terrains_peering_bit/bottom_corner = 3
4:2/0/terrains_peering_bit/bottom_left_side = 3
4:2/0/terrains_peering_bit/left_corner = 3
4:2/0/terrains_peering_bit/top_left_side = 3
4:2/0/terrains_peering_bit/top_corner = 3
4:2/0/terrains_peering_bit/top_right_side = 3
5:2/0 = 0
5:2/0/texture_origin = Vector2i(0, 16)
5:2/0/terrain_set = 0
5:2/0/terrain = 3
5:2/0/terrains_peering_bit/right_corner = 3
5:2/0/terrains_peering_bit/bottom_right_side = 3
5:2/0/terrains_peering_bit/bottom_corner = 3
5:2/0/terrains_peering_bit/bottom_left_side = 3
5:2/0/terrains_peering_bit/left_corner = 3
5:2/0/terrains_peering_bit/top_left_side = 3
5:2/0/terrains_peering_bit/top_corner = 3
5:2/0/terrains_peering_bit/top_right_side = 3
6:2/0 = 0
6:2/0/texture_origin = Vector2i(0, 16)
6:2/0/terrain_set = 0
6:2/0/terrain = 3
6:2/0/terrains_peering_bit/right_corner = 3
6:2/0/terrains_peering_bit/bottom_right_side = 3
6:2/0/terrains_peering_bit/bottom_corner = 3
6:2/0/terrains_peering_bit/bottom_left_side = 3
6:2/0/terrains_peering_bit/left_corner = 3
6:2/0/terrains_peering_bit/top_left_side = 3
6:2/0/terrains_peering_bit/top_corner = 3
6:2/0/terrains_peering_bit/top_right_side = 3
7:2/0 = 0
7:2/0/texture_origin = Vector2i(0, 15)
7:2/0/terrain_set = 0
7:2/0/terrain = 3
7:2/0/terrains_peering_bit/right_corner = 3
7:2/0/terrains_peering_bit/bottom_right_side = 3
7:2/0/terrains_peering_bit/bottom_corner = 3
7:2/0/terrains_peering_bit/bottom_left_side = 3
7:2/0/terrains_peering_bit/left_corner = 3
7:2/0/terrains_peering_bit/top_left_side = 3
7:2/0/terrains_peering_bit/top_corner = 3
7:2/0/terrains_peering_bit/top_right_side = 3
0:3/0 = 0
0:3/0/texture_origin = Vector2i(0, 16)
0:3/0/terrain_set = 0
0:3/0/terrain = 2
0:3/0/terrains_peering_bit/right_corner = 1
0:3/0/terrains_peering_bit/bottom_right_side = 2
0:3/0/terrains_peering_bit/bottom_corner = 2
0:3/0/terrains_peering_bit/bottom_left_side = 2
0:3/0/terrains_peering_bit/left_corner = 2
0:3/0/terrains_peering_bit/top_left_side = 2
0:3/0/terrains_peering_bit/top_corner = 1
0:3/0/terrains_peering_bit/top_right_side = 1
0:3/0/custom_data_0 = true
1:3/0 = 0
1:3/0/texture_origin = Vector2i(0, 16)
1:3/0/terrain_set = 0
1:3/0/terrain = 2
1:3/0/terrains_peering_bit/right_corner = 2
1:3/0/terrains_peering_bit/bottom_right_side = 2
1:3/0/terrains_peering_bit/bottom_corner = 2
1:3/0/terrains_peering_bit/bottom_left_side = 2
1:3/0/terrains_peering_bit/left_corner = 1
1:3/0/terrains_peering_bit/top_left_side = 1
1:3/0/terrains_peering_bit/top_corner = 1
1:3/0/terrains_peering_bit/top_right_side = 2
1:3/0/custom_data_0 = true
2:3/0 = 0
2:3/0/texture_origin = Vector2i(0, 16)
2:3/0/terrain_set = 0
2:3/0/terrain = 2
2:3/0/terrains_peering_bit/right_corner = 2
2:3/0/terrains_peering_bit/bottom_right_side = 2
2:3/0/terrains_peering_bit/bottom_corner = 1
2:3/0/terrains_peering_bit/bottom_left_side = 1
2:3/0/terrains_peering_bit/left_corner = 1
2:3/0/terrains_peering_bit/top_left_side = 2
2:3/0/terrains_peering_bit/top_corner = 2
2:3/0/terrains_peering_bit/top_right_side = 2
2:3/0/custom_data_0 = true
3:3/0 = 0
3:3/0/texture_origin = Vector2i(0, 16)
3:3/0/terrain_set = 0
3:3/0/terrain = 2
3:3/0/terrains_peering_bit/right_corner = 1
3:3/0/terrains_peering_bit/bottom_right_side = 1
3:3/0/terrains_peering_bit/bottom_corner = 1
3:3/0/terrains_peering_bit/bottom_left_side = 2
3:3/0/terrains_peering_bit/left_corner = 2
3:3/0/terrains_peering_bit/top_left_side = 2
3:3/0/terrains_peering_bit/top_corner = 2
3:3/0/terrains_peering_bit/top_right_side = 2
3:3/0/custom_data_0 = true
4:3/0 = 0
4:3/0/texture_origin = Vector2i(0, 16)
4:3/0/terrain_set = 0
4:3/0/terrain = 3
4:3/0/terrains_peering_bit/right_corner = 3
4:3/0/terrains_peering_bit/bottom_right_side = 3
4:3/0/terrains_peering_bit/bottom_corner = 3
4:3/0/terrains_peering_bit/bottom_left_side = 3
4:3/0/terrains_peering_bit/left_corner = 3
4:3/0/terrains_peering_bit/top_left_side = 3
4:3/0/terrains_peering_bit/top_corner = 3
4:3/0/terrains_peering_bit/top_right_side = 3
5:3/0 = 0
5:3/0/texture_origin = Vector2i(0, 16)
5:3/0/terrain_set = 0
5:3/0/terrain = 3
5:3/0/terrains_peering_bit/right_corner = 3
5:3/0/terrains_peering_bit/bottom_right_side = 3
5:3/0/terrains_peering_bit/bottom_corner = 3
5:3/0/terrains_peering_bit/bottom_left_side = 3
5:3/0/terrains_peering_bit/left_corner = 3
5:3/0/terrains_peering_bit/top_left_side = 3
5:3/0/terrains_peering_bit/top_corner = 3
5:3/0/terrains_peering_bit/top_right_side = 3
6:3/0 = 0
6:3/0/texture_origin = Vector2i(0, 16)
6:3/0/terrain_set = 0
6:3/0/terrain = 3
6:3/0/terrains_peering_bit/right_corner = 3
6:3/0/terrains_peering_bit/bottom_right_side = 3
6:3/0/terrains_peering_bit/bottom_corner = 3
6:3/0/terrains_peering_bit/bottom_left_side = 3
6:3/0/terrains_peering_bit/left_corner = 3
6:3/0/terrains_peering_bit/top_left_side = 3
6:3/0/terrains_peering_bit/top_corner = 3
6:3/0/terrains_peering_bit/top_right_side = 3
7:3/0 = 0
7:3/0/texture_origin = Vector2i(0, 16)
7:3/0/terrain_set = 0
7:3/0/terrain = 3
7:3/0/terrains_peering_bit/right_corner = 3
7:3/0/terrains_peering_bit/bottom_right_side = 3
7:3/0/terrains_peering_bit/bottom_corner = 3
7:3/0/terrains_peering_bit/bottom_left_side = 3
7:3/0/terrains_peering_bit/left_corner = 3
7:3/0/terrains_peering_bit/top_left_side = 3
7:3/0/terrains_peering_bit/top_corner = 3
7:3/0/terrains_peering_bit/top_right_side = 3
0:5/0 = 0
0:5/0/texture_origin = Vector2i(0, 16)
0:5/0/terrain_set = 0
0:5/0/terrain = 1
0:5/0/terrains_peering_bit/right_corner = 1
0:5/0/terrains_peering_bit/bottom_right_side = 1
0:5/0/terrains_peering_bit/bottom_corner = 1
0:5/0/terrains_peering_bit/bottom_left_side = 1
0:5/0/terrains_peering_bit/left_corner = 1
0:5/0/terrains_peering_bit/top_left_side = 0
0:5/0/terrains_peering_bit/top_corner = 0
0:5/0/terrains_peering_bit/top_right_side = 0
1:5/0 = 0
1:5/0/texture_origin = Vector2i(0, 16)
1:5/0/terrain_set = 0
1:5/0/terrain = 1
1:5/0/terrains_peering_bit/right_corner = 1
1:5/0/terrains_peering_bit/bottom_right_side = 1
1:5/0/terrains_peering_bit/bottom_corner = 1
1:5/0/terrains_peering_bit/bottom_left_side = 0
1:5/0/terrains_peering_bit/left_corner = 0
1:5/0/terrains_peering_bit/top_left_side = 0
1:5/0/terrains_peering_bit/top_corner = 1
1:5/0/terrains_peering_bit/top_right_side = 1
2:5/0 = 0
2:5/0/texture_origin = Vector2i(0, 16)
2:5/0/terrain_set = 0
2:5/0/terrain = 1
2:5/0/terrains_peering_bit/right_corner = 1
2:5/0/terrains_peering_bit/bottom_right_side = 0
2:5/0/terrains_peering_bit/bottom_corner = 0
2:5/0/terrains_peering_bit/bottom_left_side = 0
2:5/0/terrains_peering_bit/left_corner = 1
2:5/0/terrains_peering_bit/top_left_side = 1
2:5/0/terrains_peering_bit/top_corner = 1
2:5/0/terrains_peering_bit/top_right_side = 1
3:5/0 = 0
3:5/0/texture_origin = Vector2i(0, 16)
3:5/0/terrain_set = 0
3:5/0/terrain = 1
3:5/0/terrains_peering_bit/right_corner = 0
3:5/0/terrains_peering_bit/bottom_right_side = 0
3:5/0/terrains_peering_bit/bottom_corner = 1
3:5/0/terrains_peering_bit/bottom_left_side = 1
3:5/0/terrains_peering_bit/left_corner = 1
3:5/0/terrains_peering_bit/top_left_side = 1
3:5/0/terrains_peering_bit/top_corner = 1
3:5/0/terrains_peering_bit/top_right_side = 0
4:5/0 = 0
4:5/0/texture_origin = Vector2i(0, 16)
4:5/0/terrain_set = 0
4:5/0/terrain = 3
4:5/0/terrains_peering_bit/right_corner = 3
4:5/0/terrains_peering_bit/bottom_right_side = 3
4:5/0/terrains_peering_bit/bottom_corner = 3
4:5/0/terrains_peering_bit/bottom_left_side = 3
4:5/0/terrains_peering_bit/left_corner = 3
4:5/0/terrains_peering_bit/top_left_side = 3
4:5/0/terrains_peering_bit/top_corner = 3
4:5/0/terrains_peering_bit/top_right_side = 3
5:5/0 = 0
5:5/0/texture_origin = Vector2i(0, 16)
5:5/0/terrain_set = 0
5:5/0/terrain = 3
5:5/0/terrains_peering_bit/right_corner = 3
5:5/0/terrains_peering_bit/bottom_right_side = 3
5:5/0/terrains_peering_bit/bottom_corner = 3
5:5/0/terrains_peering_bit/bottom_left_side = 3
5:5/0/terrains_peering_bit/left_corner = 3
5:5/0/terrains_peering_bit/top_left_side = 3
5:5/0/terrains_peering_bit/top_corner = 3
5:5/0/terrains_peering_bit/top_right_side = 3
6:5/0 = 0
6:5/0/texture_origin = Vector2i(0, 16)
6:5/0/terrain_set = 0
6:5/0/terrain = 3
6:5/0/terrains_peering_bit/right_corner = 3
6:5/0/terrains_peering_bit/bottom_right_side = 3
6:5/0/terrains_peering_bit/bottom_corner = 3
6:5/0/terrains_peering_bit/bottom_left_side = 3
6:5/0/terrains_peering_bit/left_corner = 3
6:5/0/terrains_peering_bit/top_left_side = 3
6:5/0/terrains_peering_bit/top_corner = 3
6:5/0/terrains_peering_bit/top_right_side = 3
7:5/0 = 0
7:5/0/texture_origin = Vector2i(0, 16)
7:5/0/terrain_set = 0
7:5/0/terrain = 3
7:5/0/terrains_peering_bit/right_corner = 3
7:5/0/terrains_peering_bit/bottom_right_side = 3
7:5/0/terrains_peering_bit/bottom_corner = 3
7:5/0/terrains_peering_bit/bottom_left_side = 3
7:5/0/terrains_peering_bit/left_corner = 3
7:5/0/terrains_peering_bit/top_left_side = 3
7:5/0/terrains_peering_bit/top_corner = 3
7:5/0/terrains_peering_bit/top_right_side = 3
0:6/0 = 0
0:6/0/texture_origin = Vector2i(0, 16)
0:6/0/terrain_set = 0
0:6/0/terrain = 0
0:6/0/terrains_peering_bit/right_corner = 0
0:6/0/terrains_peering_bit/bottom_right_side = 0
0:6/0/terrains_peering_bit/bottom_corner = 0
0:6/0/terrains_peering_bit/bottom_left_side = 0
0:6/0/terrains_peering_bit/left_corner = 0
0:6/0/terrains_peering_bit/top_left_side = 1
0:6/0/terrains_peering_bit/top_corner = 1
0:6/0/terrains_peering_bit/top_right_side = 1
1:6/0 = 0
1:6/0/texture_origin = Vector2i(0, 16)
1:6/0/terrain_set = 0
1:6/0/terrain = 0
1:6/0/terrains_peering_bit/right_corner = 0
1:6/0/terrains_peering_bit/bottom_right_side = 0
1:6/0/terrains_peering_bit/bottom_corner = 0
1:6/0/terrains_peering_bit/bottom_left_side = 1
1:6/0/terrains_peering_bit/left_corner = 1
1:6/0/terrains_peering_bit/top_left_side = 1
1:6/0/terrains_peering_bit/top_corner = 0
1:6/0/terrains_peering_bit/top_right_side = 0
2:6/0 = 0
2:6/0/texture_origin = Vector2i(0, 16)
2:6/0/terrain_set = 0
2:6/0/terrain = 0
2:6/0/terrains_peering_bit/right_corner = 0
2:6/0/terrains_peering_bit/bottom_right_side = 1
2:6/0/terrains_peering_bit/bottom_corner = 1
2:6/0/terrains_peering_bit/bottom_left_side = 1
2:6/0/terrains_peering_bit/left_corner = 0
2:6/0/terrains_peering_bit/top_left_side = 0
2:6/0/terrains_peering_bit/top_corner = 0
2:6/0/terrains_peering_bit/top_right_side = 0
3:6/0 = 0
3:6/0/texture_origin = Vector2i(0, 16)
3:6/0/terrain_set = 0
3:6/0/terrain = 0
3:6/0/terrains_peering_bit/right_corner = 1
3:6/0/terrains_peering_bit/bottom_right_side = 1
3:6/0/terrains_peering_bit/bottom_corner = 0
3:6/0/terrains_peering_bit/bottom_left_side = 0
3:6/0/terrains_peering_bit/left_corner = 0
3:6/0/terrains_peering_bit/top_left_side = 0
3:6/0/terrains_peering_bit/top_corner = 0
3:6/0/terrains_peering_bit/top_right_side = 1
4:6/0 = 0
4:6/0/texture_origin = Vector2i(0, 16)
4:6/0/terrain_set = 0
4:6/0/terrain = 3
4:6/0/terrains_peering_bit/right_corner = 3
4:6/0/terrains_peering_bit/bottom_right_side = 3
4:6/0/terrains_peering_bit/bottom_corner = 3
4:6/0/terrains_peering_bit/bottom_left_side = 3
4:6/0/terrains_peering_bit/left_corner = 3
4:6/0/terrains_peering_bit/top_left_side = 3
4:6/0/terrains_peering_bit/top_corner = 3
4:6/0/terrains_peering_bit/top_right_side = 3
5:6/0 = 0
5:6/0/texture_origin = Vector2i(0, 16)
5:6/0/terrain_set = 0
5:6/0/terrain = 3
5:6/0/terrains_peering_bit/right_corner = 3
5:6/0/terrains_peering_bit/bottom_right_side = 3
5:6/0/terrains_peering_bit/bottom_corner = 3
5:6/0/terrains_peering_bit/bottom_left_side = 3
5:6/0/terrains_peering_bit/left_corner = 3
5:6/0/terrains_peering_bit/top_left_side = 3
5:6/0/terrains_peering_bit/top_corner = 3
5:6/0/terrains_peering_bit/top_right_side = 3
6:6/0 = 0
6:6/0/texture_origin = Vector2i(0, 16)
6:6/0/terrain_set = 0
6:6/0/terrain = 3
6:6/0/terrains_peering_bit/right_corner = 3
6:6/0/terrains_peering_bit/bottom_right_side = 3
6:6/0/terrains_peering_bit/bottom_corner = 3
6:6/0/terrains_peering_bit/bottom_left_side = 3
6:6/0/terrains_peering_bit/left_corner = 3
6:6/0/terrains_peering_bit/top_left_side = 3
6:6/0/terrains_peering_bit/top_corner = 3
6:6/0/terrains_peering_bit/top_right_side = 3
7:6/0 = 0
7:6/0/texture_origin = Vector2i(0, 16)
7:6/0/terrain_set = 0
7:6/0/terrain = 3
7:6/0/terrains_peering_bit/right_corner = 3
7:6/0/terrains_peering_bit/bottom_right_side = 3
7:6/0/terrains_peering_bit/bottom_corner = 3
7:6/0/terrains_peering_bit/bottom_left_side = 3
7:6/0/terrains_peering_bit/left_corner = 3
7:6/0/terrains_peering_bit/top_left_side = 3
7:6/0/terrains_peering_bit/top_corner = 3
7:6/0/terrains_peering_bit/top_right_side = 3
0:7/0 = 0
0:7/0/texture_origin = Vector2i(0, 16)
0:7/0/terrain_set = 0
0:7/0/terrain = 0
0:7/0/terrains_peering_bit/right_corner = 0
0:7/0/terrains_peering_bit/bottom_right_side = 0
0:7/0/terrains_peering_bit/bottom_corner = 0
0:7/0/terrains_peering_bit/bottom_left_side = 0
0:7/0/terrains_peering_bit/left_corner = 0
0:7/0/terrains_peering_bit/top_left_side = 3
0:7/0/terrains_peering_bit/top_corner = 3
0:7/0/terrains_peering_bit/top_right_side = 3
1:7/0 = 0
1:7/0/texture_origin = Vector2i(0, 16)
1:7/0/terrain_set = 0
1:7/0/terrain = 0
1:7/0/terrains_peering_bit/right_corner = 0
1:7/0/terrains_peering_bit/bottom_right_side = 0
1:7/0/terrains_peering_bit/bottom_corner = 0
1:7/0/terrains_peering_bit/bottom_left_side = 3
1:7/0/terrains_peering_bit/left_corner = 3
1:7/0/terrains_peering_bit/top_left_side = 3
1:7/0/terrains_peering_bit/top_corner = 0
1:7/0/terrains_peering_bit/top_right_side = 0
2:7/0 = 0
2:7/0/texture_origin = Vector2i(0, 16)
2:7/0/terrain_set = 0
2:7/0/terrain = 0
2:7/0/terrains_peering_bit/right_corner = 0
2:7/0/terrains_peering_bit/bottom_right_side = 3
2:7/0/terrains_peering_bit/bottom_corner = 3
2:7/0/terrains_peering_bit/bottom_left_side = 3
2:7/0/terrains_peering_bit/left_corner = 0
2:7/0/terrains_peering_bit/top_left_side = 0
2:7/0/terrains_peering_bit/top_corner = 0
2:7/0/terrains_peering_bit/top_right_side = 0
3:7/0 = 0
3:7/0/texture_origin = Vector2i(0, 16)
3:7/0/terrain_set = 0
3:7/0/terrain = 0
3:7/0/terrains_peering_bit/right_corner = 3
3:7/0/terrains_peering_bit/bottom_right_side = 3
3:7/0/terrains_peering_bit/bottom_corner = 0
3:7/0/terrains_peering_bit/bottom_left_side = 0
3:7/0/terrains_peering_bit/left_corner = 0
3:7/0/terrains_peering_bit/top_left_side = 0
3:7/0/terrains_peering_bit/top_corner = 0
3:7/0/terrains_peering_bit/top_right_side = 3
4:7/0 = 0
4:7/0/texture_origin = Vector2i(0, 16)
4:7/0/terrain_set = 0
4:7/0/terrain = 3
4:7/0/terrains_peering_bit/right_corner = 3
4:7/0/terrains_peering_bit/bottom_right_side = 3
4:7/0/terrains_peering_bit/bottom_corner = 0
4:7/0/terrains_peering_bit/bottom_left_side = 0
4:7/0/terrains_peering_bit/left_corner = 0
4:7/0/terrains_peering_bit/top_left_side = 3
4:7/0/terrains_peering_bit/top_corner = 3
4:7/0/terrains_peering_bit/top_right_side = 3
5:7/0 = 0
5:7/0/texture_origin = Vector2i(0, 16)
5:7/0/terrain_set = 0
5:7/0/terrain = 3
5:7/0/terrains_peering_bit/right_corner = 0
5:7/0/terrains_peering_bit/bottom_right_side = 3
5:7/0/terrains_peering_bit/bottom_corner = 3
5:7/0/terrains_peering_bit/bottom_left_side = 3
5:7/0/terrains_peering_bit/left_corner = 3
5:7/0/terrains_peering_bit/top_left_side = 3
5:7/0/terrains_peering_bit/top_corner = 0
5:7/0/terrains_peering_bit/top_right_side = 0
6:7/0 = 0
6:7/0/texture_origin = Vector2i(0, 16)
6:7/0/terrain_set = 0
6:7/0/terrain = 3
6:7/0/terrains_peering_bit/right_corner = 0
6:7/0/terrains_peering_bit/bottom_right_side = 0
6:7/0/terrains_peering_bit/bottom_corner = 0
6:7/0/terrains_peering_bit/bottom_left_side = 3
6:7/0/terrains_peering_bit/left_corner = 3
6:7/0/terrains_peering_bit/top_left_side = 3
6:7/0/terrains_peering_bit/top_corner = 3
6:7/0/terrains_peering_bit/top_right_side = 3
7:7/0 = 0
7:7/0/texture_origin = Vector2i(0, 16)
7:7/0/terrain_set = 0
7:7/0/terrain = 3
7:7/0/terrains_peering_bit/right_corner = 3
7:7/0/terrains_peering_bit/bottom_right_side = 3
7:7/0/terrains_peering_bit/bottom_corner = 3
7:7/0/terrains_peering_bit/bottom_left_side = 3
7:7/0/terrains_peering_bit/left_corner = 0
7:7/0/terrains_peering_bit/top_left_side = 0
7:7/0/terrains_peering_bit/top_corner = 0
7:7/0/terrains_peering_bit/top_right_side = 3
4:8/0 = 0
4:8/0/texture_origin = Vector2i(0, 16)
5:8/0 = 0
5:8/0/texture_origin = Vector2i(0, 16)
6:8/0 = 0
6:8/0/texture_origin = Vector2i(0, 16)
0:0/0 = 0
0:0/0/texture_origin = Vector2i(0, 15)
0:0/0/terrain_set = 0
0:0/0/terrain = 0
0:0/0/terrains_peering_bit/right_corner = 0
0:0/0/terrains_peering_bit/bottom_right_side = 0
0:0/0/terrains_peering_bit/bottom_corner = 0
0:0/0/terrains_peering_bit/bottom_left_side = 0
0:0/0/terrains_peering_bit/left_corner = 0
0:0/0/terrains_peering_bit/top_left_side = 0
0:0/0/terrains_peering_bit/top_corner = 0
0:0/0/terrains_peering_bit/top_right_side = 0
1:0/0 = 0
1:0/0/texture_origin = Vector2i(0, 15)
1:0/0/terrain_set = 0
1:0/0/terrain = 0
1:0/0/terrains_peering_bit/right_corner = 0
1:0/0/terrains_peering_bit/bottom_right_side = 0
1:0/0/terrains_peering_bit/bottom_corner = 0
1:0/0/terrains_peering_bit/bottom_left_side = 0
1:0/0/terrains_peering_bit/left_corner = 0
1:0/0/terrains_peering_bit/top_left_side = 0
1:0/0/terrains_peering_bit/top_corner = 0
1:0/0/terrains_peering_bit/top_right_side = 0
2:0/0 = 0
2:0/0/texture_origin = Vector2i(0, 15)
2:0/0/terrain_set = 0
2:0/0/terrain = 0
2:0/0/terrains_peering_bit/right_corner = 0
2:0/0/terrains_peering_bit/bottom_right_side = 0
2:0/0/terrains_peering_bit/bottom_corner = 0
2:0/0/terrains_peering_bit/bottom_left_side = 0
2:0/0/terrains_peering_bit/left_corner = 0
2:0/0/terrains_peering_bit/top_left_side = 0
2:0/0/terrains_peering_bit/top_corner = 0
2:0/0/terrains_peering_bit/top_right_side = 0
3:0/0 = 0
3:0/0/texture_origin = Vector2i(0, 15)
3:0/0/terrain_set = 0
3:0/0/terrain = 0
3:0/0/terrains_peering_bit/right_corner = 0
3:0/0/terrains_peering_bit/bottom_right_side = 0
3:0/0/terrains_peering_bit/bottom_corner = 0
3:0/0/terrains_peering_bit/bottom_left_side = 0
3:0/0/terrains_peering_bit/left_corner = 0
3:0/0/terrains_peering_bit/top_left_side = 0
3:0/0/terrains_peering_bit/top_corner = 0
3:0/0/terrains_peering_bit/top_right_side = 0
4:0/0 = 0
4:0/0/texture_origin = Vector2i(0, 15)
4:0/0/terrain_set = 0
4:0/0/terrain = 1
4:0/0/terrains_peering_bit/right_corner = 1
4:0/0/terrains_peering_bit/bottom_right_side = 1
4:0/0/terrains_peering_bit/bottom_corner = 1
4:0/0/terrains_peering_bit/bottom_left_side = 1
4:0/0/terrains_peering_bit/left_corner = 1
4:0/0/terrains_peering_bit/top_left_side = 1
4:0/0/terrains_peering_bit/top_corner = 1
4:0/0/terrains_peering_bit/top_right_side = 1
5:0/0 = 0
5:0/0/texture_origin = Vector2i(0, 15)
5:0/0/terrain_set = 0
5:0/0/terrain = 1
5:0/0/terrains_peering_bit/right_corner = 1
5:0/0/terrains_peering_bit/bottom_right_side = 1
5:0/0/terrains_peering_bit/bottom_corner = 1
5:0/0/terrains_peering_bit/bottom_left_side = 1
5:0/0/terrains_peering_bit/left_corner = 1
5:0/0/terrains_peering_bit/top_left_side = 1
5:0/0/terrains_peering_bit/top_corner = 1
5:0/0/terrains_peering_bit/top_right_side = 1
6:0/0 = 0
6:0/0/texture_origin = Vector2i(0, 15)
6:0/0/terrain_set = 0
6:0/0/terrain = 1
6:0/0/terrains_peering_bit/right_corner = 1
6:0/0/terrains_peering_bit/bottom_right_side = 1
6:0/0/terrains_peering_bit/bottom_corner = 1
6:0/0/terrains_peering_bit/bottom_left_side = 1
6:0/0/terrains_peering_bit/left_corner = 1
6:0/0/terrains_peering_bit/top_left_side = 1
6:0/0/terrains_peering_bit/top_corner = 1
6:0/0/terrains_peering_bit/top_right_side = 1
7:0/0 = 0
7:0/0/texture_origin = Vector2i(0, 15)
7:0/0/terrain_set = 0
7:0/0/terrain = 1
7:0/0/terrains_peering_bit/right_corner = 1
7:0/0/terrains_peering_bit/bottom_right_side = 1
7:0/0/terrains_peering_bit/bottom_corner = 1
7:0/0/terrains_peering_bit/bottom_left_side = 1
7:0/0/terrains_peering_bit/left_corner = 1
7:0/0/terrains_peering_bit/top_left_side = 1
7:0/0/terrains_peering_bit/top_corner = 1
7:0/0/terrains_peering_bit/top_right_side = 1
0:4/0 = 0
0:4/0/texture_origin = Vector2i(0, 16)
0:4/0/terrain_set = 0
0:4/0/terrain = 0
0:4/0/terrains_peering_bit/right_corner = 0
0:4/0/terrains_peering_bit/bottom_right_side = 0
0:4/0/terrains_peering_bit/bottom_corner = 1
0:4/0/terrains_peering_bit/bottom_left_side = 1
0:4/0/terrains_peering_bit/left_corner = 1
0:4/0/terrains_peering_bit/top_left_side = 0
0:4/0/terrains_peering_bit/top_corner = 0
0:4/0/terrains_peering_bit/top_right_side = 0
1:4/0 = 0
1:4/0/texture_origin = Vector2i(0, 16)
1:4/0/terrain_set = 0
1:4/0/terrain = 0
1:4/0/terrains_peering_bit/right_corner = 1
1:4/0/terrains_peering_bit/bottom_right_side = 1
1:4/0/terrains_peering_bit/bottom_corner = 1
1:4/0/terrains_peering_bit/bottom_left_side = 0
1:4/0/terrains_peering_bit/left_corner = 0
1:4/0/terrains_peering_bit/top_left_side = 0
1:4/0/terrains_peering_bit/top_corner = 0
1:4/0/terrains_peering_bit/top_right_side = 0
2:4/0 = 0
2:4/0/texture_origin = Vector2i(0, 16)
2:4/0/terrain_set = 0
2:4/0/terrain = 1
2:4/0/terrains_peering_bit/right_corner = 1
2:4/0/terrains_peering_bit/bottom_right_side = 1
2:4/0/terrains_peering_bit/bottom_corner = 0
2:4/0/terrains_peering_bit/bottom_left_side = 0
2:4/0/terrains_peering_bit/left_corner = 0
2:4/0/terrains_peering_bit/top_left_side = 1
2:4/0/terrains_peering_bit/top_corner = 1
2:4/0/terrains_peering_bit/top_right_side = 1
3:4/0 = 0
3:4/0/texture_origin = Vector2i(0, 16)
3:4/0/terrain_set = 0
3:4/0/terrain = 1
3:4/0/terrains_peering_bit/right_corner = 0
3:4/0/terrains_peering_bit/bottom_right_side = 0
3:4/0/terrains_peering_bit/bottom_corner = 0
3:4/0/terrains_peering_bit/bottom_left_side = 1
3:4/0/terrains_peering_bit/left_corner = 1
3:4/0/terrains_peering_bit/top_left_side = 1
3:4/0/terrains_peering_bit/top_corner = 1
3:4/0/terrains_peering_bit/top_right_side = 1
4:4/0 = 0
4:4/0/texture_origin = Vector2i(0, 16)
4:4/0/terrain_set = 0
4:4/0/terrain = 3
4:4/0/terrains_peering_bit/right_corner = 3
4:4/0/terrains_peering_bit/bottom_right_side = 3
4:4/0/terrains_peering_bit/bottom_corner = 3
4:4/0/terrains_peering_bit/bottom_left_side = 3
4:4/0/terrains_peering_bit/left_corner = 3
4:4/0/terrains_peering_bit/top_left_side = 3
4:4/0/terrains_peering_bit/top_corner = 3
4:4/0/terrains_peering_bit/top_right_side = 3
5:4/0 = 0
5:4/0/texture_origin = Vector2i(0, 16)
5:4/0/terrain_set = 0
5:4/0/terrain = 3
5:4/0/terrains_peering_bit/right_corner = 3
5:4/0/terrains_peering_bit/bottom_right_side = 3
5:4/0/terrains_peering_bit/bottom_corner = 3
5:4/0/terrains_peering_bit/bottom_left_side = 3
5:4/0/terrains_peering_bit/left_corner = 3
5:4/0/terrains_peering_bit/top_left_side = 3
5:4/0/terrains_peering_bit/top_corner = 3
5:4/0/terrains_peering_bit/top_right_side = 3
6:4/0 = 0
6:4/0/texture_origin = Vector2i(0, 16)
6:4/0/terrain_set = 0
6:4/0/terrain = 3
6:4/0/terrains_peering_bit/right_corner = 3
6:4/0/terrains_peering_bit/bottom_right_side = 3
6:4/0/terrains_peering_bit/bottom_corner = 3
6:4/0/terrains_peering_bit/bottom_left_side = 3
6:4/0/terrains_peering_bit/left_corner = 3
6:4/0/terrains_peering_bit/top_left_side = 3
6:4/0/terrains_peering_bit/top_corner = 3
6:4/0/terrains_peering_bit/top_right_side = 3
7:4/0 = 0
7:4/0/texture_origin = Vector2i(0, 16)
7:4/0/terrain_set = 0
7:4/0/terrain = 3
7:4/0/terrains_peering_bit/right_corner = 3
7:4/0/terrains_peering_bit/bottom_right_side = 3
7:4/0/terrains_peering_bit/bottom_corner = 3
7:4/0/terrains_peering_bit/bottom_left_side = 3
7:4/0/terrains_peering_bit/left_corner = 3
7:4/0/terrains_peering_bit/top_left_side = 3
7:4/0/terrains_peering_bit/top_corner = 3
7:4/0/terrains_peering_bit/top_right_side = 3
0:8/0 = 0
0:8/0/texture_origin = Vector2i(0, 16)
0:8/0/terrain_set = 0
0:8/0/terrain = 3
0:8/0/terrains_peering_bit/right_corner = 3
0:8/0/terrains_peering_bit/bottom_right_side = 0
0:8/0/terrains_peering_bit/bottom_corner = 0
0:8/0/terrains_peering_bit/bottom_left_side = 0
0:8/0/terrains_peering_bit/left_corner = 3
0:8/0/terrains_peering_bit/top_left_side = 3
0:8/0/terrains_peering_bit/top_corner = 3
0:8/0/terrains_peering_bit/top_right_side = 3
1:8/0 = 0
1:8/0/texture_origin = Vector2i(0, 16)
1:8/0/terrain_set = 0
1:8/0/terrain = 3
1:8/0/terrains_peering_bit/right_corner = 0
1:8/0/terrains_peering_bit/bottom_right_side = 0
1:8/0/terrains_peering_bit/bottom_corner = 3
1:8/0/terrains_peering_bit/bottom_left_side = 3
1:8/0/terrains_peering_bit/left_corner = 3
1:8/0/terrains_peering_bit/top_left_side = 3
1:8/0/terrains_peering_bit/top_corner = 3
1:8/0/terrains_peering_bit/top_right_side = 0
2:8/0 = 0
2:8/0/texture_origin = Vector2i(0, 16)
2:8/0/terrain_set = 0
2:8/0/terrain = 3
2:8/0/terrains_peering_bit/right_corner = 3
2:8/0/terrains_peering_bit/bottom_right_side = 3
2:8/0/terrains_peering_bit/bottom_corner = 3
2:8/0/terrains_peering_bit/bottom_left_side = 3
2:8/0/terrains_peering_bit/left_corner = 3
2:8/0/terrains_peering_bit/top_left_side = 0
2:8/0/terrains_peering_bit/top_corner = 0
2:8/0/terrains_peering_bit/top_right_side = 0
3:8/0 = 0
3:8/0/texture_origin = Vector2i(0, 16)
3:8/0/terrain_set = 0
3:8/0/terrain = 3
3:8/0/terrains_peering_bit/right_corner = 3
3:8/0/terrains_peering_bit/bottom_right_side = 3
3:8/0/terrains_peering_bit/bottom_corner = 3
3:8/0/terrains_peering_bit/bottom_left_side = 0
3:8/0/terrains_peering_bit/left_corner = 0
3:8/0/terrains_peering_bit/top_left_side = 0
3:8/0/terrains_peering_bit/top_corner = 3
3:8/0/terrains_peering_bit/top_right_side = 3

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_c7ve4"]
texture = ExtResource("2_r0ym5")
texture_region_size = Vector2i(64, 32)
0:0/0 = 0
0:0/0/terrain_set = 0
0:0/0/terrain = 2
0:0/0/terrains_peering_bit/right_corner = 2
0:0/0/terrains_peering_bit/bottom_right_side = 2
0:0/0/terrains_peering_bit/bottom_corner = 2
0:0/0/terrains_peering_bit/bottom_left_side = 2
0:0/0/terrains_peering_bit/left_corner = 2
0:0/0/terrains_peering_bit/top_left_side = 2
0:0/0/terrains_peering_bit/top_corner = 2
0:0/0/terrains_peering_bit/top_right_side = 2
0:0/0/custom_data_0 = true
1:0/0 = 0
1:0/0/terrain_set = 0
1:0/0/terrain = 2
1:0/0/terrains_peering_bit/right_corner = 2
1:0/0/terrains_peering_bit/bottom_right_side = 2
1:0/0/terrains_peering_bit/bottom_corner = 2
1:0/0/terrains_peering_bit/bottom_left_side = 2
1:0/0/terrains_peering_bit/left_corner = 2
1:0/0/terrains_peering_bit/top_left_side = 2
1:0/0/terrains_peering_bit/top_corner = 2
1:0/0/terrains_peering_bit/top_right_side = 2
1:0/0/custom_data_0 = true
0:1/0 = 0
0:1/0/terrain_set = 0
0:1/0/terrain = 2
0:1/0/terrains_peering_bit/right_corner = 2
0:1/0/terrains_peering_bit/bottom_right_side = 2
0:1/0/terrains_peering_bit/bottom_corner = 2
0:1/0/terrains_peering_bit/bottom_left_side = 2
0:1/0/terrains_peering_bit/left_corner = 2
0:1/0/terrains_peering_bit/top_left_side = 2
0:1/0/terrains_peering_bit/top_corner = 2
0:1/0/terrains_peering_bit/top_right_side = 2
0:1/0/custom_data_0 = true
1:1/0 = 0
1:1/0/terrain_set = 0
1:1/0/terrain = 2
1:1/0/terrains_peering_bit/right_corner = 2
1:1/0/terrains_peering_bit/bottom_right_side = 2
1:1/0/terrains_peering_bit/bottom_corner = 2
1:1/0/terrains_peering_bit/bottom_left_side = 2
1:1/0/terrains_peering_bit/left_corner = 2
1:1/0/terrains_peering_bit/top_left_side = 2
1:1/0/terrains_peering_bit/top_corner = 2
1:1/0/terrains_peering_bit/top_right_side = 2
1:1/0/custom_data_0 = true

[resource]
tile_shape = 1
tile_layout = 5
tile_size = Vector2i(64, 32)
terrain_set_0/mode = 0
terrain_set_0/terrain_0/name = "Beach"
terrain_set_0/terrain_0/color = Color(0.7882353, 0.84705883, 0, 1)
terrain_set_0/terrain_1/name = "Shallow Water"
terrain_set_0/terrain_1/color = Color(0.2623501, 0.4910108, 0.46609968, 1)
terrain_set_0/terrain_2/name = "Deep Water"
terrain_set_0/terrain_2/color = Color(0.14901961, 0, 0.90588236, 1)
terrain_set_0/terrain_3/name = "Grass"
terrain_set_0/terrain_3/color = Color(0.375, 0.5, 0.25, 1)
custom_data_layer_0/name = "is_unwalkable"
custom_data_layer_0/type = 1
sources/0 = SubResource("TileSetAtlasSource_fmib8")
sources/1 = SubResource("TileSetAtlasSource_c7ve4")


--------------------------------------------------
FILE: res:///scenes/levels/SettlementBridge.tscn
--------------------------------------------------
[gd_scene load_steps=31 format=3 uid="uid://c53k15q2w8c1a"]

[ext_resource type="PackedScene" uid="uid://dqh0xu88khxct" path="res://ui/EndOfYear_Popup.tscn" id="2_5el12"]
[ext_resource type="Script" uid="uid://dafjxa85ci2rx" path="res://scripts/buildings/SettlementBridge.gd" id="2_c48a7"]
[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="2_ggwng"]
[ext_resource type="PackedScene" uid="uid://btovbm7r6nern" path="res://ui/Storefront_UI.tscn" id="3_vj45l"]
[ext_resource type="Script" uid="uid://koj0vo5eoaum" path="res://data/units/WarbandData.gd" id="3_vlppw"]
[ext_resource type="PackedScene" uid="uid://btlcifwc6ckux" path="res://scenes/units/VikingRaider.tscn" id="4_c0sri"]
[ext_resource type="TileSet" uid="uid://xoe70lhybj8l" path="res://scenes/levels/Isometric Tileset.tres" id="6_cpd76"]
[ext_resource type="Script" uid="uid://c4bv8okjkvtt7" path="res://scripts/ui/BuildingPreviewCursor.gd" id="6_cursor"]
[ext_resource type="PackedScene" uid="uid://c5qg2j1qa4g0b" path="res://ui/Dynasty_UI.tscn" id="7_k14p1"]
[ext_resource type="Script" uid="uid://6speiwju5o1r" path="res://ui/PauseButton.gd" id="7_n23os"]
[ext_resource type="PackedScene" uid="uid://ptujtdi5jtsk" path="res://scripts/utility/GridVisualizer.tscn" id="7_oq6tm"]
[ext_resource type="PackedScene" uid="uid://1ly65bng2mep" path="res://ui/SelectionBox.tscn" id="8_cpd76"]
[ext_resource type="Script" uid="uid://bxbqkyp1d6750" path="res://player/RTSCamera.gd" id="8_ggwng"]
[ext_resource type="PackedScene" uid="uid://bmrx7k05of21t" path="res://scenes/world/Resource_Wood.tscn" id="9_vmd61"]
[ext_resource type="PackedScene" uid="uid://whql45nph2u8" path="res://ui/seasonal/SpringCouncilUI.tscn" id="10_fmib8"]
[ext_resource type="PackedScene" uid="uid://dhobag8h7m8ip" path="res://ui/components/BuildingInspector.tscn" id="11_fmib8"]
[ext_resource type="Texture2D" uid="uid://cjlq3soj1j4jj" path="res://assets/Kenney/medievalRTS_spritesheet.png" id="11_vlppw"]
[ext_resource type="Script" uid="uid://cni5gdnpbb1v2" path="res://data/resources/SeasonalCardResource.gd" id="12_iv0y3"]
[ext_resource type="PackedScene" uid="uid://c8q4w2x5y301" path="res://ui/seasonal/SummerAllocation_Ui.tscn" id="13_c7ve4"]
[ext_resource type="PackedScene" uid="uid://bfly4if3qtymg" path="res://ui/seasonal/SummerWorkspaceUI.tscn" id="13_dx1s8"]
[ext_resource type="PackedScene" uid="uid://c6b0qegdltxvw" path="res://ui/seasonal/AutumnLedger_UI.tscn" id="14_4m3mo"]
[ext_resource type="PackedScene" uid="uid://dnndecgdkcffm" path="res://ui/seasonal/WinterCourt_UI.tscn" id="14_51pa8"]
[ext_resource type="Resource" uid="uid://du2gsa2xinlrm" path="res://data/resources/Card_Focus_Raid.tres" id="14_t0qlt"]
[ext_resource type="Theme" uid="uid://63duv3n1vwhg" path="res://ui/themes/VikingDynastyTheme.tres" id="15_iv0y3"]
[ext_resource type="Resource" uid="uid://dt38bx8jkvrno" path="res://data/resources/Card_Spring_Expansion.tres" id="15_nou2g"]
[ext_resource type="PackedScene" uid="uid://cyp3t7gbdg0wx" path="res://player/RTSController.tscn" id="18_fmib8"]
[ext_resource type="PackedScene" uid="uid://bvsuoj3irdvcs" path="res://player/RTSInputHandler.tscn" id="19_c7ve4"]
[ext_resource type="PackedScene" uid="uid://io325box3m4m" path="res://scenes/world/UnitSpawner.tscn" id="20_fmib8"]

[sub_resource type="Resource" id="Resource_vmd61"]
script = ExtResource("2_ggwng")
treasury = {
"food": 500,
"gold": 500,
"stone": 500,
"wood": 500
}
population_peasants = 5
population_thralls = 2
metadata/_custom_type_script = "uid://hlb8s5g0yp6k"

[sub_resource type="GDScript" id="GDScript_cpd76"]
script/source = "# res://scripts/debug/DebugNavigationVisualizer.gd
extends Node2D

# --- Configuration ---
@export var visualize_radius: int = 10 # How many tiles around the mouse to draw solids for

# --- Internal ---
var last_start: Vector2 = Vector2.ZERO
var last_end: Vector2 = Vector2.ZERO
var raw_path: PackedVector2Array = []
var smoothed_path: PackedVector2Array = []
var debug_solid_rects: Array[Rect2] = []

func _ready() -> void:
	z_index = 4096 # Draw on top of everything
	Loggie.msg(\"Debug Visualizer Ready. Right-Click to test path.\").domain(\"DEBUG\").info()

func _unhandled_input(event: InputEvent) -> void:
	# Use Right Click to debug a path from Center of Screen -> Mouse
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_RIGHT:
		var mouse_pos = get_global_mouse_position()
		
		# Assume start point is center of screen (or find a unit if selected)
		# For this test, we just use a point 200px to the left of the mouse to simulate travel
		var start_pos = _find_debug_start_point(mouse_pos)
		
		_perform_path_test(start_pos, mouse_pos)
		get_viewport().set_input_as_handled()

func _find_debug_start_point(mouse_pos: Vector2) -> Vector2:
	# Try to find a player unit to start from
	var units = get_tree().get_nodes_in_group(\"player_units\")
	if not units.is_empty():
		# Return position of closest unit
		var closest = units[0]
		var min_d = closest.global_position.distance_to(mouse_pos)
		for u in units:
			var d = u.global_position.distance_to(mouse_pos)
			if d < min_d:
				min_d = d
				closest = u
		return closest.global_position
	
	# Fallback: Just test from screen center
	var cam = get_viewport().get_camera_2d()
	if cam: return cam.get_screen_center_position()
	return Vector2(500, 500)

func _perform_path_test(start: Vector2, end: Vector2) -> void:
	last_start = start
	last_end = end
	
	print(\"\\n=== PATHFINDING DEBUG LOG ===\")
	print(\"Request: %s -> %s\" % [start, end])
	
	# 1. Access the Grid
	var grid = NavigationManager.active_astar_grid
	if not grid:
		printerr(\"CRITICAL: No Active AStarGrid2D found in NavigationManager!\")
		return
	
	# 2. Get Raw Path (Directly from Grid, bypassing Manager smoothing)
	var cell_size = grid.cell_size
	var start_idx = Vector2i(start / cell_size)
	var end_idx = Vector2i(end / cell_size)
	
	# Clamp for raw check
	var region = grid.region
	end_idx.x = clampi(end_idx.x, region.position.x, region.end.x - 1)
	end_idx.y = clampi(end_idx.y, region.position.y, region.end.y - 1)
	
	raw_path = grid.get_point_path(start_idx, end_idx)
	print(\"Raw A* Path Points: %d\" % raw_path.size())
	
	# 3. Get Smoothed Path (Via Manager logic)
	smoothed_path = NavigationManager.get_astar_path(start, end)
	print(\"Smoothed Path Points: %d\" % smoothed_path.size())
	
	if not smoothed_path.is_empty():
		print(\"Path Start: %s\" % smoothed_path[0])
		print(\"Path End:   %s\" % smoothed_path[smoothed_path.size() - 1])
		print(\"Delta from Target: %s\" % smoothed_path[smoothed_path.size() - 1].distance_to(end))
	else:
		printerr(\"PATH FAILED: NavigationManager returned empty path.\")
	
	# 4. Scan for nearby solids (Visualizing obstacles)
	debug_solid_rects.clear()
	var mouse_grid = Vector2i(end / cell_size)
	
	for x in range(mouse_grid.x - visualize_radius, mouse_grid.x + visualize_radius):
		for y in range(mouse_grid.y - visualize_radius, mouse_grid.y + visualize_radius):
			var cell = Vector2i(x, y)
			if NavigationManager.is_point_solid(cell):
				# Create rect for drawing
				var world_pos = Vector2(x, y) * cell_size
				debug_solid_rects.append(Rect2(world_pos, cell_size))
				
	queue_redraw()

func _draw() -> void:
	if raw_path.is_empty() and smoothed_path.is_empty(): return
	
	# 1. Draw Start/End
	draw_circle(last_start, 5.0, Color.GREEN)
	draw_circle(last_end, 5.0, Color.RED)
	
	# 2. Draw Solids (Red Squares)
	for r in debug_solid_rects:
		draw_rect(r, Color(1, 0, 0, 0.3), true) # Semi-transparent red fill
		draw_rect(r, Color.RED, false, 1.0)     # Red border
	
	# 3. Draw Raw Path (Thin White Line)
	if raw_path.size() > 1:
		draw_polyline(raw_path, Color(1, 1, 1, 0.5), 2.0)
		# Draw points
		for p in raw_path:
			draw_circle(p, 2.0, Color(1, 1, 1, 0.5))
			
	# 4. Draw Smoothed Path (Thick Blue Line)
	if smoothed_path.size() > 1:
		draw_polyline(smoothed_path, Color.CYAN, 4.0)
		for p in smoothed_path:
			draw_circle(p, 4.0, Color.BLUE)
"

[node name="SettlementBridge" type="Node2D"]
script = ExtResource("2_c48a7")
home_base_data = SubResource("Resource_vmd61")
raider_scene = ExtResource("4_c0sri")
end_of_year_popup_scene = ExtResource("2_5el12")
show_ui_logs = true
show_settlement_logs = true
show_building_logs = true
metadata/_edit_horizontal_guides_ = [2658.0, 93.0]

[node name="TileMapLayer" type="TileMapLayer" parent="."]
position = Vector2(-3, 0)
tile_set = ExtResource("6_cpd76")

[node name="UnitContainer" type="Node2D" parent="."]

[node name="UI" type="CanvasLayer" parent="."]

[node name="SelectionBox" parent="UI" instance=ExtResource("8_cpd76")]

[node name="Storefront_UI" parent="UI" instance=ExtResource("3_vj45l")]

[node name="Dynasty_UI" parent="UI" instance=ExtResource("7_k14p1")]
anchors_preset = 8

[node name="EndOfYear_Popup" parent="UI" instance=ExtResource("2_5el12")]
anchors_preset = 8

[node name="PauseButton" type="Button" parent="UI"]
visible = false
offset_left = 10.0
offset_top = 10.0
offset_right = 130.0
offset_bottom = 50.0
text = "PAUSE (ESC)"
script = ExtResource("7_n23os")

[node name="BuildingInspector" parent="UI" instance=ExtResource("11_fmib8")]
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -120.5
offset_top = -120.0
offset_right = 120.5
grow_horizontal = 2
grow_vertical = 0

[node name="SpringCouncil_UI" parent="UI" instance=ExtResource("10_fmib8")]
available_advisor_cards = Array[ExtResource("12_iv0y3")]([ExtResource("14_t0qlt"), ExtResource("15_nou2g")])

[node name="SummerWorkspace_UI" parent="UI" instance=ExtResource("13_dx1s8")]

[node name="SummerRaid_UI" parent="UI" instance=ExtResource("13_c7ve4")]
mouse_filter = 1

[node name="AutumnLedgerUI" parent="UI" instance=ExtResource("14_4m3mo")]

[node name="WinterCourt_UI" parent="UI" instance=ExtResource("14_51pa8")]
theme = ExtResource("15_iv0y3")

[node name="BuildingCursor" type="Node2D" parent="."]
script = ExtResource("6_cursor")

[node name="BuildingContainer" type="Node2D" parent="."]

[node name="GridVisualizer" parent="." instance=ExtResource("7_oq6tm")]
grid_size = Vector2i(60, 60)

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(1000, 400)
script = ExtResource("8_ggwng")

[node name="MapResources" type="Node2D" parent="."]

[node name="Resource_Wood" parent="MapResources" instance=ExtResource("9_vmd61")]
position = Vector2(469, 452)

[node name="Sprite2D" parent="MapResources/Resource_Wood" index="0"]
texture = ExtResource("11_vlppw")
region_rect = Rect2(130.31061, 238.28082, 33.297256, 51.142853)

[node name="Resource_Food" parent="MapResources" instance=ExtResource("9_vmd61")]
position = Vector2(1630, 1143)
resource_type = "food"
district_radius = 280.0

[node name="Sprite2D" parent="MapResources/Resource_Food" index="0"]
position = Vector2(6, -1)
scale = Vector2(2.5, 2.1060605)
texture = ExtResource("11_vlppw")
region_rect = Rect2(202.20213, 73.07374, 43.015152, 43.971046)

[node name="RTSController" parent="." instance=ExtResource("18_fmib8")]

[node name="RtsInputHandler" parent="." instance=ExtResource("19_c7ve4")]

[node name="UnitSpawner" parent="." node_paths=PackedStringArray("unit_container", "rts_controller") instance=ExtResource("20_fmib8")]
unit_container = NodePath("../UnitContainer")
rts_controller = NodePath("../RTSController")

[node name="DebugNav" type="Node2D" parent="."]
script = SubResource("GDScript_cpd76")

[node name="TempDebugNode" type="Node" parent="."]

[editable path="MapResources/Resource_Wood"]
[editable path="MapResources/Resource_Food"]


--------------------------------------------------
FILE: res:///scenes/levels/TempDebugNode.gd
--------------------------------------------------
extends Node

## Assign your TreasuryHUD node here in the Inspector!
@export var hud_node: TreasuryHUD

# Internal tracking
var _previous_treasury: Dictionary = {}

func _ready() -> void:
	print("--- TREASURY WATCHDOG STARTED ---")
	
	if not hud_node:
		Loggie.msg("DebugTracker: HUD Node not assigned! Cannot verify UI text.").domain(LogDomains.SYSTEM).error()
		return

	# Listen to key events
	EventBus.season_changed.connect(_on_season_changed)
	EventBus.treasury_updated.connect(_on_treasury_updated)
	
	# Snapshot initial state
	if SettlementManager.current_settlement:
		_previous_treasury = SettlementManager.current_settlement.treasury.duplicate()

func _on_treasury_updated(_new_treasury: Dictionary) -> void:
	# Wait one frame to let the UI update itself first
	await get_tree().process_frame
	_verify_ui_integrity()

func _on_season_changed(new_season: String) -> void:
	print("\n=== SEASON CHANGE DETECTED: %s ===" % new_season)
	
	if not SettlementManager.current_settlement: return
	
	var current = SettlementManager.current_settlement.treasury
	
	# 1. Calculate Delta (What actually changed?)
	var delta_report = ""
	for res in GameResources.ALL_CURRENCIES:
		var old_val = _previous_treasury.get(res, 0)
		var new_val = current.get(res, 0)
		var diff = new_val - old_val
		
		if diff != 0:
			delta_report += "%s: %+d  " % [res.capitalize(), diff]
			
	if delta_report == "":
		print(">> Zero Economic Activity this season.")
	else:
		print(">> ACTUAL CHANGE: ", delta_report)
	
	# 2. Compare against Expected Forecast (Optional, creates deep insight)
	# You can uncomment this if you suspect the Forecast is lying
	# var forecast = EconomyManager.get_projected_income()
	# print(">> FORECAST WAS: ", forecast)

	# 3. Snapshot for next season
	_previous_treasury = current.duplicate()
	
	# 4. Final UI Check
	await get_tree().process_frame
	_verify_ui_integrity()

func _verify_ui_integrity() -> void:
	if not hud_node or not SettlementManager.current_settlement: return
	
	var data = SettlementManager.current_settlement.treasury
	var discrepancies = 0
	
	# Helper to clean label text (remove commas, currency symbols if you add them later)
	var check_res = func(res_key: String, label: Label) -> void:
		if not label: return
		var ui_val = int(label.text.replace(",", ""))
		var data_val = data.get(res_key, 0)
		
		if ui_val != data_val:
			printerr("!! MISMATCH %s !! Data: %d vs UI: %d" % [res_key.to_upper(), data_val, ui_val])
			discrepancies += 1
		else:
			# Uncomment for verbose confirmation
			# print("OK: %s (%d)" % [res_key, data_val])
			pass

	check_res.call(GameResources.GOLD, hud_node.gold_label)
	check_res.call(GameResources.WOOD, hud_node.wood_label)
	check_res.call(GameResources.FOOD, hud_node.food_label)
	check_res.call(GameResources.STONE, hud_node.stone_label)
	
	if discrepancies == 0:
		print(">> UI Integrity Check: PASSED (Synced)")


--------------------------------------------------
FILE: res:///scenes/missions/RaidMapLoader.gd
--------------------------------------------------
class_name RaidMapLoader
extends Node

var building_container: Node2D

func setup(p_container: Node2D, enemy_data: SettlementData) -> void:
	print("[DIAGNOSTIC] RaidMapLoader: Beginning Setup Sequence.")
	building_container = p_container
	
	# 1. Register Nodes (So Manager knows WHO to scan, but doesn't scan yet)
	SettlementManager.active_map_data = enemy_data
	SettlementManager.register_active_scene_nodes(p_container)
	
	# 2. GENERATE TERRAIN (Critical: Must happen BEFORE grid refresh)
	var root_node = p_container.get_parent() 
	var tile_map = root_node.get_node_or_null("TileMapLayer")
	
	if tile_map:
		if enemy_data.map_seed == 0:
			enemy_data.map_seed = randi()
			
		print("[DIAGNOSTIC] RaidMapLoader: Generating Terrain with Seed: ", enemy_data.map_seed)
		TerrainGenerator.generate_base_terrain(
			tile_map,
			SettlementManager.GRID_WIDTH, 
			SettlementManager.GRID_HEIGHT, 
			enemy_data.map_seed
		)
		
		# [CRITICAL WAIT]
		# Ensure TileMap has processed the changes before we scan
		# (Usually synchronous, but safe to be explicit)
	else:
		printerr("RaidMapLoader: Could not find TileMapLayer!")

	# 3. REFRESH GRID (Now that tiles exist, scan them)
	print("[DIAGNOSTIC] RaidMapLoader: Refreshing Grid State...")
	SettlementManager._refresh_grid_state()
	print("[DIAGNOSTIC] RaidMapLoader: Setup Complete.")

func load_base(data: SettlementData, is_player_owner: bool) -> BaseBuilding:
	var objective_ref: BaseBuilding = null
	
	for entry in data.placed_buildings:
		var building = _spawn_single_building_visual(entry)
		if building and building.data.is_territory_hub and not is_player_owner:
			objective_ref = building 
			
	return objective_ref

func _spawn_single_building_visual(entry: Dictionary) -> BaseBuilding:
	var res_path = entry["resource_path"]
	var original_pos = Vector2i(entry["grid_position"].x, entry["grid_position"].y)
	
	if not ResourceLoader.exists(res_path): return null
	var b_data = load(res_path) as BuildingData
	if not b_data: return null
	
	# --- NEW: SAFETY CHECK ---
	# Ensure we don't spawn on water. If the spot is solid, find a new one.
	var final_grid_pos = original_pos
	
	# 1. Check if the generated spot is illegal (Solid/Water)
	if SettlementManager.active_astar_grid.is_point_solid(original_pos):
		# 2. Search for nearest land (Spiral out 5 tiles)
		var found_land = false
		for r in range(1, 6):
			for x in range(-r, r + 1):
				for y in range(-r, r + 1):
					var check = original_pos + Vector2i(x, y)
					# Must be in bounds and NOT solid
					if SettlementManager.active_astar_grid.region.has_point(check):
						if not SettlementManager.active_astar_grid.is_point_solid(check):
							final_grid_pos = check
							found_land = true
							break
				if found_land: break
			if found_land: break
		
		if not found_land:
			print("RaidMapLoader: Could not find land for %s at %s. Skipping." % [b_data.display_name, original_pos])
			return null # Delete building rather than floating on water
			
	# Update the entry so the data matches the visual reality
	entry["grid_position"] = final_grid_pos
	# -------------------------

	var instance = b_data.scene_to_spawn.instantiate() as BaseBuilding
	instance.data = b_data
	
	# Isometric Positioning (using the new safe Grid Coordinates)
	var center_grid_x = float(final_grid_pos.x) + (float(b_data.grid_size.x) / 2.0)
	var center_grid_y = float(final_grid_pos.y) + (float(b_data.grid_size.y) / 2.0)
	
	var final_x = (center_grid_x - center_grid_y) * SettlementManager.TILE_HALF_SIZE.x
	var final_y = (center_grid_x + center_grid_y) * SettlementManager.TILE_HALF_SIZE.y
	
	instance.global_position = Vector2(final_x, final_y)
	
	building_container.add_child(instance) 
	
	instance.collision_layer = 1 | 8 
	instance.collision_mask = 0 
	
	if instance.has_node("Hitbox"):
		var hitbox = instance.get_node("Hitbox")
		hitbox.collision_layer = 8
		
	return instance


--------------------------------------------------
FILE: res:///scenes/missions/RaidMission.gd
--------------------------------------------------
# res://scenes/missions/RaidMission.gd
extends Node2D

# --- Configuration ---
@export var enemy_wave_units: Array[UnitData] = []
@export var enemy_wave_count: int = 5
@export var enemy_base_data: SettlementData
@export var default_enemy_base_path: String = "res://data/settlements/monastery_base.tres"
@export var player_spawn_formation: Dictionary = {"units_per_row": 5, "spacing": 40}
@export var is_defensive_mission: bool = false
@export var enemy_spawn_position: NodePath
@export var landing_direction: Vector2 = Vector2.RIGHT

# --- References ---
@onready var player_spawn_pos: Marker2D = $PlayerStartPosition
@onready var rts_controller: RTSController = $RTSController
@onready var building_container: Node2D = $BuildingContainer
@onready var objective_manager: RaidObjectiveManager = $RaidObjectiveManager
@onready var unit_spawner: UnitSpawner = $UnitSpawner
@export var fyrd_unit_scene: PackedScene

# --- Internal ---
var map_loader: RaidMapLoader
var objective_building: BaseBuilding = null
var unit_container: Node2D

func _ready() -> void:
	Loggie.set_domain_enabled("UI", true)
	Loggie.set_domain_enabled("RTS", true)
	Loggie.set_domain_enabled("RAID", true)
	Loggie.set_domain_enabled("MAP", true)
	
	_setup_unit_container()
	
	if unit_spawner:
		unit_spawner.unit_container = unit_container
		unit_spawner.rts_controller = rts_controller
	else:
		printerr("CRITICAL: UnitSpawner node is missing in RaidMission!")
	
	map_loader = RaidMapLoader.new()
	add_child(map_loader)
	
	if RaidManager.is_defensive_raid:
		self.is_defensive_mission = true
		objective_manager.is_defensive_mission = true
		RaidManager.is_defensive_raid = false
	
	EventBus.settlement_loaded.connect(_on_settlement_ready_for_mission)
	
	if not SettlementManager.has_current_settlement():
		_load_test_settlement()
		call_deferred("initialize_mission")
	else:
		call_deferred("initialize_mission")
		
	get_tree().node_added.connect(_on_node_added)

func _setup_unit_container() -> void:
	if has_node("UnitContainer"):
		unit_container = get_node("UnitContainer")
	else:
		unit_container = Node2D.new()
		unit_container.name = "UnitContainer"
		add_child(unit_container)

func initialize_mission() -> void:
	Loggie.msg("RaidMission: Initializing...").domain(LogDomains.RAID).info()
	
	enemy_base_data = null
	
	# 1. PRIORITY 1: CAMPAIGN FLOW
	# We check if RaidManager has a target.
	if RaidManager.current_raid_target:
		# [FIX] Unwrap the data! 
		# RaidManager.current_raid_target is usually 'RaidTargetData' (The Wrapper).
		# We need the 'SettlementData' inside it.
		var target_wrapper = RaidManager.current_raid_target
		if "settlement_data" in target_wrapper and target_wrapper.settlement_data:
			enemy_base_data = target_wrapper.settlement_data
			Loggie.msg("Loaded SettlementData from RaidManager. Seed: %d" % enemy_base_data.map_seed).domain(LogDomains.RAID).info()
		elif target_wrapper is SettlementData:
			# Handle case where Manager passed raw data
			enemy_base_data = target_wrapper
	
	# 2. PRIORITY 2: DEBUG FLOW (Fresh Generation)
	# If F6 (Scene Run), generate a new procedural base.
	elif enemy_base_data == null and OS.is_debug_build():
		Loggie.msg("Debug Mode: Generating fresh procedural base...").domain(LogDomains.RAID).info()
		enemy_base_data = MapDataGenerator._generate_procedural_settlement("Monastery", 1.0)
		# Ensure the generator gave us a seed!
		if enemy_base_data.map_seed == 0:
			enemy_base_data.map_seed = randi()
	
	# 3. SAFETY FALLBACK (Static File)
	# If all else fails, load the .tres file
	if not enemy_base_data:
		if default_enemy_base_path != "":
			Loggie.msg("Loading Default File: %s" % default_enemy_base_path).domain(LogDomains.RAID).warn()
			enemy_base_data = load(default_enemy_base_path) as SettlementData
	
	if not enemy_base_data:
		Loggie.msg("Critical: No enemy_base_data assigned!").domain(LogDomains.RAID).error()
		return

	if not _validate_nodes(): return
	
	# 4. Register & Setup
	SettlementManager.register_active_scene_nodes(unit_container)
	
	if not map_loader:
		map_loader = RaidMapLoader.new()
		add_child(map_loader)
	
	# [DIAGNOSTIC] Final check before generation
	if enemy_base_data.map_seed == 0:
		Loggie.msg("WARNING: Map Seed is 0. RaidMapLoader will randomize terrain!").domain(LogDomains.RAID).warn()
		
	map_loader.setup(unit_container, enemy_base_data) 
	
	# 3. Generate Map Visuals and refresh manager
	objective_building = map_loader.load_base(enemy_base_data, false)
	Loggie.msg("Force Refreshing Grid (Raid)...").domain(LogDomains.RAID).info()
	SettlementManager._refresh_grid_state()
	
	# 4. Spawn Civilians
	if enemy_base_data and enemy_base_data.population_peasants > 0:
		if unit_spawner:
			unit_spawner.unit_container = unit_container
			
			# Find a safe spot near the main building, or default to offset
			var spawn_origin = Vector2(200, 300)
			if is_instance_valid(objective_building):
				spawn_origin = objective_building.global_position + Vector2(0, 100)
			
			# Ensure it's valid
			spawn_origin = SettlementManager.request_valid_spawn_point(spawn_origin, 5)
			
			unit_spawner.sync_civilians(enemy_base_data.population_peasants, spawn_origin, true)
			
	# 5. Spawn Units
	if is_defensive_mission:
		_setup_defensive_mode()
	else:
		_setup_offensive_mode()
	
	# 6. Finalize Objective
	if is_instance_valid(objective_building):
		if objective_manager:
			objective_manager.initialize(rts_controller, objective_building, unit_container)
			if not objective_manager.fyrd_arrived.is_connected(_on_fyrd_arrived):
				objective_manager.fyrd_arrived.connect(_on_fyrd_arrived)
	else:
		Loggie.msg("Critical: No Objective Building found!").domain(LogDomains.RAID).error()

func _setup_defensive_mode() -> void:
	var settlement = SettlementManager.current_settlement
	if settlement:
		objective_building = map_loader.load_base(settlement, true)
	_spawn_player_garrison()
	_spawn_enemy_wave()

func _setup_offensive_mode() -> void:
	if not enemy_base_data:
		if ResourceLoader.exists(default_enemy_base_path):
			enemy_base_data = load(default_enemy_base_path)
		else: return
	
	objective_building = map_loader.load_base(enemy_base_data, false)
	
	for child in building_container.get_children():
		if child is BaseBuilding:
			child.building_destroyed.connect(_on_building_destroyed_grid_update)
			
	_spawn_player_garrison()
	_spawn_retreat_zone()
	_spawn_enemy_garrison()
	
func _on_building_destroyed_grid_update(building: BaseBuilding) -> void:
	pass

func _spawn_player_garrison() -> void:
	var warbands_to_spawn: Array[WarbandData] = []
	
	if is_defensive_mission:
		if SettlementManager.current_settlement:
			warbands_to_spawn = SettlementManager.current_settlement.warbands
	else:
		if not RaidManager.outbound_raid_force.is_empty():
			warbands_to_spawn = RaidManager.outbound_raid_force
		else:
			if SettlementManager.current_settlement:
				warbands_to_spawn = SettlementManager.current_settlement.warbands
			else:
				_spawn_test_units()
				return

	if warbands_to_spawn.is_empty():
		if not is_defensive_mission:
			objective_manager.call_deferred("_check_loss_condition")
		return
	
	var spawn_origin = player_spawn_pos.global_position
	
	if is_defensive_mission and is_instance_valid(objective_building):
		spawn_origin = objective_building.global_position + Vector2(100, 100)
	elif not is_defensive_mission:
		spawn_origin += landing_direction * 200.0
		
	# Safety Check for Player Spawn
	spawn_origin = SettlementManager.request_valid_spawn_point(spawn_origin, 4)
	
	if unit_spawner:
		unit_spawner.spawn_garrison(warbands_to_spawn, spawn_origin)

func _spawn_enemy_wave() -> void:
	var spawner = get_node_or_null(enemy_spawn_position)
	if not spawner: return
	if enemy_wave_units.is_empty(): return
	
	var origin = spawner.global_position
		
	for i in range(enemy_wave_count):
		var random_data = enemy_wave_units.pick_random()
		var scene_ref = random_data.load_scene()
		if not scene_ref: continue
		
		var unit = scene_ref.instantiate()
		unit.data = random_data 
		unit.collision_layer = 4 # Enemy Layer
		unit.add_to_group("enemy_units")
		
		# --- FIX: Safe Spawning ---
		var offset = Vector2(i * 40, 0) # Basic formation
		var target_pos = origin + offset
		
		# Validate against Grid
		unit.global_position = SettlementManager.request_valid_spawn_point(target_pos, 3)
		if unit.global_position == Vector2.INF:
			unit.global_position = target_pos # Fallback if grid is totally full
		# --------------------------
		
		unit_container.add_child(unit)
		
		if objective_building:
			unit.fsm_ready.connect(func(u): 
				if u.fsm: u.fsm.command_attack(objective_building)
			)

func _on_fyrd_arrived() -> void:
	Loggie.msg("--- FYRD SPAWN START ---").domain(LogDomains.RAID).info()
	
	if fyrd_unit_scene == null:
		var fallback = "res://scenes/units/EnemyUnit_Template.tscn" 
		if ResourceLoader.exists(fallback): fyrd_unit_scene = load(fallback)
	
	if fyrd_unit_scene == null: return

	var spawner = get_node_or_null(enemy_spawn_position)
	var origin = spawner.global_position if spawner else Vector2(1000, 0)
	
	for i in range(5):
		var unit = fyrd_unit_scene.instantiate()
		
		# --- FIX: Randomized but Validated ---
		var random_offset = Vector2(randf_range(-100, 100), randf_range(-100, 100))
		var try_pos = origin + random_offset
		var valid_pos = SettlementManager.request_valid_spawn_point(try_pos, 3)
		
		if valid_pos != Vector2.INF:
			unit.global_position = valid_pos
		else:
			unit.global_position = try_pos
		# -------------------------------------
		
		unit.collision_layer = 4
		unit.add_to_group("enemy_units")
		unit_container.add_child(unit)
		
		if unit.has_method("get_fsm"):
			unit.call_deferred("command_attack_move", player_spawn_pos.global_position if player_spawn_pos else Vector2.ZERO)
		elif unit.get("fsm"):
			unit.fsm.command_attack_move(player_spawn_pos.global_position if player_spawn_pos else Vector2.ZERO)

func _spawn_retreat_zone() -> void:
	var zone_script_path = "res://scenes/missions/RetreatZone.gd"
	if not ResourceLoader.exists(zone_script_path): return
	var zone = Area2D.new()
	zone.set_script(load(zone_script_path))
	var poly = CollisionPolygon2D.new()
	poly.polygon = PackedVector2Array([Vector2(-100,-100), Vector2(100,-100), Vector2(100,100), Vector2(-100,100)])
	zone.add_child(poly)
	zone.global_position = player_spawn_pos.global_position
	zone.add_to_group("retreat_zone")
	add_child(zone)
	zone.unit_evacuated.connect(objective_manager.on_unit_evacuated)

func _load_test_settlement() -> void:
	var data_path = "res://data/settlements/home_base_fixed.tres"
	if ResourceLoader.exists(data_path):
		var data = load(data_path)
		if data: SettlementManager.load_settlement(data)

func _on_settlement_ready_for_mission(_d):
	if not is_instance_valid(objective_manager.rts_controller):
		initialize_mission()

func _validate_nodes() -> bool:
	if not rts_controller: return false
	if not objective_manager: return false
	return true

func _spawn_test_units() -> void:
	var unit_scene = load("res://scenes/units/PlayerVikingRaider.tscn")
	if not unit_scene: return
	for i in range(5):
		var u = unit_scene.instantiate()
		var offset = Vector2(i*30, 0)
		var pos = player_spawn_pos.global_position + offset
		
		# Safe Spawn
		var safe_pos = SettlementManager.request_valid_spawn_point(pos, 2)
		if safe_pos != Vector2.INF: u.global_position = safe_pos
		else: u.global_position = pos
		
		unit_container.add_child(u)

func _spawn_enemy_garrison() -> void:
	if not enemy_base_data: return
		
	# Fail-Safe Generation
	if enemy_base_data.warbands.is_empty():
		MapDataGenerator._scale_garrison(enemy_base_data, 1.0)
	
	if not unit_spawner: return
		
	var guard_buildings = []
	for child in building_container.get_children():
		if child is BaseBuilding:
			guard_buildings.append(child)
	
	# Leverages the already fixed UnitSpawner logic
	unit_spawner.spawn_enemy_garrison(enemy_base_data.warbands, guard_buildings)

func _on_node_added(node: Node) -> void:
	if node is CivilianUnit:
		if not node.surrender_requested.is_connected(_on_civilian_surrender):
			node.surrender_requested.connect(_on_civilian_surrender)

func _on_civilian_surrender(civilian: Node2D) -> void:
	var best_leader = null
	var min_dist = INF
	
	for leader in get_tree().get_nodes_in_group("squad_leaders"):
		var dist = leader.global_position.distance_to(civilian.global_position)
		if dist < min_dist:
			min_dist = dist
			best_leader = leader
			
	if best_leader:
		best_leader.request_escort_for(civilian)

func command_scramble(target_position: Vector2) -> void:
	# FIX: Delegate selection clearing to the RTS controller directly
	if rts_controller and rts_controller.has_method("clear_selection"):
		rts_controller.clear_selection()
	
	# FIX: "controllable_units" was not defined. Using the global group.
	var controllable_units = get_tree().get_nodes_in_group("player_units")
	
	Loggie.msg("Scramble command issued to %d units" % controllable_units.size()).domain(LogDomains.RAID).info()

	for unit in controllable_units:
		if not is_instance_valid(unit): continue
		
		# Panic logic: Pick a random spot near the target
		var panic_offset = Vector2(randf_range(-80, 80), randf_range(-80, 80))
		var unique_dest = target_position + panic_offset
		
		# Use FSM retreat if available, otherwise force move
		if unit.get("fsm") and unit.fsm.has_method("command_retreat"):
			unit.fsm.command_retreat(unique_dest)
		elif unit.has_method("command_move_to"):
			unit.command_move_to(unique_dest)


--------------------------------------------------
FILE: res:///scenes/missions/RaidMission.tscn
--------------------------------------------------
[gd_scene load_steps=13 format=3 uid="uid://d3ifdm0rvd5kl"]

[ext_resource type="Script" uid="uid://cuw68f180xbui" path="res://scenes/missions/RaidMission.gd" id="1_qt4qp"]
[ext_resource type="PackedScene" uid="uid://cyp3t7gbdg0wx" path="res://player/RTSController.tscn" id="2_8icmc"]
[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="2_y6ix7"]
[ext_resource type="PackedScene" uid="uid://1ly65bng2mep" path="res://ui/SelectionBox.tscn" id="3_24u83"]
[ext_resource type="Script" uid="uid://bm330jy5v6a7d" path="res://scripts/utility/RTSInputHandler.gd" id="3_e8k8h"]
[ext_resource type="Resource" uid="uid://brnbvjwnoyh3j" path="res://data/units/EnemyVikingRaider_Data.tres" id="3_eoj4n"]
[ext_resource type="PackedScene" uid="uid://btlcifwc6ckux" path="res://scenes/units/VikingRaider.tscn" id="4_k882g"]
[ext_resource type="TileSet" uid="uid://xoe70lhybj8l" path="res://scenes/levels/Isometric Tileset.tres" id="5_k882g"]
[ext_resource type="Script" uid="uid://bxbqkyp1d6750" path="res://player/RTSCamera.gd" id="5_xkh2l"]
[ext_resource type="PackedScene" uid="uid://ptujtdi5jtsk" path="res://scripts/utility/GridVisualizer.tscn" id="6_l8hqj"]
[ext_resource type="Script" uid="uid://by77ij2ft60cp" path="res://scenes/missions/RaidObjectiveManager.gd" id="6_olj83"]
[ext_resource type="PackedScene" uid="uid://io325box3m4m" path="res://scenes/world/UnitSpawner.tscn" id="11_eoj4n"]

[node name="RaidMission" type="Node2D"]
script = ExtResource("1_qt4qp")
enemy_wave_units = Array[ExtResource("2_y6ix7")]([ExtResource("3_eoj4n")])
default_enemy_base_path = "res://data/settlements/generated/raid_rich_hub_01.tres"
enemy_spawn_position = NodePath("EnemySpawnPosition")
fyrd_unit_scene = ExtResource("4_k882g")

[node name="TileMapLayer" type="TileMapLayer" parent="."]
tile_set = ExtResource("5_k882g")

[node name="PlayerStartPosition" type="Marker2D" parent="."]
position = Vector2(100, 600)

[node name="EnemySpawnPosition" type="Marker2D" parent="."]
position = Vector2(383, -21)

[node name="RTSController" parent="." instance=ExtResource("2_8icmc")]

[node name="RTSInputHandler" type="Node" parent="."]
script = ExtResource("3_e8k8h")

[node name="CanvasLayer" type="CanvasLayer" parent="."]

[node name="SelectionBox" parent="CanvasLayer" instance=ExtResource("3_24u83")]

[node name="RTSCamera" type="Camera2D" parent="."]
position = Vector2(400, 300)
script = ExtResource("5_xkh2l")

[node name="GridVisualizer" parent="." instance=ExtResource("6_l8hqj")]
grid_size = Vector2i(60, 60)

[node name="BuildingContainer" type="Node2D" parent="."]

[node name="RaidObjectiveManager" type="Node" parent="."]
script = ExtResource("6_olj83")

[node name="UnitSpawner" parent="." instance=ExtResource("11_eoj4n")]


--------------------------------------------------
FILE: res:///scenes/missions/RaidObjectiveManager.gd
--------------------------------------------------
# res://scenes/missions/RaidObjectiveManager.gd
extends Node
class_name RaidObjectiveManager

# --- Mission Configuration ---
@export var victory_bonus_loot: Dictionary = {"gold": 200}
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
@export var is_defensive_mission: bool = false

# --- Internal State ---
var raid_loot: RaidLootData
var rts_controller: RTSController
var objective_building: BaseBuilding
var building_container: Node2D
var enemy_units: Array[BaseUnit] = [] 
var is_initialized: bool = false
var mission_over: bool = false

# --- NEW: Performance Tracking ---
var battle_start_time: int = 0
var dead_units_log: Array[UnitData] = []
# ---------------------------------

# --- RETREAT STATE ---
var escaped_unit_count: int = 0

# --- FYRD TIMER STATE ---
const FYRD_ARRIVAL_TIME: float = 120.0 # 2 Minutes
var time_remaining: float = FYRD_ARRIVAL_TIME
var fyrd_timer_active: bool = false
var timer_label: Label

signal fyrd_arrived()

# --- UI Theme ---
const UI_THEME = preload("res://ui/themes/VikingDynastyTheme.tres")

func _ready() -> void:
	raid_loot = RaidLootData.new()
	# Connect to global unit death signal to track casualties
	EventBus.player_unit_died.connect(_on_player_unit_died)
	EventBus.raid_loot_secured.connect(_on_raid_loot_secured)

func _process(delta: float) -> void:
	if fyrd_timer_active and not mission_over:
		time_remaining -= delta
		
		# Update UI
		if is_instance_valid(timer_label):
			var minutes = int(time_remaining / 60)
			var seconds = int(time_remaining) % 60
			timer_label.text = "FYRD ARRIVAL: %02d:%02d" % [minutes, seconds]
			
			if time_remaining < 30:
				timer_label.modulate = Color.RED # Panic color
		
		if time_remaining <= 0:
			_trigger_fyrd()

func initialize(
	p_rts_controller: RTSController, 
	p_objective_building: BaseBuilding, 
	p_building_container: Node2D,
	p_enemy_units: Array[BaseUnit] = []
) -> void:
	if is_initialized:
		Loggie.msg("RaidObjectiveManager: Already initialized, skipping.").domain(LogDomains.RTS).info()
		return
		
	self.rts_controller = p_rts_controller
	self.objective_building = p_objective_building
	self.building_container = p_building_container
	self.enemy_units = p_enemy_units
	
	if not is_instance_valid(rts_controller) or \
	   not is_instance_valid(objective_building) or \
	   not is_instance_valid(building_container):
		push_error("RaidObjectiveManager: Failed to initialize. Received invalid node references.")
		return
	
	# --- NEW: Start Clock ---
	battle_start_time = Time.get_ticks_msec()
	# ------------------------
	
	Loggie.msg("RaidObjectiveManager: Initialized and tracking objectives.").domain(LogDomains.RTS).info()
	
	# Connect to all necessary signals
	if not is_defensive_mission:
		_connect_to_building_signals()
		_setup_mission_ui()
		fyrd_timer_active = true
		
	_setup_win_loss_conditions()
	is_initialized = true
	
	var zones = get_tree().get_nodes_in_group("retreat_zone")
	if not zones.is_empty():
		var zone = zones[0]
		if not zone.unit_evacuated.is_connected(on_unit_evacuated):
			zone.unit_evacuated.connect(on_unit_evacuated)
			print("RaidObjectiveManager: Connected to Retreat Zone.")
	else:
		print("RaidObjectiveManager: WARNING - No Retreat Zone found to connect!")

	is_initialized = true

# --- CASUALTY TRACKING ---
func _on_player_unit_died(unit: Node2D) -> void:
	if not mission_over:
		# Capture the data before the node is deleted
		if "data" in unit and unit.data is UnitData:
			dead_units_log.append(unit.data)
		else:
			# Fallback if data is missing (shouldn't happen, but safe to add generic)
			# We insert a null or a placeholder to keep the count correct
			dead_units_log.append(null)
		# Flavor Log
		var ident = "A Warrior"
		if "unit_identity" in unit: ident = unit.unit_identity
		Loggie.msg(" CASUALTY: %s has fallen!" % ident).domain("RAID").warn()

# --- UI SETUP ---

func _setup_mission_ui() -> void:
	var canvas = get_parent().get_node_or_null("CanvasLayer")
	if not canvas: return
	
	if not is_defensive_mission:
		# 1. Timer
		_setup_timer_ui()
		
		# 2. Retreat Button
		var retreat_btn = Button.new()
		retreat_btn.text = "RETREAT!"
		retreat_btn.modulate = Color(1, 0.5, 0.5)
		retreat_btn.add_theme_font_size_override("font_size", 20)
		retreat_btn.set_anchors_and_offsets_preset(Control.PRESET_TOP_RIGHT, Control.PRESET_MODE_MINSIZE, 20)
		retreat_btn.position.y += 20
		retreat_btn.position.x -= 20
		retreat_btn.pressed.connect(_on_retreat_ordered)
		canvas.add_child(retreat_btn)

func _setup_timer_ui() -> void:
	var canvas = get_parent().get_node_or_null("CanvasLayer")
	if canvas:
		timer_label = Label.new()
		timer_label.add_theme_font_size_override("font_size", 24)
		timer_label.add_theme_color_override("font_color", Color.WHITE)
		timer_label.add_theme_constant_override("outline_size", 4)
		timer_label.add_theme_color_override("font_outline_color", Color.BLACK)
		
		timer_label.set_anchors_preset(Control.PRESET_CENTER_TOP)
		timer_label.position.y += 20
		canvas.add_child(timer_label)

# --- RETREAT LOGIC ---

func _on_retreat_ordered() -> void:
	Loggie.msg("Retreat Ordered! All units scrambling.").domain(LogDomains.RTS).warn()
	
	var spawn_marker = get_parent().get_node_or_null("PlayerStartPosition")
	if spawn_marker and rts_controller:
		rts_controller.command_scramble(spawn_marker.global_position)

func on_unit_evacuated(unit: BaseUnit) -> void:
	escaped_unit_count += 1
	if is_instance_valid(rts_controller):
		rts_controller.remove_unit(unit)

	var remaining_units = get_tree().get_nodes_in_group("player_units")
	var living_count = 0
	
	for u in remaining_units:
		# Filter out dead or queued-for-deletion units just to be safe
		if is_instance_valid(u) and not u.is_queued_for_deletion():
			living_count += 1
			
	print("RaidObjectiveManager: Evacuated! Remaining: %d" % (living_count - 1))
	
	if unit is CivilianUnit:
		# Assuming CivilianUnit has a flag or we just count all evacuated civs as thralls
		if raid_loot:
			raid_loot.add_loot("thrall", 1)
			Loggie.msg("Thrall captured!").domain(LogDomains.RAID).info()
	
	if living_count <= 1:
		print("RaidObjectiveManager: All units evacuated. Ending Mission.")
		_end_mission_via_retreat()

func _end_mission_via_retreat() -> void:
	if mission_over: return
	mission_over = true
	
	Loggie.msg("Ending mission via Retreat").domain(LogDomains.RAID).info()
	
	var mission_result = RaidResultData.new()
	mission_result.outcome = "retreat"
	mission_result.victory_grade = "Tactical Withdrawal"
	mission_result.renown_earned = 0 
	
	# Populate Loot & Casualties (Cleaned up)
	mission_result.loot = raid_loot.collected_loot.duplicate() if raid_loot else {}
	mission_result.casualties = dead_units_log.duplicate()

	RaidManager.pending_raid_result = mission_result
	
	# Note: SettlementBridge will convert "retreat" outcome to "defeat" for history stats later,
	# so we don't strictly need to set last_raid_outcome here, but it doesn't hurt.
	RaidManager.last_raid_outcome = "retreat"
	
	EventBus.scene_change_requested.emit(GameScenes.SETTLEMENT)

func _connect_to_building_signals() -> void:
	if not building_container: return
	
	for child in building_container.get_children():
		if child.has_signal("loot_stolen"):
			if not child.loot_stolen.is_connected(_on_loot_stolen):
				child.loot_stolen.connect(_on_loot_stolen)
				
		if child.has_signal("building_destroyed"):
			if not child.building_destroyed.is_connected(_on_enemy_building_destroyed_for_loot):
				child.building_destroyed.connect(_on_enemy_building_destroyed_for_loot)

# --- NEW: Callback for Pillage ---
func _on_loot_stolen(type: String, amount: int) -> void:
	if mission_over: return
	
	# Add to the temporary raid stash
	raid_loot.add_loot(type, amount)
	
	# Note: raid_loot.add_loot already has a Loggie print, so we don't need another one here.

func _on_enemy_building_destroyed_for_loot(building: BaseBuilding) -> void:
	if mission_over: return
	var building_data = building.data as BuildingData
	if raid_loot and building_data:
		raid_loot.add_loot_from_building(building_data)
		Loggie.msg("Loot secured from %s" % building_data.display_name).domain(LogDomains.RTS).info()

func _setup_win_loss_conditions() -> void:
	if is_defensive_mission:
		if objective_building.has_signal("building_destroyed"):
			objective_building.building_destroyed.connect(_on_player_hall_destroyed)
		_check_defensive_win_condition()
	else:
		_check_loss_condition()

func _check_loss_condition() -> void:
	if mission_over: return
	await get_tree().create_timer(1.0).timeout
	
	var remaining_units = 0
	if is_instance_valid(rts_controller):
		remaining_units = rts_controller.controllable_units.size()
	
	if remaining_units == 0:
		_on_mission_failed("All units destroyed")
		return 
	
	_check_loss_condition()

func _check_defensive_win_condition() -> void:
	if mission_over: return
	await get_tree().create_timer(1.0).timeout

	enemy_units = enemy_units.filter(func(unit): return is_instance_valid(unit))
	if enemy_units.is_empty():
		_on_defensive_mission_won()
		return

	_check_defensive_win_condition()

func _on_player_hall_destroyed(_building: BaseBuilding) -> void:
	if mission_over: return
	_on_mission_failed("Your Great Hall was destroyed!")

func _on_defensive_mission_won() -> void:
	if mission_over: return
	mission_over = true
	_show_victory_message("VICTORY!", "All attackers have been defeated.")
	await get_tree().create_timer(3.0).timeout
	EventBus.scene_change_requested.emit(GameScenes.SETTLEMENT)

func _on_mission_failed(reason: String) -> void:
	if mission_over: return
	mission_over = true
	Loggie.msg("Mission Failed! %s" % reason).domain(LogDomains.RTS).info()
	
	if is_defensive_mission:
		var report = DynastyManager.process_defensive_loss()
		var full_reason = reason + "\n\n" + report.get("summary_text", "")
		_show_failure_message(full_reason)
	else:
		_show_failure_message(reason + "\n\nYour raid failed. No loot was secured.")
	
	await get_tree().create_timer(6.0).timeout
	EventBus.scene_change_requested.emit(GameScenes.SETTLEMENT)

# --- VICTORY GRADING LOGIC ---
func _on_enemy_hall_destroyed(_building: BaseBuilding = null) -> void:
	if mission_over: return
	mission_over = true
	
	var duration_sec = (Time.get_ticks_msec() - battle_start_time) / 1000.0
	var grade = "Standard"
	var casualty_limit = 2
	var lost_count = dead_units_log.size()
	
	# Simple Grading Logic
	if lost_count == 0 and duration_sec < 300:
		grade = "Decisive"
	elif lost_count > casualty_limit:
		grade = "Pyrrhic"
		
	var mission_result = RaidResultData.new()
	mission_result.outcome = "victory"
	mission_result.victory_grade = grade
	
	# Calculate Loot (Base + Bonus)
	var final_loot = raid_loot.collected_loot if raid_loot else {}
	var total_loot = final_loot.duplicate()
	
	# Add Victory Bonus
	for key in victory_bonus_loot:
		var amount = victory_bonus_loot[key]
		var current = total_loot.get(key, 0)
		total_loot[key] = current + amount
	
	mission_result.loot = total_loot
	
	# Calculate Renown
	var difficulty = RaidManager.current_raid_difficulty
	# Base 200 + 50 per star
	mission_result.renown_earned = 200 + (difficulty * 50)
	
	mission_result.casualties = dead_units_log.duplicate()
	
	RaidManager.pending_raid_result = mission_result
	RaidManager.last_raid_outcome = "victory"
	
	Loggie.msg("Raid Victory!").domain(LogDomains.RAID).ctx("Grade", grade).info()
	_show_victory_message("Victory!", "The settlement lies in ruins.")

func _trigger_fyrd() -> void:
	fyrd_timer_active = false
	Loggie.msg("The Fyrd has arrived! Run!").domain(LogDomains.RTS).warn()
	if is_instance_valid(timer_label):
		timer_label.text = "THE FYRD IS HERE!"
	fyrd_arrived.emit()

# --- HELPERS ---
func _show_failure_message(reason: String) -> void:
	var popup = _create_popup_base()
	var label = Label.new()
	label.text = "DEFEAT\n\n" + reason
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.add_theme_color_override("font_color", Color.CRIMSON)
	popup.get_child(1).add_child(label)
	_add_popup_to_canvas(popup)

func _show_victory_message(title: String, subtitle: String) -> void:
	var popup = _create_popup_base()
	var label = Label.new()
	label.text = title + "\n\n" + subtitle
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.add_theme_color_override("font_color", Color.GOLD)
	popup.get_child(1).add_child(label)
	_add_popup_to_canvas(popup)

func _create_popup_base() -> Control:
	var popup = Control.new()
	popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	popup.theme = UI_THEME
	var bg = Panel.new()
	bg.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg.modulate = Color(0,0,0,0.85)
	popup.add_child(bg)
	var container = VBoxContainer.new()
	container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	popup.add_child(container)
	return popup

func _add_popup_to_canvas(popup: Control) -> void:
	var canvas = get_parent().get_node_or_null("CanvasLayer")
	if canvas: canvas.add_child(popup)
	else: get_tree().current_scene.add_child(popup)

func _on_raid_loot_secured(type: String, amount: int) -> void:
	if not raid_loot:
		raid_loot = RaidLootData.new()
		
	raid_loot.add_loot(type, amount)
	
	# Visual Feedback
	var color = Color.GOLD if type == "gold" else Color.WHITE
	if type == "thrall": color = Color.CYAN
	
	# We can spawn floating text at the Retreat Zone center (approximate)
	# or just update a UI counter. For now, let's just log it.
	print("RaidObjectiveManager: Secured %d %s!" % [amount, type])
	
	# Trigger UI update if you have a Loot HUD
	# EventBus.ui_update_loot.emit(raid_loot.collected_loot)


--------------------------------------------------
FILE: res:///scenes/missions/RetreatZone.gd
--------------------------------------------------
# res://scenes/missions/RetreatZone.gd
class_name RetreatZone
extends Area2D

signal unit_evacuated(unit: BaseUnit)

# Visuals
const COLOR_FILL = Color(0.2, 1.0, 0.2, 0.2) # Transparent Green
const COLOR_BORDER = Color(0.2, 1.0, 0.2, 0.8) # Solid Green Border

func _ready() -> void:
	# 1. Setup Collision
	# We only want to detect Player Units (Layer 2)
	collision_layer = 0 
	collision_mask = 2 
	monitorable = false
	monitoring = true
	
	body_entered.connect(_on_body_entered)
	
	# 2. Ensure we are visible for drawing
	z_index = 0 
	queue_redraw()

func _draw() -> void:
	# Draw the visual box matching the collision shape (200x200)
	# defined in RaidMission.gd
	var rect = Rect2(-100, -100, 200, 200)
	
	# Fill
	draw_rect(rect, COLOR_FILL, true)
	# Border
	draw_rect(rect, COLOR_BORDER, false, 3.0)
	
	# Optional Label
	var font = ThemeDB.get_fallback_font()
	draw_string(font, Vector2(-30, 5), "RETREAT", HORIZONTAL_ALIGNMENT_CENTER, -1, 16, Color.WHITE)

func _on_body_entered(body: Node2D) -> void:
	# 1. Handle Soldiers with Loot
	if body.has_method("add_loot"): # Duck typing for BaseUnit
		var unit = body as BaseUnit
		if not unit.inventory.is_empty():
			_bank_unit_inventory(unit)
			
	# 2. Handle Retreating Units (Evacuation)
	# If a unit is explicitly in RETREATING state, we might despawn them to save them
	if body.get("fsm") and body.fsm.current_state == UnitAIConstants.State.RETREATING:
		_evacuate_unit(body)

func _bank_unit_inventory(unit: BaseUnit) -> void:
	var total_value = 0
	
	for type in unit.inventory:
		var amount = unit.inventory[type]
		if amount > 0:
			EventBus.raid_loot_secured.emit(type, amount)
			total_value += amount
			
			# Juice
			EventBus.floating_text_requested.emit("+%d %s" % [amount, type.capitalize()], unit.global_position, Color.GOLD)
	
	# Clear the unit's backpack so they can go steal more
	unit.inventory.clear()
	unit.current_loot_weight = 0
	
	if total_value > 0:
		print("RetreatZone: Secured loot from %s" % unit.name)

func _evacuate_unit(unit: BaseUnit) -> void:
	if unit.is_queued_for_deletion(): return
	
	# 1. Visual Feedback (Fade out)
	var tween = create_tween()
	tween.tween_property(unit, "modulate:a", 0.0, 0.5)
	
	# 2. Disable Logic (Stop moving/colliding immediately)
	unit.set_physics_process(false)
	unit.set_process(false)
	unit.collision_layer = 0
	unit.collision_mask = 0
	
	# 3. Notify System
	Loggie.msg("RetreatZone: Unit escaped -> %s" % unit.name).domain("RAID").info()
	unit_evacuated.emit(unit)
	
	# 4. Cleanup after fade
	tween.tween_callback(unit.queue_free)


--------------------------------------------------
FILE: res:///scenes/units/Base_Unit.tscn
--------------------------------------------------
[gd_scene load_steps=6 format=3 uid="uid://bky4c6y8fkk8g"]

[ext_resource type="Script" uid="uid://djhncrlnql4ae" path="res://scripts/units/Base_Unit.gd" id="1_script"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="2_lfiq5"]
[ext_resource type="Shape2D" uid="uid://bda7xb0judu2h" path="res://resources/separation_circle_shape.tres" id="3_b08re"]
[ext_resource type="Script" uid="uid://di5v5jxy7ocug" path="res://scenes/units/StuckDetector.gd" id="4_ssn5w"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_n6s0a"]
size = Vector2(72, 72)

[node name="Base_Unit" type="CharacterBody2D"]
collision_layer = 2
script = ExtResource("1_script")

[node name="Sprite2D" type="Sprite2D" parent="."]
texture = ExtResource("2_lfiq5")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_n6s0a")

[node name="AttackTimer" type="Timer" parent="."]

[node name="SeparationArea" type="Area2D" parent="."]
collision_layer = 0
collision_mask = 2
monitorable = false

[node name="CollisionShape2D" type="CollisionShape2D" parent="SeparationArea"]
shape = ExtResource("3_b08re")

[node name="StuckDetector" type="Node" parent="."]
script = ExtResource("4_ssn5w")


--------------------------------------------------
FILE: res:///scenes/units/Bondi.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://b23ynenrrakpo"]

[ext_resource type="Script" uid="uid://btumxrbbibjx8" path="res://scripts/units/PlayerVikingRaider.gd" id="1_uy07r"]
[ext_resource type="Shape2D" uid="uid://bda7xb0judu2h" path="res://resources/separation_circle_shape.tres" id="2_hbse2"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_n6s0a"]
size = Vector2(72, 72)

[node name="PlayerVikingRaider" type="CharacterBody2D"]
modulate = Color(0.6, 0.7, 0.5, 1)
collision_layer = 2
script = ExtResource("1_uy07r")

[node name="Sprite2D" type="Sprite2D" parent="."]
region_rect = Rect2(509.90704, 170.3761, 21.10736, 26.607208)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_n6s0a")

[node name="AttackTimer" type="Timer" parent="."]

[node name="SeparationArea" type="Area2D" parent="."]
collision_layer = 0
collision_mask = 2
monitorable = false

[node name="CollisionShape2D" type="CollisionShape2D" parent="SeparationArea"]
shape = ExtResource("2_hbse2")


--------------------------------------------------
FILE: res:///scenes/units/BondiUnit.tscn
--------------------------------------------------
[gd_scene format=3 uid="uid://csk233jkvh54k"]

[node name="Main" type="Node2D"]


--------------------------------------------------
FILE: res:///scenes/units/Civilian.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://c7powse34uuxc"]

[ext_resource type="PackedScene" uid="uid://bky4c6y8fkk8g" path="res://scenes/units/Base_Unit.tscn" id="1_7jnl1"]
[ext_resource type="Script" uid="uid://cumpki2vfwt1e" path="res://scripts/units/CivilianUnit.gd" id="2_7jnl1"]
[ext_resource type="Resource" uid="uid://iiho31ik0qvb" path="res://data/units/Unit_Civilian.tres" id="3_obgkw"]

[node name="Civilian" instance=ExtResource("1_7jnl1")]
script = ExtResource("2_7jnl1")
mob_separation_force = 100.0
mob_separation_radius = 45.0
thrall_unit_scene = null
data = ExtResource("3_obgkw")

[node name="Sprite2D" parent="." index="0"]
modulate = Color(1, 1, 0, 1)
region_rect = Rect2(509.90704, 170.3761, 21.10736, 26.607208)


--------------------------------------------------
FILE: res:///scenes/units/Drengr.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://dwmjo52snfdsl"]

[ext_resource type="Script" uid="uid://btumxrbbibjx8" path="res://scripts/units/PlayerVikingRaider.gd" id="1_jw7fk"]
[ext_resource type="Shape2D" uid="uid://bda7xb0judu2h" path="res://resources/separation_circle_shape.tres" id="2_2vnw6"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_n6s0a"]
size = Vector2(72, 72)

[node name="Drengr" type="CharacterBody2D"]
modulate = Color(0.9, 0.4, 0.4, 1)
collision_layer = 2
script = ExtResource("1_jw7fk")

[node name="Sprite2D" type="Sprite2D" parent="."]
region_rect = Rect2(509.90704, 170.3761, 21.10736, 26.607208)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_n6s0a")

[node name="AttackTimer" type="Timer" parent="."]

[node name="SeparationArea" type="Area2D" parent="."]
collision_layer = 0
collision_mask = 2
monitorable = false

[node name="CollisionShape2D" type="CollisionShape2D" parent="SeparationArea"]
shape = ExtResource("2_2vnw6")


--------------------------------------------------
FILE: res:///scenes/units/EnemyVikingRaider(depreciated).tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://dsv0s4yq8c8m5"]

[ext_resource type="PackedScene" uid="uid://bky4c6y8fkk8g" path="res://scenes/units/Base_Unit.tscn" id="1_base"]
[ext_resource type="Script" uid="uid://cavpq2rrgln2v" path="res://scripts/units/EnemyVikingRaider.gd" id="2_script"]

[node name="EnemyVikingRaider" instance=ExtResource("1_base")]
collision_layer = 4
collision_mask = 3
script = ExtResource("2_script")
separation_enabled = true
separation_force = 30.0
separation_radius = 40.0

[node name="Sprite2D" parent="." index="0"]
scale = Vector2(0.06542969, 0.068359375)


--------------------------------------------------
FILE: res:///scenes/units/PlayerVikingRaider.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://cfanwutbtfcp2"]

[ext_resource type="PackedScene" uid="uid://bky4c6y8fkk8g" path="res://scenes/units/Base_Unit.tscn" id="1_base"]
[ext_resource type="Script" uid="uid://btumxrbbibjx8" path="res://scripts/units/PlayerVikingRaider.gd" id="2_script"]

[node name="PlayerVikingRaider" instance=ExtResource("1_base")]
script = ExtResource("2_script")

[node name="Sprite2D" parent="." index="0"]
texture = null
region_rect = Rect2(509.90704, 170.3761, 21.10736, 26.607208)


--------------------------------------------------
FILE: res:///scenes/units/StuckDetector.gd
--------------------------------------------------
extends Node

# --- CONFIG ---
@export var parent_unit: CharacterBody2D
@export var check_interval: float = 0.5
@export var stuck_limit: int = 2
@export var unit_layer_index: int = 2 

# --- STATE ---
var last_dist_to_target: float = 99999.0
var timer: float = 0.0
var stuck_count: int = 0
var is_phasing: bool = false
var cached_mask: int = 0 

func _ready() -> void:
	if not parent_unit: parent_unit = get_parent()
	await get_tree().process_frame
	if _has_target():
		last_dist_to_target = parent_unit.global_position.distance_to(parent_unit.formation_target)

func _physics_process(delta: float) -> void:
	if not _is_trying_to_move(): 
		_reset_stuck_status()
		return

	timer += delta
	if timer < check_interval: return
	
	# --- CHECK PROGRESS (Every 0.5s) ---
	timer = 0.0
	
	# Calculate current distance to the goal
	var current_dist = 0.0
	if _has_target():
		current_dist = parent_unit.global_position.distance_to(parent_unit.formation_target)
	else:
		_reset_stuck_status()
		return
		
	# DID WE IMPROVE?
	# We expect to move at least 10 pixels CLOSER to the target in 0.5s
	var progress = last_dist_to_target - current_dist
	last_dist_to_target = current_dist
	
	# If we improved by less than 10 pixels (even if we slid 50 pixels sideways), we are stuck.
	if progress < 10.0:
		stuck_count += 1
		if stuck_count >= stuck_limit and not is_phasing:
			_set_phasing(true)
	else:
		# We are making real progress -> CLEAR
		stuck_count = 0
		if is_phasing:
			_set_phasing(false)

func _set_phasing(active: bool) -> void:
	is_phasing = active
	if active:
		cached_mask = parent_unit.collision_mask
		parent_unit.collision_mask = 0  # Phase through everything
		parent_unit.modulate.a = 0.5
	else:
		parent_unit.collision_mask = cached_mask
		parent_unit.modulate.a = 1.0

func _is_trying_to_move() -> bool:
	if "velocity" in parent_unit and parent_unit.velocity.length_squared() > 100.0:
		return true
	return false

func _has_target() -> bool:
	return "formation_target" in parent_unit and parent_unit.formation_target != Vector2.ZERO

func _reset_stuck_status() -> void:
	stuck_count = 0
	timer = 0.0
	if is_phasing: _set_phasing(false)
	# Reset distance tracker so we don't trigger immediately on next move
	if _has_target():
		last_dist_to_target = parent_unit.global_position.distance_to(parent_unit.formation_target)


--------------------------------------------------
FILE: res:///scenes/units/Thrall.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://c4id53apf1ynt"]

[ext_resource type="PackedScene" uid="uid://c7powse34uuxc" path="res://scenes/units/Civilian.tscn" id="1_nf5h2"]
[ext_resource type="Script" uid="uid://i86w1ypvmn5o" path="res://scripts/units/ThrallUnit.gd" id="2_x7cfk"]

[node name="Thrall" instance=ExtResource("1_nf5h2")]
script = ExtResource("2_x7cfk")


--------------------------------------------------
FILE: res:///scenes/units/UnitDebugger.gd
--------------------------------------------------
extends Node2D
class_name UnitDebugger

# --- CONFIG ---
@export var font_size: int = 12
@export var show_visuals: bool = true

# --- REFS ---
var parent: CharacterBody2D
var stuck_detector: Node
var label: Label

func _ready() -> void:
	# 1. Attach to Parent
	parent = get_parent() as CharacterBody2D
	if not parent:
		set_process(false)
		return

	# 2. Find StuckDetector (Sibling)
	stuck_detector = parent.get_node_or_null("StuckDetector")
	
	# 3. Setup UI Label
	label = Label.new()
	label.scale = Vector2(0.5, 0.5) # Make text crisp but small
	label.position = Vector2(-20, -50)
	label.modulate = Color.YELLOW
	add_child(label)
	
	# Ensure we draw on top of the sprite
	z_index = 100 

func _process(_delta: float) -> void:
	if not show_visuals: 
		label.text = ""
		return
		
	queue_redraw()
	_update_label()

func _update_label() -> void:
	var mask_val = parent.collision_mask
	var vel_len = parent.velocity.length()
	
	var status = "OK"
	if stuck_detector:
		if stuck_detector.is_phasing: status = "PHASING"
		elif stuck_detector.stuck_count > 0: status = "STUCK (%d)" % stuck_detector.stuck_count
	
	var txt = "ID: %s\n" % parent.name
	txt += "Vel: %.1f\n" % vel_len
	txt += "Mask: %d (Layer 1=%s)\n" % [mask_val, "ON" if mask_val & 1 else "OFF"]
	txt += "State: %s" % status
	
	# Show Collision Info
	var slide_count = parent.get_slide_collision_count()
	if slide_count > 0:
		var collider = parent.get_slide_collision(0).get_collider()
		txt += "\nHit: %s" % (collider.name if collider else "null")
		
	label.text = txt

func _draw() -> void:
	if not show_visuals: return
	
	# 1. Draw Velocity (Green Arrow)
	if parent.velocity.length() > 10.0:
		draw_line(Vector2.ZERO, parent.velocity.normalized() * 30.0, Color.GREEN, 2.0)
	
	# 2. Draw Target (Red Line)
	if "formation_target" in parent and parent.formation_target != Vector2.ZERO:
		var local_target = to_local(parent.formation_target)
		# Only draw if reasonably close
		if local_target.length() < 500:
			draw_line(Vector2.ZERO, local_target, Color.RED, 1.0)
			draw_circle(local_target, 3.0, Color.RED)

# --- DEEP SCAN TRIGGER ---
func _unhandled_input(event: InputEvent) -> void:
	# Press 'P' while hovering mouse over unit to print detailed logs
	if event is InputEventKey and event.pressed and event.keycode == KEY_P:
		var mouse_pos = get_global_mouse_position()
		if parent.global_position.distance_to(mouse_pos) < 30.0:
			_print_deep_scan()

func _print_deep_scan() -> void:
	print("\n===  UNIT DIAGNOSTIC: %s ===" % parent.name)
	print("Position:      ", parent.global_position)
	print("Target (Form): ", parent.get("formation_target"))
	print("Velocity:      %s (Speed: %.2f)" % [parent.velocity, parent.velocity.length()])
	print("Collision Mask:%d (Binary: %s)" % [parent.collision_mask, String.num_int64(parent.collision_mask, 2)])
	
	if stuck_detector:
		print("--- STUCK DETECTOR ---")
		print("Is Phasing:    ", stuck_detector.is_phasing)
		print("Stuck Count:   ", stuck_detector.stuck_count)
		print("Last Check Pos:", stuck_detector.last_pos)
		print("Dist Moved:    ", parent.global_position.distance_to(stuck_detector.last_pos))
	
	var count = parent.get_slide_collision_count()
	print("--- PHYSICS ---")
	print("Slide Collisions: ", count)
	for i in range(count):
		var col = parent.get_slide_collision(i)
		print("  [%d] Hit: %s (Layer: %d)" % [i, col.get_collider().name, col.get_collider().collision_layer])
	print("================================\n")


--------------------------------------------------
FILE: res:///scenes/units/VikingRaider.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://btlcifwc6ckux"]

[ext_resource type="PackedScene" uid="uid://bky4c6y8fkk8g" path="res://scenes/units/Base_Unit.tscn" id="1_base"]
[ext_resource type="Script" uid="uid://cavpq2rrgln2v" path="res://scripts/units/EnemyVikingRaider.gd" id="2_script"]
[ext_resource type="Resource" uid="uid://brnbvjwnoyh3j" path="res://data/units/EnemyVikingRaider_Data.tres" id="3_s66tq"]

[node name="VikingRaider" instance=ExtResource("1_base")]
collision_layer = 4
script = ExtResource("2_script")
data = ExtResource("3_s66tq")
separation_enabled = false

[node name="Sprite2D" parent="." index="0"]
modulate = Color(0.5464087, 3.85046e-07, 2.4065375e-07, 1)
self_modulate = Color(1, 0, 0, 1)
scale = Vector2(0.059, 0.062)

[node name="CollisionShape2D" parent="." index="1"]
position = Vector2(-1, 0)


--------------------------------------------------
FILE: res:///scenes/world/ResourceNode.gd
--------------------------------------------------
@tool
class_name ResourceNode
extends Area2D

signal node_depleted(node: ResourceNode)

# --- Configuration ---
@export_group("District Settings")
## The type of resource. Must match EconomicBuildingData.resource_type (e.g., "wood", "food", "stone").
@export var resource_type: String = "wood":
	set(value):
		resource_type = value
		queue_redraw() # Update color in editor

## The radius (in pixels) within which gathering buildings must be placed.
## Default: 6 tiles * 32px = 192.0
@export var district_radius: float = 192.0:
	set(value):
		district_radius = value
		queue_redraw() # Update circle size in editor

@export_group("Pool Settings")
@export var max_pool: int = 1000
@export var current_pool: int = 1000
@export var is_infinite: bool = false

# --- Internal ---
# Colors for the editor visualizer
const DEBUG_COLORS = {
	"wood": Color.FOREST_GREEN,
	"food": Color.GOLDENROD,
	"stone": Color.LIGHT_SLATE_GRAY,
	"gold": Color.GOLD
}

func _ready() -> void:
	# Critical: Registers this node so the SettlementManager can find it for placement checks
	add_to_group("resource_nodes")
	
	if not Engine.is_editor_hint():
		# Runtime initialization
		current_pool = max_pool

func _draw() -> void:
	# Only draw the district radius in the Editor or if Debug Collisions is on
	if Engine.is_editor_hint() or get_tree().debug_collisions_hint:
		var color = DEBUG_COLORS.get(resource_type, Color.WHITE)
		
		# Draw faint fill area
		draw_circle(Vector2.ZERO, district_radius, Color(color.r, color.g, color.b, 0.1))
		# Draw dashed outline (approximate)
		draw_arc(Vector2.ZERO, district_radius, 0, TAU, 64, color, 2.0)

# --- Public API ---

func harvest(amount: int) -> int:
	"""
	Attempts to harvest 'amount'. Returns actual harvested amount.
	"""
	if is_depleted(): 
		return 0
	
	if is_infinite: 
		return amount
		
	var actual_amount = min(amount, current_pool)
	current_pool -= actual_amount
	
	if current_pool <= 0:
		_on_depletion()
		
	return actual_amount

func is_depleted() -> bool:
	return not is_infinite and current_pool <= 0

## Checks if a world position is inside this node's district
func is_position_in_district(world_pos: Vector2) -> bool:
	return global_position.distance_to(world_pos) <= district_radius

func _on_depletion() -> void:
	Loggie.msg("Resource Node depleted: %s" % name).domain(LogDomains.ECONOMY).info()
	node_depleted.emit(self)
	# Visual feedback for depletion can be added here (e.g., change sprite to stump)
	modulate = Color(0.5, 0.5, 0.5)


--------------------------------------------------
FILE: res:///scenes/world/Resource_Wood.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://bmrx7k05of21t"]

[ext_resource type="Script" uid="uid://cfj14fe8a8hmp" path="res://scenes/world/ResourceNode.gd" id="1_sdct1"]
[ext_resource type="Texture2D" uid="uid://db4binkwy6ipf" path="res://assets/assets_spritesheet_v2_free.png" id="2_sy4g7"]

[sub_resource type="CircleShape2D" id="CircleShape2D_vdeun"]
radius = 192.0

[node name="Resource_Wood" type="Area2D"]
script = ExtResource("1_sdct1")

[node name="Sprite2D" type="Sprite2D" parent="."]
texture = ExtResource("2_sy4g7")
region_enabled = true
region_rect = Rect2(0, 0, 61, 98.5)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("CircleShape2D_vdeun")


--------------------------------------------------
FILE: res:///scenes/world/UnitSpawner.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://io325box3m4m"]

[ext_resource type="Script" uid="uid://bu6n0wwl0x5ic" path="res://scripts/utility/UnitSpawner.gd" id="1_eyemm"]
[ext_resource type="Resource" uid="uid://iiho31ik0qvb" path="res://data/units/Unit_Civilian.tres" id="2_nudm2"]

[node name="UnitSpawner" type="Node"]
script = ExtResource("1_eyemm")
civilian_data = ExtResource("2_nudm2")


--------------------------------------------------
FILE: res:///scenes/world_map/MacroCamera.gd
--------------------------------------------------
# res://scenes/world_map/MacroCamera.gd
# Upgraded with Zoom and Edge Panning
extends Camera2D 
class_name MacroCamera

# --- Movement Settings ---
@export_group("Movement")
@export var camera_speed: float = 500.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_keyboard_movement: bool = true

# --- Zoom Settings ---
@export_group("Zoom")
@export var min_zoom: float = 0.5  # Far away
@export var max_zoom: float = 2.0  # Close up
@export var zoom_speed: float = 0.1
@export var zoom_smoothing: float = 10.0

# --- Bounds Settings ---
@export_group("Bounds")
@export var bounds_enabled: bool = true 
@export var bounds_rect: Rect2 = Rect2(0, 0, 1920, 1080)

# Internal State
var target_zoom: Vector2 = Vector2.ONE
var is_dragging: bool = false
var drag_start_pos: Vector2

func _ready() -> void:
	target_zoom = zoom
	make_current()

func snap_to_target(target_position: Vector2) -> void:
	global_position = target_position
	_clamp_camera_to_bounds()

func _process(delta: float) -> void:
	# 1. Apply Smooth Zoom
	zoom = zoom.lerp(target_zoom, zoom_smoothing * delta)
	
	# 2. Handle Movement
	if not is_dragging:
		_handle_movement(delta)
		
	# 3. Clamp Bounds
	_clamp_camera_to_bounds()

func _handle_movement(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	var viewport_size = get_viewport().get_visible_rect().size
	var mouse_pos = get_viewport().get_mouse_position()
	
	# Keyboard Movement
	if enable_keyboard_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Edge Panning
	if enable_edge_panning:
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply Movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		# Adjust speed based on zoom (move faster when zoomed out)
		var zoom_multiplier = 1.0 / zoom.x
		global_position += movement_vector * camera_speed * zoom_multiplier * delta

func _unhandled_input(event: InputEvent) -> void:
	# Zoom Controls
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			_zoom_in()
			get_viewport().set_input_as_handled()
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			_zoom_out()
			get_viewport().set_input_as_handled()
			
		# Middle-Mouse Drag
		elif event.button_index == MOUSE_BUTTON_MIDDLE:
			if event.is_pressed():
				is_dragging = true
				drag_start_pos = get_global_mouse_position() - global_position
				get_viewport().set_input_as_handled()
			else:
				is_dragging = false
				get_viewport().set_input_as_handled()
				
	elif event is InputEventMouseMotion and is_dragging:
		global_position = get_global_mouse_position() - drag_start_pos
		_clamp_camera_to_bounds()
		get_viewport().set_input_as_handled()

func _zoom_in() -> void:
	target_zoom += Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _zoom_out() -> void:
	target_zoom -= Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _clamp_zoom() -> void:
	target_zoom.x = clamp(target_zoom.x, min_zoom, max_zoom)
	target_zoom.y = clamp(target_zoom.y, min_zoom, max_zoom)

func _clamp_camera_to_bounds() -> void:
	if bounds_enabled:
		# Adjust bounds based on zoom to prevent seeing outside the map
		var view_size = get_viewport_rect().size / zoom
		var min_x = bounds_rect.position.x + view_size.x / 2
		var max_x = bounds_rect.end.x - view_size.x / 2
		var min_y = bounds_rect.position.y + view_size.y / 2
		var max_y = bounds_rect.end.y - view_size.y / 2
		
		# Only clamp if the map is larger than the view
		if min_x < max_x: global_position.x = clamp(global_position.x, min_x, max_x)
		if min_y < max_y: global_position.y = clamp(global_position.y, min_y, max_y)


--------------------------------------------------
FILE: res:///scenes/world_map/MacroCamera.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://lpxvj8dvfbnl"]

[ext_resource type="Script" uid="uid://ccjwevksm7s3s" path="res://scenes/world_map/MacroCamera.gd" id="1_tibwm"]

[node name="MacroCamera" type="Camera2D"]
script = ExtResource("1_tibwm")


--------------------------------------------------
FILE: res:///scenes/world_map/MacroMap.gd
--------------------------------------------------
# res://scenes/world_map/MacroMap.gd
extends Node2D

# --- Scene Configuration ---
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
@export var enemy_raid_chance: float = 0.25

# --- NEW: Raid Prep UI ---
@export var raid_prep_window_scene: PackedScene = preload("res://ui/RaidPrepWindow.tscn")

# --- Geography Anchor ---
@export var player_home_marker_path: NodePath = "PlayerHomeMarker"
@onready var player_home_marker: Marker2D = get_node_or_null(player_home_marker_path)
@onready var macro_camera: MacroCamera = $MacroCamera

# --- UI References ---
@onready var authority_label: Label = $UI/JarlInfo/VBoxContainer/AuthorityLabel
@onready var renown_label: Label = $UI/JarlInfo/VBoxContainer/RenownLabel
@onready var region_info_panel: PanelContainer = $UI/RegionInfo
@onready var region_name_label: Label = $UI/RegionInfo/VBoxContainer/RegionNameLabel
@onready var launch_raid_button: Button = $UI/RegionInfo/VBoxContainer/LaunchRaidButton 
@onready var target_list_container: VBoxContainer = $UI/RegionInfo/VBoxContainer/TargetList

@onready var settlement_button: Button = $UI/Actions/VBoxContainer/SettlementButton
@onready var subjugate_button: Button = $UI/RegionInfo/VBoxContainer/SubjugateButton
@onready var dynasty_button: Button = $UI/Actions/VBoxContainer/DynastyButton
@onready var dynasty_ui: DynastyUI = $UI/Dynasty_UI
@onready var marry_button: Button = $UI/RegionInfo/VBoxContainer/MarryButton
@onready var tooltip: PanelContainer = $UI/Tooltip
@onready var tooltip_label: Label = $UI/Tooltip/Label
@onready var regions_container: Node2D = $Regions

# --- Systems & State ---
var raid_prep_window: RaidPrepWindow
var journey_report_dialog: AcceptDialog

# Persistence
const SAVE_PATH = "user://campaign_map.tres"
var map_state: MapState

# Selection State
var selected_region_data: WorldRegionData
var selected_region_node: Region = null
var calculated_subjugate_cost: int = 5 
var current_attrition_risk: float = 0.0

# Visual Constants
const SAFE_COLOR := Color(0.2, 0.8, 0.2, 0.1)   # Green
const RISK_COLOR := Color(1.0, 0.6, 0.0, 0.1)   # Orange
const HIGH_RISK_COLOR := Color(1.0, 0.0, 0.0, 0.1) # Red

func _ready() -> void:
	# 1. Anchor & Camera Setup
	if not player_home_marker:
		push_error("MacroMap: 'PlayerHomeMarker' missing! Distance calculations will fail.")
	else:
		Loggie.msg("MacroMap: Geography Anchor set at %s" % player_home_marker.global_position).domain("MAP").info()
		if macro_camera:
			Loggie.msg("MacroMap: Snapping camera to home.").domain("MAP").info()
			macro_camera.snap_to_target(player_home_marker.global_position)

	# 2. Data Initialization
	_initialize_world_data()
	
	# 3. UI & Signal Connections
	if launch_raid_button: launch_raid_button.hide()
	
	DynastyManager.jarl_stats_updated.connect(_update_jarl_ui)
	DynastyManager.jarl_stats_updated.connect(func(_j): queue_redraw())
	
	for region in regions_container.get_children():
		if region is Region:
			region.region_hovered.connect(_on_region_hovered)
			region.region_exited.connect(_on_region_exited)
			region.region_selected.connect(_on_region_selected)
			
	settlement_button.pressed.connect(_on_settlement_pressed)
	subjugate_button.pressed.connect(_on_subjugate_pressed)
	dynasty_button.pressed.connect(_on_dynasty_pressed)
	marry_button.pressed.connect(_on_marry_pressed)
	
	# 4. Raid Prep UI
	if raid_prep_window_scene:
		raid_prep_window = raid_prep_window_scene.instantiate()
		$UI.add_child(raid_prep_window) 
		raid_prep_window.raid_launched.connect(_finalize_raid_launch)
		
	journey_report_dialog = AcceptDialog.new()
	journey_report_dialog.title = "Journey Report"
	journey_report_dialog.confirmed.connect(_transition_to_raid_scene)
	add_child(journey_report_dialog)
	
	# 5. Event System
	EventBus.event_system_finished.connect(_on_event_system_finished)
	
	# 6. Final Cleanup
	_update_jarl_ui(DynastyManager.get_current_jarl())
	region_info_panel.hide()
	tooltip.hide()
	queue_redraw()

# --- Raid Preparation Logic ---

func _initiate_raid(target: RaidTargetData) -> void:
	if not raid_prep_window:
		Loggie.msg("MacroMap: RaidPrepWindow scene not assigned!").domain(LogDomains.MAP).error()
		return
		
	# 1. Hide Region Panel to declutter
	region_info_panel.hide()
	
	# 2. Setup and Show Prep Window
	raid_prep_window.setup(target)

func _finalize_raid_launch(target: RaidTargetData, warbands: Array[WarbandData], provision_level: int) -> void:
	# 1. Deduct Authority (Stays in DynastyManager)
	var cost = target.raid_cost_authority
	if target.authority_cost_override > -1: cost = target.authority_cost_override
	
	if not DynastyManager.spend_authority(cost):
		Loggie.msg("MacroMap: Failed to spend authority at last second!").domain(LogDomains.MAP).error()
		return

	# 2. Commit Data to RaidManager (FIXED)
	RaidManager.set_current_raid_target(target.settlement_data)
	RaidManager.current_raid_difficulty = target.difficulty_rating
	RaidManager.prepare_raid_force(warbands, provision_level)
	
	# 3. Calculate Journey Attrition (FIXED)
	var dist = 0.0
	if player_home_marker and is_instance_valid(selected_region_node):
		dist = player_home_marker.global_position.distance_to(selected_region_node.get_global_center())
		
	var report = RaidManager.calculate_journey_attrition(dist)
	
	# 4. Show Journey Report
	journey_report_dialog.title = report.get("title", "Journey")
	journey_report_dialog.dialog_text = report.get("description", "...")
	journey_report_dialog.popup_centered()

func _transition_to_raid_scene() -> void:
	Loggie.msg("MacroMap: Transitioning to Raid...").domain(LogDomains.MAP).info()
	EventBus.scene_change_requested.emit(GameScenes.RAID_MISSION)

# --- Visuals & Data Logic ---

func _draw() -> void:
	if not player_home_marker: return
	var jarl = DynastyManager.get_current_jarl()
	if not jarl: return
	
	var safe_r = jarl.get_safe_range()
	
	draw_circle(player_home_marker.position, safe_r, SAFE_COLOR)
	draw_arc(player_home_marker.position, safe_r, 0, TAU, 64, Color.GREEN, 2.0)
	draw_arc(player_home_marker.position, safe_r + 500, 0, TAU, 64, Color.RED, 1.0)

func _initialize_world_data() -> void:
	if ResourceLoader.exists(SAVE_PATH):
		Loggie.msg("MacroMap: Loading existing campaign state...").domain("MAP").info()
		map_state = load(SAVE_PATH)
		_apply_state_to_regions()
	else:
		Loggie.msg("MacroMap: New Campaign detected. Generating world...").domain("MAP").info()
		map_state = MapState.new()
		_generate_new_world()
		_save_map_state()

func _generate_new_world() -> void:
	if not player_home_marker: return
	var jarl = DynastyManager.get_current_jarl()
	if not jarl: return
	
	var safe_range = jarl.get_safe_range()
	
	for region in regions_container.get_children():
		if not region is Region: continue
		var dist = player_home_marker.global_position.distance_to(region.get_global_center())
		var tier = 1
		if dist <= safe_range: tier = 1
		elif dist <= safe_range * 1.5: tier = 2
		else: tier = 3
		
		# --- FIX: Preserve Historical Name ---
		var current_name = ""
		if region.data:
			current_name = region.data.display_name
		# -------------------------------------
			
		# Pass the name into the generator
		var data = MapDataGenerator.generate_region_data(tier, current_name)
		
		region.data = data
		map_state.region_data_map[region.name] = data
		Loggie.msg("Generated %s (Tier %d) at dist %.0f" % [data.display_name, tier, dist]).domain("MAP").info()

func _apply_state_to_regions() -> void:
	for region in regions_container.get_children():
		if not region is Region: continue
		if map_state.region_data_map.has(region.name):
			region.data = map_state.region_data_map[region.name]

func _save_map_state() -> void:
	var error = ResourceSaver.save(map_state, SAVE_PATH)
	if error != OK: push_error("MacroMap: Failed to save map state!")


func _on_region_selected(data: WorldRegionData) -> void:
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	
	# Reset selection
	selected_region_node = null
	
	for region in regions_container.get_children():
		if region is Region and region.data == data:
			selected_region_node = region
			selected_region_node.is_selected = true
			selected_region_node.set_visual_state(false)
			break
			
	selected_region_data = data
	region_name_label.text = data.display_name
	
	# Close other UI
	if raid_prep_window: raid_prep_window.hide()
	
	var jarl = DynastyManager.get_current_jarl()
	if not jarl: return
	
	current_attrition_risk = 0.0
	if player_home_marker and is_instance_valid(selected_region_node):
		var dist = player_home_marker.global_position.distance_to(selected_region_node.get_global_center())
		var safe_range = jarl.get_safe_range()
		if dist > safe_range:
			var overage = dist - safe_range
			current_attrition_risk = (overage / 100.0) * jarl.attrition_per_100px
			current_attrition_risk = min(current_attrition_risk, 1.0)

	var is_conquered = DynastyManager.has_conquered_region(data.resource_path)
	var is_allied = DynastyManager.is_allied_region(data.resource_path)
	
	# --- NEW: Check Home Status ---
	var is_home = false
	if selected_region_node and "is_home" in selected_region_node:
		is_home = selected_region_node.is_home
	# ------------------------------
	
	_populate_raid_targets(data, is_conquered, is_allied, is_home)
	_update_diplomacy_buttons(data, is_conquered, is_allied, is_home)
	
	region_info_panel.show()


func _populate_raid_targets(data: WorldRegionData, is_conquered: bool, is_allied: bool, is_home: bool) -> void:
	for child in target_list_container.get_children(): child.queue_free()
	
	# --- NEW: Home Check ---
	if is_home:
		var label = Label.new()
		label.text = "Home Region (Safe)"
		label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		label.add_theme_color_override("font_color", Color.CORNFLOWER_BLUE)
		target_list_container.add_child(label)
		return
	# -----------------------

	if is_conquered:
		var label = Label.new()
		label.text = "Region Conquered"
		label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		target_list_container.add_child(label)
		return

	if data.raid_targets.is_empty():
		var label = Label.new()
		label.text = "No Valid Targets"
		target_list_container.add_child(label)
		return

	for target in data.raid_targets:
		if not target: continue

		var btn = Button.new()
		btn.alignment = HORIZONTAL_ALIGNMENT_LEFT
		
		var risk_text = ""
		var btn_color = Color.WHITE
		
		if current_attrition_risk > 0.0:
			risk_text = " (%d%% Risk)" % int(current_attrition_risk * 100)
			if current_attrition_risk > 0.3: btn_color = Color(1.0, 0.4, 0.4)
			else: btn_color = Color(1.0, 0.9, 0.4)
		
		if is_allied:
			btn.text = "%s (Allied)" % target.display_name
			btn.disabled = true
		else:
			var treasury = target.settlement_data.treasury
			var loot_type = "Mixed"
			if treasury.get("food", 0) > 300: loot_type = "FOOD"
			elif treasury.get("gold", 0) > 300: loot_type = "GOLD"
			elif treasury.get("wood", 0) > 300: loot_type = "WOOD"
			
			if loot_type == "GOLD": btn.add_theme_color_override("font_color", Color.GOLD)
			elif loot_type == "FOOD": btn.add_theme_color_override("font_color", Color.LIGHT_GREEN)
			else: btn.add_theme_color_override("font_color", btn_color)

			var auth_cost = target.raid_cost_authority
			if target.authority_cost_override > -1: auth_cost = target.authority_cost_override
			
			btn.text = "%s [%s] (Cost: %d Auth%s)" % [target.display_name, loot_type, auth_cost, risk_text]
			
			var can_afford = DynastyManager.can_spend_authority(auth_cost)
			if not can_afford:
				btn.disabled = true
				btn.text += " (Low Auth)"
			else:
				btn.pressed.connect(_initiate_raid.bind(target))
		
		target_list_container.add_child(btn)

func _update_diplomacy_buttons(_data: WorldRegionData, is_conquered: bool, is_allied: bool, is_home: bool) -> void:
	# --- NEW: Home Check ---
	if is_home:
		subjugate_button.disabled = true
		subjugate_button.text = "Home Territory"
		marry_button.disabled = true
		marry_button.text = "Dynasty Seat"
		return
	# -----------------------

	if is_conquered:
		subjugate_button.disabled = true
		subjugate_button.text = "Subjugate (Conquered)"
		marry_button.disabled = true
		marry_button.text = "Marry (Conquered)"
		return

	var base_cost = 5
	var ally_mod = 0
	if is_allied: ally_mod = 2
	calculated_subjugate_cost = max(1, base_cost - ally_mod)
	
	subjugate_button.text = "Subjugate (Cost: %d)" % calculated_subjugate_cost
	subjugate_button.disabled = not DynastyManager.can_spend_authority(calculated_subjugate_cost)
	
	marry_button.text = "Marry (Cost: 1 Heir)"
	var has_heir = DynastyManager.get_available_heir_count() > 0
	marry_button.disabled = is_allied or not has_heir
	if is_allied: marry_button.text = "Marry (Allied)"

func _on_subjugate_pressed() -> void:
	if not selected_region_data: return
	var success = DynastyManager.spend_authority(calculated_subjugate_cost)
	if success:
		DynastyManager.add_conquered_region(selected_region_data.resource_path)
		var jarl = DynastyManager.get_current_jarl()
		jarl.legitimacy = min(100, jarl.legitimacy + 5) 
		DynastyManager.jarl_stats_updated.emit(jarl) 
		Loggie.msg("Region %s successfully subjugated." % selected_region_data.display_name).domain("MAP").info()
		_on_region_selected(selected_region_data)

func _on_marry_pressed() -> void:
	if not selected_region_data: return
	var success = DynastyManager.marry_heir_for_alliance(selected_region_data.resource_path)
	if success: 
		Loggie.msg("Alliance with %s successful." % selected_region_data.display_name).domain("MAP").info()
		_on_region_selected(selected_region_data)

func _on_settlement_pressed() -> void: EventBus.scene_change_requested.emit(GameScenes.SETTLEMENT)
func _on_dynasty_pressed() -> void: if dynasty_ui: dynasty_ui.show()

func close_all_ui() -> void:
	var ui_closed = false
	if dynasty_ui and dynasty_ui.visible:
		dynasty_ui.hide()
		ui_closed = true
	if region_info_panel and region_info_panel.visible:
		region_info_panel.hide()
		ui_closed = true
	if raid_prep_window and raid_prep_window.visible:
		raid_prep_window.hide()
		ui_closed = true
		
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	selected_region_data = null
	selected_region_node = null
	
	if ui_closed: Loggie.msg("MacroMap: All UI closed for year transition").domain("MAP").info()

func _on_event_system_finished() -> void:
	if randf() < enemy_raid_chance:
		Loggie.msg("--- ENEMY RAID TRIGGERED ---").domain("MAP").info()
		
		# FIX: Use RaidManager for defensive state
		RaidManager.is_defensive_raid = true
		
		EventBus.scene_change_requested.emit(GameScenes.RAID_MISSION)
	else:
		Loggie.msg("No enemy raid this year.").domain("MAP").info()
		EventBus.scene_change_requested.emit(GameScenes.SETTLEMENT)

func _update_jarl_ui(jarl: JarlData) -> void:
	if not jarl: return
	authority_label.text = "Authority: %d / %d" % [jarl.current_authority, jarl.max_authority]
	renown_label.text = "Renown: %d" % jarl.renown
	_update_region_status_visuals()
	if selected_region_data: _on_region_selected(selected_region_data)

func _update_region_status_visuals() -> void:
	if not player_home_marker: return
	
	var closest_dist = INF
	var home_region: Region = null
	
	for region in regions_container.get_children():
		if not region is Region: continue
		
		# 1. Check Alliance
		if region.data and DynastyManager.is_allied_region(region.data.resource_path):
			region.is_allied = true
		else:
			region.is_allied = false
		
		# 2. Find Home (Closest to Marker)
		var dist = player_home_marker.global_position.distance_to(region.get_global_center())
		if dist < closest_dist:
			closest_dist = dist
			home_region = region
			
		# Reset home flag for now (winner takes it below)
		region.is_home = false
		
		# Refresh visual state (if not currently hovered/selected)
		if not region.is_selected:
			region.set_visual_state(false)

	# 3. Apply Home
	if home_region:
		home_region.is_home = true
		if not home_region.is_selected:
			home_region.set_visual_state(false)

func _on_region_hovered(data: WorldRegionData, _screen_position: Vector2) -> void:
	tooltip_label.text = data.display_name
	var mouse_pos = get_viewport().get_mouse_position()
	tooltip.position = mouse_pos + Vector2(15, 15)
	tooltip.show()

func _on_region_exited() -> void: tooltip.hide()

func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			_deselect_current_region()

func _deselect_current_region() -> void:
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	selected_region_node = null
	selected_region_data = null
	if region_info_panel: region_info_panel.hide()
	if raid_prep_window: raid_prep_window.hide()


--------------------------------------------------
FILE: res:///scenes/world_map/MacroMap.tscn
--------------------------------------------------
[gd_scene load_steps=22 format=3 uid="uid://ba41qxyi1a30u"]

[ext_resource type="Script" uid="uid://dmq8s5ifmd1dx" path="res://scenes/world_map/MacroMap.gd" id="1_macro_map"]
[ext_resource type="PackedScene" uid="uid://cuyni4y77q51q" path="res://scenes/world_map/Region.tscn" id="2_region"]
[ext_resource type="Texture2D" uid="uid://c32ymtbiceoe8" path="res://assets/Viking Dynasty Game Map.png" id="3_qn6r3"]
[ext_resource type="PackedScene" uid="uid://lpxvj8dvfbnl" path="res://scenes/world_map/MacroCamera.tscn" id="5_okptj"]
[ext_resource type="Script" uid="uid://4osy61evbgf0" path="res://data/world_map/RaidTargetData.gd" id="5_qn6r3"]
[ext_resource type="Script" uid="uid://dqlbgeegli821" path="res://data/world_map/WorldRegionData.gd" id="6_aeufb"]
[ext_resource type="PackedScene" uid="uid://c5qg2j1qa4g0b" path="res://ui/Dynasty_UI.tscn" id="6_tcdvw"]

[sub_resource type="Resource" id="Resource_seg4e"]
script = ExtResource("6_aeufb")
display_name = "Geatland"
description = "Southern Norway"
raid_targets = Array[ExtResource("5_qn6r3")]([null])
yearly_income = {
"gold": 250
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_3epe4"]
script = ExtResource("6_aeufb")
display_name = "Viken"
description = "Southern Norway"
raid_targets = Array[ExtResource("5_qn6r3")]([null])
yearly_income = {
"gold": 250
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_37xpq"]
script = ExtResource("6_aeufb")
display_name = "Swealand"
description = "Southern Norway"
raid_targets = Array[ExtResource("5_qn6r3")]([null])
yearly_income = {
"gold": 250
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_n4r4f"]
script = ExtResource("6_aeufb")
display_name = "Halogaland"
description = "Southern Norway"
raid_targets = Array[ExtResource("5_qn6r3")]([null])
yearly_income = {
"gold": 250
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_47i7n"]
script = ExtResource("6_aeufb")
display_name = "Denmark"
description = "Southern Norway"
raid_targets = Array[ExtResource("5_qn6r3")]([null])
yearly_income = {
"gold": 250
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_uahyi"]
script = ExtResource("6_aeufb")
display_name = "Kvenland"
description = "Southern Norway"
raid_targets = Array[ExtResource("5_qn6r3")]([null])
yearly_income = {
"gold": 250
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_jetqj"]
script = ExtResource("6_aeufb")
display_name = "Estland"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_jgfh8"]
script = ExtResource("6_aeufb")
display_name = "Courland"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_iha38"]
script = ExtResource("6_aeufb")
display_name = "Samland"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_c6sua"]
script = ExtResource("6_aeufb")
display_name = "Bjarmaland"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_pbv04"]
script = ExtResource("6_aeufb")
display_name = "Wendland"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_4nnyf"]
script = ExtResource("6_aeufb")
display_name = "Frankland"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_8ajcq"]
script = ExtResource("6_aeufb")
display_name = "Saxony"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[sub_resource type="Resource" id="Resource_yqyxo"]
script = ExtResource("6_aeufb")
display_name = "Britland"
metadata/_custom_type_script = "uid://dqlbgeegli821"

[node name="MacroMap" type="Node2D"]
script = ExtResource("1_macro_map")

[node name="TextureRect" type="TextureRect" parent="."]
offset_left = 2.0
offset_top = -4.0
offset_right = 1022.0
offset_bottom = 771.0
texture = ExtResource("3_qn6r3")

[node name="Regions" type="Node2D" parent="."]

[node name="Region_Southern_Sweden" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_seg4e")

[node name="HighlightPoly" parent="Regions/Region_Southern_Sweden" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(539, 493, 542, 507, 548, 519, 550, 534, 564, 561, 571, 570, 569, 574, 568, 577, 566, 580, 566, 587, 569, 591, 574, 596, 574, 603, 574, 607, 578, 609, 584, 609, 590, 606, 596, 607, 600, 604, 597, 597, 598, 586, 611, 581, 622, 579, 625, 580, 628, 580, 628, 573, 632, 564, 634, 560, 633, 545, 635, 535, 634, 524, 635, 515, 635, 509, 630, 505, 626, 505, 606, 489, 591, 478, 570, 465, 564, 456, 558, 453, 556, 457, 555, 459, 550, 461, 549, 466, 546, 471, 548, 477, 549, 482, 546, 488, 546, 492, 541, 491)

[node name="CollisionPolygon2D" parent="Regions/Region_Southern_Sweden" index="1"]
polygon = PackedVector2Array(0, 0)

[node name="Region_Southern_Norway" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_3epe4")

[node name="HighlightPoly" parent="Regions/Region_Southern_Norway" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(450, 509, 440, 496, 453, 483, 455, 475, 448, 478, 441, 479, 438, 471, 440, 463, 446, 456, 443.3711, 449.4278, 440, 441, 439, 426, 440, 416, 439.49124, 404.80768, 439, 394, 445, 393, 444, 385, 452, 383, 457, 375, 467, 370, 467, 363, 476, 361, 482, 362, 485, 352, 493, 341, 508, 344, 512, 340, 515, 343, 546, 348, 552, 368, 552, 391, 555, 405, 563, 410, 563, 422, 554, 428, 558, 436, 561, 455, 551, 463, 548, 472, 546, 494, 537, 491, 534, 483, 528, 482, 520, 490, 500, 507, 491, 519, 479, 524, 467, 522, 458, 514)

[node name="Region_Northern_Sweden" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_37xpq")

[node name="HighlightPoly" parent="Regions/Region_Northern_Sweden" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(632, 505, 600, 483, 581, 473, 559, 452, 559, 437, 553, 425, 561, 423, 561, 417, 561, 411, 556, 404, 553, 402, 551, 363, 549, 352, 552, 333, 558, 325, 566, 325, 574, 324, 577, 314, 569, 306, 578, 289, 579, 264, 578, 256, 589, 249, 589, 241, 601, 220, 596, 207, 601, 200, 601, 190, 607, 185, 612, 187, 616, 187, 616, 181, 616, 172, 620, 169, 640, 172, 642, 153, 643, 148, 646, 148, 655, 156, 663, 162, 673, 164, 679, 170, 687, 177, 690, 194, 694, 205, 701, 218, 698, 227, 709, 245, 705, 249, 688, 253, 679, 269, 674, 288, 682, 298, 673, 320, 657, 335, 652, 342, 648, 344, 640, 358, 637, 366, 633, 372, 632, 381, 631, 394, 630, 408, 633, 423, 637, 431, 647, 433, 656, 443, 663, 451, 665, 458, 663, 467, 660, 474, 654, 482, 650, 488, 643, 492, 636, 496, 636, 501)

[node name="Region_Northern_Norway" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_n4r4f")

[node name="HighlightPoly" parent="Regions/Region_Northern_Norway" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(515, 343, 523, 347, 535, 347, 545, 347, 549, 346, 553, 331, 559, 325, 572, 325, 575, 320, 576, 313, 572, 308, 570, 304, 574, 296, 579, 283, 579, 271, 578, 259, 579, 255, 588, 251, 590, 248, 589, 243, 600, 220, 592, 219, 585, 219, 580, 219, 573, 219, 550, 275, 541, 296, 536, 303, 538, 307, 537, 310, 535, 308, 530, 307, 528, 312, 522, 317, 519, 322, 517, 327, 515, 331, 512, 336, 512, 339)

[node name="Region_Denmark" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_47i7n")

[node name="HighlightPoly" parent="Regions/Region_Denmark" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(528, 533, 526, 537, 527, 540, 528, 545, 527, 551, 525, 556, 525, 560, 524, 564, 524, 567, 525, 569, 527, 572, 529, 572, 534, 572, 536, 575, 535, 578, 529, 588, 519, 597, 518, 608, 518, 620, 543, 625, 552, 626, 551, 618, 538, 612, 538, 604, 541, 596, 547, 592, 559, 590, 561, 596, 566, 600, 571, 605, 571, 610, 567, 611, 563, 614, 563, 619, 563, 623, 560, 628, 555, 635, 549, 634, 546, 634, 530, 633, 514, 628, 511, 628, 504, 627, 499, 627, 494, 624, 490, 621, 492, 615, 493, 611, 486, 606, 484, 604, 483, 600, 488, 592, 485, 581, 483, 577, 483, 571, 486, 565, 488, 559, 490, 556, 492, 554, 496, 553, 501, 553, 505, 553, 509, 551, 513, 546, 516, 541, 520, 538, 525, 537)

[node name="Region_Finland" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_uahyi")

[node name="HighlightPoly" parent="Regions/Region_Finland" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(648, 148, 649, 139, 653, 139, 658, 143, 665, 150, 666, 153, 672, 156, 681, 154, 685, 149, 691, 152, 697, 153, 698, 148, 700, 146, 705, 143, 704, 115, 705, 109, 710, 103, 716, 102, 720, 97, 729, 101, 738, 104, 742, 112, 744, 121, 744, 129, 741, 133, 741, 138, 741, 148, 745, 154, 754, 159, 760, 161, 767, 167, 768, 176, 766, 190, 764, 198, 770, 204, 774, 209, 779, 216, 785, 224, 788, 232, 787, 244, 788, 252, 790, 261, 798, 262, 799, 270, 805, 272, 810, 277, 810, 286, 806, 293, 811, 296, 820, 301, 830, 307, 836, 313, 836, 325, 832, 334, 827, 345, 823, 355, 821, 363, 817, 375, 809, 386, 805, 395, 800, 404, 791, 409, 788, 411, 781, 417, 772, 422, 760, 428, 749, 432, 734, 438, 725, 436, 719, 432, 708, 426, 703, 420, 695, 404, 693, 384, 691, 374, 685, 368, 685, 354, 688, 348, 688, 337, 690, 335, 694, 335, 701, 330, 703, 321, 708, 314, 714, 300, 721, 280, 727, 272, 712, 244, 704, 237, 700, 224, 698, 212, 692, 200, 688, 187, 682, 174, 675, 164, 662, 161, 653, 155)

[node name="Region_Estonia" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_jetqj")

[node name="HighlightPoly" parent="Regions/Region_Estonia" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(814, 438, 808, 438, 805, 439, 801, 441, 798, 441, 794, 441, 792, 440, 785, 440, 781, 440, 779, 440, 776, 442, 774, 445, 772, 445, 768, 447, 765, 448, 761, 449, 757, 449, 754, 451, 753, 453, 749, 456, 748, 458, 744, 461, 741, 463, 734, 469, 728, 469, 727, 471, 724, 473, 722, 475, 724, 477, 726, 479, 727, 480, 728, 482, 728, 484, 724, 488, 723, 489, 722, 493, 722, 496, 722, 498, 722, 500, 724, 500, 729, 500, 731, 498, 733, 496, 737, 494, 738, 492, 740, 490, 744, 488, 745, 485, 748, 484, 751, 487, 752, 489, 756, 489, 761, 489, 765, 488, 765, 491, 766, 495, 766, 499, 766, 502, 771, 497, 774, 496, 778, 495, 780, 494, 782, 493, 785, 494, 788, 495, 791, 496, 792, 497, 797, 499, 799, 501, 801, 502, 804, 504, 808, 503, 809, 501, 812, 500, 816, 500, 818, 500, 819, 498, 819, 496, 820, 493, 822, 491, 823, 489, 822, 484, 820, 482, 818, 478, 815, 475, 815, 472, 815, 470, 812, 466, 812, 460, 812, 455, 814, 453, 814, 449, 814, 446, 817, 440)

[node name="Region_Northern_Baltics" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_jgfh8")

[node name="HighlightPoly" parent="Regions/Region_Northern_Baltics" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(716, 563, 716, 556, 716, 551, 716, 546, 718, 542, 719, 540, 719, 534, 719, 529, 720, 523, 723, 519, 727, 517, 731, 515, 735, 512, 737, 512, 737, 513, 738, 515, 741, 516, 745, 519, 748, 522, 751, 526, 752, 529, 754, 532, 757, 532, 759, 532, 763, 532, 765, 530, 766, 528, 769, 526, 769, 524, 769, 521, 769, 519, 769, 517, 768, 514, 768, 511, 768, 507, 767, 501, 770, 498, 775, 498, 776, 496, 778, 495, 783, 495, 790, 495, 798, 499, 800, 501, 803, 503, 805, 504, 810, 501, 813, 500, 819, 500, 821, 501, 825, 504, 829, 506, 831, 508, 832, 511, 832, 517, 832, 519, 835, 519, 838, 523, 840, 527, 841, 529, 843, 533, 845, 535, 846, 538, 843, 544, 841, 547, 840, 549, 838, 552, 837, 554, 833, 556, 831, 556, 830, 555, 828, 556, 827, 559, 823, 561, 821, 561, 816, 561, 813, 560, 808, 556, 805, 555, 803, 553, 800, 552, 798, 552, 792, 552, 791, 552, 790, 551, 788, 547, 787, 546, 784, 546, 784, 549, 782, 552, 780, 554, 775, 554, 770, 554, 765, 554, 762, 554, 758, 554, 757, 554, 754, 557, 752, 555, 751, 553, 750, 553, 749, 554, 748, 556, 744, 556, 740, 556, 736, 556, 733, 557, 729, 560, 727, 562, 727, 562, 725, 564, 723, 564, 718, 565)

[node name="Region_Southern_Baltics" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_iha38")

[node name="HighlightPoly" parent="Regions/Region_Southern_Baltics" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(725, 564, 726, 567, 726, 569, 727, 571, 727, 575, 727, 577, 730, 578, 729, 580, 726, 581, 726, 585, 726, 588, 726, 590, 726, 592, 726, 594, 728, 596, 731, 596, 734, 597, 737, 599, 742, 600, 745, 600, 750, 600, 751, 599, 755, 600, 756, 601, 757, 603, 759, 604, 759, 608, 759, 610, 759, 611, 759, 614, 759, 616, 761, 617, 764, 618, 768, 620, 771, 621, 774, 622, 775, 623, 776, 625, 777, 627, 776, 630, 776, 631, 778, 632, 780, 631, 782, 631, 786, 630, 788, 629, 789, 628, 793, 629, 794, 629, 799, 624, 800, 623, 802, 620, 803, 618, 804, 618, 807, 616, 808, 615, 812, 612, 814, 609, 814, 606, 814, 603, 815, 602, 815, 599, 814, 597, 814, 595, 814, 593, 814, 590, 816, 588, 818, 588, 820, 587, 820, 584, 820, 582, 820, 581, 822, 580, 824, 580, 826, 579, 827, 576, 827, 574, 825, 573, 823, 572, 823, 569, 823, 564, 821, 563, 819, 562, 816, 562, 814, 560, 812, 558, 809, 556, 804, 554, 801, 552, 797, 553, 794, 552, 790, 551, 787, 550, 785, 547, 783, 547, 780, 551, 779, 552, 778, 552, 773, 555, 770, 553, 767, 553, 764, 553, 760, 553, 757, 553, 756, 554, 755.0067, 555.48987, 754, 557, 752.81775, 555.81775, 752, 554, 750, 553, 749, 555, 747, 557, 744, 556, 740, 556, 737, 556, 734, 557, 731, 559, 728, 560)

[node name="Region_10" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_c6sua")

[node name="HighlightPoly" parent="Regions/Region_10" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(728, 595, 727, 597, 727, 599, 729, 602, 729, 606, 729, 608, 727, 608, 726, 608, 724, 608, 722, 608, 720, 607, 718, 606, 715, 607, 713, 608, 712, 608, 710, 608, 707, 609, 707, 611, 706, 612, 705, 615, 706, 616, 706, 617, 707, 620, 707, 622, 706, 624, 704, 625, 701, 627, 700, 628, 704, 628, 706, 628, 709, 628, 713, 628, 718, 628, 724, 628, 728, 627, 730, 627, 735, 626, 740, 625, 744, 624, 747, 623, 751, 623, 754, 621, 757, 619, 758, 618, 758, 615, 759, 612, 759, 608, 759, 606, 759, 603, 758, 602, 757, 602, 755, 600, 753, 598, 751, 598, 747, 598, 745, 599, 742, 600, 739, 599, 735, 598, 734, 598, 733, 597, 731, 596, 729, 595)

[node name="Region_Germany_East" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_pbv04")

[node name="HighlightPoly" parent="Regions/Region_Germany_East" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(690, 631, 694, 631, 698, 629, 701, 627, 705, 628, 710, 628, 715, 628, 721, 628, 728, 626, 734, 626, 743, 624, 749, 623, 756, 621, 759, 619, 761, 617, 766, 619, 770, 619, 772, 621, 775, 626, 777, 629, 780, 634, 782, 640, 785, 645, 787, 649, 790, 655, 793, 659, 794, 670, 794, 671, 791, 675, 788, 677, 785, 680, 784, 682, 785, 684, 787, 686, 792, 690, 793, 694, 793, 700, 793, 705, 794, 709, 796, 713, 800, 717, 804, 721, 807, 726, 809, 729, 810, 735, 810, 738, 809, 741, 806, 745, 799, 756, 796, 763, 793, 769, 737, 767, 739, 762, 744, 759, 747, 757, 755, 753, 757, 750, 759, 745, 762, 740, 762, 736, 762, 731, 760, 726, 759, 721, 760, 716, 753, 713, 748, 708, 746, 704, 744, 699, 742, 696, 737, 692, 734, 690, 728, 690, 724, 691, 716, 692, 712, 691, 708, 691, 703, 690, 697, 687, 693, 683, 685, 679, 685, 677, 682, 676, 677, 673, 678, 669, 680, 665, 682, 664, 685, 661, 689, 654, 689, 653, 688, 646, 687, 644, 687, 638, 688, 633)

[node name="Region_Francia" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_4nnyf")

[node name="HighlightPoly" parent="Regions/Region_Francia" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(602, 655, 600, 657, 595, 657, 594, 652, 592, 649, 588, 649, 585, 649, 583, 646, 586, 643, 588, 640, 588, 638, 587, 634, 585, 634, 581, 636, 580, 638, 574, 639, 571, 640, 568, 640, 565, 644, 562, 645, 559, 647, 556, 649, 550, 650, 550, 652, 549, 655, 547, 656, 543, 655, 542, 654, 538, 655, 534, 654, 537, 650, 539, 648, 539, 646, 540, 640, 537, 638, 534, 642, 534, 644, 531, 644, 529, 642, 523, 641, 523, 641, 518, 635, 518, 633, 514, 629, 507, 629, 496, 627, 494, 626, 493, 628, 495, 631, 495, 634, 498, 636, 498, 639, 496, 641, 493, 642, 493, 643, 493, 645, 496, 645, 497, 646, 497, 649, 497, 652, 496, 655, 495, 658, 491, 660, 490, 662, 488, 667, 486, 669, 483, 667, 479, 663, 474, 663, 470, 663, 466, 664, 465, 664, 464, 666, 463, 669, 455, 672, 453, 672, 448, 673, 442, 675, 434, 676, 431, 678, 428, 685, 428, 687, 425, 690, 423, 692, 415, 696, 414, 697, 412, 702, 410, 706, 408, 709, 407, 713, 404, 716, 402, 719, 398, 722, 409, 733, 411, 734, 417, 738, 424, 742, 430, 746, 434, 747, 436, 754, 437, 762, 438, 766, 585, 768, 588, 764, 591, 761, 598, 758, 605, 756, 611, 756, 616, 755, 621, 751, 622, 743, 622, 737, 616, 731, 614, 724, 614, 717, 614, 709, 609, 702, 605, 695, 603, 691, 602, 688, 601, 683, 602, 678, 603, 673, 604, 670, 604, 664)

[node name="Region_Germany_West" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_8ajcq")

[node name="HighlightPoly" parent="Regions/Region_Germany_West" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(687, 633, 684, 631, 683, 629, 681, 626, 679, 623, 676, 618, 670, 620, 666, 621, 659, 622, 655, 625, 650, 628, 647, 630, 642, 633, 640, 636, 638, 638, 635, 639, 630, 642, 627, 643, 622, 645, 618, 646, 612, 649, 609, 651, 606, 653, 603, 654, 605, 657, 605, 658, 606, 661, 607, 665, 607, 671, 606, 674, 604, 678, 602, 682, 602, 685, 602, 687, 603, 690, 604, 692, 605, 693, 610, 697, 613, 705, 613, 709, 613, 710, 621, 711, 629, 713, 639, 716, 641, 723, 642, 730, 651, 731, 654, 736, 654, 739, 662, 741, 668, 743, 676, 748, 685, 754, 687, 755, 694, 763, 701, 772, 734, 769, 738, 762, 745, 760, 750, 758, 754, 755, 758, 752, 760, 746, 761, 733, 761, 731, 761, 725, 761, 721, 759, 716, 752, 712, 747, 707, 745, 703, 742, 697, 737, 693, 732, 691, 723, 692, 714, 692, 703, 691, 701, 688, 695, 683, 689, 681, 686, 680, 684, 677, 678, 669, 678, 666, 682, 663, 686, 658, 689, 653, 689, 650, 689, 649, 689, 642, 689, 636)

[node name="Region_Brittain" parent="Regions" instance=ExtResource("2_region")]
data = SubResource("Resource_yqyxo")

[node name="HighlightPoly" parent="Regions/Region_Brittain" index="0"]
color = Color(1, 1, 1, 0.19607843)
polygon = PackedVector2Array(264, 478, 270, 483, 272, 484, 276, 484, 281, 484, 290, 484, 297, 485, 296, 487, 296, 490, 296, 492, 293, 494, 290, 496, 285, 499, 280, 501, 277, 503, 277, 504, 278, 506, 277, 509, 272, 513, 271, 514, 279, 514, 285, 514, 292, 515, 299, 516, 303, 517, 308, 518, 310, 522, 309, 530, 304, 536, 301, 542, 298, 549, 292, 554, 287, 558, 287, 560, 288, 568, 292, 572, 297, 578, 303, 588, 305, 594, 306, 603, 305, 616, 306, 617, 312, 623, 316, 628, 319, 634, 322, 642, 323, 654, 324, 660, 327, 664, 331, 668, 330, 672, 326, 679, 326, 683, 329, 684, 332, 680, 335, 678, 351, 682, 356, 685, 359, 691, 358, 697, 354, 703, 343, 717, 337, 722, 327, 725, 333, 733, 345, 734, 342, 739, 333, 744, 323, 746, 307, 746, 291, 746, 276, 745, 260, 745, 252, 739, 246, 739, 242, 744, 237, 750, 231, 752, 226, 747, 220, 744, 207, 747, 201, 751, 195, 748, 202, 742, 210, 738, 216, 732, 221, 727, 226, 723, 231, 721, 242, 721, 252, 721, 264, 714, 254, 714, 246, 713, 236, 706, 230, 702, 219, 699, 214, 693, 223, 688, 233, 684, 242, 682, 245, 673, 245, 664, 240, 665, 233, 665, 236, 662, 240, 658, 238, 653, 239, 647, 244, 649, 248, 651, 257, 652, 267, 655, 269, 657, 268, 651, 268, 646, 270, 641, 270, 635, 275, 634, 274, 628, 267, 628, 266, 620, 265, 615, 265, 607, 270, 603, 269, 601, 261, 602, 255, 603, 250, 600, 249, 605, 248, 606, 242, 602, 242, 604, 239, 596, 237, 590, 245, 586, 247, 583, 251, 576, 247, 566, 243, 570, 241, 578, 237, 581, 229, 582, 228, 579, 234, 573, 235, 569, 230, 564, 228, 564, 226, 568, 217, 568, 218, 562, 222, 558, 230, 556, 234, 553, 237, 550, 232, 549, 226, 549, 228, 537, 241, 531, 242, 522, 236, 522, 231, 518, 229, 511, 217, 519, 208, 517, 216, 499, 221, 495, 225, 484, 232, 482, 240, 479, 245, 479, 240, 490, 236, 495, 236, 504, 238, 510, 241, 503, 248, 499, 255, 499, 255, 493, 261, 493, 261, 486)

[node name="MacroCamera" parent="." instance=ExtResource("5_okptj")]
zoom = Vector2(1.2, 1.2)
min_zoom = 1.2
bounds_rect = Rect2(0, 0, 1020, 775)

[node name="UI" type="CanvasLayer" parent="."]
layer = 10

[node name="JarlInfo" type="PanelContainer" parent="UI"]
anchors_preset = 5
anchor_left = 0.5
anchor_right = 0.5
offset_left = -20.0
offset_right = 20.0
offset_bottom = 40.0
grow_horizontal = 2
mouse_filter = 1

[node name="VBoxContainer" type="VBoxContainer" parent="UI/JarlInfo"]
layout_mode = 2

[node name="AuthorityLabel" type="Label" parent="UI/JarlInfo/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 4
text = "Authority: 3/3"
horizontal_alignment = 1

[node name="RenownLabel" type="Label" parent="UI/JarlInfo/VBoxContainer"]
layout_mode = 2
text = "Renown: 25"
horizontal_alignment = 1

[node name="Actions" type="PanelContainer" parent="UI"]
anchors_preset = 3
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -40.0
offset_top = -40.0
grow_horizontal = 0
grow_vertical = 0
mouse_filter = 2

[node name="VBoxContainer" type="VBoxContainer" parent="UI/Actions"]
layout_mode = 2

[node name="SettlementButton" type="Button" parent="UI/Actions/VBoxContainer"]
layout_mode = 2
text = "Return to Settlement"

[node name="DynastyButton" type="Button" parent="UI/Actions/VBoxContainer"]
layout_mode = 2
text = "Dynasty"

[node name="RegionInfo" type="PanelContainer" parent="UI"]
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -20.0
offset_top = -40.0
offset_right = 20.0
grow_horizontal = 2
grow_vertical = 0
mouse_filter = 1

[node name="VBoxContainer" type="VBoxContainer" parent="UI/RegionInfo"]
layout_mode = 2

[node name="RegionNameLabel" type="Label" parent="UI/RegionInfo/VBoxContainer"]
layout_mode = 2
horizontal_alignment = 1

[node name="TargetList" type="VBoxContainer" parent="UI/RegionInfo/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="LaunchRaidButton" type="Button" parent="UI/RegionInfo/VBoxContainer"]
layout_mode = 2
disabled = true
text = "Launch Raid"

[node name="SubjugateButton" type="Button" parent="UI/RegionInfo/VBoxContainer"]
layout_mode = 2
disabled = true
text = "Subjugate"

[node name="MarryButton" type="Button" parent="UI/RegionInfo/VBoxContainer"]
layout_mode = 2
disabled = true
text = "Marry for Alliance"

[node name="Tooltip" type="PanelContainer" parent="UI"]
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -51.5
offset_top = -58.0
offset_right = 98.5
offset_bottom = -28.0
grow_horizontal = 2
grow_vertical = 0
mouse_filter = 2

[node name="Label" type="Label" parent="UI/Tooltip"]
layout_mode = 2
text = "Region Name"
horizontal_alignment = 1

[node name="Dynasty_UI" parent="UI" instance=ExtResource("6_tcdvw")]
anchors_preset = 8

[node name="PlayerHomeMarker" type="Marker2D" parent="."]
position = Vector2(526, 485)

[editable path="Regions/Region_Southern_Sweden"]
[editable path="Regions/Region_Southern_Norway"]
[editable path="Regions/Region_Northern_Sweden"]
[editable path="Regions/Region_Northern_Norway"]
[editable path="Regions/Region_Denmark"]
[editable path="Regions/Region_Finland"]
[editable path="Regions/Region_Estonia"]
[editable path="Regions/Region_Northern_Baltics"]
[editable path="Regions/Region_Southern_Baltics"]
[editable path="Regions/Region_10"]
[editable path="Regions/Region_Germany_East"]
[editable path="Regions/Region_Francia"]
[editable path="Regions/Region_Germany_West"]
[editable path="Regions/Region_Brittain"]


--------------------------------------------------
FILE: res:///scenes/world_map/Region.gd
--------------------------------------------------
# res://scenes/world_map/Region.gd
class_name Region
extends Area2D

# Signals
signal region_hovered(data: WorldRegionData, screen_position: Vector2)
signal region_exited()
signal region_selected(data: WorldRegionData)

# Data
@export var data: WorldRegionData

# Node Refs
@onready var highlight_poly: Polygon2D = get_node_or_null("HighlightPoly")
@onready var collision_poly: CollisionPolygon2D = get_node_or_null("CollisionPolygon2D")

# --- Visual Settings ---
var default_color: Color = Color(0, 0, 0, 0)       # Invisible
var hover_color: Color = Color(1.0, 1.0, 1.0, 0.2) # Faint White
var selected_color: Color = Color(1.0, 0.9, 0.2, 0.4) # Yellowish

# --- NEW: Status Colors ---
var home_color: Color = Color(0.2, 0.4, 0.8, 0.25) # Royal Blue (Owned)
var allied_hover_color: Color = Color(0.2, 0.8, 1.0, 0.3) # Cyan (Friendly)
# --------------------------

# --- State Flags ---
var is_selected: bool = false
var is_home: bool = false   # Is this the player's starting region?
var is_allied: bool = false # Is this region allied via marriage?

func _ready() -> void:
	if not data:
		push_error("Region node '%s' has no WorldRegionData!" % name)
		return
	
	if not highlight_poly:
		push_error("Region '%s' missing 'HighlightPoly'." % name)
		return
		
	if not collision_poly:
		collision_poly = CollisionPolygon2D.new()
		collision_poly.name = "CollisionPolygon2D"
		add_child(collision_poly)
	
	_sync_collision_shape()
	
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	input_event.connect(_on_input_event)
	
	set_visual_state(false)

func _sync_collision_shape() -> void:
	if not highlight_poly or highlight_poly.polygon.is_empty(): return
	collision_poly.polygon = highlight_poly.polygon
	collision_poly.position = highlight_poly.position
	collision_poly.scale = highlight_poly.scale

# --- VISUAL STATE LOGIC ---
func set_visual_state(is_hovered: bool) -> void:
	if not highlight_poly: return
		
	var target_color: Color
	var should_be_visible = true
	
	if is_selected:
		target_color = selected_color
	
	elif is_hovered:
		if is_allied:
			target_color = allied_hover_color
		else:
			target_color = hover_color
			
	elif is_home:
		target_color = home_color
		
	else:
		# Default state (Unknown/Neutral)
		target_color = default_color
		should_be_visible = false
		
	highlight_poly.visible = should_be_visible
		
	var tween = create_tween()
	tween.tween_property(highlight_poly, "color", target_color, 0.15)

# --- Input Handlers ---
func _on_mouse_entered() -> void:
	if not is_selected: set_visual_state(true)
	emit_signal("region_hovered", data, get_global_mouse_position())

func _on_mouse_exited() -> void:
	if not is_selected: set_visual_state(false)
	emit_signal("region_exited")

func _on_input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		is_selected = true
		set_visual_state(true)
		emit_signal("region_selected", data)
		get_viewport().set_input_as_handled()

func get_global_center() -> Vector2:
	if not collision_poly or collision_poly.polygon.is_empty():
		return global_position
	var sum = Vector2.ZERO
	for p in collision_poly.polygon: sum += p
	return to_global(sum / collision_poly.polygon.size())


--------------------------------------------------
FILE: res:///scenes/world_map/Region.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://cuyni4y77q51q"]

[ext_resource type="Script" uid="uid://dkthq8hijbpj4" path="res://scenes/world_map/Region.gd" id="1_abcde"]

[node name="Region" type="Area2D"]
script = ExtResource("1_abcde")

[node name="HighlightPoly" type="Polygon2D" parent="."]
visible = false

[node name="CollisionPolygon2D" type="CollisionPolygon2D" parent="."]


--------------------------------------------------
FILE: res:///scripts/ai/DefenderAI.gd
--------------------------------------------------
# res://scripts/ai/DefenderAI.gd
class_name DefenderAI
extends AttackAI

# Configuration
@export var guard_radius: float = 300.0
@export var return_speed: float = 100.0

# State
var guard_post: Vector2 = Vector2.ZERO

func _ready() -> void:
	super._ready()
	if parent_node:
		guard_post = parent_node.global_position
	
	# --- FIX: Widen Vision Mask ---
	# Binary 3 = 0011 (Layer 1 + Layer 2)
	set_target_mask(3) 
	
	# Force ON by default
	set_process(true)
	set_physics_process(true)

func _on_attack_timer_timeout() -> void:
	# 1. Check Leash
	var dist_from_post = parent_node.global_position.distance_to(guard_post)
	
	if dist_from_post > guard_radius:
		# Too far! Abandon chase and return.
		_stop_attacking()
		current_target = null
		_return_to_post()
		return
		
	# 2. Standard Attack Logic
	super._on_attack_timer_timeout()

func _return_to_post() -> void:
	# Access parent FSM to order a move
	if parent_node is BaseUnit and parent_node.fsm:
		parent_node.fsm.command_move_to(guard_post)

func configure_guard_post(pos: Vector2) -> void:
	guard_post = pos


--------------------------------------------------
FILE: res:///scripts/ai/SentryAI.gd
--------------------------------------------------
# res://scripts/ai/SentryAI.gd
# Simple Sentry AI for enemy defenders in Phase 3
# GDD Ref: Phase 3 - Enemy MVP (Simple Sentry AI)

extends Node2D
class_name SentryAI

@export var detection_radius: float = 80.0
@export var attack_damage: int = 25
@export var attack_cooldown: float = 1.5

var detection_area: Area2D
var attack_timer: float = 0.0
var current_target: Node2D = null

signal enemy_detected(target: Node2D)
signal attack_executed(target: Node2D, damage: int)

func _ready() -> void:
	_setup_detection_area()
	set_process(true)

func _setup_detection_area() -> void:
	"""Create detection area for sentry"""
	detection_area = Area2D.new()
	detection_area.name = "DetectionArea"
	
	var collision_shape = CollisionShape2D.new()
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = detection_radius
	collision_shape.shape = circle_shape
	
	detection_area.add_child(collision_shape)
	add_child(detection_area)
	
	# Connect signals
	detection_area.body_entered.connect(_on_body_entered)
	detection_area.body_exited.connect(_on_body_exited)
	
	# Set collision mask to detect player units (layer 1)
	detection_area.collision_mask = 1

func _process(delta: float) -> void:
	# Update attack timer
	if attack_timer > 0:
		attack_timer -= delta
	
	# Check for and attack valid targets
	if current_target and is_instance_valid(current_target):
		if attack_timer <= 0:
			_attack_target(current_target)
			attack_timer = attack_cooldown
	else:
		current_target = null

func _on_body_entered(body: Node2D) -> void:
	"""Handle detection of player units"""
	if body.is_in_group("player_units") and not current_target:
		current_target = body
		enemy_detected.emit(body)
		# Removed print: Loggie.msg("%s detected enemy: %s" % [get_parent().name, body.name]).domain("RTS").info()

func _on_body_exited(body: Node2D) -> void:
	"""Handle player units leaving detection range"""
	if body == current_target:
		current_target = null
		# Removed print: Loggie.msg("%s lost target: %s" % [get_parent().name, body.name]).domain("RTS").info()

func _attack_target(target: Node2D) -> void:
	"""Execute attack on target"""
	if not target or not is_instance_valid(target):
		return
	
	# Check if target is still in range
	var distance = global_position.distance_to(target.global_position)
	if distance > detection_radius:
		current_target = null
		return
	
	# Removed print: Loggie.msg("%s attacking %s for %d damage" % [get_parent().name, target.name, attack_damage]).domain("RTS").info()
	
	# Apply damage if target has take_damage method
	if target.has_method("take_damage"):
		target.take_damage(attack_damage)
	elif target.has_method("receive_damage"):
		target.receive_damage(attack_damage)
	else:
		# Fallback: just remove the target for demo purposes
		push_warning("SentryAI: Target %s has no damage method; removing for demo purposes." % target.name)
		target.queue_free()
	
	attack_executed.emit(target, attack_damage)

func get_detection_radius() -> float:
	"""Get current detection radius"""
	return detection_radius

func set_detection_radius(new_radius: float) -> void:
	"""Update detection radius"""
	detection_radius = new_radius
	if detection_area:
		var collision_shape = detection_area.get_child(0) as CollisionShape2D
		if collision_shape and collision_shape.shape is CircleShape2D:
			collision_shape.shape.radius = detection_radius

func is_actively_defending() -> bool:
	"""Check if sentry is currently engaged with a target"""
	return current_target != null and is_instance_valid(current_target)


--------------------------------------------------
FILE: res:///scripts/ai/UnitAIConstants.gd
--------------------------------------------------
# res://scripts/ai/UnitAIConstants.gd
class_name UnitAIConstants
extends RefCounted

# Defines the possible states for the Unit Finite State Machine
enum State { 
	IDLE, 
	MOVING, 
	FORMATION_MOVING, 
	ATTACKING, 
	RETREATING,
	INTERACTING,
	COLLECTING, # New
	ESCORTING,  # New
	REGROUPING 
}

# Defines behavior stances
enum Stance { 
	AGGRESSIVE, 
	DEFENSIVE, 
	PASSIVE 
}
static func get_surface_distance(unit_node: Node2D, target_node: Node2D) -> float:
	if not is_instance_valid(unit_node) or not is_instance_valid(target_node):
		return INF
		
	var dist_center = unit_node.global_position.distance_to(target_node.global_position)
	
	# 1. Get Target Radius (Building or Unit)
	var r_target = _get_radius(target_node)
	
	# 2. Get Self Radius (The Unit's own body)
	var r_self = _get_radius(unit_node)
	
	# 3. Calculate gap between "skins"
	# (Distance minus both radii)
	return max(0.0, dist_center - r_target - r_self)

static func _get_radius(node: Node2D) -> float:
	# Check for Buildings (Grid based)
	if node is BaseBuilding and node.data:
		var size = min(node.data.grid_size.x, node.data.grid_size.y)
		return (size * 32.0) / 2.0
	
	# Check for Hitbox child (Common in your setup)
	if node.name == "Hitbox" and node.get_parent() is BaseBuilding:
		var b = node.get_parent()
		var size = min(b.data.grid_size.x, b.data.grid_size.y)
		return (size * 32.0) / 2.0
		
	# Check for Units/CollisionShapes
	var col = node.get_node_or_null("CollisionShape2D")
	if col:
		if col.shape is CircleShape2D: return col.shape.radius
		if col.shape is RectangleShape2D: 
			var size = min(col.shape.size.x, col.shape.size.y)
			return size / 2.0
			
	return 15.0 # Default fallback


--------------------------------------------------
FILE: res:///scripts/ai/UnitFSM.gd
--------------------------------------------------
extends Node
class_name UnitFSM

# Unit References
var unit 
var attack_ai: AttackAI 

# State Data
var current_state: UnitAIConstants.State = UnitAIConstants.State.IDLE
var stance: UnitAIConstants.Stance = UnitAIConstants.Stance.DEFENSIVE
# CHANGED: Strict typing for performance and compatibility with NavigationManager
var path: PackedVector2Array = []
var stuck_timer: float = 0.0

var los_range: float = 450.0

# Target Data
var target_position: Vector2 = Vector2.ZERO
var move_command_position: Vector2 = Vector2.ZERO

var objective_target: Node2D = null 
var current_target: Node2D = null 

# Add variable to track pillage timer
var _pillage_accumulator: float = 0.0

func _init(p_unit, p_attack_ai: AttackAI) -> void:
	unit = p_unit
	attack_ai = p_attack_ai
	
	if attack_ai:
		attack_ai.attack_started.connect(_on_ai_attack_started)
		attack_ai.attack_stopped.connect(_on_ai_attack_stopped)

func change_state(new_state: UnitAIConstants.State) -> void:
	if current_state == new_state: return
	
	_exit_state(current_state)
	current_state = new_state
	
	# Notify Unit (Trigger visual changes / Squad Orders)
	if is_instance_valid(unit):
		if unit.has_method("on_state_changed"):
			unit.on_state_changed(current_state)
	
	_enter_state(current_state)

func _enter_state(state: UnitAIConstants.State) -> void:
	match state:
		UnitAIConstants.State.IDLE:
			unit.velocity = Vector2.ZERO
		UnitAIConstants.State.MOVING, UnitAIConstants.State.INTERACTING:
			_recalculate_path()
		UnitAIConstants.State.RETREATING:
			_recalculate_path()
		UnitAIConstants.State.ATTACKING:
			unit.velocity = Vector2.ZERO
			
			# Ensure the AI is actually running!
			if attack_ai:
				attack_ai.set_process(true)
				attack_ai.set_physics_process(true)
				
				if is_instance_valid(current_target):
					attack_ai.force_target(current_target)
		UnitAIConstants.State.INTERACTING:
			_recalculate_path()
			if attack_ai: 
				attack_ai.stop_attacking()
				attack_ai.set_process(false) # Brain off
				attack_ai.set_physics_process(false)

func _exit_state(state: UnitAIConstants.State) -> void:
	match state:
		UnitAIConstants.State.MOVING, UnitAIConstants.State.INTERACTING:
			path.clear()
			stuck_timer = 0.0
		UnitAIConstants.State.FORMATION_MOVING:
			path.clear()
		UnitAIConstants.State.RETREATING:
			path.clear()
			stuck_timer = 0.0
		UnitAIConstants.State.ATTACKING:
			if attack_ai:
				attack_ai.stop_attacking()
			current_target = null
		UnitAIConstants.State.INTERACTING:
			path.clear()
			if attack_ai:
				attack_ai.set_process(true) # Brain on
				attack_ai.set_physics_process(true)

func _recalculate_path() -> void:
	var target_node = current_target if is_instance_valid(current_target) else objective_target
	
	if is_instance_valid(target_node):
		target_position = target_node.global_position
	elif target_position == Vector2.ZERO:
		change_state(UnitAIConstants.State.IDLE)
		return
	
	var start_pos = unit.global_position
	# Allow partial path if we have a solid target node (like a building)
	var allow_partial = is_instance_valid(target_node)
	
	# --- FIX: Redirect to NavigationManager for Smoothing ---
	path = NavigationManager.get_astar_path(start_pos, target_position, allow_partial)
	# -------------------------------------------------------
	
	if path.is_empty():
		# FORCE move if very close (A* sometimes fails on short distances inside cell boundaries)
		if start_pos.distance_to(target_position) < 150.0:
			path = PackedVector2Array([target_position]) 
		else:
			if unit.has_method("flash_error_color"):
				unit.flash_error_color()
			change_state(UnitAIConstants.State.IDLE)

# --- RTS COMMANDS ---

func command_defensive_attack(attacker: Node2D) -> void:
	if current_state == UnitAIConstants.State.RETREATING: return
	
	if not is_instance_valid(attacker): return
	if current_state == UnitAIConstants.State.ATTACKING and current_target == attacker: return
	current_target = attacker 
	change_state(UnitAIConstants.State.ATTACKING)

func command_attack_obstruction(target: Node2D) -> void:
	if current_state == UnitAIConstants.State.RETREATING: return
	if not is_instance_valid(target): return
	
	current_target = target
	change_state(UnitAIConstants.State.ATTACKING)

# NEW: Explicit Collect Command (Harvesting)
func command_collect(target: Node2D) -> void:
	if not is_instance_valid(target): return
	objective_target = target
	current_target = null
	target_position = target.global_position
	
	if attack_ai: attack_ai.stop_attacking()
	
	change_state(UnitAIConstants.State.COLLECTING)

func command_move_to_formation_pos(target_pos: Vector2) -> void:
	target_position = target_pos
	move_command_position = target_pos
	current_target = null 
	objective_target = null
	if attack_ai: attack_ai.stop_attacking()
	path.clear()
	path.append(target_pos)
	change_state(UnitAIConstants.State.FORMATION_MOVING)

func command_move_to(target_pos: Vector2) -> void:
	target_position = target_pos
	move_command_position = target_pos
	current_target = null
	objective_target = null
	if attack_ai: attack_ai.stop_attacking()
	
	# CRITICAL FIX: Interruption Logic
	if current_state == UnitAIConstants.State.MOVING:
		# If already moving, FORCE a path update immediately.
		_recalculate_path()
	else:
		change_state(UnitAIConstants.State.MOVING)

func command_attack(target: Node2D) -> void:
	if not is_instance_valid(target): return
	
	# SMART OVERRIDE: If target is a Resource, Harvest instead of Attack
	# Uses the group name defined in ResourceNode.gd
	if target.is_in_group("resource_nodes"):
		command_collect(target)
		return
	
	objective_target = target
	current_target = target
	target_position = target.global_position
	
	# Immediate check if already in range
	var radius = _get_target_radius(target)
	var dist = unit.global_position.distance_to(target.global_position) - radius
	
	if dist <= unit.data.attack_range + 10.0:
		change_state(UnitAIConstants.State.ATTACKING)
	else:
		change_state(UnitAIConstants.State.MOVING)

func command_retreat(target_pos: Vector2) -> void:
	target_position = target_pos
	move_command_position = target_pos
	current_target = null
	objective_target = null
	if attack_ai: attack_ai.stop_attacking()
	change_state(UnitAIConstants.State.RETREATING)

func command_interact_move(target: Node2D) -> void:
	if not is_instance_valid(target): return
	objective_target = target
	current_target = null
	target_position = target.global_position
	if attack_ai: attack_ai.stop_attacking()
	change_state(UnitAIConstants.State.INTERACTING)

# --- UPDATE LOOP ---

func update(delta: float) -> void:
	match current_state:
		UnitAIConstants.State.IDLE:
			_idle_state(delta)
		UnitAIConstants.State.MOVING:
			_move_state(delta)
		UnitAIConstants.State.FORMATION_MOVING:
			_formation_move_state(delta)
		UnitAIConstants.State.RETREATING:
			_retreat_state(delta)
		UnitAIConstants.State.ATTACKING:
			_attack_state(delta)
		UnitAIConstants.State.INTERACTING:
			_interact_state(delta)
		UnitAIConstants.State.COLLECTING:
			_collect_state(delta)
		UnitAIConstants.State.ESCORTING:
			_escort_state(delta)
		UnitAIConstants.State.REGROUPING:
			_regroup_state(delta)

# --- STATE LOGIC ---

func _collect_state(delta: float) -> void:
	if not is_instance_valid(objective_target):
		change_state(UnitAIConstants.State.IDLE)
		return

	# 1. Define Work Range (e.g., 50 pixels from the resource center)
	var work_range = 50.0 
	var dist = unit.global_position.distance_to(objective_target.global_position)

	if dist > work_range:
		# PHASE A: APPROACH
		# Use simple movement to get close
		_simple_move_to(objective_target.global_position, delta)
	else:
		# PHASE B: WORK
		# Stop moving!
		unit.velocity = Vector2.ZERO
		
		# --- TODO: FUTURE ECONOMY LOGIC ---
		# 1. Capacity Check:
		#    Example: if unit.current_resources >= unit.max_capacity_without_building: return
		
		# 2. Turn-Based / Tick Logic:
		#    If the game is turn-based, you might only want to run this logic 
		#    when a specific "Turn Tick" signal is received, rather than every delta frame.
		
		# Delegate actual gathering to the Unit's script
		if unit.has_method("process_collecting_logic"):
			unit.process_collecting_logic(delta)

func _escort_state(delta: float) -> void:
	if is_instance_valid(objective_target):
		_simple_move_to(objective_target.global_position, delta)
		
		# Arrival check (Retreat Zone)
		if unit.global_position.distance_to(objective_target.global_position) < 50.0:
			if unit.has_method("complete_escort"):
				unit.complete_escort()
	else:
		change_state(UnitAIConstants.State.IDLE)

func _regroup_state(delta: float) -> void:
	if unit.has_method("process_regroup_logic"):
		unit.process_regroup_logic(delta)
		if move_command_position != Vector2.ZERO:
			_simple_move_to(move_command_position, delta)

func _idle_state(_delta: float) -> void:
	unit.velocity = Vector2.ZERO

func _formation_move_state(_delta: float) -> void:
	if path.is_empty():
		change_state(UnitAIConstants.State.IDLE)
		return

	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	
	if unit.global_position.distance_to(next_waypoint) < 8.0:
		path.remove_at(0) # FIXED: Compatible with PackedVector2Array
		if path.is_empty():
			change_state(UnitAIConstants.State.IDLE)

func _move_state(delta: float) -> void:
	if path.is_empty():
		change_state(UnitAIConstants.State.IDLE)
		return

	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var distance_to_waypoint = unit.global_position.distance_to(next_waypoint)

	# [NEW] Apply Encumbrance Logic Here
	var speed_mult = unit.get_speed_multiplier()
	# TODO: Ensure get_speed_multiplier() connects to Inventory Weight (Unit.inventory_weight)
	var final_speed = unit.data.move_speed * speed_mult

	# Apply velocity
	unit.velocity = direction * final_speed
	
	# [NEW] Stuck Safety Check
	# If we are supposed to be moving but velocity is tiny for too long
	if unit.velocity.length_squared() < 100.0:
		stuck_timer += delta
		if stuck_timer > 1.0:
			# Try re-pathing
			stuck_timer = 0.0
			_recalculate_path()
	else:
		stuck_timer = 0.0
	
	# Standard Waypoint Logic
	if distance_to_waypoint < 10.0: # Threshold to reach point
		path.remove_at(0)
		if path.is_empty():
			# If we were moving to a specific target (like a building), switch to Interact/Attack
			if is_instance_valid(objective_target):
				 # Simple check to decide next state based on target type
				if objective_target is BaseBuilding:
					change_state(UnitAIConstants.State.INTERACTING) # Pillage
				else:
					change_state(UnitAIConstants.State.ATTACKING)
			else:
				change_state(UnitAIConstants.State.IDLE)

func _interact_state(delta: float) -> void:
	if not is_instance_valid(objective_target):
		change_state(UnitAIConstants.State.IDLE)
		return

	# 1. Move to Target (Existing Logic)
	var distance_to_target = UnitAIConstants.get_surface_distance(unit, objective_target)
	var interact_range = 25.0 # Close range for pillaging
	
	if distance_to_target > interact_range:
		# Use pathfinding if far
		if not path.is_empty():
			var next = path[0]
			var dir = (next - unit.global_position).normalized()
			unit.velocity = dir * unit.data.move_speed
			unit.move_and_slide()
			
			if unit.global_position.distance_to(next) < 8.0:
				path.remove_at(0) # FIXED: Compatible with PackedVector2Array
		else:
			# Direct approach for last mile
			var dir = (objective_target.global_position - unit.global_position).normalized()
			unit.velocity = dir * unit.data.move_speed
			unit.move_and_slide()
	else:
		# 2. Arrived -> Perform Pillage
		unit.velocity = Vector2.ZERO
		
		# Only Pillage if it's an Enemy Building
		if objective_target is BaseBuilding:
			_process_pillage_tick(delta)

func _process_pillage_tick(delta: float) -> void:
	_pillage_accumulator += delta
	if _pillage_accumulator >= 1.0: # Tick once per second
		_pillage_accumulator = 0.0
		
		if not is_instance_valid(objective_target):
			change_state(UnitAIConstants.State.IDLE)
			return

		var building = objective_target as BaseBuilding
		
		# 1. Check Capacity BEFORE stealing
		if unit.current_loot_weight >= unit.data.max_loot_capacity:
			# Visual Feedback for "Full"
			EventBus.floating_text_requested.emit("FULL!", unit.global_position, Color.YELLOW)
			return

		# 2. Steal
		var amount_to_take = unit.data.pillage_speed
		var stolen_amount = building.steal_resources(amount_to_take)
		
		if stolen_amount > 0:
			# 3. Pocket the loot
			# TODO: [Refactor] Consider unifying this with Resource Gathering logic (EconomyManager)
			unit.add_loot("gold", stolen_amount)
			
			# Juice
			EventBus.floating_text_requested.emit("+%d" % stolen_amount, unit.global_position, Color.GOLD)
		else:
			# Building empty
			EventBus.floating_text_requested.emit("Empty", unit.global_position, Color.GRAY)
			change_state(UnitAIConstants.State.IDLE)

func _retreat_state(delta: float) -> void:
	if not path.is_empty():
		var next_waypoint: Vector2 = path[0]
		var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
		var velocity: Vector2 = direction * unit.data.move_speed
		
		unit.velocity = velocity
		unit.move_and_slide()
		
		if unit.global_position.distance_to(next_waypoint) < 8.0:
			path.remove_at(0) # FIXED: Compatible with PackedVector2Array
		return

	# The Last Mile for Retreat
	var dist_to_final = unit.global_position.distance_to(target_position)
	if dist_to_final > 5.0:
		var direction = (target_position - unit.global_position).normalized()
		unit.velocity = direction * unit.data.move_speed
		unit.move_and_slide()
	else:
		unit.velocity = Vector2.ZERO

func _attack_state(_delta: float) -> void:
	if not is_instance_valid(current_target):
		_resume_objective()
		return
	
	# Check if target moved out of range
	var radius = _get_target_radius(current_target)
	var dist = unit.global_position.distance_to(current_target.global_position) - radius
	
	# Use max range (Buildings are bigger)
	var max_range = max(unit.data.attack_range, unit.data.building_attack_range)
	
	if dist > max_range + 10:
		_resume_objective()
		return
	
	unit.velocity = Vector2.ZERO

func _resume_objective() -> void:
	current_target = null
	if is_instance_valid(objective_target):
		current_target = objective_target
		change_state(UnitAIConstants.State.MOVING)
	else:
		# Auto-acquire new targets if idle
		if attack_ai and attack_ai.ai_mode == AttackAI.AI_Mode.DEFAULT:
			var new_target = _find_closest_enemy_in_los()
			if is_instance_valid(new_target):
				command_attack(new_target)
			else:
				change_state(UnitAIConstants.State.IDLE)
		else:
			change_state(UnitAIConstants.State.IDLE)

func _find_closest_enemy_in_los() -> Node2D:
	# Simple fallback to find nearby enemies
	var enemies = unit.get_tree().get_nodes_in_group("enemy_units")
	var closest: Node2D = null
	var min_dist = los_range
	
	for e in enemies:
		var d = unit.global_position.distance_to(e.global_position)
		if d < min_dist:
			min_dist = d
			closest = e
	return closest

# --- SIGNAL CALLBACKS ---

func _on_ai_attack_started(target: Node2D) -> void:
	if current_state != UnitAIConstants.State.IDLE: return
	if current_state == UnitAIConstants.State.ATTACKING and target == current_target: return
	if current_state == UnitAIConstants.State.RETREATING: return 
	if current_state == UnitAIConstants.State.INTERACTING: return 
	
	current_target = target
	change_state(UnitAIConstants.State.ATTACKING)

func _on_ai_attack_stopped() -> void:
	if current_state == UnitAIConstants.State.ATTACKING:
		# --- Anti-Flicker Guard ---
		if is_instance_valid(current_target):
			var limit = unit.data.attack_range
			if current_target is BaseBuilding or (current_target.name == "Hitbox" and current_target.get_parent() is BaseBuilding):
				limit = unit.data.building_attack_range
			
			var radius = _get_target_radius(current_target)
			var dist = unit.global_position.distance_to(current_target.global_position) - radius
			
			# If we are still comfortably in range, assume AI is just cycling/reloading
			if dist <= limit + 5.0:
				return
		
		_resume_objective()

# --- HELPER: Geometry Math ---
func _get_target_radius(target: Node2D) -> float:
	if not is_instance_valid(target): return 0.0
	
	# 1. Check for Building Hitbox
	if target.name == "Hitbox" and target.get_parent() is BaseBuilding:
		var b = target.get_parent() as BaseBuilding
		if b.data:
			var size = min(b.data.grid_size.x, b.data.grid_size.y)
			return (size * 32.0) / 2.0
	
	# 2. Check for BaseBuilding directly
	if target is BaseBuilding and target.data:
		var size = min(target.data.grid_size.x, target.data.grid_size.y)
		return (size * 32.0) / 2.0

	# 3. Check for Unit
	if target is BaseUnit:
		return 15.0
		
	# 4. Fallback: Collision Shape
	var col = target.get_node_or_null("CollisionShape2D")
	if col:
		if col.shape is CircleShape2D: return col.shape.radius
		if col.shape is RectangleShape2D: return min(col.shape.size.x, col.shape.size.y) / 2.0
		
	return 0.0
	
func command_pillage(target: Node2D) -> void:
	if not is_instance_valid(target): return
	
	# Pillage uses the same movement logic as interacting
	objective_target = target
	current_target = null
	target_position = target.global_position
	
	if attack_ai: attack_ai.stop_attacking()
	
	# We reuse INTERACTING state for now. 
	# TODO: Consolidate with command_interact_move if pillaging becomes standard interaction.
	change_state(UnitAIConstants.State.INTERACTING)

func _simple_move_to(target: Vector2, _delta: float) -> void:
	var dir = (target - unit.global_position).normalized()
	
	var speed_mult = unit.get_speed_multiplier() if unit.has_method("get_speed_multiplier") else 1.0
	var final_speed = unit.data.move_speed * speed_mult
	
	unit.velocity = dir * final_speed
	# Note: BaseUnit._physics_process is responsible for calling move_and_slide()


--------------------------------------------------
FILE: res:///scripts/buildings/SettlementBridge.gd
--------------------------------------------------
# res://scripts/buildings/SettlementBridge.gd
extends LevelBase

const MAP_WIDTH = 60
const MAP_HEIGHT = 60

# --- Exported Resources ---
@export var home_base_data: SettlementData
@export var test_building_data: BuildingData
@export var raider_scene: PackedScene
@export var end_of_year_popup_scene: PackedScene
@export var world_map_scene_path: String = "res://scenes/world_map/MacroMap.tscn"

# --- REACTIVE DEBUG SETTINGS ---
@export_group("Loggie Debug Settings")
@export var show_ui_logs: bool = false:
	set(value):
		show_ui_logs = value
		if is_inside_tree(): Loggie.set_domain_enabled("UI", value)
@export var show_settlement_logs: bool = false:
	set(value):
		show_settlement_logs = value
		if is_inside_tree(): Loggie.set_domain_enabled("SETTLEMENT", value)
@export var show_building_logs: bool = false:
	set(value):
		show_building_logs = value
		if is_inside_tree(): Loggie.set_domain_enabled("BUILDING", value)
@export var show_debug_logs: bool = true:
	set(value):
		show_debug_logs = value
		if is_inside_tree(): Loggie.set_domain_enabled("DEBUG", value)
@export var show_raid_logs: bool = true:
	set(value):
		show_raid_logs = value
		if is_inside_tree(): Loggie.set_domain_enabled(LogDomains.RAID, value)

# --- New Game Configuration ---
@export_group("New Game Settings")
@export var start_gold: int = 1000
@export var start_wood: int = 500
@export var start_food: int = 100
@export var start_stone: int = 200
@export var start_population: int = 10

# --- Default Assets ---
var default_test_building: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
var default_end_of_year_popup: PackedScene = preload("res://ui/EndOfYear_Popup.tscn")

# --- Scene Node References ---
@onready var unit_container: Node2D = $UnitContainer
@onready var ui_layer: CanvasLayer = $UI
@onready var storefront_ui: Control = $UI/Storefront_UI
@onready var building_cursor: Node2D = $BuildingCursor

# --- Local Node References ---
@onready var building_container: Node2D = $BuildingContainer
@onready var rts_controller: RTSController = $RTSController
@onready var unit_spawner: UnitSpawner = $UnitSpawner

# --- Worker & End Year UI ---
const WORK_ASSIGNMENT_SCENE_PATH = "res://ui/WorkAssignment_UI.tscn"
var work_assignment_ui: CanvasLayer
var end_of_year_popup: PanelContainer
var idle_warning_dialog: ConfirmationDialog

# --- State Variables ---
var great_hall_instance: BaseBuilding = null
var game_is_over: bool = false
var awaiting_placement: BuildingData = null

func _ready() -> void:
	Loggie.set_domain_enabled("UI", show_ui_logs)
	Loggie.set_domain_enabled("SETTLEMENT", show_settlement_logs)
	Loggie.set_domain_enabled("BUILDING", show_building_logs)
	Loggie.set_domain_enabled("DEBUG", show_debug_logs)
	
	_setup_default_resources()
	_initialize_settlement() 
	_setup_ui()
	_connect_signals()
	
	if unit_spawner:
		unit_spawner.unit_container = unit_container
		unit_spawner.rts_controller = rts_controller
	
	# PRESERVED: Set default UI state BEFORE checking for raid results
	if storefront_ui: storefront_ui.show()
	if end_of_year_popup: end_of_year_popup.hide()

	# PRESERVED: Test Data Injection
	if not DynastyManager.current_jarl:
		var test_jarl = DynastyTestDataGenerator.generate_test_dynasty()
		DynastyManager.current_jarl = test_jarl
		DynastyManager.jarl_stats_updated.emit(test_jarl)
	
	# Check for Raid Return via RaidManager
	if RaidManager.pending_raid_result != null:
		_process_raid_return()

	# PRESERVED: RTS Debug Connections
	if rts_controller and not EventBus.select_command.is_connected(rts_controller._on_select_command):
		print("DIAGNOSTIC: Forcing RTSController connections.")
		EventBus.select_command.connect(rts_controller._on_select_command)
		EventBus.move_command.connect(rts_controller._on_move_command)
		EventBus.attack_command.connect(rts_controller._on_attack_command)
		EventBus.interact_command.connect(rts_controller._on_interact_command)
	
func _exit_tree() -> void:
	SettlementManager.unregister_active_scene_nodes()

func _connect_signals() -> void:
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	EventBus.settlement_loaded.connect(_sync_villagers)
	
	EventBus.building_ready_for_placement.connect(_on_building_ready_for_placement)
	EventBus.building_placement_cancelled.connect(_on_building_placement_cancelled)
	EventBus.building_right_clicked.connect(_on_building_right_clicked)
	EventBus.dynasty_view_requested.connect(_toggle_dynasty_view)
	EventBus.end_year_requested.connect(_on_end_year_pressed)
	
	EventBus.request_worker_assignment.connect(_on_worker_requested)
	EventBus.request_worker_removal.connect(_on_worker_removal_requested)
	
	if building_cursor:
		building_cursor.placement_completed.connect(_on_building_placement_completed)
		building_cursor.placement_cancelled.connect(_on_building_placement_cancelled_by_cursor)

func _setup_default_resources() -> void:
	if not test_building_data: test_building_data = default_test_building
	if not raider_scene: raider_scene = load("res://scenes/units/VikingRaider.tscn")
	if not end_of_year_popup_scene: end_of_year_popup_scene = default_end_of_year_popup

func _setup_ui() -> void:
	# End Year Popup
	end_of_year_popup = end_of_year_popup_scene.instantiate()
	ui_layer.add_child(end_of_year_popup)
	end_of_year_popup.collect_button_pressed.connect(_on_payout_collected)
	
	# Worker UI
	if ResourceLoader.exists(WORK_ASSIGNMENT_SCENE_PATH):
		var scene = load(WORK_ASSIGNMENT_SCENE_PATH)
		if scene:
			work_assignment_ui = scene.instantiate()
			add_child(work_assignment_ui)
			if work_assignment_ui.has_signal("assignments_confirmed"):
				work_assignment_ui.assignments_confirmed.connect(_on_worker_assignments_confirmed)
	
	# Idle Warning Dialog
	idle_warning_dialog = ConfirmationDialog.new()
	idle_warning_dialog.title = "Idle Villagers"
	idle_warning_dialog.ok_button_text = "End Year Anyway"
	idle_warning_dialog.cancel_button_text = "Select Idle Worker"
	idle_warning_dialog.confirmed.connect(_start_end_year_sequence)
	
	idle_warning_dialog.canceled.connect(func():
		EventBus.worker_management_toggled.emit()
	)
	
	add_child(idle_warning_dialog)

func _on_worker_assignments_confirmed(assignments: Dictionary) -> void:
	Loggie.msg("SettlementBridge: Work assignments saved.").domain("BUILDING").info()
	if SettlementManager.current_settlement:
		SettlementManager.current_settlement.worker_assignments = assignments
		SettlementManager.save_settlement()

# =========================================================
# === WORKER ASSIGNMENT LOGIC ===
# =========================================================

func _on_worker_requested(target: BaseBuilding) -> void:
	var index = SettlementManager.get_building_index(target)
	if index == -1: 
		Loggie.msg("Building Index Not Found").domain("SETTLEMENT").error()
		return
	
	var is_construction = (target.current_state != BaseBuilding.BuildingState.ACTIVE)
	var entry
	
	if is_construction:
		entry = SettlementManager.current_settlement.pending_construction_buildings[index]
	else:
		entry = SettlementManager.current_settlement.placed_buildings[index]
	
	var current_count = entry.get("peasant_count", 0)
	var incoming_count = target.get_meta("incoming_workers", 0)
	var total_allocated = current_count + incoming_count
	
	var capacity = 0
	if is_construction:
		capacity = target.data.base_labor_capacity
	else:
		var eco_data = target.data as EconomicBuildingData
		if eco_data: capacity = eco_data.peasant_capacity
		
	if total_allocated >= capacity:
		EventBus.floating_text_requested.emit("Full (Incoming)", target.global_position, Color.RED)
		return

	if SettlementManager.get_idle_peasants() <= 0:
		EventBus.floating_text_requested.emit("No Peasants", target.global_position, Color.RED)
		return

	var civilians = get_tree().get_nodes_in_group("civilians")
	var nearest_civ: CivilianUnit = null
	var min_dist = INF
	
	for civ in civilians:
		if civ.has_meta("booked") or civ.is_queued_for_deletion(): continue
		
		if civ.fsm and civ.fsm.current_state == UnitAIConstants.State.IDLE:
			var dist = civ.global_position.distance_to(target.global_position)
			if dist < min_dist:
				min_dist = dist
				nearest_civ = civ
	
	if nearest_civ:
		nearest_civ.set_meta("booked", true)
		target.set_meta("incoming_workers", incoming_count + 1)
		
		var tween = create_tween()
		var walk_speed = 100.0
		var time = min_dist / walk_speed
		
		tween.tween_property(nearest_civ, "global_position", target.global_position, time)
		var civ_ref = weakref(nearest_civ)
		
		tween.tween_callback(func(): 
			var current_inc = target.get_meta("incoming_workers", 1)
			target.set_meta("incoming_workers", max(0, current_inc - 1))
			
			var civ = civ_ref.get_ref()
			if civ:
				_finalize_worker_assignment(target, civ)
			else:
				Loggie.msg("Worker died en route.").domain("SETTLEMENT").warn()
		)
	else:
		_finalize_worker_assignment(target, null)

func _finalize_worker_assignment(target: BaseBuilding, unit_node: Node2D) -> void:
	var index = SettlementManager.get_building_index(target)
	if index != -1:
		var is_construction = (target.current_state != BaseBuilding.BuildingState.ACTIVE)
		var entry
		if is_construction:
			entry = SettlementManager.current_settlement.pending_construction_buildings[index]
		else:
			entry = SettlementManager.current_settlement.placed_buildings[index]
			
		var current = entry.get("peasant_count", 0)
		var cap = target.data.base_labor_capacity if is_construction else (target.data as EconomicBuildingData).peasant_capacity
		
		if current < cap:
			if is_construction:
				SettlementManager.assign_construction_worker(index, "peasant", 1)
			else:
				SettlementManager.assign_worker(index, "peasant", 1)
				
			EventBus.floating_text_requested.emit("+1 Worker", target.global_position, Color.GREEN)
			
			if is_instance_valid(unit_node):
				unit_node.queue_free()
		else:
			Loggie.msg("Building full on arrival. Releasing unit.").domain("SETTLEMENT").warn()
			if is_instance_valid(unit_node):
				unit_node.set_meta("booked", null)
	else:
		if is_instance_valid(unit_node):
			unit_node.set_meta("booked", null)

	_force_inspector_refresh(target)

func _on_worker_removal_requested(target: BaseBuilding) -> void:
	var index = SettlementManager.get_building_index(target)
	if index == -1: return
	
	var entry
	var is_construction = (target.current_state != BaseBuilding.BuildingState.ACTIVE)
	
	if is_construction:
		entry = SettlementManager.current_settlement.pending_construction_buildings[index]
	else:
		entry = SettlementManager.current_settlement.placed_buildings[index]
		
	var current_workers = entry.get("peasant_count", 0)
	
	if current_workers > 0:
		if unit_spawner:
			var random_offset = Vector2(randf_range(-20, 20), randf_range(20, 40))
			var spawn_pos = target.global_position + random_offset
			unit_spawner.spawn_worker_at(spawn_pos)
			
		if is_construction:
			SettlementManager.assign_construction_worker(index, "peasant", -1)
		else:
			SettlementManager.assign_worker(index, "peasant", -1)
			
		EventBus.floating_text_requested.emit("Worker Removed", target.global_position, Color.YELLOW)
		_force_inspector_refresh(target)
	else:
		Loggie.msg("Cannot remove: 0 workers").domain("SETTLEMENT").warn()

func _force_inspector_refresh(target: BaseBuilding) -> void:
	var inspector = ui_layer.get_node_or_null("BuildingInspector")
	if inspector and inspector.visible and inspector.current_building == target:
		inspector.call("_refresh_data")

# =========================================================
# === WINTER PHASE TRANSITION ===
# =========================================================

func _on_end_year_pressed() -> void:
	Loggie.msg("SettlementBridge: End Year requested.").domain("BUILDING").info()
	
	var idle_p = SettlementManager.get_idle_peasants()
	var idle_t = SettlementManager.get_idle_thralls()
	var total_idle = idle_p + idle_t
	
	if total_idle > 0:
		idle_warning_dialog.dialog_text = "You have %d idle workers.\nUnassigned workers produce nothing.\n\nEnd year anyway?" % total_idle
		idle_warning_dialog.popup_centered()
	else:
		_start_end_year_sequence()

func _start_end_year_sequence() -> void:
	_close_all_popups()
	Loggie.msg("SettlementBridge: Handing off to DynastyManager for Winter Cycle.").domain("SETTLEMENT").info()
	
	# FIX: Call DynastyManager to prep the Jarl, not WinterManager directly
	DynastyManager.start_winter_cycle()

func _on_payout_collected(payout: Dictionary) -> void:
	if payout.has("renown"):
		var amount = payout["renown"]
		if amount != 0:
			DynastyManager.award_renown(amount)
			var msg = "Renown %s %d (Loot Distribution)" % ["gained" if amount > 0 else "lost", abs(amount)]
			Loggie.msg(msg).domain(LogDomains.DYNASTY).info()
		payout.erase("renown")
	
	SettlementManager.deposit_resources(payout)
	
	# Reset Managers
	RaidManager.pending_raid_result = null
	
	if storefront_ui: storefront_ui.show()

func _close_all_popups() -> void:
	var dynasty_ui = ui_layer.get_node_or_null("Dynasty_UI")
	if dynasty_ui: dynasty_ui.hide()
	if work_assignment_ui: work_assignment_ui.hide()
	if end_of_year_popup: end_of_year_popup.hide()

func _clear_all_buildings() -> void:
	if is_instance_valid(building_container):
		for child in building_container.get_children(): child.queue_free()
		await get_tree().process_frame
	
	if is_instance_valid(unit_container):
		for child in unit_container.get_children(): child.queue_free()
		await get_tree().process_frame
	
	if SettlementManager.current_settlement:
		SettlementManager.current_settlement.placed_buildings.clear()
		SettlementManager.current_settlement.pending_construction_buildings.clear()
		SettlementManager.current_settlement.warbands.clear()
		SettlementManager._refresh_grid_state()
	
	great_hall_instance = null
	game_is_over = false
	awaiting_placement = null

func _initialize_settlement() -> void:
	# 1. SETUP DATA
	home_base_data = _create_default_settlement() 
	SettlementManager.register_active_scene_nodes(building_container)
	SettlementManager.load_settlement(home_base_data) 
	home_base_data = SettlementManager.current_settlement 

	# 2. GENERATE TERRAIN
	# We must generate the visual tiles before we can scan them for navigation.
	if has_node("TileMapLayer"):
		TerrainGenerator.generate_base_terrain(
			$TileMapLayer,
			MAP_WIDTH, # Or use a constant from a global config
			MAP_HEIGHT,
			home_base_data.map_seed 
		)

	# This calls the function in LevelBase.gd
	# It handles the wait time AND the NavigationManager setup for you.
	await setup_level_navigation(
		$TileMapLayer, 
		MAP_WIDTH, 
		MAP_HEIGHT
	)
	
	NavigationManager.initialize_grid_from_tilemap(
		$TileMapLayer,
		Vector2i(MAP_WIDTH, MAP_HEIGHT),
		Vector2i(64, 32) # Your Tile Dimensions
	)
	
	# 5. SPAWN BUILDINGS
	# This will automatically punch holes in the Navigation Grid we just made.
	_spawn_placed_buildings()
	# 6. SPAWN UNITS
	# Now they can safely request spawn points because the grid is ready.
	_sync_villagers()
	_spawn_player_garrison()
	
func _spawn_placed_buildings() -> void:
	if not SettlementManager.current_settlement: return
	
	for child in building_container.get_children(): child.queue_free()
	great_hall_instance = null 
	
	for building_entry in SettlementManager.current_settlement.placed_buildings:
		var b = _spawn_single_building(building_entry, false) 
		if b and b.data.is_territory_hub: 
			great_hall_instance = b
			print("SettlementBridge: Great Hall registered at ", b.global_position)
		
	for building_entry in SettlementManager.current_settlement.pending_construction_buildings:
		var b = _spawn_single_building(building_entry, true)
		if b:
			var progress = building_entry.get("progress", 0)
			if progress > 0:
				b.construction_progress = progress
				b.set_state(BaseBuilding.BuildingState.UNDER_CONSTRUCTION)
				if b.has_method("update_visual_state"): b.update_visual_state() 
			else:
				b.set_state(BaseBuilding.BuildingState.BLUEPRINT)
	
	if unit_spawner: unit_spawner.clear_units()
	

func _spawn_single_building(entry: Dictionary, is_new: bool) -> BaseBuilding:
	var res_path = entry["resource_path"]
	var grid_pos = Vector2i(entry["grid_position"].x, entry["grid_position"].y)
	var building_data = load(res_path) as BuildingData
	
	if not building_data: return null

	var new_building = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	new_building.grid_coordinate = grid_pos
	
	# --- FIX: ISOMETRIC POSITIONING ---
	# 1. Calculate the logical center of the building on the grid
	var center_grid_x = float(grid_pos.x) + (float(building_data.grid_size.x) / 2.0)
	var center_grid_y = float(grid_pos.y) + (float(building_data.grid_size.y) / 2.0)
	
	# 2. Convert Grid Center -> World Pixels (Isometric Formula)
	#    Formula matches SettlementManager.place_building logic
	var final_x = (center_grid_x - center_grid_y) * SettlementManager.TILE_HALF_SIZE.x
	var final_y = (center_grid_x + center_grid_y) * SettlementManager.TILE_HALF_SIZE.y
	
	new_building.global_position = Vector2(final_x, final_y)
	# ----------------------------------
	
	building_container.add_child(new_building)
	
	if is_new:
		new_building.set_state(BaseBuilding.BuildingState.UNDER_CONSTRUCTION)
	else:
		new_building.set_state(BaseBuilding.BuildingState.ACTIVE)
		
	return new_building

func _create_default_settlement() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = { "gold": start_gold, "wood": start_wood, "food": start_food, "stone": start_stone }
	settlement.population_peasants = start_population
	settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
	var great_hall_entry = { "resource_path": "res://data/buildings/GreatHall.tres", "grid_position": Vector2i(28, 18) }
	settlement.placed_buildings.append(great_hall_entry)
	return settlement

func _on_settlement_loaded(_settlement_data: SettlementData) -> void:
	pass

func _setup_great_hall(hall_instance: BaseBuilding) -> void:
	if not is_instance_valid(hall_instance): return
	great_hall_instance = hall_instance
	great_hall_instance.building_destroyed.connect(_on_great_hall_destroyed)

func _on_great_hall_destroyed(_building: BaseBuilding) -> void:
	game_is_over = true
	if is_instance_valid(unit_container):
		for enemy in unit_container.get_children(): enemy.queue_free()

func _on_building_ready_for_placement(building_data: BuildingData) -> void:
	awaiting_placement = building_data
	building_cursor.set_building_preview(building_data)

func _on_building_placement_cancelled(_building_data: BuildingData) -> void: pass

func _on_building_placement_completed() -> void:
	if awaiting_placement and SettlementManager.current_settlement:
		# --- FIX: Use Manager API for Coordinate Conversion ---
		# This handles the Isometric Math automatically
		var grid_pos = SettlementManager.world_to_grid(building_cursor.global_position)
		SettlementManager.place_building(awaiting_placement, grid_pos, true)
	awaiting_placement = null

func _on_building_placement_cancelled_by_cursor() -> void:
	if awaiting_placement:
		SettlementManager.deposit_resources(awaiting_placement.build_cost)
		awaiting_placement = null

func _on_building_right_clicked(building: BaseBuilding) -> void:
	if building_cursor.is_active: return
	var data = building.data
	var cost = data.build_cost
	SettlementManager.deposit_resources(cost)
	SettlementManager.remove_building(building)
	if SettlementManager.attempt_purchase(cost):
		EventBus.building_ready_for_placement.emit(data)

# --- Process Raid Return ---
func _process_raid_return() -> void:
	if RaidManager.pending_raid_result == null:
		return
		
	var result: RaidResultData = RaidManager.pending_raid_result
	var outcome = result.outcome
	
	Loggie.msg("Processing Raid Return: %s" % outcome).domain(LogDomains.SETTLEMENT).info()
	
	var raw_gold = result.loot.get("gold", 0)
	var total_wergild = 0
	var dead_count = 0
	
	for u_data in result.casualties:
		if u_data:
			total_wergild += u_data.wergild_cost
			dead_count += 1
	
	var net_gold = max(0, raw_gold - total_wergild)
	
	if outcome == "victory":
		RaidManager.last_raid_outcome = "victory"
	elif outcome == "retreat":
		RaidManager.last_raid_outcome = "defeat"
	else:
		RaidManager.last_raid_outcome = "neutral"
		
	if SettlementManager.current_settlement:
		var warbands_to_disband: Array[WarbandData] = []
		
		for warband in SettlementManager.current_settlement.warbands:
			if warband.is_bondi or warband.is_seasonal:
				if warband.is_bondi and warband.current_manpower > 0:
					SettlementManager.current_settlement.population_peasants += warband.current_manpower
					Loggie.msg("Bondi returned to fields.").domain("SETTLEMENT").info()
				
				if warband.is_seasonal:
					Loggie.msg("Seasonal Drengir have departed.").domain("SETTLEMENT").info()
				
				warbands_to_disband.append(warband)
		
		for wb in warbands_to_disband:
			SettlementManager.current_settlement.warbands.erase(wb)
			
		_sync_villagers()

	var grade = result.victory_grade
	var xp_gain = 0
	
	if outcome == "victory": 
		xp_gain = 50
		if grade == "Decisive": xp_gain = 75
		elif grade == "Pyrrhic": xp_gain = 25
	elif outcome == "retreat": 
		xp_gain = 20
	
	if xp_gain > 0 and DynastyManager.active_year_modifiers.has("BLOT_ODIN"):
		xp_gain = int(xp_gain * 1.5)
		
	if SettlementManager.current_settlement and xp_gain > 0:
		for warband in SettlementManager.current_settlement.warbands:
			if not warband.is_wounded:
				warband.experience += xp_gain

	var loot_summary = result.loot.duplicate()
	loot_summary["gold"] = net_gold
	
	var title_text = "Raid Result"
	
	if outcome == "victory":
		var difficulty = RaidManager.current_raid_difficulty
		var bonus = 200 + (difficulty * 50)
		if grade == "Decisive": bonus += 100
		
		loot_summary["gold"] = net_gold + bonus
		
		if not loot_summary.has("thrall"):
			loot_summary["population"] = randi_range(2, 4) * difficulty
		
		title_text = "Victory! (%s)" % grade
		
		var jarl = DynastyManager.get_current_jarl()
		if jarl:
			jarl.offensive_wins += 1
			jarl.battles_won += 1
			jarl.successful_raids += 1
			if jarl.has_trait("Warlord") and grade == "Decisive":
				DynastyManager.current_jarl.current_authority += 1
			DynastyManager.jarl_stats_updated.emit(jarl)
			
	elif outcome == "retreat":
		title_text = "Retreat"
		var total_loot_count = 0
		for k in loot_summary:
			if k != "gold": total_loot_count += loot_summary[k]
		total_loot_count += net_gold
		
		if total_loot_count > 0:
			title_text += "\n(Loot Secured)"
		else:
			title_text += "\n(Empty Handed)"

	if dead_count > 0:
		title_text += "\n(Wergild Paid: -%d Gold)" % total_wergild

	if result.renown_earned != 0:
		loot_summary["renown"] = result.renown_earned

	if not is_instance_valid(end_of_year_popup):
		var popup = default_end_of_year_popup.instantiate()
		ui_layer.add_child(popup)
		end_of_year_popup = popup
		
	end_of_year_popup.display_payout(loot_summary, title_text)
	
	RaidManager.pending_raid_result = null
	RaidManager.reset_raid_state()
	
func _sync_villagers(_data: SettlementData = null) -> void:
	if not SettlementManager.has_current_settlement(): return
	if not is_instance_valid(great_hall_instance): return
	if not unit_spawner: return
	
	var idle_count = SettlementManager.get_idle_peasants()
	var origin = great_hall_instance.global_position
	
	unit_spawner.sync_civilians(idle_count, origin)

func _toggle_dynasty_view() -> void:
	var dynasty_ui = ui_layer.get_node_or_null("Dynasty_UI")
	if dynasty_ui:
		if dynasty_ui.visible:
			dynasty_ui.hide()
		else:
			if storefront_ui: storefront_ui.call("_close_all_windows") 
			dynasty_ui.show()
			Loggie.msg("Opening Dynasty View").domain("UI").info()
	else:
		Loggie.msg("Error: Dynasty_UI node not found in SettlementBridge/UI").domain("UI").error()

func _spawn_player_garrison() -> void:
	if not SettlementManager.has_current_settlement(): return
	if not is_instance_valid(great_hall_instance): return
	if not unit_spawner: return
	
	var warbands = SettlementManager.current_settlement.warbands
	var origin = great_hall_instance.global_position
	
	unit_spawner.spawn_garrison(warbands, origin)


--------------------------------------------------
FILE: res:///scripts/data/GameResources.gd
--------------------------------------------------
# res://scripts/data/GameResources.gd
class_name GameResources
extends RefCounted

# -- Core Currencies --
const GOLD := "gold"
const WOOD := "wood"
const FOOD := "food"
const STONE := "stone"

# -- Population --
const POP_PEASANT := "peasant"
const POP_THRALL := "thrall"

# -- Helpers for UI Iteration --
const ALL_CURRENCIES = [GOLD, WOOD, FOOD, STONE]
const ALL_POPULATION = [POP_PEASANT, POP_THRALL]

# Optional: Centralized display names
static func get_display_name(key: String) -> String:
	match key:
		GOLD: return "Gold"
		WOOD: return "Wood"
		FOOD: return "Food"
		STONE: return "Stone"
		POP_PEASANT: return "Villager"
		POP_THRALL: return "Thrall"
		_: return "Unknown"


--------------------------------------------------
FILE: res:///scripts/data/GameScenes.gd
--------------------------------------------------
# res://scripts/data/GameScenes.gd
class_name GameScenes
extends RefCounted

# Core Views
const SETTLEMENT := "settlement"
const WORLD_MAP := "world_map"

# Missions
const RAID_MISSION := "raid_mission"

const WINTER_COURT := "winter_court"


--------------------------------------------------
FILE: res:///scripts/formations/SquadFormation.gd
--------------------------------------------------
# res://scripts/formations/SquadFormation.gd
# Squad Formation Manager - Company of Heroes style formations
# Handles formation positioning and movement for multiple units

class_name SquadFormation
extends RefCounted # Changed from implicit to explicit for better memory management

enum FormationType {
	LINE,      # Horizontal line formation  
	COLUMN,    # Vertical column formation
	WEDGE,     # V-shaped formation
	BOX,       # Rectangular formation
	CIRCLE     # Circular formation
}

# Formation settings
var formation_type: FormationType = FormationType.LINE
var unit_spacing: float = 40.0
var max_units_per_row: int = 4

# Squad data
var units: Array[Node2D] = []
var leader_position: Vector2 = Vector2.ZERO
var target_position: Vector2 = Vector2.ZERO
var formation_center: Vector2 = Vector2.ZERO

# Movement state
var is_moving: bool = false
var move_speed: float = 100.0

func _init(squad_units: Array[Node2D] = []) -> void:
	units = squad_units
	if not units.is_empty():
		formation_center = _calculate_center_position()

func add_unit(unit: Node2D) -> void:
	if unit not in units:
		units.append(unit)
		_update_formation_positions()

func remove_unit(unit: Node2D) -> void:
	units.erase(unit)
	_update_formation_positions()

func set_formation_type(new_type: FormationType) -> void:
	formation_type = new_type
	_update_formation_positions()

func move_to_position(target_pos: Vector2, direction: Vector2 = Vector2.DOWN) -> void:
	target_position = target_pos
	is_moving = true
	
	var formation_positions = _calculate_formation_positions(target_pos, direction)
	
	# TRACKER: Keep track of grid cells claimed by this squad
	var claimed_cells: Array[Vector2i] = []
	
	for i in range(min(units.size(), formation_positions.size())):
		var unit = units[i]
		if not is_instance_valid(unit): continue
			
		var raw_dest = formation_positions[i]
		var final_dest = raw_dest
		
		# --- PHASE 4 FIX: ANTI-BUNCHING ---
		if SettlementManager:
			# Pass the 'claimed_cells' so this unit doesn't pick a spot 
			# that a previous squadmate already took.
			final_dest = SettlementManager.validate_formation_point(raw_dest, claimed_cells)
			
			# Register this spot as taken
			var grid_spot = SettlementManager.world_to_grid(final_dest)
			claimed_cells.append(grid_spot)
		# ----------------------------------
		
		_move_unit_to_position(unit, final_dest)
	
	Loggie.msg("Squad moving to %s in %s formation" % [target_pos, FormationType.keys()[formation_type]]).domain("RTS").info()


# --- EXISTING SHAPE LOGIC (Preserved) ---

func _calculate_formation_positions(center_pos: Vector2, direction: Vector2) -> Array[Vector2]:
	var positions: Array[Vector2] = []
	var unit_count = units.size()
	
	# Invert direction to correct rotation (AI Fix preserved)
	var rotation_angle = Vector2.DOWN.angle_to(direction * -1.0)
	
	match formation_type:
		FormationType.LINE:
			positions = _calculate_line_formation(center_pos, unit_count)
		FormationType.COLUMN:
			positions = _calculate_column_formation(center_pos, unit_count)
		FormationType.WEDGE:
			positions = _calculate_wedge_formation(center_pos, unit_count)
		FormationType.BOX:
			positions = _calculate_box_formation(center_pos, unit_count)
		FormationType.CIRCLE:
			positions = _calculate_circle_formation(center_pos, unit_count)
	
	# Apply Rotation
	var rotated_positions: Array[Vector2] = []
	for pos in positions:
		var relative_pos = pos - center_pos
		var rotated_relative_pos = relative_pos.rotated(rotation_angle)
		rotated_positions.append(center_pos + rotated_relative_pos)
	
	return rotated_positions

func _calculate_line_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	var positions: Array[Vector2] = []
	var start_x = center_pos.x - (unit_count - 1) * unit_spacing * 0.5
	for i in range(unit_count):
		positions.append(Vector2(start_x + i * unit_spacing, center_pos.y))
	return positions

func _calculate_column_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	var positions: Array[Vector2] = []
	var start_y = center_pos.y - (unit_count - 1) * unit_spacing * 0.5
	for i in range(unit_count):
		positions.append(Vector2(center_pos.x, start_y + i * unit_spacing))
	return positions

func _calculate_wedge_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	var positions: Array[Vector2] = []
	positions.append(center_pos) # Leader
	
	var side_offset = unit_spacing * 0.7 
	var rear_offset = unit_spacing
	
	for i in range(1, unit_count):
		var row = (i + 1) / 2 
		var side = 1 if i % 2 == 1 else -1 
		# Use + to face DOWN default
		var pos = Vector2(
			center_pos.x + side * side_offset * row,
			center_pos.y + rear_offset * row
		)
		positions.append(pos)
	return positions

func _calculate_box_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	var positions: Array[Vector2] = []
	var rows = int(ceil(float(unit_count) / max_units_per_row))
	var cols = min(unit_count, max_units_per_row)
	
	var start_x = center_pos.x - (cols - 1) * unit_spacing * 0.5
	var start_y = center_pos.y - (rows - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var row = i / max_units_per_row
		var col = i % max_units_per_row
		
		# Center last row
		var row_unit_count = min(max_units_per_row, unit_count - row * max_units_per_row)
		var row_start_x = center_pos.x - (row_unit_count - 1) * unit_spacing * 0.5
		
		var pos = Vector2(
			row_start_x + col * unit_spacing,
			start_y + row * unit_spacing
		)
		positions.append(pos)
	return positions

func _calculate_circle_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	var positions: Array[Vector2] = []
	var radius = max(unit_spacing, unit_count * unit_spacing / (2 * PI))
	for i in range(unit_count):
		var angle = (2 * PI * i) / unit_count
		positions.append(Vector2(
			center_pos.x + cos(angle) * radius,
			center_pos.y + sin(angle) * radius
		))
	return positions

func _move_unit_to_position(unit: Node2D, target_pos: Vector2) -> void:
	if not is_instance_valid(unit): return
	
	# Prefer FSM Formation Move (Clears current target, sets path)
	if "fsm" in unit and unit.fsm != null:
		unit.fsm.command_move_to_formation_pos(target_pos)
	elif unit.has_method("command_move_to"):
		unit.command_move_to(target_pos)

func _update_formation_positions() -> void:
	if not units.is_empty():
		formation_center = _calculate_center_position()

func _calculate_center_position() -> Vector2:
	if units.is_empty(): return Vector2.ZERO
	var total_pos = Vector2.ZERO
	for unit in units:
		if is_instance_valid(unit): total_pos += unit.global_position
	return total_pos / units.size()

func get_unit_count() -> int: return units.size()
func is_squad_moving() -> bool: return is_moving
func get_formation_info() -> Dictionary:
	return {
		"type": FormationType.keys()[formation_type],
		"unit_count": units.size(),
		"spacing": unit_spacing,
		"center": formation_center,
		"is_moving": is_moving
	}


--------------------------------------------------
FILE: res:///scripts/generators/DynastyGenerator.gd
--------------------------------------------------
# res://scripts/generators/DynastyGenerator.gd
class_name DynastyGenerator
extends RefCounted

const MALE_NAMES = ["Ragnar", "Bjorn", "Ivar", "Sigurd", "Ubbe", "Halfdan", "Harald", "Erik", "Leif", "Sven", "Olaf", "Knut", "Torstein", "Floki", "Rollo", "Arvid"]
const FEMALE_NAMES = ["Lagertha", "Aslaug", "Gunnhild", "Torvi", "Helga", "Siggy", "Astrid", "Freydis", "Ylva", "Thyra", "Ingrid", "Ragnhild", "Sif", "Hilda"]
const SURNAMES = ["Lothbrok", "Ironside", "the Boneless", "Snake-in-the-Eye", "Fairhair", "Red", "the Lucky", "Forkbeard"]

# --- PORTRAIT CONFIGURATION ---
# Add your file paths here. You can add as many as you like.
const PORTRAIT_PATHS = {
	"Male": {
		"Young": [
			"res://assets/portraits/young male.png",
			"res://assets/portraits/young man 2.png"
		],
		"Adult": [
			"res://assets/portraits/adult male.png",
			"res://assets/portraits/adult male 2.png"
		],
		"Elder": [
			"res://assets/portraits/elder male.png",
			"res://assets/portraits/male/elder_2.png"
		]
	},
	"Female": {
		"Young": [
			"res://assets/portraits/young woman 2.png",
			"res://assets/portraits/young woman.png"
		],
		"Adult": [
			"res://assets/portraits/shield maiden.png",
			"res://assets/portraits/adult woman.png"
		],
		"Elder": [
			"res://assets/portraits/elderly woman 2.png",
			
		]
	}
}

static func generate_random_dynasty() -> JarlData:
	var jarl = JarlData.new()
	
	# 1. Basic Identity
	jarl.gender = "Male" if randf() > 0.3 else "Female"
	jarl.display_name = _generate_name(jarl.gender)
	jarl.age = randi_range(25, 45)
	
	# --- NEW: Assign Portrait ---
	jarl.portrait = _get_random_portrait(jarl.gender, jarl.age)
	
	# 2. Base Stats
	jarl.command = randi_range(8, 15)
	jarl.stewardship = randi_range(8, 15)
	jarl.diplomacy = randi_range(8, 15)
	jarl.prowess = randi_range(8, 15)
	jarl.learning = randi_range(5, 12)
	
	# 3. Derived Stats
	jarl.renown = 0
	jarl.current_authority = 3
	jarl.max_authority = 3
	jarl.legitimacy = 50 
	
	# 4. Generate Heirs
	var heir_count = randi_range(1, 2)
	for i in range(heir_count):
		var heir = _generate_heir(jarl.age)
		if i == 0:
			heir.is_designated_heir = true
		jarl.heirs.append(heir)
	
	Loggie.msg("DynastyGenerator: Created %s (Age %d) with %d heirs." % [jarl.display_name, jarl.age, heir_count]).domain(LogDomains.DYNASTY).info()
	return jarl

static func _generate_heir(parent_age: int) -> JarlHeirData:
	var heir = JarlHeirData.new()
	heir.gender = "Male" if randf() > 0.5 else "Female"
	heir.display_name = _generate_name(heir.gender, false) 
	
	# Age logic
	var max_age = max(0, parent_age - 16)
	heir.age = randi_range(max(0, max_age - 10), max_age)
	heir.age = max(0, heir.age)
	
	# --- NEW: Assign Portrait ---
	heir.portrait = _get_random_portrait(heir.gender, heir.age)
	
	# Random Stats
	heir.command = randi_range(5, 12)
	heir.stewardship = randi_range(5, 12)
	heir.prowess = randi_range(5, 12)
	heir.learning = randi_range(5, 12)
	
	heir.status = JarlHeirData.HeirStatus.Available
	
	return heir

static func _generate_name(gender: String, include_surname: bool = true) -> String:
	var name_list = MALE_NAMES if gender == "Male" else FEMALE_NAMES
	var first = name_list.pick_random()
	
	if include_surname and randf() > 0.4:
		var last = SURNAMES.pick_random()
		return "%s %s" % [first, last]
	
	return first

# --- HELPER: Selects the correct image based on stats ---
static func _get_random_portrait(gender: String, age: int) -> Texture2D:
	var age_category = "Adult"
	
	if age < 20:
		age_category = "Young"
	elif age > 50:
		age_category = "Elder"
		
	if PORTRAIT_PATHS.has(gender) and PORTRAIT_PATHS[gender].has(age_category):
		var paths = PORTRAIT_PATHS[gender][age_category]
		if not paths.is_empty():
			var path = paths.pick_random()
			if ResourceLoader.exists(path):
				return load(path)
			else:
				# Fallback if you haven't added the files yet
				return null
				
	return null

static func generate_newborn() -> JarlHeirData:
	var baby = JarlHeirData.new()
	baby.age = 0
	baby.gender = "Male" if randf() > 0.5 else "Female"
	baby.display_name = _generate_name(baby.gender, false) # No surname for kids
	
	# 1. Assign Portrait (Will pick from "Young" category)
	baby.portrait = _get_random_portrait(baby.gender, 0)
	
	# 2. Genetic Traits (Moved here from DynastyManager)
	if randf() < 0.2:
		var trait_data = JarlTraitData.new()
		trait_data.display_name = ["Strong", "Genius", "Giant", "Frail"].pick_random()
		baby.genetic_trait = trait_data
		
	# 3. Base Stats (Babies start with potential, but low raw ability)
	# We can simulate "potential" by giving them average stats now that grow, 
	# or just randomizing them like the adults. Let's randomize for now.
	baby.command = randi_range(2, 8)
	baby.stewardship = randi_range(2, 8)
	baby.prowess = randi_range(2, 8)
	baby.learning = randi_range(2, 8)
	
	baby.status = JarlHeirData.HeirStatus.Available
	return baby

static func get_random_viking_name() -> String:
	var gender = "Male" if randf() > 0.2 else "Female" # Mostly male raiders historically
	var list = MALE_NAMES if gender == "Male" else FEMALE_NAMES
	return list.pick_random()


--------------------------------------------------
FILE: res:///scripts/generators/MapDataGenerator.gd
--------------------------------------------------
class_name MapDataGenerator
extends RefCounted

# --- Historical Names List ---
const REGION_NAMES = [
	"Geatland", "Viken", "Swealand", "Halogaland", 
	"Denmark", "Kvenland", "Estland", "Courland", 
	"Samland", "Bjarmaland", "Wendland", "Saxony", 
	"Frankland", "Britland"
]

# --- Templates ---
const LAYOUT_MONASTERY = "res://data/settlements/monastery_base.tres"
const LAYOUT_VILLAGE = "res://data/settlements/economic_base.tres"
const LAYOUT_FORTRESS = "res://data/settlements/fortress_layout.tres"

# --- Building Resources ---
const B_FARM = "res://data/buildings/generated/Eco_Farm.tres"
const B_MARKET = "res://data/buildings/generated/Eco_Market.tres"
const B_RELIC = "res://data/buildings/generated/Eco_Reliquary.tres"
const B_HALL = "res://data/buildings/GreatHall.tres"
const B_WALL = "res://data/buildings/Bldg_Wall.tres"

# --- Generation Logic ---

static func generate_region_data(tier: int, fixed_name: String = "") -> WorldRegionData:
	var data = WorldRegionData.new()
	
	if fixed_name != "":
		data.display_name = fixed_name
	else:
		data.display_name = _generate_name()
		
	data.region_type_tag = "Province"
	
	# Difficulty Logic
	var base_diff = 1.0 + (float(tier - 1) * 0.8)
	var variance = randf_range(0.0, 0.5)
	var final_difficulty = base_diff + variance
	
	var target_count = randi_range(1, 3)
	var min_cost = 999 
	
	for i in range(target_count):
		var target = _generate_target_for_tier(data.display_name, tier, final_difficulty)
		if target:
			data.raid_targets.append(target)
			if target.raid_cost_authority < min_cost:
				min_cost = target.raid_cost_authority
	
	data.base_authority_cost = min_cost if min_cost != 999 else 1
	data.yearly_income = {"gold": int(10 * final_difficulty), "food": int(20 * final_difficulty)}
	data.description = "A Tier %d region.\nDifficulty Rating: %.1f" % [tier, final_difficulty]
	
	return data

static func _generate_name() -> String:
	return REGION_NAMES.pick_random()

static func _generate_target_for_tier(region_name: String, tier: int, difficulty: float) -> RaidTargetData:
	var target = RaidTargetData.new()
	var type = _pick_type_by_tier(tier)
	
	target.display_name = "%s %s" % [region_name, type]
	target.difficulty_rating = int(round(difficulty))
	target.raid_cost_authority = max(1, int(round(difficulty * 0.5)))
	target.settlement_data = _generate_procedural_settlement(type, difficulty)
	return target

static func _pick_type_by_tier(tier: int) -> String:
	var roll = randf()
	match tier:
		1: return "Farmstead" if roll < 0.6 else "Monastery"
		2: return "Village" if roll < 0.5 else "Trading Post"
		_: return "Fortress"

# =========================================================
# === PROCEDURAL SETTLEMENT GENERATION (GRID AWARE) ===
# =========================================================

static func _generate_procedural_settlement(type: String, difficulty: float) -> SettlementData:
	var s = SettlementData.new()
	s.map_seed = randi() 
	s.placed_buildings.clear()
	s.warbands.clear()
	
	# 1. Generate a consistent Seed for this map
	# This ensures TerrainGenerator creates the same land every time we load this specific RaidTarget
	
	
	# 2. Setup Economy (Loot)
	match type:
		"Farmstead": s.treasury = {"food": 500, "wood": 100, "gold": 20}
		"Monastery": s.treasury = {"gold": 400, "food": 50, "wood": 0}
		"Trading Post": s.treasury = {"gold": 250, "wood": 250, "food": 100}
		_: s.treasury = {"gold": 100, "wood": 100, "food": 100}
			
	# 3. Smart Placement System
	# We use a Dictionary to track occupied tiles: { Vector2i: true }
	var occupied_grid = {}
	
	# Determine Layout Center (Safe Zone for Terrain)
	# Assuming 60x60 grid, center is 30,30. We shift slightly up (20) for Isometric view balance.
	var map_center = Vector2i(30, 20)
	
	# --- STEP A: Place Great Hall (Always Center) ---
	var hall_path = B_HALL
	if type == "Monastery": hall_path = B_RELIC # Monasteries have Reliquaries as their "Hall"
	
	_try_place_building(s, occupied_grid, hall_path, map_center)
	
	# --- STEP B: Place Support Buildings ---
	var building_count = int(3 * difficulty)
	var primary_path = B_FARM
	if type == "Monastery": primary_path = B_RELIC
	elif type == "Trading Post" or type == "Village": primary_path = B_MARKET
	
	for i in range(building_count):
		# Pick a random building type based on the theme
		var path = primary_path
		if randf() < 0.3: path = B_FARM # Mixed economy
		
		# Find a valid spot spiraling out from center
		# We try 10 times to find a spot for this specific building
		for attempt in range(10):
			var radius = randi_range(4, 12) # Keep within 4-12 tiles of center (Safe Land)
			var angle = randf() * TAU
			var offset = Vector2(cos(angle), sin(angle)) * radius
			var target_pos = map_center + Vector2i(round(offset.x), round(offset.y))
			
			if _try_place_building(s, occupied_grid, path, target_pos):
				break # Success, move to next building
	
	# --- STEP C: Garrison ---
	_scale_garrison(s, difficulty)
	
	return s

## Attempts to place a building at the target grid position.
## Returns true if successful (space was empty), false if blocked.
static func _try_place_building(settlement: SettlementData, occupied: Dictionary, res_path: String, pos: Vector2i) -> bool:
	# 1. Load Data to check Size
	if not ResourceLoader.exists(res_path): 
		return false
		
	var b_data = load(res_path) as BuildingData
	if not b_data: return false
	
	var width = b_data.grid_size.x
	var height = b_data.grid_size.y
	
	# 2. Check Overlap
	# We buffer by 1 extra tile to leave walking space between buildings
	var buffer = 1 
	
	for x in range(-buffer, width + buffer):
		for y in range(-buffer, height + buffer):
			var check_pos = pos + Vector2i(x, y)
			
			# Check Bounds (Safety against map edge)
			if check_pos.x < 2 or check_pos.x > 58 or check_pos.y < 2 or check_pos.y > 58:
				return false
				
			# Check Occupancy
			# Note: We strictly forbid overlap on the building footprint (0 to width),
			# but the buffer is just a "preference". For this simple generator, 
			# we treat the buffer as hard occupancy to prevent clutter.
			if occupied.has(check_pos):
				return false
	
	# 3. Place Logic
	# If we got here, the space is clear.
	settlement.placed_buildings.append({
		"resource_path": res_path,
		"grid_position": pos
	})
	
	# 4. Mark Occupied
	for x in range(width):
		for y in range(height):
			var mark_pos = pos + Vector2i(x, y)
			occupied[mark_pos] = true
			
	return true

# =========================================================
# === HELPERS ===
# =========================================================

static func _clone_settlement_data(original: SettlementData) -> SettlementData:
	var clone = SettlementData.new()
	clone.treasury = original.treasury.duplicate()
	clone.map_seed = original.map_seed # Preserve seed!
	
	clone.placed_buildings.clear()
	for b in original.placed_buildings:
		clone.placed_buildings.append(b.duplicate())
		
	clone.pending_construction_buildings.clear()
	for p in original.pending_construction_buildings:
		clone.pending_construction_buildings.append(p.duplicate())
		
	clone.warbands.clear() 
	clone.population_peasants = original.population_peasants
	clone.population_thralls = original.population_thralls
	
	return clone

static func _scale_garrison(settlement: SettlementData, multiplier: float) -> void:
	if not settlement: return
	
	if settlement.warbands.is_empty():
		var possible_paths = [
			"res://data/units/EnemyVikingRaider_Data.tres",
			"res://data/units/Unit_Bondi.tres",
			"res://data/units/Unit_Drengr.tres"
		]
		
		var unit_data: UnitData = null
		for path in possible_paths:
			if ResourceLoader.exists(path):
				unit_data = load(path)
				break
		
		if unit_data:
			var count = int(3 * multiplier)
			count = max(1, count) 
			
			for i in range(count):
				var wb = WarbandData.new(unit_data)
				wb.custom_name = "Defenders %d" % (i + 1)
				settlement.warbands.append(wb)
				
			print("MapGenerator: Assigned %d squads of %s." % [count, unit_data.display_name])
		else:
			printerr("CRITICAL: MapDataGenerator could not find ANY unit files!")
			return

	var original_count = settlement.warbands.size()
	var target_count = int(original_count * multiplier)
	var needed = target_count - original_count
	if needed > 0:
		for i in range(needed):
			var source = settlement.warbands.pick_random()
			var new_wb = WarbandData.new(source.unit_type)
			new_wb.custom_name = source.custom_name + " (Reinforcements)"
			settlement.warbands.append(new_wb)


--------------------------------------------------
FILE: res:///scripts/generators/TerrainGenerator.gd
--------------------------------------------------
class_name TerrainGenerator
extends RefCounted

const TERRAIN_SET_ID = 0 
const TERRAIN_BEACH = 0
const TERRAIN_SHALLOW = 1
const TERRAIN_DEEP = 2
const TERRAIN_GRASS = 3

# Map Settings (60x60)
const LEVEL_BEACH_START = 50   # Land goes much further down now
const LEVEL_SHALLOW_START = 55
const LEVEL_DEEP_START = 58

static func generate_base_terrain(tile_layer: TileMapLayer, width: int, height: int, map_seed: int) -> void:
	if not tile_layer: return
	tile_layer.clear()
	
	var rng = RandomNumberGenerator.new()
	if map_seed == 0: rng.randomize()
	else: rng.seed = map_seed
	
	print("TerrainGenerator: Carving Fjord with Seed: %d" % rng.seed)
	
	# 1. Prepare Arrays
	# We use a Dictionary for fast lookups: cells[Vector2i(x,y)] = TERRAIN_TYPE
	# This lets us overwrite "Grass" with "Water" easily before painting.
	var terrain_map = {}
	
	# 2. Fill Base Gradient (Mostly Land)
	for x in range(-5, width + 5): # Add buffer for autotiler
		for y in range(-5, height + 5):
			var grid_pos = Vector2i(x, y)
			
			# Base horizontal noise
			var noise = rng.randi_range(-1, 1)
			var effective_y = y + noise
			
			if effective_y >= LEVEL_DEEP_START:
				terrain_map[grid_pos] = TERRAIN_DEEP
			elif effective_y >= LEVEL_SHALLOW_START:
				terrain_map[grid_pos] = TERRAIN_SHALLOW
			elif effective_y >= LEVEL_BEACH_START:
				terrain_map[grid_pos] = TERRAIN_BEACH
			else:
				terrain_map[grid_pos] = TERRAIN_GRASS

	# 3. CARVE THE FJORD
	# We pass the dictionary by reference to modify it
	_carve_fjord(terrain_map, width, height, rng)
	
	# 4. Convert Dictionary to Arrays for Godot
	var cells_grass: Array[Vector2i] = []
	var cells_beach: Array[Vector2i] = []
	var cells_shallow: Array[Vector2i] = []
	var cells_deep: Array[Vector2i] = []
	
	for pos in terrain_map:
		var type = terrain_map[pos]
		match type:
			TERRAIN_GRASS: cells_grass.append(pos)
			TERRAIN_BEACH: cells_beach.append(pos)
			TERRAIN_SHALLOW: cells_shallow.append(pos)
			TERRAIN_DEEP: cells_deep.append(pos)
			
	# 5. Paint
	tile_layer.set_cells_terrain_connect(cells_deep, TERRAIN_SET_ID, TERRAIN_DEEP, false)
	tile_layer.set_cells_terrain_connect(cells_shallow, TERRAIN_SET_ID, TERRAIN_SHALLOW, false)
	tile_layer.set_cells_terrain_connect(cells_beach, TERRAIN_SET_ID, TERRAIN_BEACH, false)
	tile_layer.set_cells_terrain_connect(cells_grass, TERRAIN_SET_ID, TERRAIN_GRASS, false)

# --- THE FJORD LOGIC ---
static func _carve_fjord(terrain_map: Dictionary, width: int, height: int, rng: RandomNumberGenerator) -> void:
	# 1. Start at the bottom center-ish
	var current_x = rng.randi_range(20, 40) # Middle of map
	var current_y = height + 2 # Start off-screen at bottom
	
	# 2. Decide how far up it goes (Stop at row 15, keeping top area safe for base)
	var end_y = rng.randi_range(10, 20)
	
	# 3. Walk the path
	while current_y > end_y:
		# Wiggle the path left/right
		current_x += rng.randi_range(-2, 2)
		current_x = clampi(current_x, 10, width - 10) # Keep in bounds
		
		# Move Up
		current_y -= 1
		
		# Determine Width (Wider at bottom, narrow at top)
		var progress = float(current_y) / float(height) # 0.0 (top) to 1.0 (bottom)
		var fjord_width = int(lerp(2.0, 8.0, progress)) # 2 tiles wide at tip, 8 at mouth
		
		# 4. Dig the hole (Circle Brush)
		for x in range(current_x - fjord_width, current_x + fjord_width):
			for y in range(current_y - 1, current_y + 2): # Slight vertical brush
				var pos = Vector2i(x, y)
				
				# Check distance to center of river (make it round)
				if Vector2(x, y).distance_to(Vector2(current_x, current_y)) <= fjord_width:
					# Force Deep Water
					terrain_map[pos] = TERRAIN_DEEP
					
					# Add Coastline (optional: turn neighbors into Beach)
					_add_coastline_around(terrain_map, pos)

static func _add_coastline_around(terrain_map: Dictionary, water_pos: Vector2i) -> void:
	# Look at neighbors
	var neighbors = [
		Vector2i(0, 1), Vector2i(0, -1), Vector2i(1, 0), Vector2i(-1, 0)
	]
	
	for n in neighbors:
		var check_pos = water_pos + n
		if terrain_map.has(check_pos):
			# If the neighbor is GRASS, turn it into BEACH or SHALLOW
			# This prevents "Grass touching Deep Water" directly
			if terrain_map[check_pos] == TERRAIN_GRASS:
				terrain_map[check_pos] = TERRAIN_BEACH


--------------------------------------------------
FILE: res:///scripts/ui/BuildingPreviewCursor.gd
--------------------------------------------------
#res://scripts/ui/BuildingPreviewCursor.gd
extends Node2D
class_name BuildingPreviewCursor

const ISO_PLACEHOLDER_SCRIPT = "res://scripts/utility/IsoPlaceholder.gd"

# --- Components ---
var current_building_data: BuildingData
var preview_visuals: Node2D 
var is_active: bool = false
var error_label: Label 

# --- Grid & Placement ---
var grid_overlay: Node2D
var can_place: bool = false
var current_grid_pos: Vector2i = Vector2i.ZERO

# --- Visual Settings ---
var valid_color: Color = Color(0.4, 1.0, 0.4, 0.7)    # Greenish
var invalid_color: Color = Color(1.0, 0.4, 0.4, 0.7)  # Reddish

# --- Tether Settings ---
var nearest_node: Node2D = null 
var tether_color_valid: Color = Color(0.2, 1.0, 0.2, 0.8) 
var tether_color_invalid: Color = Color(1.0, 0.2, 0.2, 0.8)

signal placement_completed
signal placement_cancelled

func _ready() -> void:
	z_index = 100 
	
	grid_overlay = Node2D.new()
	grid_overlay.name = "GridOverlay"
	add_child(grid_overlay)
	
	error_label = Label.new()
	error_label.add_theme_color_override("font_color", Color.RED)
	error_label.add_theme_color_override("font_outline_color", Color.BLACK)
	error_label.add_theme_constant_override("outline_size", 4)
	error_label.add_theme_font_size_override("font_size", 24)
	error_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	error_label.position = Vector2(-100, -80) 
	error_label.custom_minimum_size = Vector2(200, 30)
	error_label.visible = false
	add_child(error_label)
	
	EventBus.building_ready_for_placement.connect(set_building_preview)
	
	visible = false
	set_process(false)
	set_process_input(false)

func set_building_preview(building_data: BuildingData) -> void:
	if not building_data: return
	current_building_data = building_data
	
	_cleanup_preview()
	
	# --- 1. Determine Visuals ---
	var tex_to_use: Texture2D = null
	
	# FIX: Prioritize the In-Game Sprite (building_texture) over the UI Icon
	if "building_texture" in building_data and building_data.building_texture:
		tex_to_use = building_data.building_texture
	# Priority 2: Extract from Scene (AI/Generated Content)
	elif building_data.scene_to_spawn:
		tex_to_use = _extract_texture_from_scene(building_data.scene_to_spawn)
	# Priority 3: Fallback to Icon (better than nothing, but might be a square)
	elif building_data.icon:
		tex_to_use = building_data.icon
	
	if tex_to_use:
		# A. Create Sprite
		var sprite = Sprite2D.new()
		sprite.texture = tex_to_use
		sprite.centered = true
		sprite.offset = Vector2(0, -tex_to_use.get_height() / 2.0)
		preview_visuals = sprite
	else:
		# B. Create Procedural Placeholder
		Loggie.msg("No texture for %s, generating procedural placeholder." % building_data.display_name).domain(LogDomains.UI).debug()
		preview_visuals = _create_procedural_placeholder(building_data)

	if preview_visuals:
		preview_visuals.modulate = valid_color
		add_child(preview_visuals)
	
	# --- 2. Create Isometric Outline ---
	_create_grid_outline(building_data.grid_size)
	
	# --- 3. Activate ---
	is_active = true
	visible = true
	set_process(true)
	set_process_input(true)
	
	Loggie.msg("Placement Mode Started: %s" % building_data.display_name).domain(LogDomains.UI).debug()

func _create_procedural_placeholder(data: BuildingData) -> Node2D:
	var placeholder = Node2D.new()
	if ResourceLoader.exists(ISO_PLACEHOLDER_SCRIPT):
		var script = load(ISO_PLACEHOLDER_SCRIPT)
		placeholder.set_script(script)
		if "grid_size" in placeholder:
			placeholder.set("grid_size", data.grid_size)
		elif "data" in placeholder:
			placeholder.set("data", data)
		placeholder.queue_redraw()
	else:
		Loggie.msg("IsoPlaceholder script missing!").domain(LogDomains.UI).error()
	return placeholder

func _extract_texture_from_scene(packed_scene: PackedScene) -> Texture2D:
	if not packed_scene: return null
	var instance = packed_scene.instantiate()
	var found_tex: Texture2D = null
	if instance is Sprite2D:
		found_tex = instance.texture
	else:
		for child in instance.get_children():
			if child is Sprite2D:
				found_tex = child.texture
				break
	instance.queue_free()
	return found_tex

func _process(_delta: float) -> void:
	if not is_active or not current_building_data: return
	
	var mouse_pos = get_global_mouse_position()
	
	if SettlementManager:
		current_grid_pos = SettlementManager.world_to_grid(mouse_pos)
		
		if SettlementManager.has_method("get_footprint_center"):
			global_position = SettlementManager.get_footprint_center(current_grid_pos, current_building_data.grid_size)
		else:
			global_position = SettlementManager.grid_to_world(current_grid_pos)
			
		var error = SettlementManager.get_placement_error(current_grid_pos, current_building_data.grid_size, current_building_data)
		can_place = (error == "")
		
		if can_place:
			error_label.visible = false
		else:
			error_label.text = error
			error_label.visible = true
			
	else:
		global_position = mouse_pos
		can_place = true
		error_label.visible = false
	
	_find_nearest_resource_node(global_position)
	_update_visual_feedback()
	queue_redraw()

func _input(event: InputEvent) -> void:
	if not is_active: return
	
	if event is InputEventMouseButton and event.is_pressed():
		if event.button_index == MOUSE_BUTTON_LEFT:
			_try_place_building()
			get_viewport().set_input_as_handled() 
			
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			cancel_preview()
			get_viewport().set_input_as_handled()

func _try_place_building() -> void:
	if not is_active or not can_place: return
	
	if SettlementManager:
		SettlementManager.place_building(current_building_data, current_grid_pos, true)
		EventBus.purchase_successful.emit("Construction Started")
	
	placement_completed.emit()
	
	if not Input.is_key_pressed(KEY_SHIFT):
		cancel_preview()

func cancel_preview() -> void:
	is_active = false
	visible = false
	set_process(false)
	set_process_input(false)
	
	current_building_data = null
	_cleanup_preview()
	
	placement_cancelled.emit()
	Loggie.msg("Placement Cancelled").domain(LogDomains.UI).debug()

func _cleanup_preview() -> void:
	if preview_visuals: 
		preview_visuals.queue_free()
		preview_visuals = null
	_clear_grid_overlay()

func _update_visual_feedback() -> void:
	if not preview_visuals: return
	preview_visuals.modulate = valid_color if can_place else invalid_color

func _find_nearest_resource_node(world_pos: Vector2) -> void:
	nearest_node = null
	if not current_building_data is EconomicBuildingData: return
		
	var target_type = (current_building_data as EconomicBuildingData).resource_type
	var min_dist = INF
	
	var nodes = get_tree().get_nodes_in_group("resource_nodes")
	
	for node in nodes:
		if "resource_type" in node and node.resource_type == target_type:
			if node.has_method("is_depleted") and node.is_depleted(): continue
			
			var dist = world_pos.distance_to(node.global_position)
			if dist < min_dist:
				min_dist = dist
				nearest_node = node

func _draw() -> void:
	if is_active and nearest_node:
		var start = Vector2.ZERO 
		var end = to_local(nearest_node.global_position)
		var dist = global_position.distance_to(nearest_node.global_position)
		
		var radius = 300.0
		if "district_radius" in nearest_node:
			radius = nearest_node.district_radius
			
		var is_in_range = dist <= radius
		var color = tether_color_valid if is_in_range else tether_color_invalid
		
		draw_line(start, end, color, 2.0)
		draw_circle(end, 5.0, color)

func _create_grid_outline(grid_size: Vector2i) -> void:
	_clear_grid_overlay()
	
	var tile_size = Vector2(64, 32)
	if SettlementManager and SettlementManager.has_method("get_active_grid_cell_size"):
		tile_size = SettlementManager.get_active_grid_cell_size()
		
	# Isometric Basis Vectors (Standard Iso Down)
	# Moving 1 in Grid X moves (32, 16) in pixels
	# Moving 1 in Grid Y moves (-32, 16) in pixels
	var half_w = tile_size.x * 0.5 # 32
	var half_h = tile_size.y * 0.5 # 16
	
	var basis_x = Vector2(half_w, half_h)
	var basis_y = Vector2(-half_w, half_h)
	
	var w = float(grid_size.x)
	var h = float(grid_size.y)
	
	# Calculate Corners relative to Center (0,0 local)
	# Center of grid (w, h) is at (w/2, h/2)
	# So Top-Left (0,0) is at (-w/2, -h/2)
	
	var top_left_grid = Vector2(-w * 0.5, -h * 0.5)
	
	# Convert grid corners to pixel offsets
	var p_top_left = (basis_x * top_left_grid.x) + (basis_y * top_left_grid.y)
	var p_top_right = (basis_x * (top_left_grid.x + w)) + (basis_y * top_left_grid.y)
	var p_bot_right = (basis_x * (top_left_grid.x + w)) + (basis_y * (top_left_grid.y + h))
	var p_bot_left = (basis_x * top_left_grid.x) + (basis_y * (top_left_grid.y + h))
	
	var rect = Line2D.new()
	# Draw loop: TL -> TR -> BR -> BL -> TL
	rect.points = PackedVector2Array([
		p_top_left,
		p_top_right,
		p_bot_right,
		p_bot_left,
		p_top_left
	])
	
	rect.width = 2.0
	rect.default_color = Color(0.2, 1.0, 0.2, 0.8)
	grid_overlay.add_child(rect)

func _clear_grid_overlay() -> void:
	for child in grid_overlay.get_children(): child.queue_free()


--------------------------------------------------
FILE: res:///scripts/ui/PauseMenu.gd
--------------------------------------------------
# res://scripts/ui/PauseMenu.gd
extends CanvasLayer

# --- Main Menu References ---
@onready var main_container: VBoxContainer = $PanelContainer/MainMenuContainer
@onready var resume_button: Button = $PanelContainer/MainMenuContainer/ResumeButton
@onready var save_button: Button = $PanelContainer/MainMenuContainer/SaveButton
@onready var debug_button: Button = $PanelContainer/MainMenuContainer/DebugButton
@onready var new_game_button: Button = $PanelContainer/MainMenuContainer/NewGameButton
@onready var quit_button: Button = $PanelContainer/MainMenuContainer/QuitButton

# --- Debug Menu References ---
@onready var debug_container: VBoxContainer = $PanelContainer/DebugMenuContainer
@onready var btn_add_gold: Button = $PanelContainer/DebugMenuContainer/Btn_AddGold
@onready var btn_add_renown: Button = $PanelContainer/DebugMenuContainer/Btn_AddRenown
@onready var btn_unlock_legacy: Button = $PanelContainer/DebugMenuContainer/Btn_UnlockLegacy
@onready var btn_trigger_raid: Button = $PanelContainer/DebugMenuContainer/Btn_TriggerRaid
@onready var btn_kill_jarl: Button = $PanelContainer/DebugMenuContainer/Btn_KillJarl
@onready var btn_back: Button = $PanelContainer/DebugMenuContainer/Btn_Back

func _ready() -> void:
	main_container.show()
	if debug_container: debug_container.hide()
	
	resume_button.pressed.connect(_on_resume_pressed)
	save_button.pressed.connect(_on_save_pressed)
	
	if debug_button:
		debug_button.pressed.connect(_on_debug_menu_pressed)
	
	if new_game_button:
		new_game_button.pressed.connect(_on_new_game_pressed)
		
	quit_button.pressed.connect(_on_quit_pressed)
	
	if debug_container:
		btn_add_gold.pressed.connect(_cheat_add_gold)
		btn_add_renown.pressed.connect(_cheat_add_renown)
		btn_unlock_legacy.pressed.connect(_cheat_unlock_legacy)
		btn_trigger_raid.pressed.connect(_cheat_trigger_raid)
		btn_kill_jarl.pressed.connect(_cheat_kill_jarl)
		btn_back.pressed.connect(_on_back_pressed)
	var container = find_child("VBoxContainer", true, false) # Adjust if your layout is named differently
	if container:
		var debug_raid_btn = Button.new()
		debug_raid_btn.text = "DEBUG: Instant Raid"
		debug_raid_btn.name = "Btn_DebugRaid"
		debug_raid_btn.pressed.connect(_on_debug_raid_pressed)
		
		# Add a separator for cleanliness
		container.add_child(HSeparator.new()) 
		container.add_child(debug_raid_btn)

func _unhandled_input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_pause"):
		get_viewport().set_input_as_handled()
		_on_resume_pressed()

func _on_debug_raid_pressed() -> void:
	print("[DEBUG] Launching Instant Raid Sequence...")
	
	# 1. Setup Mock Target Data (Prevent "Null Target" crash)
	var debug_target = RaidTargetData.new()
	debug_target.display_name = "Debug Monastery"
	debug_target.raid_cost_authority = 0
	
	# Load a valid enemy base to prevent "Ghost Wall" bugs
	# Ensure this path matches your project structure
	var base_path = "res://data/settlements/monastery_base.tres"
	if ResourceLoader.exists(base_path):
		debug_target.settlement_data = load(base_path)
	
	DynastyManager.set_current_raid_target(debug_target)
	
	# 2. Setup Mock Army
	# If we have a settlement, send all current warbands.
	# If not (e.g. testing from title screen), create a dummy squad.
	var army: Array[WarbandData] = []
	
	if SettlementManager.has_current_settlement():
		army = SettlementManager.current_settlement.warbands.duplicate()
	
	if army.is_empty():
		# Fallback: Spawn 1 generic raider squad
		var unit_data = load("res://data/units/Unit_PlayerRaider.tres") # Check path!
		if unit_data:
			var wb = WarbandData.new(unit_data)
			wb.custom_name = "Debug Raiders"
			army.append(wb)
	
	DynastyManager.outbound_raid_force = army
	
	# 3. Unpause and Switch Scene
	get_tree().paused = false
	EventBus.scene_change_requested.emit(GameScenes.RAID_MISSION)
	
	# Close the menu
	queue_free()

# --- Navigation ---
func _on_resume_pressed() -> void:
	get_tree().paused = false
	queue_free()

func _on_debug_menu_pressed() -> void:
	main_container.hide()
	debug_container.show()

func _on_back_pressed() -> void:
	debug_container.hide()
	main_container.show()

# --- Standard Actions ---
func _on_save_pressed() -> void:
	if SettlementManager.has_current_settlement():
		SettlementManager.save_settlement()
		Loggie.msg("Game saved from pause menu.").domain("UI").info()

func _on_new_game_pressed() -> void:
	# 1. Wipe old save data
	SettlementManager.delete_save_file()
	
	# 2. Generate new Dynasty & Campaign State
	if is_instance_valid(DynastyManager):
		# --- FIX: Call the new method, not the old one ---
		DynastyManager.start_new_campaign()
		# -------------------------------------------------
		
	# 3. Unpause and go to Settlement view
	get_tree().paused = false
	EventBus.scene_change_requested.emit(GameScenes.SETTLEMENT)
	queue_free()

func _on_quit_pressed() -> void:
	get_tree().quit()

# --- CHEATS ---
func _cheat_add_gold() -> void:
	if SettlementManager.has_current_settlement():
		SettlementManager.deposit_resources({"gold": 1000, "wood": 1000})
		Loggie.msg("CHEAT: Added 1000 Gold/Wood").domain("SYSTEM").warn()

func _cheat_add_renown() -> void:
	if DynastyManager.current_jarl:
		DynastyManager.award_renown(500)
		Loggie.msg("CHEAT: Added 500 Renown").domain("SYSTEM").warn()

func _cheat_unlock_legacy() -> void:
	if not DynastyManager.has_purchased_upgrade("UPG_TRAINING_GROUNDS"):
		DynastyManager.purchase_legacy_upgrade("UPG_TRAINING_GROUNDS")
		Loggie.msg("CHEAT: Training Grounds Unlocked").domain("SYSTEM").warn()
		if DynastyManager.current_jarl:
			DynastyManager.jarl_stats_updated.emit(DynastyManager.current_jarl)

func _cheat_trigger_raid() -> void:
	# 1. Flag as Standard (Offensive) Raid
	DynastyManager.is_defensive_raid = false
	
	# 2. Setup Debug Target
	# We create the wrapper to hold the data nicely...
	var debug_target = RaidTargetData.new()
	debug_target.display_name = "Cheat Target"
	debug_target.raid_cost_authority = 0
	debug_target.difficulty_rating = 1
	
	# Load the default monastery
	var base_path = "res://data/settlements/monastery_base.tres"
	if ResourceLoader.exists(base_path):
		debug_target.settlement_data = load(base_path)
	
	# [FIX] Unwrap the data!
	# DynastyManager expects the inner SettlementData, not the RaidTargetData wrapper.
	if debug_target.settlement_data:
		DynastyManager.set_current_raid_target(debug_target.settlement_data)
		# Manually sync difficulty since we aren't passing the wrapper
		DynastyManager.current_raid_difficulty = debug_target.difficulty_rating
	else:
		print("Error: Could not load 'monastery_base.tres'. Raid aborted.")
		return

	# 3. Ensure Army
	if DynastyManager.outbound_raid_force.is_empty():
		var unit_data = load("res://data/units/Unit_PlayerRaider.tres")
		if unit_data:
			var wb = WarbandData.new(unit_data)
			wb.custom_name = "Cheat Squad"
			DynastyManager.outbound_raid_force.append(wb)

	# 4. Launch
	EventBus.scene_change_requested.emit(GameScenes.RAID_MISSION) # Use constant if available
	get_tree().paused = false
	queue_free()

func _cheat_kill_jarl() -> void:
	Loggie.msg("CHEAT: Assassinating Jarl...").domain("SYSTEM").warn()
	DynastyManager.debug_kill_jarl()
	get_tree().paused = false
	queue_free()


--------------------------------------------------
FILE: res:///scripts/ui/PauseMenu.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bchdch4f1tcym"]

[ext_resource type="Script" uid="uid://b44aq3vstkx50" path="res://scripts/ui/PauseMenu.gd" id="1_ubb4e"]

[node name="PauseMenu" type="CanvasLayer"]
process_mode = 2
script = ExtResource("1_ubb4e")

[node name="PanelContainer" type="PanelContainer" parent="."]
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
grow_horizontal = 2
grow_vertical = 2

[node name="MainMenuContainer" type="VBoxContainer" parent="PanelContainer"]
layout_mode = 2

[node name="ResumeButton" type="Button" parent="PanelContainer/MainMenuContainer"]
layout_mode = 2
text = "Resume"

[node name="SaveButton" type="Button" parent="PanelContainer/MainMenuContainer"]
layout_mode = 2
text = "Save Game"

[node name="NewGameButton" type="Button" parent="PanelContainer/MainMenuContainer"]
modulate = Color(1, 0, 0, 1)
layout_mode = 2
text = "Start New Game (Wipe Save)"

[node name="DebugButton" type="Button" parent="PanelContainer/MainMenuContainer"]
layout_mode = 2
text = "Debugs/Cheats"

[node name="QuitButton" type="Button" parent="PanelContainer/MainMenuContainer"]
layout_mode = 2
text = "Quit Game"

[node name="DebugMenuContainer" type="VBoxContainer" parent="PanelContainer"]
visible = false
layout_mode = 2

[node name="Btn_AddGold" type="Button" parent="PanelContainer/DebugMenuContainer"]
layout_mode = 2
text = "+1000 Gold"

[node name="Btn_AddRenown" type="Button" parent="PanelContainer/DebugMenuContainer"]
layout_mode = 2
text = "+500 Renown"

[node name="Btn_UnlockLegacy" type="Button" parent="PanelContainer/DebugMenuContainer"]
layout_mode = 2
text = "Unlock Training Grounds"

[node name="Btn_TriggerRaid" type="Button" parent="PanelContainer/DebugMenuContainer"]
layout_mode = 2
text = "Trigger Raid"

[node name="Btn_KillJarl" type="Button" parent="PanelContainer/DebugMenuContainer"]
layout_mode = 2
text = "Kill Current Jarl"

[node name="Btn_Back" type="Button" parent="PanelContainer/DebugMenuContainer"]
layout_mode = 2
text = "Back"


--------------------------------------------------
FILE: res:///scripts/units/Base_Unit.gd
--------------------------------------------------
# res://scripts/units/Base_Unit.gd
class_name BaseUnit
extends CharacterBody2D

signal destroyed
signal fsm_ready(unit)

@export var data: UnitData
var unit_identity: String = ""
var warband_ref: WarbandData

var fsm
var current_health: int = 50
var attack_ai: AttackAI = null
var _last_pos: Vector2 = Vector2.ZERO
var _stuck_timer: float = 0.0

@onready var attack_timer: Timer = $AttackTimer
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
@onready var separation_area: Area2D = $SeparationArea

@export_group("AI")
@export var separation_enabled: bool = true
@export var separation_force: float = 30.0
@export var separation_radius: float = 40.0
# --- NEW: Obstacle Avoidance ---
@export var avoidance_enabled: bool = true
@export var avoidance_force: float = 150.0 
@export var whisker_length: float = 40.0

# --- NEW: Hierarchy System ---
# Higher number = "I push you, you don't push me"
@export var avoidance_priority: int = 1
# -------------------------------

#Debug Toggle
@export var debug_avoidance_logs: bool = true
var _debug_log_timer: float = 0.0

# --- NEW: Control Protocol ---
# If true, child classes (SquadSoldier) control velocity directly.
# BaseUnit will skip FSM updates but still apply Separation/Avoidance.
var uses_external_steering: bool = false
var _last_avoid_dir: Vector2 = Vector2.ZERO
# -----------------------------

var _color_tween: Tween
const STATE_COLORS := {
	UnitAIConstants.State.IDLE: Color(0.3, 0.6, 1.0),
	UnitAIConstants.State.MOVING: Color(0.4, 1.0, 0.4),
	UnitAIConstants.State.FORMATION_MOVING: Color(0.4, 1.0, 0.4),
	UnitAIConstants.State.ATTACKING: Color(1.0, 0.3, 0.3)
}
const ERROR_COLOR := Color(0.7, 0.3, 1.0)

const LAYER_ENV = 1
const LAYER_PLAYER_UNIT = 2
const LAYER_ENEMY_UNIT = 4
const LAYER_ENEMY_BLDG = 8

var _is_dying: bool = false

signal inventory_updated(current_load: int, max_load: int)
var inventory: Dictionary = {} 
var current_loot_weight: int = 0

func _ready() -> void:
	if not data:
		push_warning("BaseUnit: Node '%s' is missing 'UnitData'." % name)
		return
	
	var hp_mult = 1.0
	var dmg_mult = 1.0
	
	if is_in_group("player_units"):
	# Add the percentage (e.g., 0.10) to the base multiplier (1.0)
		dmg_mult += DynastyManager.active_year_modifiers.get("mod_unit_damage", 0.0)
	
	if warband_ref:
		var level_mult = warband_ref.get_stat_multiplier()
		hp_mult *= level_mult
		dmg_mult *= level_mult
		
		hp_mult *= warband_ref.get_gear_health_mult()
		dmg_mult *= warband_ref.get_gear_damage_mult()
		
		if warband_ref.assigned_heir_name != "":
			var heir = DynastyManager.find_heir_by_name(warband_ref.assigned_heir_name)
			if heir:
				if heir.prowess > 5:
					var p_bonus = 1.0 + ((heir.prowess - 5) * 0.10)
					dmg_mult *= p_bonus
				modulate = Color(1.2, 1.2, 0.8) 
				
		if unit_identity == "":
			unit_identity = DynastyGenerator.get_random_viking_name()
			
	current_health = int(data.max_health * hp_mult)
	
	_apply_texture_and_scale()
	_setup_collision_logic()
	call_deferred("_deferred_setup", dmg_mult)
	
	sprite.modulate = STATE_COLORS.get(UnitAIConstants.State.IDLE, Color.WHITE)
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)
	
	var area_shape = separation_area.get_node_or_null("CollisionShape2D")
	if area_shape and area_shape.shape is CircleShape2D:
		area_shape.shape.radius = separation_radius

func _setup_collision_logic() -> void:
	var physics_mask = 0
	var separation_mask = 0
	var is_player = (collision_layer & LAYER_PLAYER_UNIT) != 0
	var is_enemy = (collision_layer & LAYER_ENEMY_UNIT) != 0
	
	if is_player:
		physics_mask = LAYER_ENV | LAYER_ENEMY_UNIT | LAYER_ENEMY_BLDG
	elif is_enemy:
		physics_mask = LAYER_ENV | LAYER_PLAYER_UNIT | LAYER_ENEMY_BLDG
	else:
		physics_mask = LAYER_ENV | LAYER_PLAYER_UNIT | LAYER_ENEMY_UNIT | LAYER_ENEMY_BLDG

	self.collision_mask = physics_mask
	separation_mask = LAYER_PLAYER_UNIT | LAYER_ENEMY_UNIT
	
	if separation_area:
		separation_area.collision_mask = separation_mask

func _deferred_setup(damage_mult: float = 1.0) -> void:
	_create_unit_hitbox()
	if data.ai_component_scene:
		attack_ai = data.ai_component_scene.instantiate() as AttackAI
		if attack_ai:
			add_child(attack_ai)
			attack_ai.configure_from_data(data)
			attack_ai.attack_damage = int(attack_ai.attack_damage * damage_mult)
			
			var target_mask = 0
			if self.collision_layer & LAYER_PLAYER_UNIT: 
				target_mask = LAYER_ENEMY_UNIT | LAYER_ENEMY_BLDG
			elif self.collision_layer & LAYER_ENEMY_UNIT: 
				target_mask = LAYER_ENV | LAYER_PLAYER_UNIT
			
			attack_ai.set_target_mask(target_mask)
	else:
		if not is_in_group("civilians"):
			push_error("Config Error: Unit '%s' missing AI." % name)

	fsm = UnitFSM.new(self, attack_ai)
	fsm_ready.emit(self)
	
func _apply_texture_and_scale() -> void:
	if data.target_pixel_size.x <= 0 or data.target_pixel_size.y <= 0: return
	var target_size: Vector2 = data.target_pixel_size

	if data.visual_texture: sprite.texture = data.visual_texture
	
	if sprite.texture:
		var texture_size: Vector2 = sprite.texture.get_size()
		if texture_size.x > 0 and texture_size.y > 0:
			sprite.scale = target_size / texture_size
	
	if collision_shape and collision_shape.shape is RectangleShape2D:
		collision_shape.shape.size = target_size

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	if fsm and fsm.current_state == UnitAIConstants.State.MOVING:
		fsm._recalculate_path()

func _physics_process(delta: float) -> void:
	if not data: return

	var desired_velocity = Vector2.ZERO
	
	# 1. Determine Input Velocity
	if uses_external_steering:
		# Trust that the child class (SquadSoldier) set 'velocity' correctly
		desired_velocity = velocity
	else:
		# Standard FSM Control
		if fsm:
			fsm.update(delta)
			desired_velocity = velocity 
	
	# 2. Context Steering: Add Forces (Shared by ALL units)
	var final_velocity = desired_velocity
	
	if separation_enabled:
		# Calculate separation (prevents stacking)
		final_velocity += calculate_separation_push(delta)
	
	if avoidance_enabled and final_velocity.length_squared() > 10.0:
		# Calculate whiskers (prevents corner stuck)
		final_velocity += _calculate_obstacle_avoidance()
	
	# 3. Inertia & Movement
	if final_velocity.length_squared() > 1.0:
		velocity = velocity.lerp(final_velocity, data.acceleration * delta)
	else:
		velocity = velocity.lerp(Vector2.ZERO, data.linear_damping * delta)
	
	move_and_slide()
	
	# 4. Anti-Stuck Logic
	if not uses_external_steering and fsm and fsm.current_state == UnitAIConstants.State.MOVING:
		_check_stuck_timer(delta)
			
	_last_pos = global_position

func calculate_separation_push(delta: float) -> Vector2:
	var push_vector = Vector2.ZERO
	if not separation_area: return Vector2.ZERO
	
	var neighbors = separation_area.get_overlapping_bodies()
	if neighbors.is_empty(): return Vector2.ZERO
		
	for neighbor in neighbors:
		if neighbor == self: continue
		
		# Only push against units (CharacterBody2D)
		if neighbor is CharacterBody2D:
			var away_vector = global_position - neighbor.global_position
			var distance_sq = away_vector.length_squared()
			if distance_sq < 1.0: distance_sq = 1.0
			
			if distance_sq < separation_radius * separation_radius:
				var current_push_strength = 1.0 - (sqrt(distance_sq) / separation_radius)
				
				# --- ANCESTOR'S LEGACY FIX: Rank Check ---
				if neighbor is BaseUnit:
					# Case A: They are lower rank (Leader vs Soldier)
					# Result: I ignore them (or barely feel them). They will move instead.
					if neighbor.avoidance_priority < self.avoidance_priority:
						current_push_strength *= 0.1 # 90% resistance to being pushed by minions
					
					# Case B: They are higher rank (Soldier vs Leader)
					# Result: I get out of the way FAST.
					elif neighbor.avoidance_priority > self.avoidance_priority:
						current_push_strength *= 2.0 # Double panic to clear the path
				# -----------------------------------------
				
				push_vector += away_vector.normalized() * current_push_strength
	
	return push_vector * separation_force * 2.0

# --- NEW: Whisker Logic ---
func _calculate_obstacle_avoidance() -> Vector2:
	if velocity.length_squared() < 1.0: return Vector2.ZERO
	
	var space_state = get_world_2d().direct_space_state
	var speed_ratio = velocity.length() / max(data.move_speed, 1.0)
	var current_whisker_len = whisker_length * clamp(speed_ratio, 0.2, 1.2)
	
	var angles = [0.0, deg_to_rad(-35), deg_to_rad(35)]
	var hit_count = 0
	var total_escape_dir = Vector2.ZERO
	
	# Debug Data
	var log_hits = []
	
	for angle in angles:
		var dir = velocity.normalized().rotated(angle)
		var query = PhysicsRayQueryParameters2D.create(
			global_position, 
			global_position + (dir * current_whisker_len),
			LAYER_ENV
		)
		var result = space_state.intersect_ray(query)
		
		if result:
			hit_count += 1
			var hit_normal = result.normal
			
			# 1. Calculate Tangents
			var tangent_left = Vector2(-hit_normal.y, hit_normal.x)
			var tangent_right = Vector2(hit_normal.y, -hit_normal.x)
			
			# 2. Score Tangents
			var dot_left = tangent_left.dot(velocity)
			var dot_right = tangent_right.dot(velocity)
			var best_tangent = tangent_left
			
			if dot_right > dot_left:
				best_tangent = tangent_right
			
			# 3. Apply Force with "Anti-Brake" Logic
			var normal_influence = 0.05 # Default: Only 5% pushback, 95% slide
			
			# FIX: If Head-On (Center Ray), use 100% Slide (No Brake)
			if abs(angle) < 0.01: 
				normal_influence = 0.0
			
			var escape_dir = (best_tangent * (1.0 - normal_influence)) + (hit_normal * normal_influence)
			total_escape_dir += escape_dir.normalized()
			
			if debug_avoidance_logs:
				log_hits.append({"angle": rad_to_deg(angle), "normal": hit_normal, "escape": escape_dir})

	var final_steer = Vector2.ZERO
	if hit_count > 0:
		# FIX: Average the direction, don't sum the magnitude!
		# This ensures force remains constant (150) regardless of 1, 2, or 3 hits.
		var avg_dir = total_escape_dir / hit_count
		final_steer = avg_dir.normalized() * avoidance_force

	# --- DEBUG LOGGER ---
	if debug_avoidance_logs and hit_count > 0:
		_debug_log_timer += get_process_delta_time()
		if _debug_log_timer > 0.5:
			_debug_log_timer = 0.0
			print("\n[AVOIDANCE DEBUG] Unit: %s" % name)
			print(" -> Velocity: %s" % velocity)
			print(" -> Hits: %d | Final Steer: %s" % [hit_count, final_steer])
			print("------------------------------------------------")
			
	return final_steer

func _check_stuck_timer(delta: float) -> void:
	var distance_moved = global_position.distance_squared_to(_last_pos)
	if distance_moved < 1.0:
		_stuck_timer += delta
		if _stuck_timer > 1.5:
			_handle_stuck_unit()
	else:
		_stuck_timer = 0.0

func _handle_stuck_unit() -> void:
	if fsm:
		var random_nudge = Vector2(randf_range(-1,1), randf_range(-1,1)) * 10.0
		global_position += random_nudge
		fsm._recalculate_path()
		_stuck_timer = 0.0

func on_state_changed(state: UnitAIConstants.State) -> void:
	var to_color: Color = STATE_COLORS.get(state, Color.WHITE)
	_tween_color(to_color, 0.2)

func flash_error_color() -> void:
	var back_color: Color = STATE_COLORS.get(fsm.current_state, Color.WHITE)
	var t := create_tween()
	t.tween_property(sprite, "modulate", ERROR_COLOR, 0.08).set_trans(Tween.TRANS_SINE)
	t.tween_property(sprite, "modulate", back_color, 0.18).set_trans(Tween.TRANS_SINE)

func _tween_color(to_color: Color, duration: float = 0.2) -> void:
	if _color_tween and _color_tween.is_running(): _color_tween.kill()
	_color_tween = create_tween()
	_color_tween.tween_property(sprite, "modulate", to_color, duration).set_trans(Tween.TRANS_SINE)

func take_damage(amount: int, attacker: Node2D = null) -> void:
	if _is_dying: return
	current_health = max(0, current_health - amount)
	if fsm and is_instance_valid(attacker):
		fsm.command_defensive_attack(attacker)
	if current_health == 0:
		_is_dying = true
		call_deferred("die")

func die() -> void:
	if is_in_group("player_units"):
		EventBus.player_unit_died.emit(self)
	destroyed.emit()
	queue_free()

func command_move_to(target_pos: Vector2) -> void:
	if fsm: fsm.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	if fsm: fsm.command_attack(target)

var is_selected: bool = false
func set_selected(selected: bool) -> void:
	is_selected = selected
	queue_redraw()

func _draw() -> void:
	if is_selected:
		draw_circle(Vector2.ZERO, 25.0, Color(1, 1, 0, 0.8), false, 3.0)

func _create_unit_hitbox() -> void:
	var hitbox_area = Area2D.new()
	hitbox_area.name = "Hitbox"
	
	var layer_value = LAYER_PLAYER_UNIT
	if self.collision_layer & LAYER_ENEMY_UNIT: layer_value = LAYER_ENEMY_UNIT
	
	hitbox_area.collision_layer = layer_value
	hitbox_area.monitorable = true 
	hitbox_area.monitoring = false
	
	var hitbox_shape = CollisionShape2D.new()
	if collision_shape and collision_shape.shape:
		hitbox_shape.shape = collision_shape.shape.duplicate()
	else:
		hitbox_shape.shape = CircleShape2D.new()
		hitbox_shape.shape.radius = 15.0
	
	hitbox_area.add_child(hitbox_shape)
	add_child(hitbox_area)

func command_retreat(target_pos: Vector2) -> void:
	if fsm: fsm.command_retreat(target_pos)

func command_start_working(target_building: BaseBuilding, target_node: ResourceNode) -> void:
	if fsm and fsm.has_method("command_start_cycle"):
		fsm.command_start_cycle(target_building, target_node)

func add_loot(resource_type: String, amount: int) -> int:
	if not data: return 0
	var cap = data.max_loot_capacity if "max_loot_capacity" in data else 0
	var space_left = cap - current_loot_weight
	if space_left <= 0: return 0
	var actual_amount = min(amount, space_left)
	if not inventory.has(resource_type): inventory[resource_type] = 0
	inventory[resource_type] += actual_amount
	current_loot_weight += actual_amount
	inventory_updated.emit(current_loot_weight, cap)
	return actual_amount

func get_speed_multiplier() -> float:
	if not data: return 1.0
	var cap = data.max_loot_capacity if "max_loot_capacity" in data else 0
	if cap <= 0: return 1.0
	var penalty = data.encumbrance_speed_penalty if "encumbrance_speed_penalty" in data else 0.0
	var ratio = float(current_loot_weight) / float(cap)
	return 1.0 - (ratio * penalty)


--------------------------------------------------
FILE: res:///scripts/units/CivilianUnit.gd
--------------------------------------------------
class_name CivilianUnit
extends BaseUnit

# --- Mob Settings ---
@export_group("Mob AI")
@export var mob_separation_force: float = 100.0 
@export var mob_separation_radius: float = 45.0 

@export var thrall_unit_scene: PackedScene 
@export var surrender_hp_threshold: int = 10 # Triggers when HP <= 10

# Signal for the Manager to hear
signal surrender_requested(civilian_node: Node2D)

# --- State ---
var interaction_target: BaseBuilding = null
var skip_assignment_logic: bool = false
var _is_surrendered: bool = false
var escort_target: Node2D = null

func _ready() -> void:
	separation_force = mob_separation_force
	separation_radius = mob_separation_radius
	separation_enabled = true
	super._ready()
	add_to_group("civilians")

func _physics_process(delta: float) -> void:
	if _is_surrendered:
		_process_surrender_behavior(delta)
	else:
		super._physics_process(delta)

# [CRITICAL RESTORATION] Override Take Damage
func take_damage(amount: int, attacker: Node2D = null) -> void:
	if _is_surrendered: return
	
	current_health -= amount
	print("Civilian hit! HP: ", current_health) # Debug Logic
	
	if current_health <= surrender_hp_threshold:
		current_health = 1 # Keep alive for escort
		_trigger_surrender()

func _trigger_surrender() -> void:
	if _is_surrendered: return
	_is_surrendered = true
	
	print("Civilian Surrendered!") # Debug Logic
	
	# Visual Feedback
	modulate = Color(0.5, 0.5, 0.5, 1.0) # Turn Grey
	EventBus.floating_text_requested.emit("Surrendered!", global_position, Color.WHITE)
	
	# Stop Moving
	if fsm: 
		fsm.change_state(UnitAIConstants.State.IDLE)
		velocity = Vector2.ZERO
	
	# Emit Signal for SquadLeader to hear
	surrender_requested.emit(self)

# Logic to follow the soldier
func attach_to_escort(soldier: Node2D) -> void:
	escort_target = soldier
	EventBus.floating_text_requested.emit("Captured", global_position, Color.CYAN)

func _process_surrender_behavior(_delta: float) -> void:
	if is_instance_valid(escort_target):
		var dist = global_position.distance_to(escort_target.global_position)
		if dist > 60.0:
			var dir = (escort_target.global_position - global_position).normalized()
			# Dragged slower than normal speed
			velocity = dir * (data.move_speed * 0.9)
			move_and_slide()
		else:
			velocity = Vector2.ZERO

# ... (Keep existing interaction/assignment functions if you use them for home base) ...
func command_interact(target: Node2D) -> void:
	if target is BaseBuilding:
		interaction_target = target
		if fsm and fsm.has_method("command_interact_move"):
			fsm.command_interact_move(target)


--------------------------------------------------
FILE: res:///scripts/units/EnemyVikingRaider.gd
--------------------------------------------------
# res://scripts/units/EnemyVikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Target position is now set correctly ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set the node (for attacking)
	fsm.target_unit = target
	
	# --- THIS IS THE FIX ---
	# Target the building's actual center.
	# The FSM will find the closest walkable spot.
	fsm.target_position = target.global_position
	# --- END FIX ---
	
	# Start the FSM
	# --- THIS IS THE FINAL FIX ---
	# Updated to use the new constants script
	fsm.change_state(UnitAIConstants.State.MOVING)
	# --- END FIX ---
	Loggie.msg("Viking Raider initialized and moving to target: %s" % target.data.display_name).domain("RTS").info()


--------------------------------------------------
FILE: res:///scripts/units/PlayerVikingRaider.gd
--------------------------------------------------
# res://scripts/units/PlayerVikingRaider.gd
#
# Player-controlled Viking Raider unit.
# This script is now much simpler. It just inherits all the
# complex logic from BaseUnit and the FSM.

extends BaseUnit
class_name PlayerVikingRaider

func _ready() -> void:
	# --- FIX: Add to group BEFORE super._ready() ---
	# BaseUnit._ready() checks this group to apply the Thor damage buff.
	add_to_group("player_units")
	# -----------------------------------------------
	
	# Call parent _ready to initialize base unit systems (Health, AI, FSM)
	super._ready()
	
	Loggie.msg("PlayerVikingRaider '%s' initialized and ready for RTS control" % name).domain("RTS").info()

# We override the command_attack function just to add a print statement,
# then we call super.command_attack(target) to let the Base_Unit and FSM
# handle the *actual* logic correctly.
func command_attack(target: Node2D) -> void:
	if not fsm or not is_instance_valid(target):
		push_warning("Player Raider FSM or target is not valid.")
		return

	Loggie.msg("Player Viking Raider '%s' attacking %s" % [name, target.name]).domain("RTS").info()

	# Pass the command to the base class, which will pass it to the FSM
	super.command_attack(target)

# Override die method to handle player unit death
func die() -> void:
	"""Handle player unit death with proper cleanup"""
	# Remove from player units group
	remove_from_group("player_units")
	
	# Notify other systems about unit death
	EventBus.emit_signal("player_unit_died", self)
	
	Loggie.msg("Player Viking Raider '%s' has fallen in battle!" % name).domain("RTS").info()
	
	# Call parent die method
	super.die()


--------------------------------------------------
FILE: res:///scripts/units/SquadLeader.gd
--------------------------------------------------
# res://scripts/units/SquadLeader.gd
class_name SquadLeader
extends BaseUnit

# --- Internal State ---
var squad_soldiers: Array[SquadSoldier] = []
var formation: SquadFormation
var last_facing_direction: Vector2 = Vector2.DOWN
var attached_thralls: Array[ThrallUnit] = []
# Debug
var debug_formation_points: Array[Vector2] = []

func _ready() -> void:
	super._ready()
	avoidance_priority = 10
	add_to_group("squad_leaders")
	add_to_group("player_units")
	
	formation = SquadFormation.new()
	formation.unit_spacing = 65.0 
	formation.formation_type = SquadFormation.FormationType.BOX
	
	call_deferred("_initialize_squad")

func _initialize_squad() -> void:
	if not warband_ref or not data: return
	
	if squad_soldiers.is_empty():
		_recruit_fresh_squad()
	
	_refresh_formation_registry()

func _recruit_fresh_squad() -> void:
	var soldiers_needed = max(0, warband_ref.current_manpower - 1)
	if soldiers_needed == 0: return
	
	var base_scene = data.load_scene()
	if not base_scene: 
		base_scene = data.scene_to_spawn
	
	if not base_scene: 
		printerr("SquadLeader: Could not load scene for soldier spawn!")
		return
	
	for i in range(soldiers_needed):
		var soldier_instance = base_scene.instantiate()
		
		var soldier_script = load("res://scripts/units/SquadSoldier.gd")
		soldier_instance.set_script(soldier_script)
		
		soldier_instance.data = data
		soldier_instance.warband_ref = warband_ref
		soldier_instance.leader = self
		soldier_instance.position = position 
		
		get_parent().add_child(soldier_instance)
		squad_soldiers.append(soldier_instance)

	_refresh_formation_registry()
	_update_formation_targets(true)

func attach_thrall(thrall: ThrallUnit) -> void:
	if not thrall in attached_thralls:
		attached_thralls.append(thrall)
		thrall.assigned_leader = self
		# Assign a random offset "behind" the leader (assuming Down is default, we adjust dynamically)
		# For simplicity, we assign a random circle offset around the "rear" area
		var angle = randf_range(PI/4, 3*PI/4) # Behind (90 to 270 degrees roughly)
		var dist = randf_range(40.0, 80.0)
		thrall.follow_offset = Vector2(cos(angle), sin(angle)) * dist
		
		# Log it or Juice it
		EventBus.floating_text_requested.emit("Thrall Captured!", thrall.global_position, Color.CYAN)

func _physics_process(delta: float) -> void:
	super._physics_process(delta)
	
	# --- FIX: STABILIZED ROTATION ---
	# Only rotate if we are actively trying to move (via FSM)
	# AND moving fast enough to have a clear direction.
	var is_voluntarily_moving = false
	if fsm:
		is_voluntarily_moving = fsm.current_state == UnitAIConstants.State.MOVING or \
								fsm.current_state == UnitAIConstants.State.FORMATION_MOVING
	
	# Increase threshold to 50.0 (approx 7 pixels/sec) to ignore micro-jitters
	if is_voluntarily_moving and velocity.length_squared() > 50.0:
		last_facing_direction = velocity.normalized()
	# --------------------------------
	
	_update_formation_targets()
	queue_redraw()

func _update_formation_targets(snap_to_position: bool = false) -> void:
	if squad_soldiers.is_empty(): return
	var slots = formation._calculate_formation_positions(global_position, last_facing_direction)
	debug_formation_points = slots
	
	for i in range(min(squad_soldiers.size(), slots.size() - 1)):
		var soldier = squad_soldiers[i]
		if is_instance_valid(soldier):
			var target = slots[i+1]
			soldier.formation_target = target
			if snap_to_position:
				soldier.global_position = target
				soldier.velocity = Vector2.ZERO

func _draw() -> void:
	if is_selected:
		for i in range(debug_formation_points.size()):
			var point = to_local(debug_formation_points[i])
			if i == 0:
				draw_circle(point, 5.0, Color.GREEN)
			else:
				draw_circle(point, 3.0, Color.CYAN)
				draw_line(Vector2.ZERO, point, Color(0, 1, 1, 0.2), 1.0)

func remove_soldier(soldier: SquadSoldier) -> void:
	if soldier in squad_soldiers:
		squad_soldiers.erase(soldier)
		_refresh_formation_registry()

func absorb_existing_soldiers(list: Array[SquadSoldier]) -> void:
	squad_soldiers = list
	for s in squad_soldiers:
		s.leader = self
	_refresh_formation_registry()

func _refresh_formation_registry() -> void:
	formation.units.clear()
	formation.add_unit(self)
	for s in squad_soldiers:
		formation.add_unit(s)

func set_selected(val: bool) -> void:
	super.set_selected(val)
	for s in squad_soldiers:
		if is_instance_valid(s):
			s.set_selected(val)

func die() -> void:
	if warband_ref and warband_ref.assigned_heir_name != "":
		DynastyManager.kill_heir_by_name(warband_ref.assigned_heir_name, "Killed in battle")
		warband_ref.assigned_heir_name = "" 
	
	var living_soldiers: Array[SquadSoldier] = []
	for s in squad_soldiers:
		if is_instance_valid(s) and s.current_health > 0:
			living_soldiers.append(s)
			
	if not living_soldiers.is_empty():
		var new_leader_host = living_soldiers.pop_front()
		
		var new_leader = duplicate()
		new_leader.set_script(load("res://scripts/units/SquadLeader.gd"))
		new_leader.position = new_leader_host.position
		new_leader.current_health = new_leader_host.current_health
		new_leader.warband_ref = warband_ref
		
		get_parent().add_child(new_leader)
		new_leader.absorb_existing_soldiers(living_soldiers)
		
		# --- FIX: Notify RTS Controller of Promotion ---
		EventBus.player_unit_spawned.emit(new_leader)
		# -----------------------------------------------
		
		new_leader_host.queue_free()
	else:
		if warband_ref:
			EventBus.player_unit_died.emit(self)
	
	super.die()

func on_state_changed(new_state: int) -> void:
	super.on_state_changed(new_state)
	
	if new_state == UnitAIConstants.State.ATTACKING:
		print("DEBUG LEADER: I am attacking! Ordering %d soldiers to charge." % squad_soldiers.size())
		_order_squad_attack()
	elif new_state == UnitAIConstants.State.IDLE or new_state == UnitAIConstants.State.MOVING:
		_order_squad_regroup()

func _order_squad_attack() -> void:
	if not fsm or not is_instance_valid(fsm.current_target): 
		print("DEBUG LEADER: Cannot order attack - No target in FSM.")
		return
	
	var target = fsm.current_target
	print("DEBUG LEADER: Ordering charge against %s" % target.name)
	
	for soldier in squad_soldiers:
		if is_instance_valid(soldier):
			if soldier.attack_ai:
				soldier.attack_ai.force_target(target)
			else:
				push_error("DEBUG LEADER: Soldier %s has no AttackAI!" % soldier.name)

func _order_squad_regroup() -> void:
	for soldier in squad_soldiers:
		if is_instance_valid(soldier) and soldier.attack_ai:
			# Clear the forced target so they return to formation
			soldier.attack_ai.stop_attacking()

func request_escort_for(civilian: Node2D) -> void:
	print("SquadLeader: Received request to escort %s" % civilian.name)
	
	var best_candidate: SquadSoldier = null
	var min_dist = INF
	
	# Tuning Params
	var max_batch_dist = 300.0
	var max_prisoners = 3
	
	# Priority 1: Batching (Find someone already working)
	for soldier in squad_soldiers:
		if not is_instance_valid(soldier) or not soldier.is_inside_tree(): continue
		
		# Check state string/enum based on your setup
		if soldier.fsm.current_state in [UnitAIConstants.State.COLLECTING, UnitAIConstants.State.ESCORTING]:
			var total_load = soldier.escorted_prisoners.size() + soldier.pending_prisoners.size()
			if total_load < max_prisoners:
				var dist = soldier.global_position.distance_to(civilian.global_position)
				if dist < max_batch_dist:
					best_candidate = soldier
					print("SquadLeader: Found BATCH candidate (Dist: %s)" % dist)
					break 
	
	# Priority 2: New Volunteer (Pull from combat)
	if not best_candidate:
		var closest_combatant = null
		var closest_d = INF
		
		for soldier in squad_soldiers:
			if not is_instance_valid(soldier): continue
			
			# Check logic: Are they busy?
			# We accept IDLE, ATTACKING, MOVING (Formation)
			# We DO NOT accept RETREATING or dead units
			var state = soldier.fsm.current_state
			if state in [UnitAIConstants.State.IDLE, UnitAIConstants.State.ATTACKING, UnitAIConstants.State.MOVING, UnitAIConstants.State.FORMATION_MOVING]:
				var dist = soldier.global_position.distance_to(civilian.global_position)
				print("SquadLeader: Candidate %s is valid (Dist: %s)" % [soldier.name, dist])
				if dist < closest_d:
					closest_d = dist
					closest_combatant = soldier
			else:
				print("SquadLeader: Candidate %s REJECTED (State: %s)" % [soldier.name, state])
		
		best_candidate = closest_combatant

	if best_candidate:
		print("SquadLeader: Assigning task to %s" % best_candidate.name)
		best_candidate.assign_escort_task(civilian)
	else:
		print("SquadLeader: FAILED to find any candidate! Squad size: %d" % squad_soldiers.size())


--------------------------------------------------
FILE: res:///scripts/units/SquadSoldier.gd
--------------------------------------------------
# res://scripts/units/SquadSoldier.gd
class_name SquadSoldier
extends BaseUnit

var leader: SquadLeader
var formation_target: Vector2 = Vector2.ZERO
var brawl_target: Node2D = null
var is_rubber_banding: bool = false
var stuck_detector: Node

const MAX_DIST_FROM_LEADER = 300.0
const CATCHUP_DIST = 80.0
const SPRINT_SPEED_MULT = 2.5

var pending_prisoners: Array[Node2D] = [] 
var escorted_prisoners: Array[Node2D] = []
var retreat_zone_cache: Node2D = null

func _ready() -> void:
	separation_force = 80.0 
	separation_radius = 25.0
	separation_enabled = true
	avoidance_priority = 1
	super._ready()

	if attack_ai:
		attack_ai.attack_started.connect(func(t): if not is_rubber_banding: brawl_target = t)
		attack_ai.attack_stopped.connect(func(): brawl_target = null)
		if attack_ai.detection_area:
			for c in attack_ai.detection_area.get_children():
				if c is CollisionShape2D and c.shape is CircleShape2D: c.shape.radius = 120.0

	stuck_detector = get_node_or_null("StuckDetector")
	
	# If you injected it via code in the previous step, find it by that name:
	if not stuck_detector:
		stuck_detector = get_node_or_null("DEBUG_StuckReporter") # Or "StuckDetector" depending on your setup
		
	super._ready()
	
func _physics_process(delta: float) -> void:
	# 1. FSM High Priority (Tasks like Collecting/Escorting take precedence)
	# (We keep the super call here because these states rely on standard NavAgent logic)
	if fsm.current_state in [UnitAIConstants.State.COLLECTING, UnitAIConstants.State.ESCORTING, UnitAIConstants.State.REGROUPING, UnitAIConstants.State.RETREATING]:
		uses_external_steering = false 
		super._physics_process(delta)
		return

	# 2. Safety
	if not is_instance_valid(leader):
		velocity = Vector2.ZERO
		return
		
	# 3. Take Control
	uses_external_steering = true
	
	# 4. Rubber Banding Logic
	var speed = data.move_speed
	var dist_leader = global_position.distance_to(leader.global_position)
	
	var is_phasing = false
	if stuck_detector and "is_phasing" in stuck_detector:
		is_phasing = stuck_detector.is_phasing
	
	# Only update Rubber Band state if we are NOT currently phasing through a wall.
	# If we are phasing, we want to keep the Mask at 0 (set by the detector).
	if not is_phasing:
		if not is_rubber_banding and dist_leader > MAX_DIST_FROM_LEADER:
			is_rubber_banding = true
			collision_mask = 1 
			modulate.a = 0.5
			separation_enabled = false 
		elif is_rubber_banding and dist_leader < CATCHUP_DIST:
			is_rubber_banding = false
			_setup_collision_logic()
			modulate.a = 1.0
			separation_enabled = true
		
	if is_rubber_banding:
		brawl_target = null
		speed *= SPRINT_SPEED_MULT
	
	# 5. Determine Target
	var final_dest = formation_target
	var stop_dist = 15.0
	
	if is_instance_valid(brawl_target) and not is_rubber_banding:
		final_dest = brawl_target.global_position
		# Smart Stop Distance logic...
		var range_limit = data.attack_range
		if brawl_target is BaseBuilding or (brawl_target.name == "Hitbox" and brawl_target.get_parent() is BaseBuilding):
			range_limit = data.building_attack_range
		var r_target = _get_radius(brawl_target)
		stop_dist = r_target + range_limit - 5.0
		if stop_dist < 5.0: stop_dist = 5.0
		if attack_ai: attack_ai.force_target(brawl_target)
	
	# 6. Apply Steering (Formation Attraction)
	if final_dest != Vector2.ZERO:
		var dist = global_position.distance_to(final_dest)
		
		if dist > stop_dist:
			# Calculate desired velocity
			var desired_velocity = (final_dest - global_position).normalized() * speed
			
			# Apply simple steering to smooth it out
			velocity = velocity.lerp(desired_velocity, 10.0 * delta)
		else:
			# Damping when arrived
			velocity = velocity.lerp(Vector2.ZERO, 10.0 * delta)
			
	# --- THE FIX ---
	# We DO NOT call super._physics_process(delta) here anymore.
	# The parent likely requires a NavPath to move, which we don't have.
	# We manually apply separation and move.
	
	if separation_enabled:
		velocity += calculate_separation_push(delta)
	
	move_and_slide()
	# ---------------

# ... (Keep the rest of the file: _get_radius, assign_escort_task, etc.) ...
func _get_radius(node: Node2D) -> float:
	if node.name == "Hitbox" and node.get_parent() is BaseBuilding:
		var b = node.get_parent()
		if b.data: return (min(b.data.grid_size.x, b.data.grid_size.y) * 32.0) / 2.0
	return 15.0

func assign_escort_task(prisoner: Node2D) -> void:
	if not is_inside_tree() or not prisoner: return
	if not retreat_zone_cache: retreat_zone_cache = get_tree().get_first_node_in_group("retreat_zone")
	
	if not prisoner in pending_prisoners and not prisoner in escorted_prisoners:
		pending_prisoners.append(prisoner)
	
	if fsm:
		fsm.objective_target = prisoner
		fsm.change_state(UnitAIConstants.State.COLLECTING)

func _set_next_collection_target() -> void:
	if pending_prisoners.size() > 0:
		var next = pending_prisoners[0]
		fsm.objective_target = next
		fsm.change_state(UnitAIConstants.State.COLLECTING)
		EventBus.floating_text_requested.emit("Got it!", global_position, Color.WHITE)
	else:
		_switch_to_escorting()

func process_collecting_logic(_delta: float) -> void:
	if not is_instance_valid(fsm.objective_target):
		pending_prisoners.erase(fsm.objective_target)
		_set_next_collection_target()
		return

	var dist = global_position.distance_to(fsm.objective_target.global_position)
	if dist < 50.0:
		_collect_prisoner(fsm.objective_target)

func _collect_prisoner(prisoner: Node2D) -> void:
	pending_prisoners.erase(prisoner)
	if not prisoner in escorted_prisoners:
		escorted_prisoners.append(prisoner)
		if prisoner.has_method("attach_to_escort"):
			prisoner.attach_to_escort(self)
	
	if pending_prisoners.size() > 0:
		_set_next_collection_target()
	else:
		_switch_to_escorting()

func _switch_to_escorting() -> void:
	if escorted_prisoners.is_empty():
		fsm.change_state(UnitAIConstants.State.REGROUPING)
		return
	fsm.objective_target = retreat_zone_cache
	fsm.change_state(UnitAIConstants.State.ESCORTING)

func process_escort_logic(_delta: float) -> void:
	pass
	
func complete_escort() -> void:
	if escorted_prisoners.is_empty():
		fsm.change_state(UnitAIConstants.State.REGROUPING)
		return

	var count = 0
	for prisoner in escorted_prisoners:
		if is_instance_valid(prisoner):
			EventBus.raid_loot_secured.emit("thrall", 1) 
			EventBus.floating_text_requested.emit("+1 Thrall", prisoner.global_position, Color.CYAN)
			prisoner.queue_free()
			count += 1
	
	escorted_prisoners.clear()
	EventBus.floating_text_requested.emit("Prisoners Secured", global_position, Color.GREEN)
	fsm.change_state(UnitAIConstants.State.REGROUPING)

func process_regroup_logic(_delta: float) -> void:
	if is_instance_valid(leader):
		fsm.move_command_position = leader.global_position
		if global_position.distance_to(leader.global_position) < 100.0:
			fsm.change_state(UnitAIConstants.State.MOVING)
	else:
		fsm.change_state(UnitAIConstants.State.IDLE)


--------------------------------------------------
FILE: res:///scripts/units/ThrallUnit.gd
--------------------------------------------------
class_name ThrallUnit
extends BaseUnit

var assigned_leader: Node2D = null
var follow_offset: Vector2 = Vector2.ZERO

func _ready() -> void:
	super._ready()
	# Thralls are slow but carry a lot (defined in their UnitData usually)
	# For now, we ensure they don't fight back
	if fsm:
		fsm.change_state(UnitAIConstants.State.IDLE)

func _physics_process(delta: float) -> void:
	# Passive Logic: Baggage Train Movement
	# If we have a leader, we drift towards our assigned slot behind them
	if is_instance_valid(assigned_leader):
		_process_baggage_movement(delta)
	else:
		super._physics_process(delta)

func _process_baggage_movement(delta: float) -> void:
	# Calculate where we should be relative to the leader
	# We use the leader's global position + our random offset, rotated by leader's facing
	# Note: Leader facing isn't explicitly stored, so we use velocity or last_facing
	var target_pos = assigned_leader.global_position + follow_offset
	
	var dist = global_position.distance_to(target_pos)
	if dist > 10.0:
		var dir = (target_pos - global_position).normalized()
		# Thralls match leader speed roughly, but rubber band if far behind
		var move_speed = data.move_speed
		if dist > 200.0: move_speed *= 1.5 # Catch up sprint
		
		velocity = dir * move_speed
		move_and_slide()


--------------------------------------------------
FILE: res:///scripts/utility/GridUtils.gd
--------------------------------------------------
class_name GridUtils
extends RefCounted

# --- CONSTANTS ---
# The Holy Standards of Viking Dynasty
const TILE_WIDTH: int = 64
const TILE_HEIGHT: int = 32
const TILE_SIZE := Vector2(TILE_WIDTH, TILE_HEIGHT)
const TILE_HALF := Vector2(TILE_WIDTH * 0.5, TILE_HEIGHT * 0.5)

# --- ISOMETRIC PROJECTION MATH ---

## Converts Logical Grid Coords (Vector2i) -> World Position (Vector2).
## Returns the CENTER of the tile floor.
static func grid_to_iso(grid_pos: Vector2i) -> Vector2:
	# Standard Isometric Matrix for 2:1 Tiles
	# x = (row - col) * half_width
	# y = (row + col) * half_height
	var x = (grid_pos.x - grid_pos.y) * TILE_HALF.x
	var y = (grid_pos.x + grid_pos.y) * TILE_HALF.y
	return Vector2(x, y)

## Converts World Position (Vector2) -> Logical Grid Coords (Vector2i).
## Useful for mouse picking the terrain floor.
static func iso_to_grid(world_pos: Vector2) -> Vector2i:
	# Inverted Matrix
	var x = (world_pos.x / TILE_HALF.x + world_pos.y / TILE_HALF.y) * 0.5
	var y = (world_pos.y / TILE_HALF.y - world_pos.x / TILE_HALF.x) * 0.5
	return Vector2i(floor(x), floor(y))

## Snaps a world position to the exact center of its isometric tile.
static func snap_to_grid(world_pos: Vector2) -> Vector2:
	var grid_pos = iso_to_grid(world_pos)
	return grid_to_iso(grid_pos)

# --- VISUAL HELPERS ---

## Calculates the visual center offset for multi-tile buildings.
## A 2x2 building's sprite center is NOT the anchor tile center.
## It is the center of the union of the 4 tiles.
static func get_center_offset(grid_size: Vector2i) -> Vector2:
	# Formula: (SizeX - SizeY) * HalfWidth, (SizeX + SizeY) * HalfHeight
	# However, we usually want the offset relative to the Anchor Tile (0,0)
	
	# If we assume the sprite pivot is Bottom-Center of the Anchor Tile:
	# We want to move it to the visual center of the footprint.
	
	# For a 1x1: Offset is 0,0
	# For a 2x2: We need to move "down" the screen
	
	# Refined Formula for Pivot correction:
	var offset_x = (grid_size.x - 1.0 - (grid_size.y - 1.0)) * TILE_HALF.x * 0.5
	var offset_y = (grid_size.x - 1.0 + (grid_size.y - 1.0)) * TILE_HALF.y * 0.5
	
	return Vector2(offset_x, offset_y)

# --- EXISTING UTILITIES (Preserved & Typed) ---

static func is_within_bounds(grid: AStarGrid2D, cell: Vector2i) -> bool:
	if not grid: return false
	return grid.region.has_point(cell)

static func is_area_clear(grid: AStarGrid2D, top_left_pos: Vector2i, size: Vector2i) -> bool:
	if not grid: return false
	
	for x in range(size.x):
		for y in range(size.y):
			var cell = top_left_pos + Vector2i(x, y)
			if not is_within_bounds(grid, cell): return false
			if grid.is_point_solid(cell): return false
				
	return true

static func calculate_territory(placed_buildings: Array, grid_region: Rect2i) -> Dictionary:
	var buildable_map: Dictionary = {}
	
	for entry in placed_buildings:
		var path = entry.get("resource_path", "")
		if path == "": continue
		
		var data = load(path) as BuildingData
		if not data: continue
		
		if data.is_territory_hub or data.extends_territory:
			var raw_pos = entry["grid_position"]
			var center = Vector2i(raw_pos.x, raw_pos.y)
			var r = data.territory_radius
			var r_sq = r * r
			
			for x in range(center.x - r, center.x + r + 1):
				for y in range(center.y - r, center.y + r + 1):
					var cell = Vector2i(x, y)
					if not grid_region.has_point(cell): continue
					
					# Distance check (Euclidean distance on logical grid is acceptable for radius)
					if Vector2(cell).distance_squared_to(Vector2(center)) <= r_sq:
						buildable_map[cell] = true

	return buildable_map


--------------------------------------------------
FILE: res:///scripts/utility/GridVisualizer.gd
--------------------------------------------------
#res://scripts/utility/GridVisualizer.gd
@tool
class_name GridVisualizer
extends Node2D

# --- Editor Settings ---
@export_group("Grid Settings")
@export var show_grid: bool = true:
	set(value):
		show_grid = value
		queue_redraw()

@export var debug_show_solids: bool = false: # DISABLED BY DEFAULT
	set(value):
		debug_show_solids = value
		queue_redraw()

@export var grid_size: Vector2i = Vector2i(60, 40):
	set(value):
		grid_size = value
		queue_redraw()

@export var tile_dimensions: Vector2i = Vector2i(64, 32):
	set(value):
		tile_dimensions = value
		_precalculate_iso_offsets() 
		queue_redraw()

@export_tool_button("Force Redraw") var force_redraw_action = _on_force_redraw

# --- Visual Settings ---
const GRID_COLOR := Color(1.0, 1.0, 1.0, 0.1) 
const BORDER_COLOR := Color(1.0, 0.6, 0.0, 0.8) 
const SOLID_COLOR := Color(1.0, 0.0, 0.0, 0.3)

# Store pre-calculated polygon offsets to avoid math in loops
var _iso_offsets: PackedVector2Array = []

func _ready() -> void:
	_precalculate_iso_offsets()
	
	if not Engine.is_editor_hint():
		# Connect signal to only redraw grid when the map actually changes
		EventBus.pathfinding_grid_updated.connect(queue_redraw.unbind(1))
		
		# Attach the dynamic drawer as a child
		if ResourceLoader.exists("res://scripts/utility/UnitPathDrawer.gd"):
			var path_drawer = load("res://scripts/utility/UnitPathDrawer.gd").new() 
			if path_drawer:
				add_child(path_drawer)
		else:
			printerr("GridVisualizer: Could not find UnitPathDrawer.gd!")
			
	queue_redraw()

func _on_force_redraw() -> void:
	_precalculate_iso_offsets()
	queue_redraw()

func _precalculate_iso_offsets() -> void:
	var half = Vector2(tile_dimensions) * 0.5
	_iso_offsets = PackedVector2Array([
		Vector2(0, -half.y), # Top
		Vector2(half.x, 0),  # Right
		Vector2(0, half.y),  # Bottom
		Vector2(-half.x, 0)  # Left
	])

func _draw() -> void:
	# 1. Draw Grid Lines (Editor & Runtime)
	if show_grid:
		_draw_map_border()
		_draw_optimized_grid()

	# 2. Draw Solids (Runtime Only)
	if not debug_show_solids:
		return

	if Engine.is_editor_hint() or not NavigationManager.active_astar_grid: 
		return

	# Optimization: Only draw nearby cells to save FPS
	var cam = get_viewport().get_camera_2d()
	if cam:
		if not NavigationManager.has_method("_world_to_grid"): return
		
		var center = NavigationManager._world_to_grid(cam.get_screen_center_position())
		var range_val = 20 
		
		var grid = NavigationManager.active_astar_grid
		var region = grid.region
		
		for x in range(center.x - range_val, center.x + range_val):
			for y in range(center.y - range_val, center.y + range_val):
				var cell = Vector2i(x, y)
				if not region.has_point(cell): continue
				
				if grid.is_point_solid(cell):
					_draw_iso_poly_optimized(cell, SOLID_COLOR, true)

func _draw_iso_poly_optimized(grid_pos: Vector2i, color: Color, fill: bool) -> void:
	if not NavigationManager.has_method("_grid_to_world"): return
	
	var center = NavigationManager._grid_to_world(grid_pos)
	
	# FIX: Apply Isometric Vertical Offset
	# NavigationManager returns the Grid Intersection (Top Corner).
	# We need to shift down by Half-Height to reach the Tile Center.
	center.y += tile_dimensions.y * 0.5
	
	var points = _iso_offsets.duplicate()
	
	# Shift points to the correct world position
	for i in range(points.size()):
		points[i] += center
	
	if fill:
		draw_polygon(points, [color])
	else:
		points.append(points[0]) # Close the loop
		draw_polyline(points, color, 1.0)

# ... Border and Grid Logic ...
func _draw_map_border() -> void:
	# (Keeping your existing border logic logic)
	if not ClassDB.class_exists("GridUtils") and not get_tree().root.has_node("GridUtils"):
		return 

	pass 

func _draw_optimized_grid() -> void:
	var col = GRID_COLOR
	var half_w = tile_dimensions.x * 0.5
	var half_h = tile_dimensions.y * 0.5
	
	# Helper for iso conversion inside loop
	var grid_to_iso = func(g: Vector2i) -> Vector2:
		return Vector2((g.x - g.y) * half_w, (g.x + g.y) * half_h)

	for x in range(grid_size.x + 1):
		var start = grid_to_iso.call(Vector2i(x, 0))
		var end = grid_to_iso.call(Vector2i(x, grid_size.y))
		draw_line(start, end, col, 1.0)
	for y in range(grid_size.y + 1):
		var start = grid_to_iso.call(Vector2i(0, y))
		var end = grid_to_iso.call(Vector2i(grid_size.x, y))
		draw_line(start, end, col, 1.0)


--------------------------------------------------
FILE: res:///scripts/utility/GridVisualizer.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://ptujtdi5jtsk"]

[ext_resource type="Script" uid="uid://2iyfg3te1n3y" path="res://scripts/utility/GridVisualizer.gd" id="1_4xql8"]
[ext_resource type="Script" uid="uid://bjfe6p2f6m3kq" path="res://scripts/utility/UnitPathDrawer.gd" id="2_ctnk8"]

[node name="GridVisualizer" type="Node2D"]
script = ExtResource("1_4xql8")

[node name="UnitPathDrawer" type="Node2D" parent="."]
script = ExtResource("2_ctnk8")


--------------------------------------------------
FILE: res:///scripts/utility/IsoPlaceholder.gd
--------------------------------------------------
@tool
class_name IsoPlaceholder
extends Node2D

# --- Configuration ---
@export var data: BuildingData:
	set(value):
		data = value
		queue_redraw()

@export var color: Color = Color.CORNFLOWER_BLUE:
	set(value):
		color = value
		queue_redraw()

@export var height: float = 64.0:
	set(value):
		height = value
		queue_redraw()

# --- Constants (Must match SettlementManager) ---
const TILE_WIDTH = 64
const TILE_HEIGHT = 32

func _ready() -> void:
	# Auto-grab data if attached to a BaseBuilding that has it
	if not data and get_parent().get("data"):
		data = get_parent().data

func _draw() -> void:
	if not data:
		# Draw a default 1x1 diamond if no data exists
		_draw_iso_box(Vector2i(1, 1), Color.GRAY)
		return
		
	_draw_iso_box(data.grid_size, color)

func _draw_iso_box(size: Vector2i, base_color: Color) -> void:
	# 1. Calculate Dimensions
	# In Isometric, the "Width" of the visual sprite is based on grid columns
	var half_w = TILE_WIDTH * 0.5
	var half_h = TILE_HEIGHT * 0.5
	
	# Because our system centers the node on the "Footprint Center", 
	# we calculate offsets from (0,0).
	
	# Total pixel dimensions of the footprint
	var total_w = (size.x + size.y) * half_w
	var total_h = (size.x + size.y) * half_h
	
	# 2. Define the 4 Corners of the Base (Footprint) relative to Center
	# Top Tip
	var p_top = Vector2(0, -total_h * 0.5) 
	# Right Tip
	var p_right = Vector2(total_w * 0.5, 0)
	# Bottom Tip
	var p_bottom = Vector2(0, total_h * 0.5)
	# Left Tip
	var p_left = Vector2(-total_w * 0.5, 0)
	
	# Note: The math above assumes a perfectly square bounding box. 
	# For strict Grid sizing (e.g. 2x1 buildings), we use the projection logic:
	
	# Let's do it strictly by vector addition to support non-square buildings (e.g. 3x1 walls)
	# Vector X moves (32, 16). Vector Y moves (-32, 16).
	var vec_x = Vector2(half_w, half_h) # Down-Right
	var vec_y = Vector2(-half_w, half_h) # Down-Left
	
	# Start at Top Tip (which is offset by half the total size to center it)
	var top_origin = -((vec_x * size.x) + (vec_y * size.y)) * 0.5
	
	var c_top = top_origin
	var c_right = top_origin + (vec_x * size.x)
	var c_bottom = top_origin + (vec_x * size.x) + (vec_y * size.y)
	var c_left = top_origin + (vec_y * size.y)
	
	# 3. Define the Roof (Base shifted up by height)
	var roof_offset = Vector2(0, -height)
	var r_top = c_top + roof_offset
	var r_right = c_right + roof_offset
	var r_bottom = c_bottom + roof_offset
	var r_left = c_left + roof_offset
	
	# --- DRAWING ---
	
	# A. Left Wall (Darkest)
	var wall_left_pts = PackedVector2Array([c_left, c_bottom, r_bottom, r_left])
	draw_colored_polygon(wall_left_pts, base_color.darkened(0.4))
	draw_polyline(wall_left_pts, Color.BLACK, 2.0)
	
	# B. Right Wall (Medium)
	var wall_right_pts = PackedVector2Array([c_bottom, c_right, r_right, r_bottom])
	draw_colored_polygon(wall_right_pts, base_color.darkened(0.2))
	draw_polyline(wall_right_pts, Color.BLACK, 2.0)
	
	# C. Roof (Lightest)
	var roof_pts = PackedVector2Array([r_left, r_bottom, r_right, r_top])
	draw_colored_polygon(roof_pts, base_color)
	draw_polyline(roof_pts, Color.BLACK, 2.0)
	
	# D. Footprint Outline (Optional - shows grid alignment)
	var base_pts = PackedVector2Array([c_top, c_right, c_bottom, c_left, c_top])
	draw_polyline(base_pts, Color.WHITE.darkened(0.5), 1.0)


--------------------------------------------------
FILE: res:///scripts/utility/LevelBase.gd
--------------------------------------------------
# res://scripts/levels/LevelBase.gd
class_name LevelBase
extends Node2D

# This function handles the "delicate dance" of initializing the grid
# so your actual level scripts don't have to worry about timing.
func setup_level_navigation(tilemap_layer: TileMapLayer, width: int, height: int) -> void:
	# 1. Wait for Godot to catch up visually/physically
	await get_tree().process_frame
	
	# 2. Initialize the Navigation Manager
	Loggie.msg("Initializing Navigation Grid for Level...").domain("SYSTEM").info()
	
	NavigationManager.initialize_grid_from_tilemap(
		tilemap_layer,
		Vector2i(width, height),
		Vector2i(64, 32) # Your standard tile size
	)
	
	Loggie.msg("Navigation Ready.").domain("SYSTEM").info()


--------------------------------------------------
FILE: res:///scripts/utility/RTSInputHandler.gd
--------------------------------------------------
# res://scripts/input/RTSInputHandler.gd
class_name RTSInputHandler
extends Node

# We can toggle this if we open a menu and want to stop RTS hotkeys
var input_enabled: bool = true

func _ready() -> void:
	# Listen for UI blocking requests (e.g. opening the Dynasty Tree)
	EventBus.camera_input_lock_requested.connect(func(locked): input_enabled = !locked)

func _unhandled_input(event: InputEvent) -> void:
	if not input_enabled: return
	
	if event is InputEventKey and event.is_pressed():
		_handle_control_groups(event)
		_handle_formations(event)

func _handle_control_groups(event: InputEventKey) -> void:
	# Keys 0-9
	if event.keycode >= KEY_0 and event.keycode <= KEY_9:
		var group_index = event.keycode - KEY_0
		
		# CTRL+Number = Assign, Number = Select
		# We emit the intent, we don't do the logic here.
		EventBus.control_group_command.emit(group_index, event.ctrl_pressed)
		get_viewport().set_input_as_handled()

func _handle_formations(event: InputEventKey) -> void:
	# Map Keys to SquadFormation.FormationType Integers
	# LINE=0, COLUMN=1, WEDGE=2, BOX=3, CIRCLE=4
	match event.keycode:
		KEY_F1: 
			EventBus.formation_change_command.emit(0) # LINE
			get_viewport().set_input_as_handled()
		KEY_F2:
			EventBus.formation_change_command.emit(1) # COLUMN
			get_viewport().set_input_as_handled()
		KEY_F3:
			EventBus.formation_change_command.emit(2) # WEDGE
			get_viewport().set_input_as_handled()
		KEY_F4:
			EventBus.formation_change_command.emit(3) # BOX
			get_viewport().set_input_as_handled()
		KEY_F5:
			EventBus.formation_change_command.emit(4) # CIRCLE
			get_viewport().set_input_as_handled()


--------------------------------------------------
FILE: res:///scripts/utility/UnitPathDrawer.gd
--------------------------------------------------
class_name UnitPathDrawer
extends Node2D

# Opt #1: Cache unit references to avoid get_nodes_in_group every frame
var _cached_units: Array[Node] = []
var _cache_timer: float = 0.0

func _ready() -> void:
	# Ensure this doesn't run in editor to save resources
	if Engine.is_editor_hint():
		set_process(false)
		return
	
	_refresh_unit_cache()
	
	# Optional: If you have a signal for units spawning/dying, connect it here
	# EventBus.unit_list_changed.connect(_refresh_unit_cache)

func _process(delta: float) -> void:
	# Periodically refresh cache (every 1 second) if no signals are available
	_cache_timer += delta
	if _cache_timer > 1.0:
		_refresh_unit_cache()
		_cache_timer = 0.0
		
	queue_redraw()

func _refresh_unit_cache() -> void:
	_cached_units = get_tree().get_nodes_in_group("player_units")

func _draw() -> void:
	# Opt #1: Iterate over cached array instead of SceneTree
	for unit in _cached_units:
		if is_instance_valid(unit) and unit.get("fsm"):
			# Check size directly on the PackedVector2Array
			if unit.fsm.path.size() > 0:
				# FIX: Initialize PackedArray with start point, then append the path array
				var points = PackedVector2Array([unit.global_position])
				points.append_array(unit.fsm.path)
				
				if points.size() > 1:
					draw_polyline(points, Color.CYAN, 2.0)
					# Draw destination dot
					draw_circle(unit.fsm.target_position, 4.0, Color.BLUE)


--------------------------------------------------
FILE: res:///scripts/utility/UnitSpawner.gd
--------------------------------------------------
class_name UnitSpawner
extends Node

# --- Configuration ---
@export_group("References")
@export var unit_container: Node2D
@export var rts_controller: RTSController

@export_group("Defaults")
@export var civilian_data: UnitData
@export var spawn_radius_min: float = 100.0
@export var spawn_radius_max: float = 250.0

# --- Constants ---
const LAYER_PLAYER = 2
const LAYER_ENEMY = 4
const SQUAD_SPACING = 150.0
const UNITS_PER_ROW = 5

func _ready() -> void:
	if not unit_container:
		unit_container = get_parent().get_node_or_null("UnitContainer")
	if not unit_container:
		Loggie.msg("UnitSpawner: CRITICAL - No UnitContainer found!").domain(LogDomains.SYSTEM).error()

func clear_units() -> void:
	if not unit_container: return
	for child in unit_container.get_children():
		child.queue_free()

# --- PUBLIC SPAWN API ---

func spawn_garrison(warbands: Array[WarbandData], spawn_origin: Vector2) -> void:
	Loggie.msg("UnitSpawner: Requesting deployment for %d Player Warbands." % warbands.size()).domain(LogDomains.RTS).info()

	if not _validate_spawn_setup(): return
	
	var current_index = 0
	
	for warband in warbands:
		if warband.is_wounded: 
			Loggie.msg("Skipping %s (Wounded)" % warband.custom_name).domain(LogDomains.RTS).debug()
			continue
			
		var ideal_pos = _calculate_formation_pos(spawn_origin, current_index)
		
		# Spawn the Squad Leader
		var unit_instance = _spawn_unit_core(warband, ideal_pos, true)
		if unit_instance:
			if rts_controller:
				rts_controller.add_unit_to_group(unit_instance)
			current_index += 1
		
	Loggie.msg("UnitSpawner: Deployment Complete. %d Squads active." % current_index).domain(LogDomains.RTS).info()

func spawn_enemy_garrison(warbands: Array[WarbandData], buildings: Array) -> void:
	Loggie.msg("UnitSpawner: Spawning %d Enemy Warbands." % warbands.size()).domain(LogDomains.RAID).info()
	
	if not _validate_spawn_setup(): return

	for i in range(warbands.size()):
		var warband = warbands[i]
		var guard_pos = Vector2.ZERO
		if not buildings.is_empty():
			var b = buildings[i % buildings.size()]
			if is_instance_valid(b):
				guard_pos = b.global_position + Vector2(randf_range(-50, 50), randf_range(-50, 50))
		
		var unit_instance = _spawn_unit_core(warband, guard_pos, false)
		
		if unit_instance:
			unit_instance.fsm_ready.connect(_on_enemy_unit_ready.bind(guard_pos))

# --- CORE LOGIC ---

func _spawn_unit_core(warband: WarbandData, target_pos: Vector2, is_player: bool) -> BaseUnit:
	if not warband or not warband.unit_type: return null
	
	var unit_data = warband.unit_type
	var scene_ref = unit_data.load_scene()
	if not scene_ref:
		Loggie.msg("Failed to load scene for %s" % unit_data.display_name).domain(LogDomains.SYSTEM).error()
		return null
	
	# 1. Coordinate Safety Check
	var final_pos = target_pos
	
	# REFACTOR FIX: Use NavigationManager directly
	if NavigationManager:
		final_pos = NavigationManager.request_valid_spawn_point(target_pos, 4)
		if final_pos == Vector2.INF:
			Loggie.msg("Spawn blocked at %s for %s" % [target_pos, unit_data.display_name]).domain(LogDomains.NAVIGATION).warn()
			return null
	
	# 2. Instantiate
	var unit = scene_ref.instantiate() as BaseUnit
	
	# 3. Inject Dependencies
	unit.warband_ref = warband
	unit.data = unit_data
	
	if is_player:
		unit.collision_layer = LAYER_PLAYER
		unit.add_to_group("player_units")
		
		# Always apply Squad Leader Script
		var leader_script = load("res://scripts/units/SquadLeader.gd")
		if unit.get_script() != leader_script:
			unit.set_script(leader_script)
			# Re-inject dependencies
			unit.warband_ref = warband
			unit.data = unit_data
	else:
		unit.collision_layer = LAYER_ENEMY
		unit.add_to_group("enemy_units")
	
	# 4. Position & Parent
	unit.global_position = final_pos
	unit_container.add_child(unit)
	
	# 5. Global Event
	if is_player:
		EventBus.player_unit_spawned.emit(unit)
		
	return unit

# --- HELPER LOGIC ---

func _calculate_formation_pos(origin: Vector2, index: int) -> Vector2:
	var row = index / UNITS_PER_ROW
	var col = index % UNITS_PER_ROW
	var offset = Vector2(
		(col - (UNITS_PER_ROW / 2.0)) * SQUAD_SPACING,
		row * SQUAD_SPACING + 200.0
	)
	return origin + offset

func _validate_spawn_setup() -> bool:
	if not unit_container:
		Loggie.msg("Cannot spawn: UnitContainer missing.").domain(LogDomains.SYSTEM).error()
		return false
	return true

func _on_enemy_unit_ready(unit: BaseUnit, guard_pos: Vector2) -> void:
	if not is_instance_valid(unit): return
	if unit.fsm: unit.fsm.change_state(0) # IDLE
	if unit.attack_ai:
		unit.attack_ai.set_process(true)
		unit.attack_ai.set_physics_process(true)
		if unit.attack_ai.has_method("set_target_mask"):
			unit.attack_ai.set_target_mask(LAYER_PLAYER + 1) 
		if unit.attack_ai is DefenderAI:
			(unit.attack_ai as DefenderAI).configure_guard_post(guard_pos)

func sync_civilians(target_count: int, spawn_origin: Vector2, is_enemy: bool = false) -> void:
	var current_civs = []
	if unit_container:
		for child in unit_container.get_children():
			if child is CivilianUnit:
				current_civs.append(child)
	var diff = target_count - current_civs.size()
	if diff > 0:
		_spawn_civilians(diff, spawn_origin, is_enemy)
	elif diff < 0:
		_despawn_civilians(abs(diff), current_civs)


func _spawn_civilians(count: int, origin: Vector2, is_enemy: bool) -> void:
	if not civilian_data: 
		printerr("UnitSpawner: No civilian_data assigned!")
		return
		
	var scene_ref = civilian_data.load_scene()
	if not scene_ref: return
	
	print("[UnitSpawner] Spawning %d civilians around %s" % [count, origin])
	
	for i in range(count):
		var civ = scene_ref.instantiate()
		
		# 1. Set Groups/Layers
		if is_enemy:
			civ.collision_layer = LAYER_ENEMY
			civ.add_to_group("enemy_units")
			if civ.is_in_group("player_units"): civ.remove_from_group("player_units")
		else:
			civ.collision_layer = LAYER_PLAYER
			civ.add_to_group("player_units")
			
		# 2. Generate Random Position
		var angle = randf() * TAU
		var distance = randf_range(spawn_radius_min, spawn_radius_max)
		var tentative_pos = origin + (Vector2(cos(angle), sin(angle)) * distance)
		
		var final_pos = tentative_pos
		
		# 3. --- SAFETY CHECK (REFACTORED) ---
		if NavigationManager:
			# Debug: What is the random spot?
			var grid_check = NavigationManager._world_to_grid(tentative_pos)
			var is_water = NavigationManager.is_point_solid(grid_check)
			
			if is_water:
				# It landed in water. Request nearest land (Radius 5 tiles).
				var safe_pos = NavigationManager.request_valid_spawn_point(tentative_pos, 5)
				
				if safe_pos != Vector2.INF:
					final_pos = safe_pos
				else:
					# Deep water / No land found. Fallback to Origin.
					final_pos = origin 
		# -----------------------
		
		civ.global_position = final_pos
		unit_container.add_child(civ)
		
		if not is_enemy:
			EventBus.player_unit_spawned.emit(civ)

func _despawn_civilians(count: int, list: Array) -> void:
	for i in range(count):
		if i < list.size():
			var civ = list[i]
			if is_instance_valid(civ):
				if rts_controller: rts_controller.remove_unit(civ)
				civ.queue_free()

func spawn_worker_at(location: Vector2) -> void:
	if not civilian_data: return
	var scene_ref = civilian_data.load_scene()
	if not scene_ref: return
	var civ = scene_ref.instantiate()
	civ.global_position = location
	civ.collision_layer = LAYER_PLAYER
	civ.add_to_group("player_units")
	civ.add_to_group("civilians")
	if unit_container:
		unit_container.add_child(civ)
		EventBus.player_unit_spawned.emit(civ)


--------------------------------------------------
FILE: res:///test/base/GutTestBase.gd
--------------------------------------------------
# res://test/base/GutTestBase.gd
class_name GutTestBase
extends GutTest

# This runs before EVERY test in ANY script that extends GutTestBase
func before_each():
	# 1. Reset Singletons
	# We reset state to prevent "pollution" from previous tests
	if SettlementManager:
		SettlementManager.reset_manager_state()
		SettlementManager.current_settlement = null
		
	if DynastyManager:
		DynastyManager.active_year_modifiers.clear()
		DynastyManager.current_jarl = null
		
	if WinterManager:
		WinterManager.winter_crisis_active = false
		WinterManager.winter_consumption_report.clear()
	# 2. Silence Logs during testing (Optional, keeps output clean)
	# Loggie.set_domain_enabled(LogDomains.SYSTEM, false)

# --- FACTORY HELPERS (Reduces boilerplate in tests) ---

func create_mock_jarl(authority: int = 3, renown: int = 100) -> JarlData:
	var jarl = JarlData.new()
	jarl.display_name = "Test Jarl"
	jarl.current_authority = authority
	jarl.max_authority = authority
	jarl.renown = renown
	DynastyManager.current_jarl = jarl
	return jarl

func create_mock_settlement(pop: int = 10, food: int = 100) -> SettlementData:
	var s = SettlementData.new()
	s.population_peasants = pop
	s.treasury = {
		GameResources.FOOD: food,
		GameResources.WOOD: 100,
		GameResources.GOLD: 100
	}
	s.warbands.clear() # Safety clear
	SettlementManager.current_settlement = s
	return s

func create_mock_warband(unit_data: UnitData = null) -> WarbandData:
	if not unit_data:
		# Load a real one if none provided, or mock one
		unit_data = load("res://data/units/Unit_PlayerRaider.tres")
	
	var wb = WarbandData.new(unit_data)
	wb.current_manpower = 10
	return wb


--------------------------------------------------
FILE: res:///test/fixtures/DynastyTestDataGenerator.gd
--------------------------------------------------
# res://test/DynastyTestDataGenerator.gd
class_name DynastyTestDataGenerator
extends RefCounted

static func generate_test_dynasty() -> JarlData:
	var jarl = JarlData.new()
	jarl.display_name = "Jarl Testor the Builder"
	jarl.age = 45
	jarl.renown = 1250
	jarl.current_authority = 3
	jarl.max_authority = 5
	
	# --- 1. Populate Ancestors ---
	var ancestors_data: Array[Dictionary] = [
		{
			"name": "Harald Tanglehair",
			"death_reason": "Died in battle against Saxons",
			"final_renown": 800
		},
		{
			"name": "Halfdan the Black",
			"death_reason": "Drowned in a frozen lake",
			"final_renown": 1500
		},
		{
			"name": "Sigurd Snake-in-the-Eye",
			"death_reason": "Old age",
			"final_renown": 2200
		}
	]
	jarl.ancestors = ancestors_data
	
	# --- 2. Create Heirs with different states ---
	
	# Heir 1: The Golden Child (Designated)
	var heir1 = JarlHeirData.new()
	heir1.display_name = "Magnus"
	heir1.age = 22
	heir1.prowess = 15
	heir1.stewardship = 12
	heir1.is_designated_heir = true
	heir1.status = JarlHeirData.HeirStatus.Available
	# Dummy Trait
	heir1.genetic_trait = JarlTraitData.new()
	heir1.genetic_trait.display_name = "Strong"
	jarl.heirs.append(heir1)
	
	# Heir 2: The Adventurer (On Expedition)
	var heir2 = JarlHeirData.new()
	heir2.display_name = "Leif"
	heir2.age = 20
	heir2.prowess = 10
	heir2.stewardship = 8
	heir2.status = JarlHeirData.HeirStatus.OnExpedition
	heir2.expedition_years_remaining = 2
	jarl.heirs.append(heir2)
	
	# Heir 3: The Unfortunate (Maimed)
	var heir3 = JarlHeirData.new()
	heir3.display_name = "Ivar"
	heir3.age = 19
	heir3.prowess = 4
	heir3.stewardship = 14
	heir3.status = JarlHeirData.HeirStatus.Maimed
	heir3.genetic_trait = JarlTraitData.new()
	heir3.genetic_trait.display_name = "Genius"
	jarl.heirs.append(heir3)
	
	# Heir 4: The Diplomat (Married Off)
	var heir4 = JarlHeirData.new()
	heir4.display_name = "Gyda"
	heir4.age = 18
	heir4.gender = "Female"
	heir4.prowess = 5
	heir4.stewardship = 15
	heir4.status = JarlHeirData.HeirStatus.MarriedOff
	jarl.heirs.append(heir4)
	
	print("DynastyTestDataGenerator: Generated Jarl '%s' with %d heirs." % [jarl.display_name, jarl.heirs.size()])
	return jarl


--------------------------------------------------
FILE: res:///test/fixtures/SmokeTest.gd
--------------------------------------------------
# res://test/SquadSystemTest.gd
extends Node2D

# Dependencies
const UNIT_SPAWNER_SCRIPT = preload("res://scripts/utility/UnitSpawner.gd")
const PLAYER_UNIT_DATA_PATH = "res://data/units/Unit_PlayerRaider.tres"

var spawner: UnitSpawner
var unit_container: Node2D
var rts_controller: RTSController

func _ready() -> void:
	print("\n --- STARTING SQUAD SYSTEM SMOKE TEST --- ")
	
	# 1. SETUP ENVIRONMENT
	_setup_scene_tree()
	
	# 2. CREATE MOCK DATA
	var warbands = _create_mock_warbands()
	
	# 3. EXECUTE SPAWN
	print(" Requesting Spawn of %d Warbands..." % warbands.size())
	spawner.spawn_garrison(warbands, Vector2(500, 300))
	
	# 4. VERIFY
	# Wait a few frames for deferred calls (add_child, _ready, etc)
	await get_tree().process_frame
	await get_tree().process_frame
	await get_tree().process_frame
	
	_verify_spawn_results()
	
	print("\n TEST COMPLETE.")

func _setup_scene_tree() -> void:
	# Create Container
	unit_container = Node2D.new()
	unit_container.name = "UnitContainer"
	add_child(unit_container)
	
	# Create RTS Controller (Stub)
	rts_controller = RTSController.new()
	rts_controller.name = "RTSController"
	add_child(rts_controller)
	
	# Create Spawner
	spawner = UnitSpawner.new()
	spawner.name = "UnitSpawner"
	spawner.unit_container = unit_container
	spawner.rts_controller = rts_controller
	add_child(spawner)

func _create_mock_warbands() -> Array[WarbandData]:
	var list: Array[WarbandData] = []
	
	if not ResourceLoader.exists(PLAYER_UNIT_DATA_PATH):
		printerr(" CRITICAL: Could not find Unit Data at ", PLAYER_UNIT_DATA_PATH)
		return []
		
	var u_data = load(PLAYER_UNIT_DATA_PATH)
	
	# Create 1 Warband with 5 Men
	var wb = WarbandData.new()
	wb.unit_type = u_data
	wb.custom_name = "Test Squad Alpha"
	wb.current_manpower = 5
	list.append(wb)
	
	return list

func _verify_spawn_results() -> void:
	print("\n --- VERIFICATION ---")
	
	# 1. Check for Squad Leaders
	var leaders = []
	for child in unit_container.get_children():
		if child is SquadLeader:
			leaders.append(child)
			
	if leaders.size() == 1:
		print(" PASS: 1 Squad Leader found.")
	else:
		printerr(" FAIL: Found %d Leaders (Expected 1)." % leaders.size())
		return

	# 2. Check for Minions
	var leader = leaders[0]
	# Minions are siblings of the leader in the container
	var minions = []
	for child in unit_container.get_children():
		# Check if script is SquadSoldier (using resource path check is safe)
		if child.get_script().resource_path.contains("SquadSoldier"):
			minions.append(child)
			
	# Expected: 4 Minions (5 Manpower - 1 Leader)
	if minions.size() == 4:
		print(" PASS: 4 Minions found (Manpower 5 - Leader).")
	else:
		printerr(" FAIL: Found %d Minions (Expected 4)." % minions.size())
		
	# 3. Check Formation Link
	if leader.squad_soldiers.size() == minions.size():
		print(" PASS: Leader knows about all %d minions." % leader.squad_soldiers.size())
	else:
		printerr(" FAIL: Leader only tracks %d/%d minions." % [leader.squad_soldiers.size(), minions.size()])


--------------------------------------------------
FILE: res:///test/fixtures/SmokeTest.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bw2amv84rt3x0"]

[ext_resource type="Script" uid="uid://bqu7pti50egpb" path="res://test/fixtures/SmokeTest.gd" id="1_oxlj3"]

[node name="SmokeTest" type="Node2D"]
script = ExtResource("1_oxlj3")

[node name="CanvasLayer" type="CanvasLayer" parent="."]


--------------------------------------------------
FILE: res:///test/fixtures/TestUtils.gd
--------------------------------------------------
class_name TestUtils
extends RefCounted

# Standard Dummy Data to prevent null crashes
static func create_dummy_data() -> UnitData:
	var d = UnitData.new()
	d.max_loot_capacity = 100
	d.move_speed = 100.0
	d.encumbrance_speed_penalty = 0.5
	d.wergild_cost = 50
	return d

# The Universal Unit Creator
static func create_mock_unit(unit_class, parent_node: Node, data_override: UnitData = null) -> Node2D:
	var unit = unit_class.new()
	
	# 1. Assign Data
	unit.data = data_override if data_override else create_dummy_data()
	
	# 2. Mock Sprite (Prevents "Sprite2D" crashes)
	var sprite = Sprite2D.new()
	sprite.name = "Sprite2D"
	var img = Image.create(32, 32, false, Image.FORMAT_RGBA8)
	sprite.texture = ImageTexture.create_from_image(img)
	unit.add_child(sprite)
	
	# 3. Mock Physics (Prevents "CollisionShape2D" crashes)
	var col = CollisionShape2D.new()
	col.name = "CollisionShape2D"
	unit.add_child(col)
	
	# 4. Mock Timers
	var timer = Timer.new()
	timer.name = "AttackTimer"
	unit.add_child(timer)
	
	# 5. Mock Separation Area (Detailed Structure)
	var sep = Area2D.new()
	sep.name = "SeparationArea"
	var sep_col = CollisionShape2D.new()
	sep_col.name = "CollisionShape2D" # Critical Name
	sep_col.shape = CircleShape2D.new()
	sep_col.shape.radius = 15.0
	sep.add_child(sep_col)
	unit.add_child(sep)
	
	# 6. Force Brain Init (Prevents Race Conditions in Tests)
	if not unit.fsm:
		unit.fsm = UnitFSM.new(unit, null)
		
	# 7. Add to Scene (Triggers _ready)
	if parent_node:
		parent_node.add_child(unit)
	
	return unit

# UI Mocker for EndOfYear Popup
static func create_mock_end_year_popup() -> PanelContainer:
	var root = PanelContainer.new()
	
	var margin = MarginContainer.new()
	margin.name = "MarginContainer"
	root.add_child(margin)
	
	var vbox = VBoxContainer.new()
	vbox.name = "VBoxContainer"
	margin.add_child(vbox)
	
	var label = RichTextLabel.new()
	label.name = "PayoutLabel"
	vbox.add_child(label)
	
	var loot_panel = PanelContainer.new()
	loot_panel.name = "LootDistributionPanel"
	vbox.add_child(loot_panel)
	
	var slider = HSlider.new()
	slider.name = "LootSlider"
	loot_panel.add_child(slider)
	
	var dist_label = Label.new()
	dist_label.name = "DistributionResultLabel"
	vbox.add_child(dist_label)
	
	var btn = Button.new()
	btn.name = "CollectButton"
	vbox.add_child(btn)
	
	var script = load("res://ui/EndOfYear_Popup.gd")
	root.set_script(script)
	
	return root

static func create_mock_bridge() -> Node:
	var bridge_script = load("res://scripts/buildings/SettlementBridge.gd")
	var bridge = bridge_script.new()
	
	# Mock the dependencies that cause crashes
	var unit_cont = Node2D.new()
	unit_cont.name = "UnitContainer"
	bridge.add_child(unit_cont)
	
	var ui_node = CanvasLayer.new()
	ui_node.name = "UI"
	bridge.add_child(ui_node)
	
	return bridge


--------------------------------------------------
FILE: res:///test/integration/test_building_placement.gd
--------------------------------------------------
extends GutTest

# --- Mock Building Class ---
# [FIX] Must extend BaseBuilding to satisfy the return type contract.
class MockBuilding extends BaseBuilding:
	# We override _ready to stop the REAL BaseBuilding logic from running
	# and crashing because it can't find dependencies.
	func _ready():
		pass
		
	# We override set_state to do nothing, just in case.
	func set_state(_val): 
		pass

var _manager_ref
var _container

func before_all():
	# 1. Setup SettlementManager
	if has_node("/root/SettlementManager"):
		_manager_ref = get_node("/root/SettlementManager")
	else:
		_manager_ref = load("res://autoload/SettlementManager.gd").new()
		add_child_autofree(_manager_ref)
		_manager_ref._ready()
	
	# 2. Setup a Dummy Scene Container
	_container = Node2D.new()
	add_child_autofree(_container)
	_manager_ref.register_active_scene_nodes(_container)

func test_building_visual_alignment():
	# --- SETUP ---
	var mock_data = BuildingData.new()
	mock_data.grid_size = Vector2i(1, 1) # 1x1 Building
	mock_data.resource_path = "res://data/buildings/mock_hall.tres"
	
	# --- Create Mock Scene ---
	var mock_node = MockBuilding.new()
	
	var dummy_scene = PackedScene.new()
	dummy_scene.pack(mock_node)
	mock_data.scene_to_spawn = dummy_scene
	
	mock_node.free()
	
	# --- ACTION ---
	# Place at (5, 5).
	var target_grid = Vector2i(5, 5)
	
	# This instantiates MockBuilding (which is now a valid BaseBuilding subtype)
	var building_instance = _manager_ref.place_building(mock_data, target_grid)
	
	# --- ASSERTION ---
	var actual_pos = building_instance.global_position
	
	# Expected ISOMETRIC Position for (5,5) 1x1
	# X = 0, Y = 160 (Top) + 16 (Half Height) = 176
	var expected_x = 0.0
	var expected_y = 176.0 
	
	assert_almost_eq(actual_pos.x, expected_x, 1.0, 
		"X Position Mismatch! Got %s, Expected %s. (Using Orthogonal logic?)" % [actual_pos.x, expected_x])
		
	assert_almost_eq(actual_pos.y, expected_y, 1.0, 
		"Y Position Mismatch! Got %s, Expected %s." % [actual_pos.y, expected_y])

func after_all():
	if is_instance_valid(_manager_ref):
		_manager_ref.unregister_active_scene_nodes()


--------------------------------------------------
FILE: res:///test/integration/test_economy_flow.gd
--------------------------------------------------
# res://test/integration/test_economy_flow.gd
extends GutTestBase

func test_population_growth_with_surplus():
	# 1. Setup (Using Helper!)
	var s = create_mock_settlement(10, 500) # 10 Pop, 500 Food (Abundance)
	create_mock_jarl()
	
	# 2. Execute Year End
	var payout = EconomyManager.calculate_payout()
	
	# 3. Assert
	# 10 people * 10 food = 100 demand. 500 available. Surplus!
	# Base growth 2% + 1% bonus = 3%. 10 * 0.03 = 0.3 -> Min 1 growth.
	
	# Parse the output string or check data directly?
	# Best to check the simulation result returned in payout
	var growth_str = payout.get("population_growth", "")
	
	assert_string_contains(growth_str, "+1", "Should grow by at least 1 peasant in abundance.")

func test_construction_labor_deduction():
	# 1. Setup
	var s = create_mock_settlement(10, 100)
	
	# Add a pending building
	var blueprint = {
		"resource_path": "res://data/buildings/Bldg_Wall.tres",
		"grid_position": Vector2i(0,0),
		"progress": 0,
		"peasant_count": 2, # 2 Workers assigned
		"thrall_count": 0
	}
	s.pending_construction_buildings.append(blueprint)
	
	# 2. Execute
	EconomyManager.calculate_payout()
	
	# 3. Assert
	# 2 Peasants * 25 Efficiency = 50 Progress
	var updated_bp = s.pending_construction_buildings[0]
	assert_eq(updated_bp["progress"], 50, "Construction progress should increase based on labor.")


--------------------------------------------------
FILE: res:///test/integration/test_escort_cycle.gd
--------------------------------------------------
extends GutTestBase

var leader: SquadLeader
var soldier: SquadSoldier
var civilian: CivilianUnit
var retreat_zone: Area2D

func before_each():
	# 1. Specific Environment Setup
	retreat_zone = Area2D.new()
	retreat_zone.add_to_group("retreat_zone")
	retreat_zone.position = Vector2(1000, 1000) 
	add_child_autofree(retreat_zone)
	
	# 2. Use Factory for Units (Auto-adds to tree because we pass 'self')
	leader = TestUtils.create_mock_unit(SquadLeader, self)
	soldier = TestUtils.create_mock_unit(SquadSoldier, self)
	civilian = TestUtils.create_mock_unit(CivilianUnit, self)
	
	# 3. Connect Logic
	leader.squad_soldiers.append(soldier)
	soldier.leader = leader
	soldier.global_position = Vector2(100, 100) 
	
	# Auto-free handled by parent_node logic in TestUtils? 
	# No, TestUtils adds child but doesn't register autofree.
	# We should manually autofree them to be safe, or update TestUtils.
	# For now, let's explicit autofree to be safe.
	autofree(leader)
	autofree(soldier)
	autofree(civilian)

func test_civilian_surrender_signal():
	watch_signals(civilian)
	civilian.current_health = 10
	civilian.surrender_hp_threshold = 5
	civilian.take_damage(8, leader)
	assert_signal_emitted(civilian, "surrender_requested")
	assert_eq(civilian.current_health, 1)

func test_leader_finds_volunteer():
	civilian.global_position = Vector2(150, 150) 
	leader.request_escort_for(civilian)
	assert_eq(soldier.fsm.current_state, UnitAIConstants.State.COLLECTING)
	assert_eq(soldier.fsm.objective_target, civilian)

func test_soldier_collects_prisoner():
	soldier.assign_escort_task(civilian)
	soldier.global_position = civilian.global_position
	soldier.process_collecting_logic(0.1)
	assert_true(civilian in soldier.escorted_prisoners)
	assert_eq(soldier.fsm.current_state, UnitAIConstants.State.ESCORTING)

func test_escort_completion():
	soldier.escorted_prisoners.append(civilian)
	soldier.fsm.change_state(UnitAIConstants.State.ESCORTING)
	soldier.fsm.objective_target = retreat_zone
	soldier.global_position = retreat_zone.global_position
	soldier.complete_escort()
	assert_true(civilian.is_queued_for_deletion())
	assert_eq(soldier.escorted_prisoners.size(), 0)
	assert_eq(soldier.fsm.current_state, UnitAIConstants.State.REGROUPING)

func test_batching_logic():
	# Use Factory for quick instances
	var civ1 = TestUtils.create_mock_unit(CivilianUnit, self)
	var civ2 = TestUtils.create_mock_unit(CivilianUnit, self)
	autofree(civ1)
	autofree(civ2)
	
	soldier.assign_escort_task(civ1)
	soldier.assign_escort_task(civ2)
	assert_true(civ2 in soldier.pending_prisoners)
	
	soldier.global_position = civ1.global_position
	soldier.process_collecting_logic(0.1)
	
	assert_eq(soldier.fsm.current_state, UnitAIConstants.State.COLLECTING)
	assert_eq(soldier.fsm.objective_target, civ2)


--------------------------------------------------
FILE: res:///test/integration/test_fleet_mechanics.gd
--------------------------------------------------
# res://test/integration/test_fleet_mechanics.gd
extends GutTestBase

const NAUST_PATH = "res://data/buildings/generated/Bldg_Naust.tres"

func before_each():
	super.before_each()
	# Ensure we have a clean settlement
	create_mock_settlement()

func test_base_fleet_capacity():
	# 1. Assert Base State (No buildings)
	var cap = SettlementManager.get_total_ship_capacity_squads()
	assert_eq(cap, 3, "Base capacity should be 3 Squads (1 Ship) with no buildings.")

func test_naust_increases_capacity():
	# 1. Check if the AI Importer worked
	if not FileAccess.file_exists(NAUST_PATH):
		fail_test("Could not find Naust data at %s. Did you run the Importer?" % NAUST_PATH)
		return
		
	# 2. Add a Naust to the settlement
	var entry = {
		"resource_path": NAUST_PATH,
		"grid_position": Vector2i(0,0)
	}
	SettlementManager.current_settlement.placed_buildings.append(entry)
	
	# 3. Assert Capacity Increase
	var cap = SettlementManager.get_total_ship_capacity_squads()
	
	# Expected: 3 (Base) + 3 (Naust) = 6
	assert_eq(cap, 6, "Building a Naust should increase capacity by 3 squads.")

func test_overflow_logic():
	# 1. Setup: Base Capacity (3)
	# Fill the spots with 3 existing squads
	var s = SettlementManager.current_settlement
	s.warbands.append(create_mock_warband())
	s.warbands.append(create_mock_warband())
	s.warbands.append(create_mock_warband())
	
	# 2. Simulate "The Call": 5 new squads arrive
	var arriving_squads = 5
	var capacity = SettlementManager.get_total_ship_capacity_squads() # Should be 3
	var current_filled = s.warbands.size() # 3
	
	var open_slots = max(0, capacity - current_filled)
	var accepted = min(arriving_squads, open_slots)
	var rejected = arriving_squads - accepted
	
	# 3. Assert
	assert_eq(open_slots, 0, "Should have 0 open slots.")
	assert_eq(accepted, 0, "Should accept 0 new squads.")
	assert_eq(rejected, 5, "Should turn away all 5 squads.")

func test_naust_solves_overflow():
	# 1. Setup: Base Capacity (3) but FULL
	var s = SettlementManager.current_settlement
	s.warbands.append(create_mock_warband())
	s.warbands.append(create_mock_warband())
	s.warbands.append(create_mock_warband())
	
	# 2. Build a Naust!
	if FileAccess.file_exists(NAUST_PATH):
		s.placed_buildings.append({ "resource_path": NAUST_PATH, "grid_position": Vector2i(0,0) })
	
	# 3. Recalculate Capacity
	var capacity = SettlementManager.get_total_ship_capacity_squads() # Should be 6 now
	
	# 4. Simulate "The Call": 2 new squads arrive
	var arriving_squads = 2
	var current_filled = s.warbands.size() # 3
	
	var open_slots = max(0, capacity - current_filled) # 6 - 3 = 3 slots
	var accepted = min(arriving_squads, open_slots)
	var rejected = arriving_squads - accepted
	
	# 5. Assert
	assert_eq(capacity, 6, "Capacity should be 6.")
	assert_eq(open_slots, 3, "Should have 3 open slots.")
	assert_eq(accepted, 2, "Should accept both squads.")
	assert_eq(rejected, 0, "No one should be turned away.")


--------------------------------------------------
FILE: res:///test/integration/test_military_spawning.gd
--------------------------------------------------
# res://test/integration/test_military_spawning.gd
extends GutTestBase

var spawner: UnitSpawner
var unit_container: Node2D
var rts_controller: RTSController

const RAIDER_DATA_PATH = "res://data/units/Unit_PlayerRaider.tres"

func before_each():
	super.before_each()
	unit_container = autoqfree(Node2D.new())
	unit_container.name = "UnitContainer"
	add_child(unit_container)
	
	rts_controller = autoqfree(RTSController.new())
	rts_controller.name = "RTSController"
	add_child(rts_controller)
	
	spawner = autoqfree(UnitSpawner.new())
	spawner.name = "UnitSpawner"
	spawner.unit_container = unit_container
	spawner.rts_controller = rts_controller
	add_child(spawner)

func test_spawn_full_strength_squad():
	var unit_data = load(RAIDER_DATA_PATH)
	if not unit_data:
		pending("Skipping test: Unit_PlayerRaider.tres not found.")
		return

	var warband = create_mock_warband(unit_data)
	warband.current_manpower = 5 
	
	spawner.spawn_garrison([warband], Vector2.ZERO)
	
	# --- FIX: Wait for deferred spawn logic to execute ---
	await wait_seconds(0.2) 
	# -----------------------------------------------------
	
	var child_count = unit_container.get_child_count()
	assert_eq(child_count, 5, "Should spawn 5 total units (1 Leader + 4 Soldiers)")
	
	var leaders = get_nodes_by_class(unit_container, "SquadLeader")
	assert_eq(leaders.size(), 1, "Exactly one SquadLeader should exist")
	
	if leaders.size() > 0:
		var leader = leaders[0] as SquadLeader
		assert_eq(leader.warband_ref, warband, "Leader should link to the correct Warband Data")
		assert_eq(leader.squad_soldiers.size(), 4, "Leader should track 4 soldiers")

	var minions = get_nodes_by_class(unit_container, "SquadSoldier")
	assert_eq(minions.size(), 4, "Exactly four SquadSoldiers should exist")
	
	if leaders.size() > 0:
		for minion in minions:
			assert_eq(minion.leader, leaders[0], "Minion should know its Leader")

func test_wounded_warband_skipped():
	var unit_data = load(RAIDER_DATA_PATH)
	var warband = create_mock_warband(unit_data)
	warband.is_wounded = true 
	
	spawner.spawn_garrison([warband], Vector2.ZERO)
	
	# Wait briefly to ensure nothing happens
	await wait_seconds(0.1)
	
	assert_eq(unit_container.get_child_count(), 0, "Wounded warbands should NOT spawn units")

func test_multiple_squad_offset():
	var unit_data = load(RAIDER_DATA_PATH)
	var wb1 = create_mock_warband(unit_data)
	var wb2 = create_mock_warband(unit_data)
	
	spawner.spawn_garrison([wb1, wb2], Vector2(1000, 1000))
	
	# --- FIX: Wait for deferred spawn ---
	await wait_seconds(0.2)
	# ------------------------------------
	
	var leaders = get_nodes_by_class(unit_container, "SquadLeader")
	assert_eq(leaders.size(), 2, "Should spawn 2 leaders")
	
	if leaders.size() >= 2:
		var l1 = leaders[0]
		var l2 = leaders[1]
		assert_ne(l1.global_position, l2.global_position, "Squads should spawn at different positions")
		var dist = l1.global_position.distance_to(Vector2(1000, 1000))
		assert_lt(dist, 500.0, "Squads should spawn near the target origin")

func get_nodes_by_class(parent: Node, class_name_str: String) -> Array:
	var result = []
	for child in parent.get_children():
		if child.get_script().resource_path.contains(class_name_str):
			result.append(child)
	return result


--------------------------------------------------
FILE: res:///test/integration/test_navigation_logic.gd
--------------------------------------------------
extends GutTest

var _grid: AStarGrid2D
var _nav_manager = NavigationManager 

func before_each():
	# 1. Setup a clean 100x100 Grid
	_grid = AStarGrid2D.new()
	_grid.region = Rect2i(0, 0, 100, 100)
	_grid.cell_size = Vector2(32, 32)
	
	# --- THE FIX: Center the points! ---
	# Without this, points are at Top-Left (0,0).
	# With this, points are at Center (16,16).
	_grid.offset = _grid.cell_size / 2 
	# -----------------------------------
	
	_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_ALWAYS
	_grid.update()
	
	_nav_manager.register_grid(_grid, self)

func after_each():
	_nav_manager.unregister_grid()
	_grid = null

func test_smoothing_removes_zigzag():
	# Start at (0,0) center -> (16, 16)
	var start_pos = Vector2(16, 16) 
	# End at (10,10) center -> (336, 336)
	var end_pos = Vector2(336, 336) 
	
	var path = _nav_manager.get_astar_path(start_pos, end_pos)
	
	assert_gt(path.size(), 0, "Path should not be empty")
	
	# Verify String Pulling (Should be 2 points for a straight diagonal)
	assert_lt(path.size(), 5, "Path should be smoothed! Zig-zag detected if size > 5. Actual: %s" % path.size())
	
	# Verify Start
	assert_eq(path[0], start_pos, "Path must start at origin")
	
	# Verify End
	# Now that the grid is offset, the last point should match our centered target
	var last_point = path[path.size() - 1]
	assert_almost_eq(last_point.distance_to(end_pos), 0.0, 1.0, "Path must end at target")

func test_start_position_precision_fix():
	# Start at (5,5) (Top-left of first tile)
	var exact_unit_pos = Vector2(5, 5)
	var target_pos = Vector2(100, 100)
	
	var path = _nav_manager.get_astar_path(exact_unit_pos, target_pos)
	
	assert_gt(path.size(), 0)
	assert_eq(path[0], exact_unit_pos, "Path start point must match Unit Position, NOT Grid Center.")

func test_obstacle_avoidance_with_smoothing():
	var start_pos = Vector2(16, 16)   # 0,0
	var end_pos = Vector2(80, 80)     # 2,2
	
	# Block the middle diagonal (1,1)
	_grid.set_point_solid(Vector2i(1, 1), true)
	
	var path = _nav_manager.get_astar_path(start_pos, end_pos)
	
	assert_gt(path.size(), 0, "Should find a path around the wall")
	
	var wall_center = Vector2(48, 48) # Center of 1,1
	for point in path:
		var dist = point.distance_to(wall_center)
		# Should keep distance (radius 16)
		assert_gt(dist, 16.0, "Path point %s is inside the solid wall!" % point)

	# If we smoothed perfectly through a wall, size would be 2. Since wall exists, it must be > 2.
	assert_gt(path.size(), 2, "Path should have added a corner waypoint to avoid the wall.")

func test_out_of_bounds_handling():
	var start = Vector2(16, 16)
	var waaaay_out = Vector2(99999, 99999)
	
	var path = _nav_manager.get_astar_path(start, waaaay_out)
	
	assert_gt(path.size(), 0, "Should clamp target and return valid path")
	
	var last_point = path[path.size() - 1]
	# Max bounds is 100 * 32 = 3200 + offset 16 = 3216
	# We allow a little tolerance
	assert_lt(last_point.x, 3250.0, "Target should be clamped within bounds")


--------------------------------------------------
FILE: res:///test/integration/test_new_game_flow.gd
--------------------------------------------------
# res://test/integration/test_new_game_flow.gd
extends GutTest

const USER_SAVE_PATH = "user://savegame_dynasty.tres"

func before_each():
	# Clean slate: Remove existing save file to ensure we test generation, not loading
	if FileAccess.file_exists(USER_SAVE_PATH):
		DirAccess.remove_absolute(USER_SAVE_PATH)
	
	# Reset Manager
	if DynastyManager:
		DynastyManager.current_jarl = null

func after_all():
	# Cleanup: Remove the test save file
	if FileAccess.file_exists(USER_SAVE_PATH):
		DirAccess.remove_absolute(USER_SAVE_PATH)

func test_generator_produces_valid_jarl():
	# 1. Generate
	var jarl = DynastyGenerator.generate_random_dynasty()
	
	# 2. Verify Basic Stats
	assert_not_null(jarl, "Jarl should not be null")
	assert_gt(jarl.age, 16, "Jarl should be an adult")
	assert_gt(jarl.display_name.length(), 0, "Jarl should have a name")
	
	# 3. Verify Stats Ranges (Based on Generator logic 8-15)
	assert_between(jarl.command, 8, 15, "Command within range")
	assert_between(jarl.stewardship, 8, 15, "Stewardship within range")
	
	# 4. Verify Heirs
	assert_gt(jarl.heirs.size(), 0, "Should generate at least 1 heir")
	var designated_found = false
	for heir in jarl.heirs:
		if heir.is_designated_heir:
			designated_found = true
	assert_true(designated_found, "One heir should be auto-designated")

func test_heir_age_logic():
	var jarl = DynastyGenerator.generate_random_dynasty()
	
	for heir in jarl.heirs:
		# Logic: Parent must be at least 16 when child born
		var max_possible_age = jarl.age - 16
		assert_lt(heir.age, jarl.age, "Heir must be younger than parent")
		assert_lte(heir.age, max_possible_age, "Heir age valid relative to parent maturity")

func test_start_new_campaign_flow():
	# 1. Setup Signal Watcher
	watch_signals(DynastyManager)
	
	# 2. Execute Action
	DynastyManager.start_new_campaign()
	
	# 3. Verify Signal Emission
	assert_signal_emitted(DynastyManager, "jarl_stats_updated", "UI should be notified of new Jarl")
	
	# 4. Verify Manager State
	var current = DynastyManager.current_jarl
	assert_not_null(current, "Manager should hold new Jarl")
	assert_eq(current.resource_path, USER_SAVE_PATH, "Resource path should be bound to user save")
	
	# 5. Verify Persistence
	# FIX: assert_file_exists only accepts the path, no custom message
	assert_file_exists(USER_SAVE_PATH)

func test_persistence_loading():
	# 1. Generate and Save
	DynastyManager.start_new_campaign()
	var original_name = DynastyManager.current_jarl.display_name
	
	# 2. Nuke memory to simulate restart
	DynastyManager.current_jarl = null
	
	# 3. Trigger Load (via getter or private method)
	# We use get_current_jarl() which triggers _load_game_data if null
	var loaded_jarl = DynastyManager.get_current_jarl()
	
	# 4. Verify
	assert_not_null(loaded_jarl, "Should load from disk")
	assert_eq(loaded_jarl.display_name, original_name, "Name should match saved data")


--------------------------------------------------
FILE: res:///test/integration/test_terrain_solids.gd
--------------------------------------------------
extends GutTest

var _manager_ref
var _layer: TileMapLayer
var _container: Node2D
var _scene_root: Node2D

func before_all():
	# 1. Setup Manager
	if has_node("/root/SettlementManager"):
		_manager_ref = get_node("/root/SettlementManager")
	else:
		_manager_ref = load("res://autoload/SettlementManager.gd").new()
		add_child_autofree(_manager_ref)
		_manager_ref._ready()
	
	# 2. Setup Scene Hierarchy
	_scene_root = Node2D.new()
	add_child_autofree(_scene_root)
	
	_layer = TileMapLayer.new()
	_layer.name = "TileMapLayer"
	_scene_root.add_child(_layer)
	
	_container = Node2D.new()
	_container.name = "BuildingContainer"
	_scene_root.add_child(_container)
	
	# 3. Build TileSet with Custom Data (The correct Godot 4 way)
	var ts = TileSet.new()
	ts.add_custom_data_layer() 
	ts.set_custom_data_layer_name(0, "is_unwalkable")
	ts.set_custom_data_layer_type(0, TYPE_BOOL)
	
	var source = TileSetAtlasSource.new()
	var tex = PlaceholderTexture2D.new()
	tex.size = Vector2(64, 64)
	source.texture = tex
	source.texture_region_size = Vector2i(64, 64)
	
	source.create_tile(Vector2i(0, 0))
	var tile_data = source.get_tile_data(Vector2i(0, 0), 0)
	tile_data.set_custom_data("is_unwalkable", true)
	
	# [CRITICAL] Capture the Source ID!
	var source_id = ts.add_source(source)
	_layer.tile_set = ts
	
	# Paint the "Water" tile at Grid (5, 5) using the correct Source ID
	_layer.set_cell(Vector2i(5, 5), source_id, Vector2i(0, 0))

func test_water_blocks_grid():
	# --- ACTION ---
	# 1. Register
	_manager_ref.register_active_scene_nodes(_container)
	
	# [FIX] Manual Injection Fallback
	# If the automatic sibling detection failed (common in tests), force it.
	if not _manager_ref.active_tilemap_layer:
		_manager_ref.active_tilemap_layer = _layer
		
	# 2. Refresh (This triggers the scan)
	_manager_ref._refresh_grid_state()
	
	# --- ASSERTION ---
	assert_not_null(_manager_ref.active_tilemap_layer, "Active TileMapLayer should be assigned.")
	
	# Check the Grid Logic
	var is_solid = _manager_ref.active_astar_grid.is_point_solid(Vector2i(5, 5))
	
	if not is_solid:
		# Debug info if it fails
		var data = _layer.get_cell_tile_data(Vector2i(5, 5))
		var val = data.get_custom_data("is_unwalkable") if data else "NULL DATA"
		gut.p("DEBUG FAILURE: Tile Data at (5,5) -> is_unwalkable: %s" % val)
		
	assert_true(is_solid, "Grid (5,5) should be SOLID because tile has 'is_unwalkable' = true.")
	
	# Control Check
	var is_empty_solid = _manager_ref.active_astar_grid.is_point_solid(Vector2i(6, 6))
	assert_false(is_empty_solid, "Grid (6,6) should be WALKABLE.")

func after_all():
	if is_instance_valid(_manager_ref):
		_manager_ref.unregister_active_scene_nodes()


--------------------------------------------------
FILE: res:///test/integration/test_winter_systems.gd
--------------------------------------------------
# res://test/integration/test_winter_systems.gd
extends GutTest

# --- SETUP & TEARDOWN ---
func before_each():
	# 1. Reset Managers
	SettlementManager.reset_manager_state()
	DynastyManager.winter_crisis_active = false
	DynastyManager.winter_consumption_report.clear()
	
	# 2. FORCE NORMAL WINTER (Disable RNG for logic tests)
	WinterManager.harsh_chance = 0.0
	WinterManager.mild_chance = 0.0
	WinterManager.current_severity = WinterManager.WinterSeverity.NORMAL
	
	# 3. Mock Jarl
	var jarl = JarlData.new()
	jarl.display_name = "Test Jarl"
	jarl.current_hall_actions = 3
	DynastyManager.current_jarl = jarl

func after_all():
	# Restore RNG defaults (Optional, good practice)
	WinterManager.harsh_chance = 0.2
	WinterManager.mild_chance = 0.05

# --- TESTS ---

func test_winter_crisis_detection_starvation():
	# 1. Setup: 50 Pop vs 0 Food
	var settlement = SettlementData.new()
	settlement.population_peasants = 50
	settlement.treasury = { "food": 0, "wood": 100, "gold": 0 }
	SettlementManager.current_settlement = settlement
	
	# 2. Execute
	DynastyManager._calculate_winter_needs()
	
	# 3. Assert
	assert_true(DynastyManager.winter_crisis_active, "Crisis should be active.")
	
	var report = DynastyManager.winter_consumption_report
	# With Normal Winter forced, 50 pop = 50 food needed
	assert_eq(report["food_deficit"], 50, "Deficit should be exactly 50 (Normal Winter).")

func test_winter_crisis_resolution_via_gold():
	# 1. Setup
	var settlement = SettlementData.new()
	settlement.population_peasants = 10 
	settlement.treasury = { "food": 0, "wood": 100, "gold": 1000 }
	SettlementManager.current_settlement = settlement
	
	DynastyManager._calculate_winter_needs()
	
	# 2. Execute
	var success = DynastyManager.resolve_crisis_with_gold()
	
	# 3. Assert
	assert_true(success)
	assert_false(DynastyManager.winter_crisis_active)
	# 10 Food * 5 Gold = 50 Gold Cost
	assert_eq(settlement.treasury["gold"], 950, "Gold should decrease by 50.")

func test_ui_locking_during_crisis():
	# 1. Setup
	var settlement = SettlementData.new()
	settlement.population_peasants = 50
	settlement.treasury = { "food": 0, "wood": 0, "gold": 0 }
	SettlementManager.current_settlement = settlement
	DynastyManager._calculate_winter_needs()
	
	# 2. Load UI
	var ui = autoqfree(load("res://ui/WinterCourt_UI.tscn").instantiate())
	add_child(ui)
	
	# --- FIX: Use new wait method ---
	await wait_physics_frames(1) 
	# --------------------------------
	
	# 3. Assert
	var btn_end = ui.find_child("Btn_EndWinter", true, false)
	assert_true(btn_end.disabled, "End Winter button should be locked.")


--------------------------------------------------
FILE: res:///test/unit/test_RaidManager.gd
--------------------------------------------------
extends GutTest

var raid_manager
var mock_jarl

func before_each():
	# 1. Get the Autoload
	raid_manager = RaidManager
	
	# 2. Create a Mock Jarl
	# We need to manually set this on DynastyManager because the game isn't running normally
	mock_jarl = JarlData.new()
	mock_jarl.display_name = "Test Jarl"
	mock_jarl.command = 5
	# Base Jarl stats usually default to safe_range ~200 + (command * 50)
	
	DynastyManager.current_jarl = mock_jarl

func after_each():
	raid_manager.reset_raid_state()
	DynastyManager.current_jarl = null

func test_initial_state():
	assert_eq(raid_manager.raid_provisions_level, 1, "Default provisions should be 1")
	assert_eq(raid_manager.outbound_raid_force.size(), 0, "Force should be empty")

func test_prepare_raid_force():
	var warband = WarbandData.new()
	
	# FIX: Explicitly type the array so it matches the function signature
	var force: Array[WarbandData] = [warband]
	
	raid_manager.prepare_raid_force(force, 2)
	
	assert_eq(raid_manager.outbound_raid_force.size(), 1)
	assert_eq(raid_manager.raid_provisions_level, 2)

func test_attrition_safe_range():
	# Setup Jarl to have a known safe range
	mock_jarl.command = 20 # Should result in huge safe range
	
	var result = raid_manager.calculate_journey_attrition(10.0)
	
	assert_eq(result["modifier"], 1.0, "Should be no damage for short range")
	# Check title only if it exists, to be safe against RNG
	if result.has("title") and raid_manager.raid_provisions_level == 1:
		assert_eq(result["title"], "Uneventful Journey")

func test_attrition_risky_range():
	# Force a very difficult journey
	mock_jarl.command = 0
	
	# Distance 5000 is likely way beyond safe range
	var result = raid_manager.calculate_journey_attrition(5000.0)
	
	assert_has(result, "modifier")
	assert_has(result, "title")
	assert_has(result, "description")

func test_defensive_loss_renoun():
	mock_jarl.renown = 1000
	
	# NOTE: This test assumes EconomyManager handles a null Settlement safely.
	# If EconomyManager crashes, we may need to mock SettlementManager here too.
	var result = raid_manager.process_defensive_loss()
	
	assert_lt(mock_jarl.renown, 1000, "Renown should decrease after defeat")
	assert_has(result, "summary_text")


--------------------------------------------------
FILE: res:///test/unit/test_WinterManager.gd
--------------------------------------------------
extends GutTest

var winter_manager
var mock_settlement
var mock_jarl

func before_each():
	winter_manager = WinterManager
	
	# Mock Settlement Data
	mock_settlement = SettlementData.new()
	mock_settlement.population_peasants = 10
	mock_settlement.treasury = {"food": 100, "wood": 100, "gold": 1000}
	
	# Inject into Singleton
	SettlementManager.current_settlement = mock_settlement
	
	# Mock Jarl for Actions
	mock_jarl = JarlData.new()
	mock_jarl.current_hall_actions = 5
	DynastyManager.current_jarl = mock_jarl

func after_each():
	SettlementManager.current_settlement = null
	DynastyManager.current_jarl = null
	winter_manager.winter_crisis_active = false
	winter_manager.winter_consumption_report.clear()

func test_calculate_demand_normal():
	# Force normal via probability manipulation or just check math logic
	winter_manager.current_severity = winter_manager.WinterSeverity.NORMAL
	
	var report = winter_manager.calculate_winter_demand(mock_settlement)
	
	# 10 peasants * 1 + 0 warbands * 5 = 10 food
	# Base wood = 20
	assert_eq(report["food_demand"], 10)
	assert_eq(report["wood_demand"], 20)

func test_consumption_applied_when_affordable():
	# Ensure calculated needs are applied if treasury has enough
	winter_manager._calculate_winter_needs()
	
	assert_false(winter_manager.winter_crisis_active, "Should not be a crisis")
	
	# Check if treasury was deducted
	# Normal demand is ~10 food, ~20 wood
	assert_lt(mock_settlement.treasury["food"], 100)
	assert_lt(mock_settlement.treasury["wood"], 100)

func test_crisis_trigger():
	# Bankrupt the settlement
	mock_settlement.treasury["food"] = 0
	
	winter_manager._calculate_winter_needs()
	
	assert_true(winter_manager.winter_crisis_active, "Crisis should trigger on deficit")
	assert_gt(winter_manager.winter_consumption_report["food_deficit"], 0)

func test_resolve_crisis_with_gold():
	# Setup Crisis
	mock_settlement.treasury["food"] = 0
	winter_manager._calculate_winter_needs()
	
	# Resolve
	var success = winter_manager.resolve_crisis_with_gold()
	
	assert_true(success)
	assert_false(winter_manager.winter_crisis_active)
	# Gold should be reduced (Cost is Deficit * 5)
	assert_lt(mock_settlement.treasury["gold"], 1000)

func test_resolve_sacrifice_burn_ships():
	# Setup Crisis (Wood deficit)
	mock_settlement.treasury["wood"] = 0
	mock_settlement.fleet_readiness = 1.0
	winter_manager._calculate_winter_needs()
	
	# Resolve
	var success = winter_manager.resolve_crisis_with_sacrifice("burn_ships")
	
	assert_true(success)
	assert_eq(mock_settlement.fleet_readiness, 0.0)
	assert_eq(mock_jarl.current_hall_actions, 4, "Should spend 1 action")


--------------------------------------------------
FILE: res:///test/unit/test_dynasty_modifiers.gd
--------------------------------------------------
extends GutTest

## test_dynasty_modifiers.gd
## Verifies the Data-Driven Seasonal Modifier logic in DynastyManager.
## Ensures cards correctly aggregate stats and reset properly.

func before_each():
	# Ensure a clean slate before every test
	DynastyManager.reset_year_stats()

func after_each():
	# Cleanup after tests
	DynastyManager.reset_year_stats()

func test_initial_state():
	# Verify all stats start at 0.0
	var stats = DynastyManager.active_year_modifiers
	assert_eq(stats["mod_unit_damage"], 0.0, "Damage mod should init at 0")
	assert_eq(stats["mod_raid_xp"], 0.0, "Raid XP mod should init at 0")

func test_single_card_aggregation():
	# Setup
	var card = SeasonalCardResource.new()
	card.display_name = "Test Feast"
	card.mod_unit_damage = 0.15 # +15% Damage
	card.mod_raid_xp = 0.0
	
	# Execute
	DynastyManager.aggregate_card_effects(card)
	
	# Assert
	var stats = DynastyManager.active_year_modifiers
	assert_almost_eq(stats["mod_unit_damage"], 0.15, 0.001, "Damage mod should update to 0.15")
	assert_eq(stats["mod_raid_xp"], 0.0, "Unchanged stat should remain 0")

func test_modifier_stacking():
	# Setup Card A (+10% Damage)
	var card_a = SeasonalCardResource.new()
	card_a.display_name = "Training"
	card_a.mod_unit_damage = 0.10
	
	# Setup Card B (+5% Damage, +20% Harvest)
	var card_b = SeasonalCardResource.new()
	card_b.display_name = "Blessing"
	card_b.mod_unit_damage = 0.05
	card_b.mod_harvest_yield = 0.20
	
	# Execute
	DynastyManager.aggregate_card_effects(card_a)
	DynastyManager.aggregate_card_effects(card_b)
	
	# Assert
	var stats = DynastyManager.active_year_modifiers
	# 0.10 + 0.05 should equal 0.15
	assert_almost_eq(stats["mod_unit_damage"], 0.15, 0.001, "Damage modifiers should stack")
	assert_almost_eq(stats["mod_harvest_yield"], 0.20, 0.001, "Harvest modifier should be applied")

func test_negative_modifiers():
	# Setup Penalty Card (-10% XP)
	var card = SeasonalCardResource.new()
	card.mod_raid_xp = -0.10
	
	# Execute
	DynastyManager.aggregate_card_effects(card)
	
	# Assert
	assert_almost_eq(DynastyManager.active_year_modifiers["mod_raid_xp"], -0.10, 0.001, "Should handle negative modifiers")

func test_reset_functionality():
	# Setup
	var card = SeasonalCardResource.new()
	card.mod_birth_chance = 0.5
	DynastyManager.aggregate_card_effects(card)
	
	# Pre-check
	assert_gt(DynastyManager.active_year_modifiers["mod_birth_chance"], 0.0, "Stat should be set before reset")
	
	# Execute Reset
	DynastyManager.reset_year_stats()
	
	# Assert
	assert_eq(DynastyManager.active_year_modifiers["mod_birth_chance"], 0.0, "Stat should be 0.0 after reset")


--------------------------------------------------
FILE: res:///test/unit/test_economy_seasonal.gd
--------------------------------------------------
extends GutTest

const TEMP_BUILDING_PATH = "user://temp_test_eco_building.tres"

var _mock_settlement: SettlementData
var _mock_jarl: JarlData

func before_all():
	# Create a temporary building resource for testing
	var b_data = EconomicBuildingData.new()
	b_data.resource_type = "gold"
	b_data.base_passive_output = 100 # Easy math: 100/yr -> 25/season
	b_data.storage_capacity_bonus = 1000 # huge cap
	ResourceSaver.save(b_data, TEMP_BUILDING_PATH)

func after_all():
	# Cleanup
	if FileAccess.file_exists(TEMP_BUILDING_PATH):
		DirAccess.remove_absolute(TEMP_BUILDING_PATH)

func before_each():
	# 1. Mock Settlement
	_mock_settlement = SettlementData.new()
	_mock_settlement.treasury = {"gold": 0, "wood": 0, "food": 0}
	_mock_settlement.placed_buildings = []
	_mock_settlement.population_peasants = 10
	SettlementManager.current_settlement = _mock_settlement
	
	# 2. Mock Jarl (Neutral Stats)
	_mock_jarl = JarlData.new()
	_mock_jarl.stewardship = 10 # Multiplier = 1.0
	DynastyManager.current_jarl = _mock_jarl

func after_each():
	SettlementManager.current_settlement = null
	DynastyManager.current_jarl = null

# --- TESTS ---

func test_projected_income_calculation():
	# Setup: Add the temp building
	_add_building_to_settlement(TEMP_BUILDING_PATH)
	
	var projection = EconomyManager.get_projected_income()
	
	assert_has(projection, "gold", "Projection should contain gold")
	assert_eq(projection["gold"], 100, "Base output should be 100 (100 base * 1 worker * 1.0 stew)")

func test_seasonal_payout_spring():
	# Gold should pay 25% in Spring
	_add_building_to_settlement(TEMP_BUILDING_PATH)
	
	EconomyManager.calculate_seasonal_payout("Spring")
	
	assert_eq(_mock_settlement.treasury["gold"], 25, "Spring should pay 25% of annual gold (100 -> 25)")

func test_seasonal_payout_autumn_food():
	# Setup Food Building (Farm)
	var farm_data = EconomicBuildingData.new()
	farm_data.resource_type = "food"
	farm_data.base_passive_output = 200
	var farm_path = "user://temp_test_farm.tres"
	ResourceSaver.save(farm_data, farm_path)
	
	_add_building_to_settlement(farm_path)
	
	# TEST 1: Summer (No Harvest)
	EconomyManager.calculate_seasonal_payout("Summer")
	assert_eq(_mock_settlement.treasury["food"], 0, "Summer should yield 0 Food")
	
	# TEST 2: Autumn (Harvest)
	EconomyManager.calculate_seasonal_payout("Autumn")
	# Treasury accumulates, so if Summer added 0, Autumn adds 200 -> Total 200
	assert_eq(_mock_settlement.treasury["food"], 200, "Autumn should yield 100% of annual Food")
	
	# Cleanup
	DirAccess.remove_absolute(farm_path)

func test_storage_caps():
	# Cap is 500 (Base Gold) + 1000 (Building) = 1500
	# Updated to match EconomyManager.BASE_GOLD_CAPACITY
	_add_building_to_settlement(TEMP_BUILDING_PATH)
	
	# Fill treasury to near cap (1500 - 10)
	_mock_settlement.treasury["gold"] = 1490
	
	# Payout tries to add 25
	EconomyManager.calculate_seasonal_payout("Spring")
	
	# Should be clamped at 1500
	assert_eq(_mock_settlement.treasury["gold"], 1500, "Treasury should not exceed calculated cap (1500)")

func test_stewardship_bonus():
	# Increase Jarl Skill to 20 (+50% bonus)
	_mock_jarl.stewardship = 20 
	_add_building_to_settlement(TEMP_BUILDING_PATH)
	
	var projection = EconomyManager.get_projected_income()
	# Base 100 * 1.5 = 150
	assert_eq(projection["gold"], 150, "Stewardship should boost income by 50%")

# --- HELPER ---

func _add_building_to_settlement(path: String):
	# Emulates the dictionary structure used by SettlementData
	_mock_settlement.placed_buildings.append({
		"resource_path": path,
		"peasant_count": 1, # 1 Worker assigned
		"thrall_count": 0,
		"grid_position": Vector2i(0,0)
	})


--------------------------------------------------
FILE: res:///test/unit/test_grid_math.gd
--------------------------------------------------
extends GutTestBase

func test_origin_alignment():
	var result = GridUtils.grid_to_iso(Vector2i(0, 0))
	assert_eq(result, Vector2(0, 0), "Origin (0,0) should map to World (0,0)")

func test_step_check():
	# Moving 1 X in grid (Down-Right in Iso)
	# x = (1 - 0) * 32 = 32
	# y = (1 + 0) * 16 = 16
	var result = GridUtils.grid_to_iso(Vector2i(1, 0))
	assert_eq(result, Vector2(32, 16), "Grid(1,0) should map to World(32, 16)")
	
	# Moving 1 Y in grid (Down-Left in Iso)
	# x = (0 - 1) * 32 = -32
	# y = (0 + 1) * 16 = 16
	result = GridUtils.grid_to_iso(Vector2i(0, 1))
	assert_eq(result, Vector2(-32, 16), "Grid(0,1) should map to World(-32, 16)")

func test_round_trip():
	var start_grid = Vector2i(5, 7)
	var world_pos = GridUtils.grid_to_iso(start_grid)
	var end_grid = GridUtils.iso_to_grid(world_pos)
	assert_eq(end_grid, start_grid, "Round trip conversion should match exactly")

func test_snap_to_grid():
	# Pixel perfect center is (32, 16) for (1,0)
	# We test a point slightly off-center: (33, 17)
	var input = Vector2(33, 17)
	var snapped = GridUtils.snap_to_grid(input)
	assert_eq(snapped, Vector2(32, 16), "Should snap 33,17 to the center 32,16")
	
func test_bounds_check():
	var grid = AStarGrid2D.new()
	grid.region = Rect2i(0, 0, 10, 10)
	
	assert_true(GridUtils.is_within_bounds(grid, Vector2i(5, 5)), "5,5 is inside")
	assert_false(GridUtils.is_within_bounds(grid, Vector2i(10, 10)), "10,10 is out of bounds (max is inclusive-exclusive)")
	assert_false(GridUtils.is_within_bounds(grid, Vector2i(-1, 0)), "-1 is out of bounds")


--------------------------------------------------
FILE: res:///test/unit/test_inventory_mechanics.gd
--------------------------------------------------
extends GutTestBase

var unit: BaseUnit
var unit_data: UnitData

func before_each():
	# Setup a mock unit with known capacity stats
	unit = BaseUnit.new()
	unit_data = UnitData.new()
	unit_data.max_loot_capacity = 100
	unit_data.encumbrance_speed_penalty = 0.5 # 50% slow at max load
	unit.data = unit_data

func after_each():
	unit.free()

func test_add_loot_under_cap():
	var added = unit.add_loot("gold", 50)
	assert_eq(added, 50, "Should add full amount when space exists")
	assert_eq(unit.current_loot_weight, 50, "Weight should update")
	assert_eq(unit.inventory["gold"], 50, "Inventory dictionary should update")

func test_add_loot_over_cap():
	unit.add_loot("gold", 80)
	var added = unit.add_loot("gold", 50) # Try adding 50 more (only 20 space left)
	
	assert_eq(added, 20, "Should only add what fits")
	assert_eq(unit.current_loot_weight, 100, "Should be capped at max")
	assert_eq(unit.inventory["gold"], 100, "Inventory should be capped")

func test_encumbrance_math():
	# 1. Empty = 1.0 speed multiplier
	assert_eq(unit.get_speed_multiplier(), 1.0, "Empty unit should have full speed")
	
	# 2. Half Full (50/100)
	# Logic: 50% load * 50% max_penalty = 25% total penalty -> 0.75 speed
	unit.add_loot("gold", 50)
	assert_eq(unit.get_speed_multiplier(), 0.75, "Half load should apply half penalty")
	
	# 3. Full (100/100)
	# Logic: 100% load * 50% max_penalty = 50% total penalty -> 0.5 speed
	unit.add_loot("gold", 50)
	assert_eq(unit.get_speed_multiplier(), 0.5, "Full load should apply max penalty")


--------------------------------------------------
FILE: res:///test/unit/test_spawn_logic.gd
--------------------------------------------------
extends GutTest

var _manager_ref
var _grid_width = 10
var _grid_height = 10

func before_all():
	# 1. Setup a Mock SettlementManager
	if has_node("/root/SettlementManager"):
		_manager_ref = get_node("/root/SettlementManager")
	else:
		_manager_ref = load("res://autoload/SettlementManager.gd").new()
		add_child_autofree(_manager_ref)
		
	# 2. Force Initialize the AStarGrid
	_manager_ref.active_astar_grid = AStarGrid2D.new()
	_manager_ref.active_astar_grid.region = Rect2i(0, 0, _grid_width, _grid_height)
	_manager_ref.active_astar_grid.cell_size = Vector2(64, 32)
	_manager_ref.active_astar_grid.update()
	
	# 3. FILL MAP WITH WATER (Make everything Solid)
	# We simulate a map that is 100% water initially
	for x in range(_grid_width):
		for y in range(_grid_height):
			_manager_ref.active_astar_grid.set_point_solid(Vector2i(x, y), true)

	# 4. Create a Tiny Island at (5,5)
	# Only (5,5) is walkable.
	_manager_ref.active_astar_grid.set_point_solid(Vector2i(5, 5), false)

func test_spawn_safety_check():
	# --- SCENARIO 1: Spawn in Deep Water (0,0) ---
	# There is no land nearby. Should return INF (Failure).
	var water_pos = _manager_ref.grid_to_world(Vector2i(0, 0))
	var result = _manager_ref.request_valid_spawn_point(water_pos, 2) # Check radius 2
	
	assert_eq(result, Vector2.INF, "Deep water spawn should fail (return INF).")

	# --- SCENARIO 2: Spawn Near Shore (5,4) ---
	# (5,4) is Water, but (5,5) is Land. Radius 1 should find it.
	var shore_water_pos = _manager_ref.grid_to_world(Vector2i(5, 4))
	var shore_result = _manager_ref.request_valid_spawn_point(shore_water_pos, 2)
	
	assert_ne(shore_result, Vector2.INF, "Shore spawn should find nearby land.")
	
	var result_grid = _manager_ref.world_to_grid(shore_result)
	assert_eq(result_grid, Vector2i(5, 5), "Should snap to the only valid land tile (5,5).")

func test_spawn_on_valid_land():
	# --- SCENARIO 3: Spawn on Land (5,5) ---
	# Already safe. Should return original position.
	var land_pos = _manager_ref.grid_to_world(Vector2i(5, 5))
	var result = _manager_ref.request_valid_spawn_point(land_pos, 2)
	
	# Note: It might snap to center, so distance should be near 0
	assert_almost_eq(result.x, land_pos.x, 1.0, "Valid land spawn should remain unchanged.")
	assert_almost_eq(result.y, land_pos.y, 1.0, "Valid land spawn should remain unchanged.")


--------------------------------------------------
FILE: res:///test/unit/test_squad_math.gd
--------------------------------------------------
# res://test/unit/test_squad_math.gd
extends GutTestBase

var formation: SquadFormation

func before_each():
	super.before_each() # Always call super!
	formation = SquadFormation.new()
	formation.unit_spacing = 50.0

func test_line_formation_positions():
	# Setup: 3 Units, Line Formation
	formation.set_formation_type(SquadFormation.FormationType.LINE)
	var center = Vector2(100, 100)
	var facing = Vector2.DOWN
	var count = 3
	
	# Execute
	# We fake the unit list size by passing 'count' to internal logic or just checking the math function directly if exposed.
	# Since _calculate_line_formation is internal, we test via the public API that returns points.
	# Note: We need to expose a way to test points without nodes, or mock the nodes.
	# For this test, we will rely on the fact that _calculate_formation_positions returns Array[Vector2]
	
	var points = formation._calculate_formation_positions(center, facing)
	
	# Assert
	# We expect 3 points.
	# Point 0 (Leader/Center): (100, 100)
	# Point 1 (Left): (50, 100)
	# Point 2 (Right): (150, 100) 
	# (Exact sorting depends on your algo, but count must be correct)
	
	# Actually, looking at your SquadFormation script, it requires 'units' array to be populated to know count.
	# Let's mock that.
	formation.units = [Node2D.new(), Node2D.new(), Node2D.new()] # 3 Mock Units
	
	points = formation._calculate_formation_positions(center, facing)
	
	assert_eq(points.size(), 3, "Should generate 3 points for 3 units.")
	assert_true(points.has(center), "Center point should exist.")
	
	# Cleanup Mocks
	for u in formation.units: u.free()

func test_box_formation_rotation():
	# Setup: 2 Units (Leader + 1), Box Formation
	# We want to verify that if we face RIGHT, the formation rotates.
	formation.units = [Node2D.new(), Node2D.new()]
	var center = Vector2.ZERO
	var facing = Vector2.RIGHT 
	
	var points = formation._calculate_formation_positions(center, facing)
	
	# Assert
	# If facing RIGHT, the "Side" unit should be rotated relative to the leader.
	# This confirms your rotation matrix math is working.
	var p2 = points[1]
	
	# In a Box/Line, if facing Down (0,1), p2 is at (x+spacing, y).
	# If facing Right (1,0), p2 should be at (x, y-spacing) or similar depending on rotation logic.
	assert_ne(p2, Vector2(50, 0), "Point should be rotated away from default.")
	
	for u in formation.units: u.free()


--------------------------------------------------
FILE: res:///test/unit/test_wergild.gd
--------------------------------------------------
extends GutTestBase

var bridge_instance = null
var bondi_data = null
var drengr_data = null
var popup_instance = null

func before_each():
	# 1. Setup Mock Data
	bondi_data = UnitData.new()
	bondi_data.wergild_cost = 50
	
	drengr_data = UnitData.new()
	drengr_data.wergild_cost = 100
	
	# 2. Use Factory for Bridge (Auto-mocks UnitContainer and UI)
	bridge_instance = TestUtils.create_mock_bridge()
	
	# 3. Use Factory for Popup
	popup_instance = TestUtils.create_mock_end_year_popup()
	bridge_instance.end_of_year_popup = popup_instance
	
	# 4. Add to Tree
	add_child_autofree(bridge_instance)
	add_child_autofree(popup_instance)

func test_wergild_calculation_simple():
	var result = {
		"gold_looted": 500,
		"casualties": [bondi_data, bondi_data] 
	}
	
	var total_wergild = 0
	for unit in result.casualties:
		total_wergild += unit.wergild_cost
		
	assert_eq(total_wergild, 100)
	var net_gold = result.gold_looted - total_wergild
	assert_eq(net_gold, 400)

func test_wergild_bankruptcy_protection():
	var result = {
		"gold_looted": 50,
		"casualties": [drengr_data] 
	}
	var total_wergild = result.casualties[0].wergild_cost
	var net_gold = max(0, result.gold_looted - total_wergild)
	assert_eq(net_gold, 0)


--------------------------------------------------
FILE: res:///test/unit/test_winter_math.gd
--------------------------------------------------
# res://test/unit/test_winter_math.gd
extends GutTest

var _default_harsh: float
var _default_mild: float

func before_all():
	# Save original defaults so we don't break other tests later
	_default_harsh = WinterManager.harsh_chance
	_default_mild = WinterManager.mild_chance

func after_each():
	# Reset to defaults after every test
	WinterManager.harsh_chance = _default_harsh
	WinterManager.mild_chance = _default_mild
	WinterManager.current_severity = WinterManager.WinterSeverity.NORMAL

func test_demand_calculation_normal():
	# 1. Setup
	var settlement = SettlementData.new()
	settlement.population_peasants = 100
	settlement.warbands.clear()
	
	# 2. FORCE NORMAL WINTER (0% chance of extreme weather)
	WinterManager.harsh_chance = 0.0
	WinterManager.mild_chance = 0.0
	
	# 3. Execute
	var report = WinterManager.calculate_winter_demand(settlement)
	
	# 4. Assert (100 pop * 1 = 100)
	assert_eq(report["food_demand"], 100, "Normal winter food should be 1:1.")
	assert_eq(report["wood_demand"], 20, "Base wood cost should be 20.")

func test_demand_calculation_harsh():
	# 1. Setup
	var settlement = SettlementData.new()
	settlement.population_peasants = 100
	settlement.warbands.clear()
	
	# 2. FORCE HARSH WINTER (100% chance)
	WinterManager.harsh_chance = 1.0
	WinterManager.mild_chance = 0.0
	
	# 3. Execute
	var report = WinterManager.calculate_winter_demand(settlement)
	
	# 4. Assert (100 * 1.5 = 150)
	assert_eq(report["food_demand"], 150, "Harsh winter should increase cost by 50%.")


--------------------------------------------------
FILE: res:///textures/placeholders/building_placeholder.tres
--------------------------------------------------
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://ds2w780g4nf1t"]

[resource]
size = Vector2(128, 128)


--------------------------------------------------
FILE: res:///textures/placeholders/defensive_placeholder.tres
--------------------------------------------------
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://db3pfgf4u4pql"]

[resource]
size = Vector2(96, 96)


--------------------------------------------------
FILE: res:///textures/placeholders/unit_placeholder.tres
--------------------------------------------------
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://bg2e08mncpjg1"]

[resource]
size = Vector2(64, 64)


--------------------------------------------------
FILE: res:///textures/placeholders/unit_texture.tres
--------------------------------------------------
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://cybqs3wt5wpg3"]

[resource]
size = Vector2(10, 2)


--------------------------------------------------
FILE: res:///tools/AIContentImporter.gd
--------------------------------------------------
# res://tools/AIContentImporter.gd
@tool
extends EditorScript

# --- INSTRUCTIONS ---
# 1. Ask the AI to generate content.
# 2. Use "sub_folder" to organize files (e.g., "player", "enemy", "bosses").
#
# Format: 
#   {
#       "type": "unit", 
#       "sub_folder": "player",  <-- NEW FIELD
#       "file_name": "Unit_Huscarl", 
#       "display_name": "Huscarl", 
#       ...
#   }

const BASE_DIR_UNITS = "res://data/units/"
const BASE_DIR_BUILDINGS = "res://data/buildings/"

# PASTE AI OUTPUT HERE
var RAW_DATA = [
	{
		"type": "building",
		"file_name": "Eco_Farm",
		"display_name": "Farmstead",
		"description": "A cluster of crops and livestock. Yields FOOD when raided.",
		"resource_type": "food", # Used by EconomicBuildingData
		"base_passive_output": 100, # Base loot amount
		"cost": { "wood": 50 },
		"stats": { "hp": 50, "construction_effort": 50 }
	},
	{
		"type": "building",
		"file_name": "Eco_Market",
		"display_name": "Trade Stall",
		"description": "A merchant's stall. Yields GOLD and GOODS when raided.",
		"resource_type": "gold",
		"base_passive_output": 75,
		"cost": { "wood": 100 },
		"stats": { "hp": 80, "construction_effort": 80 }
	},
	{
		"type": "building",
		"file_name": "Eco_Reliquary",
		"display_name": "Reliquary",
		"description": "A holy shrine containing silver and relics. Yields HIGH GOLD.",
		"resource_type": "gold",
		"base_passive_output": 150,
		"cost": { "stone": 100, "gold": 100 },
		"stats": { "hp": 60, "construction_effort": 120 }
	}
]

func _run():
	var count = 0
	
	for entry in RAW_DATA:
		var res: Resource
		var base_path = ""
		var sub_folder = entry.get("sub_folder", "generated") # Default to 'generated' if missing
		
		if entry["type"] == "unit":
			res = _create_unit(entry)
			base_path = BASE_DIR_UNITS
		elif entry["type"] == "building":
			res = _create_building(entry)
			base_path = BASE_DIR_BUILDINGS
			
		if res and base_path != "":
			# Construct full path with subfolder
			var target_dir = base_path.path_join(sub_folder)
			_ensure_dir(target_dir)
			
			var full_path = target_dir.path_join(entry["file_name"] + ".tres")
			
			var error = ResourceSaver.save(res, full_path)
			if error == OK:
				print(" Generated: %s" % full_path)
				count += 1
			else:
				print(" Failed to save: %s" % full_path)
	
	print("--- Import Complete: %d files created ---" % count)
	EditorInterface.get_resource_filesystem().scan()

func _create_unit(data: Dictionary) -> UnitData:
	var u = UnitData.new()
	u.display_name = data.get("display_name", "Unnamed")
	u.spawn_cost = data.get("cost", {})
	
	var stats = data.get("stats", {})
	u.max_health = stats.get("hp", 50)
	u.attack_damage = stats.get("dmg", 10)
	u.move_speed = stats.get("speed", 100.0)
	
	# Assign default scenes
	u.scene_to_spawn = load("res://scenes/units/PlayerVikingRaider.tscn")
	
	return u

func _create_building(data: Dictionary) -> BuildingData:
	# Default to Economic, can be changed
	var b = EconomicBuildingData.new() 
	b.display_name = data.get("display_name", "Unnamed")
	b.description = data.get("description", "No description provided.")
	b.build_cost = data.get("cost", {})
	
	var stats = data.get("stats", {})
	b.max_health = stats.get("hp", 200)
	b.construction_effort_required = stats.get("construction_effort", 100)
	
	# --- NEW: Import Fleet Capacity ---
	if data.has("fleet_capacity"):
		b.fleet_capacity_bonus = data["fleet_capacity"]
	# ----------------------------------
	
	# Assign default scenes
	# If you have a specific Naust scene, you can change this line manually later
	# or add logic here to pick based on name.
	b.scene_to_spawn = load("res://scenes/buildings/Base_Building.tscn")
	b.is_player_buildable = true 
	
	return b
func _ensure_dir(path: String):
	if not DirAccess.dir_exists_absolute(path):
		DirAccess.make_dir_recursive_absolute(path)


--------------------------------------------------
FILE: res:///tools/AIContentImporter_Template.gd
--------------------------------------------------
# res://tools/ContentImporter.gd
@tool
extends EditorScript

# --- INSTRUCTIONS ---
# 1. Ask the AI to generate content using the format in 'RAW_DATA'.Example:
#	"Give me the output as a JSON-style array of dictionaries compatible with my Godot importer. 
#	Format: {"type": "unit", "file_name": "Unique_File_Name", "display_name": "In Game Name", "stats": {"hp": int, "dmg": int, "speed": float}, "cost": {"gold": int}}
# 2. Paste the AI's output into the 'RAW_DATA' variable below.
# 3. Run this script (File > Run or Ctrl+Shift+X).
# 4. The .tres files will appear in the target folder.

const SAVE_DIR_UNITS = "res://data/units/generated/"
const SAVE_DIR_BUILDINGS = "res://data/buildings/generated/"

# PASTE AI OUTPUT HERE
var RAW_DATA = [
	{
		"type": "unit",
		"file_name": "Enemy_Berserker",
		"display_name": "Frenzied Berserker",
		"stats": { "hp": 80, "dmg": 25, "speed": 120.0 },
		"cost": { "gold": 50, "food": 50 }
	},
	{
		"type": "building",
		"file_name": "Eco_Fishery",
		"display_name": "Fisherman's Hut",
		"stats": { "hp": 150, "construction_effort": 120 },
		"cost": { "wood": 100 }
	}
]

func _run():
	# Ensure directories exist
	_ensure_dir(SAVE_DIR_UNITS)
	_ensure_dir(SAVE_DIR_BUILDINGS)
	
	var count = 0
	
	for entry in RAW_DATA:
		var res: Resource
		var path: String
		
		if entry["type"] == "unit":
			res = _create_unit(entry)
			path = SAVE_DIR_UNITS + entry["file_name"] + ".tres"
		elif entry["type"] == "building":
			res = _create_building(entry)
			path = SAVE_DIR_BUILDINGS + entry["file_name"] + ".tres"
			
		if res:
			var error = ResourceSaver.save(res, path)
			if error == OK:
				print(" Generated: %s" % path)
				count += 1
			else:
				print(" Failed to save: %s" % path)
	
	print("--- Import Complete: %d files created ---" % count)
	EditorInterface.get_resource_filesystem().scan()

func _create_unit(data: Dictionary) -> UnitData:
	var u = UnitData.new()
	u.display_name = data.get("display_name", "Unnamed")
	u.spawn_cost = data.get("cost", {})
	
	var stats = data.get("stats", {})
	u.max_health = stats.get("hp", 50)
	u.attack_damage = stats.get("dmg", 10)
	u.move_speed = stats.get("speed", 100.0)
	
	# Assign default scenes (You can change these later in Inspector)
	u.scene_to_spawn = load("res://scenes/units/EnemyVikingRaider.tscn")
	
	return u

func _create_building(data: Dictionary) -> BuildingData:
	# Default to Economic, can be changed
	var b = EconomicBuildingData.new() 
	b.display_name = data.get("display_name", "Unnamed")
	b.build_cost = data.get("cost", {})
	
	var stats = data.get("stats", {})
	b.max_health = stats.get("hp", 200)
	b.construction_effort_required = stats.get("construction_effort", 100)
	
	# Assign default scenes
	b.scene_to_spawn = load("res://scenes/buildings/Base_Building.tscn")
	
	return b

func _ensure_dir(path: String):
	if not DirAccess.dir_exists_absolute(path):
		DirAccess.make_dir_recursive_absolute(path)


--------------------------------------------------
FILE: res:///tools/ContextGenerator_Gemini.gd
--------------------------------------------------
@tool
extends EditorScript

# =============================================================================
# GODOT AI CONTEXT GENERATOR (V3 - API MAP OPTIMIZED)
# =============================================================================
# Improvements:
# 1. Parsing: Now captures 'static', '@onready', and modifier keywords correctly.
# 2. Format: Outputs Markdown (.md) for superior Gemini navigation.
# 3. Size: Aggressively trims whitespace to save context tokens.
# =============================================================================

const OUTPUT_DIR = "res://_context_dumps"
const OUTPUT_FILENAME = "gemini_api_map.md" # Changed to .md

const IGNORE_DIRS = [
	"res://addons", "res://.godot", "res://.git", 
	"res://assets", "res://exports", "res://_context_dumps"
]

const INCLUDE_EXTENSIONS = ["gd", "tscn", "tres"]

# Max file size to parse (1MB)
const MAX_FILE_SIZE_BYTES = 1024 * 1024 

# FLUFF FILTER: Skip these resource types
const SKIP_RESOURCE_TYPES = [
	"TileSet", "NavigationPolygon", "Mesh", "ArrayMesh", 
	"CompressedTexture2D", "Image", "AudioStreamWAV", "AudioStreamMP3",
	"FontFile", "StyleBoxFlat", "StyleBoxTexture", "Theme", "GradientTexture2D"
]

var _preload_map = {} 

func _run() -> void:
	print("---  Starting Gemini API Map Generation (V3) ---")
	var time_start = Time.get_ticks_msec()
	
	if not DirAccess.dir_exists_absolute(OUTPUT_DIR):
		DirAccess.make_dir_recursive_absolute(OUTPUT_DIR)
	
	var out_path = OUTPUT_DIR + "/" + OUTPUT_FILENAME
	var file = FileAccess.open(out_path, FileAccess.WRITE)
	if not file:
		printerr(" Error: Could not open output file.")
		return

	# 1. Header
	file.store_line("# PROJECT API MAP")
	file.store_line("> **CONTEXT INSTRUCTION:** This file contains the STRUCTURE of the project. Implementation details are hidden to save space. Use this to understand available classes, functions, and signals.")
	file.store_line("> Generated: %s\n" % Time.get_datetime_string_from_system())

	# 2. Gather & Sort Files
	var all_files = _get_all_files("res://")
	var gd_files: Array[String] = []
	var tscn_files: Array[String] = []
	var tres_files: Array[String] = []
	
	for p in all_files:
		match p.get_extension():
			"gd": gd_files.append(p)
			"tscn": tscn_files.append(p)
			"tres": tres_files.append(p)
	
	gd_files.sort()
	tscn_files.sort()
	tres_files.sort()

	# 3. Build Content (Markdown Format)
	var buffer: Array[String] = []
	
	# -- Architecture Overview --
	buffer.append("##  GLOBAL ARCHITECTURE")
	_write_architecture(buffer)
	
	# -- Scenes --
	buffer.append("\n##  SCENE STRUCTURES")
	for p in tscn_files:
		buffer.append(_parse_scene(p))

	# -- Scripts (The API) --
	buffer.append("\n##  SCRIPT API (Logic Structures)")
	for p in gd_files:
		buffer.append(_parse_script(p))
		
	# -- Data --
	buffer.append("\n##  GAME DATA (Resources)")
	for p in tres_files:
		var res_text = _parse_resource(p)
		if res_text != "": buffer.append(res_text)

	# -- Dependencies --
	if not _preload_map.is_empty():
		buffer.append("\n##  DEPENDENCY GRAPH")
		_write_dependencies(buffer)

	# 4. Save
	file.store_string("\n".join(buffer))
	file.close()
	
	var elapsed = (Time.get_ticks_msec() - time_start) / 1000.0
	print(" API Map Generated: %s" % out_path)
	print(" Time: %.2fs | Files: %d" % [elapsed, all_files.size()])
	
	OS.shell_open(ProjectSettings.globalize_path(OUTPUT_DIR))

# =============================================================================
# PARSERS
# =============================================================================

func _write_architecture(out: Array):
	out.append("### Autoloads (Singletons)")
	var found = false
	for prop in ProjectSettings.get_property_list():
		if prop.name.begins_with("autoload/"):
			var name = prop.name.trim_prefix("autoload/")
			var path = ProjectSettings.get_setting(prop.name).replace("*", "")
			out.append("- **%s**: `%s`" % [name, path])
			found = true
	if not found: out.append("(None)")
	
	out.append("\n### Physics Layers")
	for i in range(1, 33):
		var layer = ProjectSettings.get_setting("layer_names/2d_physics/layer_%d" % i)
		if layer: out.append("- Layer %d: %s" % [i, layer])

func _parse_script(path: String) -> String:
	var f = FileAccess.open(path, FileAccess.READ)
	if not f: return ""
	if f.get_length() > MAX_FILE_SIZE_BYTES: return "### %s\n(Skipped - Too Large)" % path

	var lines: Array[String] = []
	var local_preloads = []
	
	while not f.eof_reached():
		var line = f.get_line()
		var s = line.strip_edges()
		
		# Capture Preloads
		if "preload(" in line or "load(" in line:
			var dep = _extract_preload(line)
			if dep: local_preloads.append(dep)

		# SENIOR FIX: Robust Keyword Detection
		# We check if the line STARTS with these, OR if it's an onready/static var
		var is_structure = false
		
		if s.begins_with("extends") or s.begins_with("class_name"):
			is_structure = true
		elif s.begins_with("signal") or s.begins_with("enum"):
			is_structure = true
		elif s.begins_with("const"):
			is_structure = true
		
		# Variable Logic (Catch @onready and @export)
		elif s.begins_with("var") or s.begins_with("@"):
			# Only keep if it defines data, skip random annotations if they aren't variables
			if "var " in s or "@export" in s or "signal " in s:
				is_structure = true
		
		# Function Logic (Catch static func)
		elif "func " in s: 
			# We filter out indented lambdas if necessary, but usually top-level funcs are fine
			# This captures "static func", "func _ready():", etc.
			if not s.begins_with("#"): # Ignore commented out functions
				is_structure = true

		if is_structure:
			lines.append(line)

	f.close()
	
	if not local_preloads.is_empty():
		_preload_map[path] = local_preloads

	# Markdown Code Block
	return "\n### `%s`\n```gdscript\n%s\n```" % [path, "\n".join(lines)]

func _parse_scene(path: String) -> String:
	var f = FileAccess.open(path, FileAccess.READ)
	if not f: return ""
	
	var nodes = {} 
	var connections = []
	var ext_res = {} 
	
	while not f.eof_reached():
		var line = f.get_line().strip_edges()
		
		if line.begins_with("[ext_resource"):
			var id = _get_attr(line, "id")
			var p = _get_attr(line, "path")
			if id and p: ext_res[id] = p
			
		elif line.begins_with("[node"):
			var name = _get_attr(line, "name")
			var type = _get_attr(line, "type")
			var parent = _get_attr(line, "parent")
			var script_id = _extract_res_id(line)
			var script_path = ""
			if script_id and ext_res.has(script_id): script_path = ext_res[script_id].get_file()
			if parent == "": parent = "."
			
			var full_path = name if parent == "." else parent + "/" + name
			nodes[full_path] = {"name": name, "type": type, "script": script_path, "parent": parent, "children": []}
			
		elif line.begins_with("[connection"):
			# Parse connection for readability: "signal='timeout' from='Timer' to='.'"
			var sig = _get_attr(line, "signal")
			var from = _get_attr(line, "from")
			var to = _get_attr(line, "to")
			var method = _get_attr(line, "method")
			connections.append("- `%s` -> `%s` :: %s()" % [from, to, method])

	f.close()
	
	# Build Tree
	var roots = []
	for p in nodes:
		var n = nodes[p]
		if n.parent == ".": roots.append(p)
		elif nodes.has(n.parent): nodes[n.parent].children.append(p)
	
	var out: Array[String] = []
	for r in roots: _print_tree(nodes, r, 0, out)
	
	var tree_str = "\n".join(out)
	var signal_str = ""
	if not connections.is_empty():
		signal_str = "\n**Signals:**\n" + "\n".join(connections)
		
	return "\n### `%s`\n%s%s" % [path, tree_str, signal_str]

func _print_tree(nodes: Dictionary, key: String, depth: int, out: Array):
	var n = nodes[key]
	var indent = "  ".repeat(depth)
	var s_info = " (`%s`)" % n.script if n.script else ""
	out.append("%s- **%s** [%s]%s" % [indent, n.name, n.type, s_info])
	for child in n.children: _print_tree(nodes, child, depth + 1, out)

func _parse_resource(path: String) -> String:
	var f = FileAccess.open(path, FileAccess.READ)
	if not f: return ""
	
	# Check for filter
	var type_line = ""
	var content = []
	var is_filtered = false
	
	while not f.eof_reached():
		var line = f.get_line()
		content.append(line)
		if line.begins_with("[gd_resource"):
			var type = _get_attr(line, "type")
			if type in SKIP_RESOURCE_TYPES:
				is_filtered = true
				break
	f.close()
	
	if is_filtered: return ""
	
	# Compress output
	var clean_lines: Array[String] = []
	clean_lines.append(content[0]) # Header
	
	for i in range(1, content.size()):
		var s = content[i].strip_edges()
		if s == "": continue
		if s.begins_with("metadata/"): continue
		
		# Truncate arrays
		if s.length() > 150: 
			clean_lines.append(s.substr(0, 150) + "...")
		else:
			clean_lines.append(s)
			
	return "\n### `%s`\n```text\n%s\n```" % [path, "\n".join(clean_lines)]

func _write_dependencies(out: Array):
	for k in _preload_map:
		out.append("- `%s`" % k)
		for d in _preload_map[k]: 
			out.append("  - depends on: `%s`" % d)

# =============================================================================
# UTILS
# =============================================================================

func _get_all_files(path: String) -> Array:
	var res = []
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var n = dir.get_next()
		while n != "":
			if dir.current_is_dir():
				if n not in [".", ".."]:
					var full = path + "/" + n
					var skip = false
					for i in IGNORE_DIRS: if full.begins_with(i): skip = true
					if not skip: res.append_array(_get_all_files(full))
			else:
				if n.get_extension() in INCLUDE_EXTENSIONS: res.append(path + "/" + n)
			n = dir.get_next()
	return res

func _get_attr(line: String, attr: String) -> String:
	var start = line.find(attr + "=")
	if start == -1: return ""
	start += attr.length() + 1
	var quote = '"'
	if start < line.length() and line[start] == "'": quote = "'"
	var end = line.find(quote, start + 1)
	if end != -1: return line.substr(start + 1, end - start - 1)
	return ""

func _extract_res_id(line: String) -> String:
	var i = line.find("ExtResource(")
	if i == -1: return ""
	var sub = line.substr(i)
	var quote = '"'
	if "'" in sub: quote = "'"
	var start = sub.find(quote) + 1
	var end = sub.find(quote, start)
	return sub.substr(start, end - start)

func _extract_preload(line: String) -> String:
	var i = line.find("preload(")
	if i == -1: i = line.find("load(")
	if i == -1: return ""
	var sub = line.substr(i)
	var quote = '"'
	if "'" in sub: quote = "'"
	var start = sub.find(quote) + 1
	var end = sub.find(quote, start)
	if start > 0 and end > start: return sub.substr(start, end - start)
	return ""


--------------------------------------------------
FILE: res:///tools/ContextGenerator_NotebookLM.gd
--------------------------------------------------
@tool
extends EditorScript

# =============================================================================
# NOTEBOOKLM SOURCE GENERATOR (V3 - FULL DUMP)
# =============================================================================
# OBJECTIVE: Dump the ENTIRE source code of the project.
# DIFFERS FROM GEMINI SCRIPT: This does NOT filter function bodies. 
# It includes every line of logic so NotebookLM can analyze implementation.
# =============================================================================

# OUTPUT FILE - Distinct name to avoid mix-ups
const OUTPUT_PATH = "res://_context_dumps/_NBLM_FULL_SOURCE.txt" 

# Recursive directories to scan
const SCAN_DIRS = ["res://"]

# Ignore list (Technical noise)
const IGNORE_DIRS = [
	"res://addons", "res://.godot", "res://.git", 
	"res://assets", "res://exports", "res://_context_dumps"
]

# Files to include
const INCLUDE_EXTENSIONS = ["gd", "tscn", "tres"]

func _run() -> void:
	print("---  Starting NotebookLM Full Source Dump ---")
	var time_start = Time.get_ticks_msec()
	
	var file = FileAccess.open(OUTPUT_PATH, FileAccess.WRITE)
	if not file:
		printerr(" Error: Could not open output file: %s" % OUTPUT_PATH)
		return

	# 1. Explicit Header for the AI
	file.store_line("PROJECT SOURCE CODE LIBRARY")
	file.store_line("===========================")
	file.store_line("CONTAINS: Full Implementation Logic, Scene Trees, and Resource Data.")
	file.store_line("INSTRUCTION: This is the raw source code. Use this to answer specific implementation questions.")
	file.store_line("GENERATED: %s" % Time.get_datetime_string_from_system())
	file.store_line("===========================\n")

	# 2. Gather Files
	var all_files = _get_all_files("res://")
	
	# Sort to keep folders together
	all_files.sort()

	# 3. Process
	for path in all_files:
		_process_file(path, file)

	file.close()
	
	var elapsed = (Time.get_ticks_msec() - time_start) / 1000.0
	print(" Full Source Saved: %s" % OUTPUT_PATH)
	print(" Time: %.2fs | Files Parsed: %d" % [elapsed, all_files.size()])
	
	# Auto-open the folder so you see the file
	OS.shell_open(ProjectSettings.globalize_path("res://_context_dumps"))

# =============================================================================
# FILE PROCESSORS
# =============================================================================

func _process_file(path: String, f: FileAccess):
	var ext = path.get_extension()
	
	# Standard separator
	f.store_line("\n" + "-".repeat(50))
	f.store_line("FILE: " + path)
	f.store_line("-".repeat(50))
	
	match ext:
		"gd": _write_script_content(path, f)
		"tscn": _write_scene_smart(path, f)
		"tres": _write_resource_content(path, f)

func _write_script_content(path: String, f: FileAccess):
	# CRITICAL: We use get_file_as_string to ensure we get THE WHOLE FILE.
	# We do NOT filter for "func" or "var". We want the logic.
	var content = FileAccess.get_file_as_string(path)
	f.store_line(content)

func _write_resource_content(path: String, f: FileAccess):
	var content = FileAccess.get_file_as_string(path)
	# Skip binary blobs
	if content.length() > 50000:
		f.store_line("[Skipped - File too large]")
		return
	f.store_line(content)

func _write_scene_smart(path: String, f: FileAccess):
	# We just dump the text. NotebookLM is smart enough to read raw .tscn
	# if we give it the whole file. 
	var content = FileAccess.get_file_as_string(path)
	f.store_line(content)

# =============================================================================
# UTILS
# =============================================================================

func _get_all_files(path: String) -> Array:
	var res = []
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var n = dir.get_next()
		while n != "":
			if dir.current_is_dir():
				if n not in [".", ".."]:
					var full = path + "/" + n
					var skip = false
					for i in IGNORE_DIRS: if full.begins_with(i): skip = true
					if not skip: res.append_array(_get_all_files(full))
			else:
				if n.get_extension() in INCLUDE_EXTENSIONS: res.append(path + "/" + n)
			n = dir.get_next()
	return res


--------------------------------------------------
FILE: res:///tools/EditorOnly.gd
--------------------------------------------------
# res://tools/UpdateRegionNames.gd
@tool
extends EditorScript

const SCENE_PATH = "res://scenes/world_map/MacroMap.tscn"

# The Historical Mapping provided by your consultant
const NAME_MAP = {
	"Region_Southern_Sweden": "Geatland",
	"Region_Southern_Norway": "Viken",
	"Region_Northern_Sweden": "Swealand",
	"Region_Northern_Norway": "Halogaland",
	"Region_Denmark": "Denmark",
	"Region_Finland": "Kvenland",
	"Region_Estonia": "Estland",
	"Region_Northern_Baltics": "Courland",
	"Region_Southern_Baltics": "Samland",
	"Region_10": "Bjarmaland",
	"Region_Germany_East": "Wendland",
	"Region_Germany_West": "Saxony",
	"Region_Francia": "Frankland",
	"Region_Brittain": "Britland"
}

func _run():
	print("---  Updating Historical Region Names ---")
	
	# 1. Load the Scene
	var scene = load(SCENE_PATH).instantiate()
	var regions_root = scene.get_node_or_null("Regions")
	
	if not regions_root:
		printerr("Error: Could not find 'Regions' node in MacroMap.tscn")
		scene.free()
		return
		
	var count = 0
	
	# 2. Iterate through our map
	for node_name in NAME_MAP:
		var region_node = regions_root.get_node_or_null(node_name)
		
		if region_node:
			var new_name = NAME_MAP[node_name]
			
			# Ensure Data Exists
			if not region_node.data:
				region_node.data = WorldRegionData.new()
				print(" > Created missing data for %s" % node_name)
			
			# CRITICAL: Make Unique
			# Many regions currently share "Resource_seg4e". 
			# We must duplicate it so changing one doesn't change them all.
			region_node.data = region_node.data.duplicate()
			
			# Update Name
			region_node.data.display_name = new_name
			print(" > Renamed [%s] -> %s" % [node_name, new_name])
			count += 1
		else:
			printerr("  Node not found: ", node_name)
			
	# 3. Save Changes
	if count > 0:
		var packed = PackedScene.new()
		packed.pack(scene)
		var err = ResourceSaver.save(packed, SCENE_PATH)
		
		if err == OK:
			print(" Success! %d regions updated." % count)
			print("   Scene saved to: ", SCENE_PATH)
			EditorInterface.get_resource_filesystem().scan()
		else:
			printerr(" Failed to save scene. Error: ", err)
	
	scene.free()


--------------------------------------------------
FILE: res:///tools/EnemyBaseEditor.gd
--------------------------------------------------
@tool
extends EditorScript

# Simple Enemy Base Layout Editor
# Usage: Tools -> Execute Script to run this

func _run():
	print("=== ENEMY BASE LAYOUT EDITOR ===")
	
	var settlement_path = "res://data/settlements/monastery_base.tres"
	var settlement_data: SettlementData = load(settlement_path)
	
	if not settlement_data:
		print("ERROR: Could not load settlement data!")
		return
	
	print("Current layout for: " + settlement_path)
	print("Grid positions (format: Building @ X,Y):")
	print("-".repeat(40))
	
	for i in range(settlement_data.placed_buildings.size()):
		var building = settlement_data.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("-".repeat(40))
	print("To modify layout:")
	print("1. Edit grid_position values in the .tres file")
	print("2. Or use this script to create new layouts")
	print("3. Grid range: 0-%d (width), 0-%d (height)" % [
		SettlementManager.grid_width-1, 
		SettlementManager.grid_height-1
	])

# Helper function to create new enemy base layouts
static func create_enemy_base_layout(buildings: Array[Dictionary], save_path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 500, "wood": 200, "food": 150, "stone": 100}
	settlement.placed_buildings = buildings
	
	ResourceSaver.save(settlement, save_path)
	print("Created new enemy base: " + save_path)

# Example usage:
# EnemyBaseEditor.create_fortress_layout()
static func create_fortress_layout():
	var buildings = [
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(32, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	create_enemy_base_layout(buildings, "res://data/settlements/fortress_base.tres")


--------------------------------------------------
FILE: res:///tools/GenerateBandContent.gd
--------------------------------------------------
# res://tools/GenerateBondiContent.gd
@tool
extends EditorScript

func _run():
	print("--- Generating Bondi Content ---")
	
	# 1. Create Unit Data
	var bondi_data = UnitData.new()
	bondi_data.display_name = "Bondi"
	bondi_data.max_health = 40 # Slightly tougher than a peasant
	bondi_data.attack_damage = 6 
	bondi_data.move_speed = 75.0
	bondi_data.spawn_cost = {"food": 0} # Costs population to draft
	
	# Link to the scene
	bondi_data.scene_path = "res://scenes/units/Bondi.tscn"
	
	# Load visual
	if ResourceLoader.exists("res://ui/assets/res_peasant.png"):
		bondi_data.icon = load("res://ui/assets/res_peasant.png")
	
	# Save Data
	ResourceSaver.save(bondi_data, "res://data/units/Unit_Bondi.tres")
	print("Saved UnitData: res://data/units/Unit_Bondi.tres")
	
	# 2. Create Unit Scene
	var source_path = "res://scenes/units/PlayerVikingRaider.tscn"
	if ResourceLoader.exists(source_path):
		var base_scene = load(source_path).instantiate()
		
		# Tint them brownish/green to look like farmers
		base_scene.modulate = Color(0.6, 0.7, 0.5) 
		
		var packed = PackedScene.new()
		packed.pack(base_scene)
		ResourceSaver.save(packed, "res://scenes/units/Bondi.tscn")
		print("Saved Scene: res://scenes/units/Bondi.tscn")
		base_scene.queue_free()
	else:
		printerr("Could not find source scene to clone!")
		
	EditorInterface.get_resource_filesystem().scan()


--------------------------------------------------
FILE: res:///tools/GenerateRaidMap.gd
--------------------------------------------------
# res://tools/GenerateRaidMap.gd
@tool
extends EditorScript

# --- CONFIGURATION ---
const TARGET_PATH = "res://data/settlements/generated/raid_rich_hub_01.tres"
const GRID_W = 80 
const GRID_H = 50
const BEACH_WIDTH = 15 

# --- BUILDING PALETTE ---
const B_HALL = "res://data/buildings/GreatHall.tres"
const B_WALL = "res://data/buildings/Bldg_Wall.tres"
const B_TOWER = "res://data/buildings/Monastery_Watchtower.tres"

const RICH_BUILDINGS = [
	"res://data/buildings/Monastery_Library.tres",
	"res://data/buildings/Monastery_Scriptorium.tres",
	"res://data/buildings/Monastery_Chapel.tres"
]

const MID_BUILDINGS = [
	"res://data/buildings/Monastery_Granary.tres",
	"res://data/buildings/Monastery_Granary.tres" 
]

const POOR_BUILDINGS = [
	"res://data/buildings/Player_Farm.tres",
	"res://data/buildings/LumberYard.tres"
]

# --- STATE ---
var occupied_cells: Dictionary = {}
var placed_list: Array[Dictionary] = []

func _run() -> void:
	print("--- Generating Procedural Raid Map (The Hub) ---")
	_reset()
	
	var center = Vector2i(int(GRID_W * 0.7), int(GRID_H * 0.5))
	
	_place_building(B_HALL, center)
	_generate_citadel_layer(center, 6, 10)
	_generate_scatter_layer(center, 12, 20, MID_BUILDINGS, 0.6)
	_generate_scatter_layer(center, 22, 35, POOR_BUILDINGS, 0.3)
	
	_save_resource()

func _reset() -> void:
	occupied_cells.clear()
	placed_list.clear()

func _generate_citadel_layer(center: Vector2i, radius_min: int, radius_max: int) -> void:
	for x in range(center.x - radius_max, center.x + radius_max + 1):
		for y in range(center.y - radius_max, center.y + radius_max + 1):
			var pos = Vector2i(x, y)
			var dist = Vector2(pos).distance_to(Vector2(center))
			
			if dist >= radius_max - 1.5 and dist <= radius_max:
				if abs(pos.y - center.y) < 3 and pos.x < center.x:
					continue
					
				if (x % 6 == 0 and y % 6 == 0) or dist > radius_max - 0.5:
					_try_place(B_TOWER, pos)
				else:
					_try_place(B_WALL, pos)
					
	var attempts = 20
	for i in range(attempts):
		var building = RICH_BUILDINGS.pick_random()
		var offset = Vector2(randf_range(-1, 1), randf_range(-1, 1)).normalized() * randf_range(radius_min, radius_max - 2)
		var pos = center + Vector2i(offset)
		_try_place(building, pos)

func _generate_scatter_layer(center: Vector2i, r_min: int, r_max: int, palette: Array, density: float) -> void:
	for x in range(center.x - r_max, center.x + r_max):
		for y in range(center.y - r_max, center.y + r_max):
			var pos = Vector2i(x, y)
			
			if pos.x < BEACH_WIDTH: continue
			
			var dist = Vector2(pos).distance_to(Vector2(center))
			
			if dist > r_min and dist < r_max:
				if randf() < density * 0.1: 
					var b = palette.pick_random()
					_try_place(b, pos)

func _try_place(path: String, grid_pos: Vector2i) -> void:
	var data = load(path) as BuildingData
	if not data: return
	
	var size = data.grid_size
	
	if grid_pos.x < BEACH_WIDTH: return
	if grid_pos.x + size.x >= GRID_W: return
	if grid_pos.y < 0 or grid_pos.y + size.y >= GRID_H: return
	
	for x in range(size.x):
		for y in range(size.y):
			var check = grid_pos + Vector2i(x, y)
			if occupied_cells.has(check):
				return 
				
	_place_building(path, grid_pos)

func _place_building(path: String, grid_pos: Vector2i) -> void:
	var data = load(path) as BuildingData
	var size = data.grid_size
	
	for x in range(size.x):
		for y in range(size.y):
			occupied_cells[grid_pos + Vector2i(x, y)] = true
			
	placed_list.append({
		"resource_path": path,
		"grid_position": grid_pos
	})

func _save_resource() -> void:
	var dir = TARGET_PATH.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir):
		DirAccess.make_dir_recursive_absolute(dir)
		
	var s_data = SettlementData.new()
	s_data.placed_buildings = placed_list
	s_data.treasury = {"gold": 2000, "wood": 1000, "food": 800, "stone": 500}
	
	# --- FIX: Use clear() instead of assignment to respect strict typing ---
	s_data.warbands.clear() 
	# ---------------------------------------------------------------------
	
	var err = ResourceSaver.save(s_data, TARGET_PATH)
	if err == OK:
		print(" Map Saved: ", TARGET_PATH)
		print("   Buildings: ", placed_list.size())
		EditorInterface.get_resource_filesystem().scan()
	else:
		printerr(" Save Failed: ", err)


--------------------------------------------------
FILE: res:///tools/LevelExporter.gd
--------------------------------------------------
# res://tools/LevelExporter.gd
@tool
extends EditorScript

# --- CONFIGURATION ---
# CHANGE THIS PATH before running the script to save to a new file.
const TARGET_SAVE_PATH = "res://data/settlements/new_raid_map.tres"
const CONTAINER_NAME = "BuildingContainer"
const CELL_SIZE = Vector2(32, 32)

func _run():
	# 1. Get the Active Scene Root
	# FIXED: Called directly from the EditorInterface type
	var root = EditorInterface.get_edited_scene_root()
	if not root:
		print("Error: No scene open.")
		return

	# 2. Find the Container
	var container = root.get_node_or_null(CONTAINER_NAME)
	if not container:
		print("Error: Could not find '%s' node. Ensure your scene has a node named exactly '%s'." % [CONTAINER_NAME, CONTAINER_NAME])
		return

	# 3. Create the Data Object
	var settlement_data = SettlementData.new()
	# Default treasury for a raid target (can be edited in Inspector later)
	settlement_data.treasury = {"gold": 500, "wood": 500, "food": 500, "stone": 200}
	settlement_data.placed_buildings = []
	# Initialize garrison with default enemy
	settlement_data.warbands = [] 

	# 4. Scrape the Buildings
	var buildings = container.get_children()
	var count = 0

	for node in buildings:
		# Skip hidden nodes (allows us to temporarily remove things without deleting)
		if not node.visible:
			continue

		if node is BaseBuilding and node.data:
			# Calculate Top-Left Grid Position
			# BaseBuilding centers sprites, so we offset by half size to get grid origin
			var building_size_px = Vector2(node.data.grid_size) * CELL_SIZE
			var top_left_pos = node.position - (building_size_px / 2.0)

			# Round to nearest tile to handle imprecise dragging
			var grid_x = round(top_left_pos.x / CELL_SIZE.x)
			var grid_y = round(top_left_pos.y / CELL_SIZE.y)
			var grid_pos = Vector2i(grid_x, grid_y)

			# Construct the Dictionary Entry expected by SettlementData
			var entry = {
				"resource_path": node.data.resource_path,
				"grid_position": grid_pos
			}

			settlement_data.placed_buildings.append(entry)
			count += 1
		else:
			print("Warning: Found non-building node '%s' in container. Skipping." % node.name)

	# 5. Save to Disk
	var error = ResourceSaver.save(settlement_data, TARGET_SAVE_PATH)
	if error == OK:
		print(" SUCCESS: Exported %d buildings to %s" % [count, TARGET_SAVE_PATH])
		# FIXED: Called directly from the EditorInterface type
		EditorInterface.get_resource_filesystem().scan()
	else:
		print(" ERROR: Failed to save resource. Error Code: %s" % error)


--------------------------------------------------
FILE: res:///tools/Raid_prep_generatory.gd
--------------------------------------------------
# res://tools/SceneGenerator_RaidPrep.gd
@tool
extends EditorScript

const SCENE_PATH = "res://ui/RaidPrepWindow.tscn"
const SCRIPT_PATH = "res://ui/RaidPrepWindow.gd"

func _run() -> void:
	print("--- Generating Raid Prep Window Scene (v3 - Bondi) ---")
	
	var root = PanelContainer.new()
	root.name = "RaidPrepWindow"
	var script = load(SCRIPT_PATH)
	if not script:
		printerr("Error: Could not find script at ", SCRIPT_PATH)
		return
	root.set_script(script)
	
	var margin = MarginContainer.new()
	margin.name = "MarginContainer"
	margin.add_theme_constant_override("margin_top", 20)
	margin.add_theme_constant_override("margin_left", 20)
	margin.add_theme_constant_override("margin_right", 20)
	margin.add_theme_constant_override("margin_bottom", 20)
	root.add_child(margin)
	margin.set_owner(root)
	
	var main_vbox = VBoxContainer.new()
	main_vbox.name = "MainVBox"
	main_vbox.add_theme_constant_override("separation", 10)
	margin.add_child(main_vbox)
	main_vbox.set_owner(root)
	
	# Header
	var header = Label.new()
	header.name = "HeaderLabel"
	header.text = "Muster the Leidang" # Historically accurate flavor!
	header.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	header.add_theme_font_size_override("font_size", 24)
	main_vbox.add_child(header)
	header.set_owner(root)
	
	var sep1 = HSeparator.new()
	sep1.name = "HSeparator"
	main_vbox.add_child(sep1)
	sep1.set_owner(root)
	
	# Content
	var content_hbox = HBoxContainer.new()
	content_hbox.name = "ContentHBox"
	content_hbox.size_flags_vertical = Control.SIZE_EXPAND_FILL
	content_hbox.add_theme_constant_override("separation", 20)
	main_vbox.add_child(content_hbox)
	content_hbox.set_owner(root)
	
	# --- LEFT COL ---
	var left_col = VBoxContainer.new()
	left_col.name = "LeftCol"
	left_col.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	content_hbox.add_child(left_col)
	left_col.set_owner(root)
	
	var target_name = Label.new()
	target_name.name = "TargetNameLabel"
	target_name.text = "Target Name"
	target_name.add_theme_font_size_override("font_size", 20)
	target_name.add_theme_color_override("font_color", Color.GOLD)
	left_col.add_child(target_name)
	target_name.set_owner(root)
	
	var desc_label = RichTextLabel.new()
	desc_label.name = "DescriptionLabel"
	desc_label.text = "Description goes here..."
	desc_label.fit_content = true
	desc_label.size_flags_vertical = Control.SIZE_EXPAND_FILL
	left_col.add_child(desc_label)
	desc_label.set_owner(root)
	
	var stats_grid = GridContainer.new()
	stats_grid.name = "StatsGrid"
	stats_grid.columns = 2
	left_col.add_child(stats_grid)
	stats_grid.set_owner(root)
	
	_add_stat_row(stats_grid, root, "LabelDiff", "Difficulty:", "ValDiff", "1 Star")
	_add_stat_row(stats_grid, root, "LabelCost", "Auth Cost:", "ValCost", "1")
	_add_stat_row(stats_grid, root, "LabelTravel", "Travel Time:", "ValTravel", "Medium")
	
	# Separator
	var vsep = VSeparator.new()
	vsep.name = "VSeparator"
	content_hbox.add_child(vsep)
	vsep.set_owner(root)
	
	# --- RIGHT COL (Muster) ---
	var right_col = VBoxContainer.new()
	right_col.name = "RightCol"
	right_col.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	content_hbox.add_child(right_col)
	right_col.set_owner(root)
	
	var cap_label = Label.new()
	cap_label.name = "CapacityLabel"
	cap_label.text = "Fleet Capacity: 0/4"
	cap_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	right_col.add_child(cap_label)
	cap_label.set_owner(root)
	
	var scroll = ScrollContainer.new()
	scroll.name = "ScrollContainer"
	scroll.size_flags_vertical = Control.SIZE_EXPAND_FILL
	right_col.add_child(scroll)
	scroll.set_owner(root)
	
	var warband_list = VBoxContainer.new()
	warband_list.name = "WarbandList"
	warband_list.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	scroll.add_child(warband_list)
	warband_list.set_owner(root)
	
	# --- NEW: BONDI PANEL ---
	var bondi_panel = PanelContainer.new()
	bondi_panel.name = "BondiPanel"
	right_col.add_child(bondi_panel)
	bondi_panel.set_owner(root)
	
	var bondi_vbox = VBoxContainer.new()
	bondi_vbox.name = "BondiVBox"
	bondi_panel.add_child(bondi_vbox)
	bondi_vbox.set_owner(root)
	
	var bondi_label = Label.new()
	bondi_label.name = "BondiLabel"
	bondi_label.text = "Call the Bondi (Farmers)"
	bondi_label.add_theme_color_override("font_color", Color.LIGHT_BLUE)
	bondi_vbox.add_child(bondi_label)
	bondi_label.set_owner(root)
	
	var bondi_slider_box = HBoxContainer.new()
	bondi_slider_box.name = "BondiSliderBox"
	bondi_vbox.add_child(bondi_slider_box)
	bondi_slider_box.set_owner(root)
	
	var bondi_slider = HSlider.new()
	bondi_slider.name = "BondiSlider"
	bondi_slider.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	bondi_slider.size_flags_vertical = Control.SIZE_SHRINK_CENTER
	bondi_slider.min_value = 0
	bondi_slider.max_value = 10
	bondi_slider_box.add_child(bondi_slider)
	bondi_slider.set_owner(root)
	
	var bondi_count_lbl = Label.new()
	bondi_count_lbl.name = "BondiCountLabel"
	bondi_count_lbl.text = "0 / 10"
	bondi_count_lbl.custom_minimum_size.x = 60
	bondi_count_lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	bondi_slider_box.add_child(bondi_count_lbl)
	bondi_count_lbl.set_owner(root)
	
	# --- BOTTOM SECTION ---
	var sep2 = HSeparator.new()
	sep2.name = "HSeparator2"
	main_vbox.add_child(sep2)
	sep2.set_owner(root)
	
	var prov_panel = PanelContainer.new()
	prov_panel.name = "ProvisionsPanel"
	main_vbox.add_child(prov_panel)
	prov_panel.set_owner(root)
	
	var prov_hbox = HBoxContainer.new()
	prov_hbox.name = "HBox"
	prov_panel.add_child(prov_hbox)
	prov_hbox.set_owner(root)
	
	var l_supplies = Label.new()
	l_supplies.name = "Label"
	l_supplies.text = "Supplies:"
	prov_hbox.add_child(l_supplies)
	l_supplies.set_owner(root)
	
	var slider = HSlider.new()
	slider.name = "ProvisionSlider"
	slider.min_value = 0
	slider.max_value = 2
	slider.value = 1
	slider.tick_count = 3
	slider.ticks_on_borders = true
	slider.custom_minimum_size.x = 150
	slider.size_flags_vertical = Control.SIZE_SHRINK_CENTER
	prov_hbox.add_child(slider)
	slider.set_owner(root)
	
	var cost_l = Label.new()
	cost_l.name = "CostLabel"
	cost_l.text = "0 Food"
	prov_hbox.add_child(cost_l)
	cost_l.set_owner(root)
	
	var eff_l = Label.new()
	eff_l.name = "EffectLabel"
	eff_l.text = "Normal Risk"
	eff_l.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	eff_l.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	prov_hbox.add_child(eff_l)
	eff_l.set_owner(root)
	
	var actions = HBoxContainer.new()
	actions.name = "ActionButtons"
	actions.alignment = BoxContainer.ALIGNMENT_END
	actions.add_theme_constant_override("separation", 20)
	main_vbox.add_child(actions)
	actions.set_owner(root)
	
	var btn_cancel = Button.new()
	btn_cancel.name = "CancelButton"
	btn_cancel.text = "Cancel"
	btn_cancel.custom_minimum_size = Vector2(100, 40)
	actions.add_child(btn_cancel)
	btn_cancel.set_owner(root)
	
	var btn_launch = Button.new()
	btn_launch.name = "LaunchButton"
	btn_launch.text = "Set Sail"
	btn_launch.custom_minimum_size = Vector2(120, 40)
	actions.add_child(btn_launch)
	btn_launch.set_owner(root)
	
	var packed_scene = PackedScene.new()
	packed_scene.pack(root)
	var error = ResourceSaver.save(packed_scene, SCENE_PATH)
	if error == OK:
		print(" Scene generated: ", SCENE_PATH)
		EditorInterface.get_resource_filesystem().scan()
	else:
		printerr(" Failed to save scene: ", error)

func _add_stat_row(parent, owner, label_name, label_text, val_name, val_text):
	var l = Label.new()
	l.name = label_name
	l.text = label_text
	l.modulate = Color.LIGHT_GRAY
	parent.add_child(l)
	l.set_owner(owner)
	
	var v = Label.new()
	v.name = val_name
	v.text = val_text
	parent.add_child(v)
	v.set_owner(owner)


--------------------------------------------------
FILE: res:///tools/SceneGeneratorTool.gd
--------------------------------------------------
# res://tools/MakeDrengrMelee.gd
@tool
extends EditorScript

func _run() -> void:
	print("--- Converting Units to Melee ---")
	
	var paths = [
		"res://data/units/Unit_Drengr.tres",
		"res://data/units/Unit_Bondi.tres"
	]
	
	for path in paths:
		if ResourceLoader.exists(path):
			var data = load(path) as UnitData
			
			# 1. Remove Projectile (Enables Melee Mode)
			data.projectile_scene = null
			
			# 2. Ensure Attack Range is Short
			data.attack_range = 15.0
			
			# 3. Save
			ResourceSaver.save(data, path)
			print(" Converted %s to Melee Mode." % path.get_file())
		else:
			print("Skipping %s (Not found)" % path)
			
	print("--- Done. Re-run game. ---")


--------------------------------------------------
FILE: res:///tools/SettlementLayoutEditor.gd
--------------------------------------------------
# SettlementLayoutEditor.gd
# Tool to help create custom settlement layouts
@tool
extends EditorScript

# Define available buildings with their paths
const BUILDINGS = {
	"Great Hall": "res://data/buildings/GreatHall.tres",
	"Wall": "res://data/buildings/Bldg_Wall.tres", 
	"Lumber Yard": "res://data/buildings/LumberYard.tres",
	"Chapel": "res://data/buildings/Monastery_Chapel.tres",
	"Granary": "res://data/buildings/Monastery_Granary.tres",
	"Library": "res://data/buildings/Monastery_Library.tres",
	"Scriptorium": "res://data/buildings/Monastery_Scriptorium.tres",
	"Watchtower": "res://data/buildings/Monastery_Watchtower.tres"
}

func _run():
	print("=== SETTLEMENT LAYOUT EDITOR ===")
	print("Available buildings:")
	for name in BUILDINGS.keys():
		print("  - %s: %s" % [name, BUILDINGS[name]])
	
	print("\n=== EXAMPLE LAYOUTS ===")
	
	# Example 1: Small Defensive Settlement
	var small_defensive = create_small_defensive_layout()
	print("\n1. SMALL DEFENSIVE LAYOUT:")
	print_layout(small_defensive)
	save_layout(small_defensive, "res://data/settlements/small_defensive.tres")
	
	# Example 2: Economic Settlement
	var economic = create_economic_layout()
	print("\n2. ECONOMIC LAYOUT:")
	print_layout(economic)
	save_layout(economic, "res://data/settlements/economic_base.tres")
	
	# Example 3: Monastery Layout
	var monastery = create_monastery_layout()
	print("\n3. MONASTERY LAYOUT:")
	print_layout(monastery)
	save_layout(monastery, "res://data/settlements/monastery_base.tres")
	
	print("\n=== LAYOUT FILES CREATED ===")
	print("You can now use these layouts by:")
	print("1. Loading them in the Inspector on SettlementBridge")
	print("2. Or copying the placement arrays manually")

func create_small_defensive_layout() -> Array[Dictionary]:
	return [
		# Great Hall in center
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(8, 6)},
		
		# Defensive walls around perimeter
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(7, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(11, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(13, 4)},
		
		# Watchtowers at corners
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(4, 3)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(14, 3)},
		
		# Basic resource building
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 8)}
	]

func create_economic_layout() -> Array[Dictionary]:
	return [
		# Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 8)},
		
		# Economic buildings clustered together
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(8, 6)},
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(12, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(14, 6)},
		
		# Minimal defenses
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(10, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(10, 3)}
	]

func create_monastery_layout() -> Array[Dictionary]:
	return [
		# Central Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 10)},
		
		# Monastery buildings in organized pattern
		{"resource_path": BUILDINGS["Chapel"], "grid_position": Vector2i(8, 7)},
		{"resource_path": BUILDINGS["Library"], "grid_position": Vector2i(12, 7)},
		{"resource_path": BUILDINGS["Scriptorium"], "grid_position": Vector2i(8, 13)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(12, 13)},
		
		# Outer walls for protection
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(14, 5)},
		
		# Watchtowers
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 15)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 15)}
	]

func print_layout(layout: Array[Dictionary]):
	for i in range(layout.size()):
		var building = layout[i]
		var name = get_building_name(building["resource_path"])
		var pos = building["grid_position"]
		print("  [%d] %s at (%d, %d)" % [i, name, pos.x, pos.y])

func get_building_name(path: String) -> String:
	for name in BUILDINGS.keys():
		if BUILDINGS[name] == path:
			return name
	return "Unknown"

func save_layout(layout: Array[Dictionary], path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 200, "stone": 300}
	settlement.placed_buildings = layout
	settlement.garrisoned_units = {"res://data/units/Unit_PlayerRaider.tres": 3}
	
	var error = ResourceSaver.save(settlement, path)
	if error == OK:
		print(" Saved layout to: %s" % path)
	else:
		print(" Failed to save layout to: %s" % path)


--------------------------------------------------
FILE: res:///tools/TestPopulationLogic.gd
--------------------------------------------------
@tool
extends EditorScript

# --- Constants from EconomyManager ---
const FOOD_PER_PERSON = 10
const BASE_GROWTH = 0.02
const STARVATION_RATE = -0.15
const UNREST_PER_EXCESS = 2

func _run():
	print("---  POPULATION LOGIC SIMULATION ---")
	
	# Scenario 1: The "Good Year"
	# 10 People, 200 Food (Abundance), 15 Land Capacity
	_test_scenario("Abundance", 10, 200, 15)
	
	# Scenario 2: "The Squeeze" (Land Hunger)
	# 20 People, 200 Food (Sufficient), 10 Land Capacity (Overpopulated)
	_test_scenario("Land Hunger", 20, 200, 10)
	
	# Scenario 3: "The Winter of Death" (Famine)
	# 10 People, 50 Food (Starvation), 15 Land Capacity
	_test_scenario("Famine", 10, 50, 15)

func _test_scenario(title: String, pop: int, food: int, land_cap: int) -> void:
	print("\n[%s] Start: Pop %d | Food %d | Land Cap %d" % [title, pop, food, land_cap])
	
	var food_req = pop * FOOD_PER_PERSON
	var growth_rate = BASE_GROWTH
	var status = "Normal"
	
	# 1. Food Check
	if food < food_req:
		growth_rate = STARVATION_RATE
		status = "STARVATION"
	elif food > (food_req * 1.5):
		growth_rate += 0.01
		status = "Booming"
		
	# 2. Calc New Pop
	var net_change = int(pop * growth_rate)
	# Force at least 1 change if rate is non-zero
	if growth_rate > 0 and net_change == 0: net_change = 1
	
	var new_pop = pop + net_change
	
	print(" > Food Status: %s (Req: %d)" % [status, food_req])
	print(" > Growth: %d%% -> Net Change: %+d" % [growth_rate * 100, net_change])
	print(" > New Population: %d" % new_pop)
	
	# 3. Land Hunger Check
	if new_pop > land_cap:
		var excess = new_pop - land_cap
		var unrest = excess * UNREST_PER_EXCESS
		print(" >  UNREST! %d landless men generate +%d Unrest" % [excess, unrest])
	else:
		print(" >  Stable. Capacity for %d more." % (land_cap - new_pop))


--------------------------------------------------
FILE: res:///tools/ThemeBuilder.gd
--------------------------------------------------
@tool
extends EditorScript

# This script assembles the "VikingDynastyTheme.tres" using the assets
# generated by UIAssetGen.gd.

const THEME_PATH = "res://ui/themes/VikingDynastyTheme.tres"
const ASSET_PATH = "res://ui/assets/"
const FONT_PATH = "res://assets/fonts/"

# Colors
const COL_INK = Color("#2b221b")
const COL_PARCHMENT = Color("#f5e6d3")
const COL_GOLD = Color("#c5a54e")

func _run() -> void:
	print("--- Building Chronicler Theme ---")
	
	# 1. Create or Load Theme
	var theme = Theme.new()
	
	# 2. Load Fonts (with fallbacks)
	var font_header = _try_load_font("UncialAntiqua-Regular.ttf")
	var font_body = _try_load_font("CrimsonText-Regular.ttf")
	
	if font_header:
		theme.set_default_font(font_body)
		theme.set_default_font_size(20)
	
	# --- BUTTON STYLING (Wood) ---
	var wood_tex = load(ASSET_PATH + "wood_bg.png")
	if wood_tex:
		var style_normal = StyleBoxTexture.new()
		style_normal.texture = wood_tex
		style_normal.modulate_color = Color.WHITE
		# Add margins so text doesn't hit the edge
		style_normal.content_margin_left = 10
		style_normal.content_margin_right = 10
		style_normal.content_margin_top = 5
		style_normal.content_margin_bottom = 5
		
		var style_hover = style_normal.duplicate()
		style_hover.modulate_color = Color(1.2, 1.2, 1.2) # Lighter
		
		var style_pressed = style_normal.duplicate()
		style_pressed.modulate_color = Color(0.8, 0.8, 0.8) # Darker
		
		var style_disabled = style_normal.duplicate()
		style_disabled.modulate_color = Color(0.5, 0.5, 0.5) # Greyed out

		theme.set_stylebox("normal", "Button", style_normal)
		theme.set_stylebox("hover", "Button", style_hover)
		theme.set_stylebox("pressed", "Button", style_pressed)
		theme.set_stylebox("disabled", "Button", style_disabled)
		
		# Button Text Colors
		theme.set_color("font_color", "Button", COL_PARCHMENT)
		theme.set_color("font_hover_color", "Button", Color.WHITE)
		theme.set_font("font", "Button", font_header)
		theme.set_font_size("font_size", "Button", 20)

	# --- PANEL CONTAINER (Parchment) ---
	var parchment_tex = load(ASSET_PATH + "parchment_bg.png")
	if parchment_tex:
		var style_panel = StyleBoxTexture.new()
		style_panel.texture = parchment_tex
		style_panel.axis_stretch_horizontal = StyleBoxTexture.AXIS_STRETCH_MODE_TILE
		style_panel.axis_stretch_vertical = StyleBoxTexture.AXIS_STRETCH_MODE_TILE
		# Margins
		style_panel.content_margin_left = 20
		style_panel.content_margin_right = 20
		style_panel.content_margin_top = 20
		style_panel.content_margin_bottom = 20
		
		theme.set_stylebox("panel", "PanelContainer", style_panel)

	# --- LABELS (Ink) ---
	theme.set_color("font_color", "Label", COL_INK)
	theme.set_color("default_color", "RichTextLabel", COL_INK)
	
	# --- HEADER LABEL VARIATION ---
	# Usage: Add "Header" to the Label's theme_type_variation property
	theme.set_font("font", "HeaderLabel", font_header)
	theme.set_font_size("font_size", "HeaderLabel", 24)
	theme.set_color("font_color", "HeaderLabel", COL_INK)
# --- RESOURCE TAG VARIATION (Dark Plaque) ---
	var tag_tex = load(ASSET_PATH + "resource_tag.png")
	if tag_tex:
		var style_tag = StyleBoxTexture.new()
		style_tag.texture = tag_tex
		# Margins to give the text breathing room inside the box
		style_tag.content_margin_left = 12
		style_tag.content_margin_right = 12
		style_tag.content_margin_top = 8
		style_tag.content_margin_bottom = 4
		
		# Define the variation
		theme.set_stylebox("normal", "ResourceLabel", style_tag)
		theme.set_color("font_color", "ResourceLabel", COL_PARCHMENT) # Light text
		theme.set_font("font", "ResourceLabel", font_header) # Use the Fancy Font
		theme.set_font_size("font_size", "ResourceLabel", 24) # Bigger!
	# --- TOOLTIP ---
	var tooltip_tex = load(ASSET_PATH + "tooltip_bg.png")
	if tooltip_tex:
		var style_tooltip = StyleBoxTexture.new()
		style_tooltip.texture = tooltip_tex
		style_tooltip.content_margin_left = 10
		style_tooltip.content_margin_right = 10
		style_tooltip.content_margin_top = 5
		style_tooltip.content_margin_bottom = 5
		
		# TooltipPanel is the background
		theme.set_stylebox("panel", "TooltipPanel", style_tooltip)
		
		# TooltipLabel is the text
		theme.set_color("font_color", "TooltipLabel", Color.WHITE)
		theme.set_font_size("font_size", "TooltipLabel", 18)
	# --- SAVE ---
	if not DirAccess.dir_exists_absolute(THEME_PATH.get_base_dir()):
		DirAccess.make_dir_recursive_absolute(THEME_PATH.get_base_dir())
		
	var error = ResourceSaver.save(theme, THEME_PATH)
	if error == OK:
		print("Theme saved to: ", THEME_PATH)
	else:
		print("Error saving theme: ", error)
		
	EditorInterface.get_resource_filesystem().scan()

func _try_load_font(filename: String) -> Font:
	var path = FONT_PATH + filename
	if ResourceLoader.exists(path):
		return load(path)
	print("Warning: Font not found at ", path, ". Using default.")
	return ThemeDB.get_fallback_font()


--------------------------------------------------
FILE: res:///ui/BuildingPreviewCursor.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://c3spjoajs73th"]

[ext_resource type="Script" uid="uid://c4bv8okjkvtt7" path="res://scripts/ui/BuildingPreviewCursor.gd" id="1"]

[node name="BuildingPreviewCursor" type="Node2D"]
script = ExtResource("1")


--------------------------------------------------
FILE: res:///ui/DynastyUI.gd
--------------------------------------------------
# res://ui/DynastyUI.gd
class_name DynastyUI
extends PanelContainer

# References
@onready var ancestors_container: HBoxContainer = $Margin/MainLayout/AncestorsScroll/AncestorsHBox
@onready var current_jarl_name: Label = $Margin/MainLayout/CurrentJarlPanel/Stats/NameLabel
@onready var current_jarl_stats: Label = $Margin/MainLayout/CurrentJarlPanel/Stats/StatsLabel
@onready var current_jarl_portrait: TextureRect = $Margin/MainLayout/CurrentJarlPanel/Portrait
@onready var heirs_container: HBoxContainer = $Margin/MainLayout/HeirsScroll/HeirsHBox
@onready var close_button: Button = $Margin/MainLayout/CloseButton
@onready var context_menu: PopupMenu = $ContextMenu

# Resources
const HEIR_CARD_SCENE = preload("res://ui/components/HeirCard.tscn")
const PLACEHOLDER_ICON = preload("res://textures/placeholders/unit_placeholder.png")

var selected_heir: JarlHeirData

func _ready() -> void:
	close_button.pressed.connect(_on_close_button_pressed)
	DynastyManager.jarl_stats_updated.connect(_on_jarl_stats_updated)
	
	visibility_changed.connect(_on_visibility_changed)
	
	if current_jarl_portrait:
		current_jarl_portrait.custom_minimum_size = Vector2(128, 128)
		current_jarl_portrait.expand_mode = TextureRect.EXPAND_IGNORE_SIZE
		current_jarl_portrait.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
	
	# Setup Context Menu
	context_menu.add_item("Designate Heir (Cost: 1 Authority)", 0)
	context_menu.add_item("Fund Expedition (Cost: 500 Gold)", 1)
	context_menu.add_item("Arrange Marriage (Cost: 1 Heir)", 2)
	context_menu.add_item("Assign as Captain", 3)
	context_menu.id_pressed.connect(_on_context_menu_item_pressed)
	
	if DynastyManager.current_jarl:
		_on_jarl_stats_updated(DynastyManager.get_current_jarl())
	
	hide()

func _on_visibility_changed() -> void:
	if visible and DynastyManager.current_jarl:
		_on_jarl_stats_updated(DynastyManager.get_current_jarl())
		Loggie.msg("Dynasty UI: Auto-refreshed data on visible.").domain("UI").info()
	
	# --- NEW: Lock/Unlock Camera Input ---
	# This tells the RTSCamera to ignore zoom/pan inputs while this UI is visible.
	EventBus.camera_input_lock_requested.emit(visible)
	# -------------------------------------

func _on_jarl_stats_updated(jarl: JarlData) -> void:
	if not jarl: return
	
	# 1. Update Current Jarl Name
	current_jarl_name.text = jarl.display_name
	
	# 2. Update Full Stats
	var prowess = jarl.get_effective_skill("prowess")
	var stewardship = jarl.get_effective_skill("stewardship")
	var command = jarl.get_effective_skill("command")
	var learning = jarl.get_effective_skill("learning")
	
	var stats_text = "Age: %d  |  Renown: %d  |  Authority: %d/%d\n" % [jarl.age, jarl.renown, jarl.current_authority, jarl.max_authority]
	stats_text += "------------------------------------------------\n"
	stats_text += " Prowess: %d    Command: %d\n" % [prowess, command]
	stats_text += " Stewardship: %d    Learning: %d" % [stewardship, learning]
	
	current_jarl_stats.text = stats_text

	# 3. Update Portrait
	if jarl.portrait:
		current_jarl_portrait.texture = jarl.portrait
	else:
		current_jarl_portrait.texture = PLACEHOLDER_ICON

	# 4. Update Lists
	_populate_ancestors(jarl.ancestors)
	_populate_heirs(jarl.heirs)

func _populate_ancestors(ancestors_data: Array) -> void:
	for child in ancestors_container.get_children():
		child.queue_free()
		
	for data in ancestors_data:
		var texture = TextureRect.new()
		texture.custom_minimum_size = Vector2(64, 64)
		texture.expand_mode = TextureRect.EXPAND_IGNORE_SIZE
		texture.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
		texture.mouse_filter = Control.MOUSE_FILTER_STOP 
		
		if data.has("portrait") and data["portrait"] != null:
			texture.texture = data["portrait"]
		else:
			texture.texture = PLACEHOLDER_ICON
			
		texture.tooltip_text = "%s\nFinal Renown: %d\nDied: %s" % [
			data.get("name", "Ancestor"), 
			data.get("final_renown", 0),
			data.get("death_reason", "Unknown")
		]
		
		texture.modulate = Color(0.5, 0.5, 0.5, 0.8) 
		ancestors_container.add_child(texture)

func _populate_heirs(heirs_data: Array[JarlHeirData]) -> void:
	for child in heirs_container.get_children():
		child.queue_free()
		
	for heir in heirs_data:
		var card = HEIR_CARD_SCENE.instantiate()
		heirs_container.add_child(card)
		card.setup(heir)
		card.card_clicked.connect(_on_heir_card_clicked)

func _on_heir_card_clicked(heir: JarlHeirData, mouse_pos: Vector2) -> void:
	selected_heir = heir
	
	context_menu.set_item_disabled(0, false) 
	context_menu.set_item_disabled(1, false) 
	context_menu.set_item_disabled(2, false) 
	
	if heir.status != JarlHeirData.HeirStatus.Available:
		context_menu.set_item_disabled(1, true) 
		context_menu.set_item_disabled(2, true) 
	
	if heir.is_designated_heir:
		context_menu.set_item_text(0, "Designated Heir (Active)")
		context_menu.set_item_disabled(0, true)
	else:
		context_menu.set_item_text(0, "Designate Heir (Cost: 1 Authority)")
	
	context_menu.position = Vector2i(mouse_pos)
	context_menu.popup()

func _on_context_menu_item_pressed(id: int) -> void:
	if not selected_heir: return
	
	match id:
		0: # Designate Heir
			DynastyManager.designate_heir(selected_heir)
		1: # Fund Expedition
			var cost = {"gold": 500}
			if SettlementManager.attempt_purchase(cost):
				DynastyManager.start_heir_expedition(selected_heir)
			else:
				Loggie.msg("Not enough gold for expedition.").domain("UI").info()
		2: # Arrange Marriage
			if DynastyManager.get_current_jarl():
				selected_heir.status = JarlHeirData.HeirStatus.MarriedOff
				DynastyManager.award_renown(150) 
				Loggie.msg("Heir married off for Renown.").domain("UI").info()
		3: # Assign Captain
			_open_warband_assignment_dialog()
			
func _on_close_button_pressed() -> void:
	hide()

func _input(event: InputEvent) -> void:
	if visible and event is InputEventKey and event.pressed:
		if event.keycode == KEY_ESCAPE:
			_on_close_button_pressed()
			get_viewport().set_input_as_handled()

func _open_warband_assignment_dialog() -> void:
	var settlement = SettlementManager.current_settlement
	if not settlement or settlement.warbands.is_empty():
		Loggie.msg("No Warbands available to lead.").domain("UI").warn()
		return
		
	for wb in settlement.warbands:
		if wb.assigned_heir_name == "":
			wb.assigned_heir_name = selected_heir.display_name
			Loggie.msg("Heir %s assigned to lead %s" % [selected_heir.display_name, wb.custom_name]).domain("UI").info()
			wb.add_history("Year %d: Led by %s" % [DynastyManager.current_jarl.age, selected_heir.display_name])
			return
			
	Loggie.msg("All Warbands already have captains!").domain("UI").warn()


--------------------------------------------------
FILE: res:///ui/Dynasty_UI.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://c5qg2j1qa4g0b"]

[ext_resource type="Script" uid="uid://dpijiwr0pfpn7" path="res://ui/DynastyUI.gd" id="1_abcde"]

[node name="Dynasty_UI" type="PanelContainer"]
custom_minimum_size = Vector2(800, 600)
anchors_preset = -1
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -200.0
offset_top = -150.0
offset_right = 200.0
offset_bottom = 150.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_abcde")

[node name="Margin" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="MainLayout" type="VBoxContainer" parent="Margin"]
layout_mode = 2

[node name="AncestorsScroll" type="ScrollContainer" parent="Margin/MainLayout"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2
size_flags_vertical = 3

[node name="AncestorsHBox" type="HBoxContainer" parent="Margin/MainLayout/AncestorsScroll"]
layout_mode = 2

[node name="HSeparator" type="HSeparator" parent="Margin/MainLayout"]
layout_mode = 2

[node name="CurrentJarlPanel" type="HBoxContainer" parent="Margin/MainLayout"]
layout_mode = 2
size_flags_horizontal = 4

[node name="Portrait" type="TextureRect" parent="Margin/MainLayout/CurrentJarlPanel"]
custom_minimum_size = Vector2(128, 128)
layout_mode = 2
expand_mode = 5

[node name="Stats" type="VBoxContainer" parent="Margin/MainLayout/CurrentJarlPanel"]
layout_mode = 2

[node name="NameLabel" type="Label" parent="Margin/MainLayout/CurrentJarlPanel/Stats"]
layout_mode = 2

[node name="StatsLabel" type="Label" parent="Margin/MainLayout/CurrentJarlPanel/Stats"]
layout_mode = 2

[node name="HSeparator2" type="HSeparator" parent="Margin/MainLayout"]
layout_mode = 2

[node name="HeirsLabel" type="Label" parent="Margin/MainLayout"]
layout_mode = 2
text = "Heirs:"

[node name="HeirsScroll" type="ScrollContainer" parent="Margin/MainLayout"]
custom_minimum_size = Vector2(128, 128)
layout_mode = 2
size_flags_vertical = 3

[node name="HeirsHBox" type="HBoxContainer" parent="Margin/MainLayout/HeirsScroll"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="CloseButton" type="Button" parent="Margin/MainLayout"]
layout_mode = 2
text = "Close"

[node name="ContextMenu" type="PopupMenu" parent="."]


--------------------------------------------------
FILE: res:///ui/EndOfYear_Popup.gd
--------------------------------------------------
# res://ui/EndOfYear_Popup.gd
extends PanelContainer

signal collect_button_pressed(payout: Dictionary)

@onready var payout_label: RichTextLabel = $MarginContainer/VBoxContainer/PayoutLabel
@onready var collect_button: Button = $MarginContainer/VBoxContainer/CollectButton
@onready var loot_panel: PanelContainer = %LootDistributionPanel
@onready var loot_slider: HSlider = %LootSlider
@onready var result_label: Label = %DistributionResultLabel

var _base_payout: Dictionary = {}
var _final_payout: Dictionary = {}
var _total_loot_gold: int = 0

func _ready() -> void:
	# --- FIX: Allow this node to run while game is paused ---
	process_mode = Node.PROCESS_MODE_WHEN_PAUSED
	# -------------------------------------------------------
	
	collect_button.pressed.connect(_on_collect_pressed)
	if loot_slider:
		loot_slider.value_changed.connect(_update_distribution_preview)
	
	# Ensure hidden and not blocking input at start
	hide() 

func display_payout(payout: Dictionary, title: String = "Welcome home!") -> void:
	_base_payout = payout.duplicate()
	_final_payout = payout.duplicate()
	
	var is_raid = title.contains("Raid") or title.contains("Victory")
	_total_loot_gold = payout.get("gold", 0)
	
	# Logic to show/hide slider
	if is_raid and _total_loot_gold > 0:
		if loot_panel: loot_panel.show()
		if loot_slider: 
			loot_slider.value = 0 
			_update_distribution_preview(0)
	else:
		if loot_panel: loot_panel.hide()
	
	_update_text_display(title)
	
	# --- FIX: PAUSE THE GAME ---
	get_tree().paused = true
	# ---------------------------
	
	show()
	# Force layout update to prevent squashed UI
	queue_sort()

func _update_distribution_preview(percent_shared: float) -> void:
	var share_pct = percent_shared / 100.0
	var gold_shared = int(_total_loot_gold * share_pct)
	var gold_kept = _total_loot_gold - gold_shared
	
	var renown_change = 0
	if percent_shared < 20: renown_change = -50
	elif percent_shared < 50: renown_change = 0
	elif percent_shared < 80: renown_change = 20
	else: renown_change = 100
		
	if result_label:
		var sign_str = "+" if renown_change > 0 else ""
		result_label.text = "Keep: %d G  |  Share: %d G\nRenown: %s%d" % [gold_kept, gold_shared, sign_str, renown_change]
		
		# Use brighter colors for readability
		result_label.modulate = Color.WHITE
		if renown_change < 0: result_label.modulate = Color(1, 0.4, 0.4) # Bright Salmon
		elif renown_change > 0: result_label.modulate = Color(0.4, 1, 0.4) # Bright Green
	
	_final_payout = _base_payout.duplicate()
	_final_payout["gold"] = gold_kept
	_final_payout["renown"] = renown_change

func _update_text_display(title: String) -> void:
	var text: String = "[b]%s[/b]\n\n" % title
	if _base_payout.has("_messages"):
		text += "[b]Incidents:[/b]\n"
		for msg in _base_payout["_messages"]: text += "%s\n" % msg
		text += "\n"
	text += "[b]Resources:[/b]\n"
	for key in _base_payout:
		if key.begins_with("_") or key == "population_growth": continue
		var val = _base_payout[key]
		if val != 0:
			var col = "green" if val > 0 else "salmon" # Brighter red
			text += "- %s: [color=%s]%d[/color]\n" % [key.capitalize(), col, val]
	payout_label.text = text

func _on_collect_pressed() -> void:
	# --- FIX: UNPAUSE THE GAME ---
	get_tree().paused = false
	# -----------------------------
	
	collect_button_pressed.emit(_final_payout)
	hide()


--------------------------------------------------
FILE: res:///ui/EndOfYear_Popup.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://dqh0xu88khxct"]

[ext_resource type="Script" uid="uid://pi8qvm18eita" path="res://ui/EndOfYear_Popup.gd" id="1_3kn8e"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_5jo2q"]
bg_color = Color(0.1, 0.1, 0.1, 0.98)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.77254903, 0.64705884, 0.30588236, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_7yhkd"]
bg_color = Color(0, 0, 0, 0.5)
corner_radius_top_left = 4
corner_radius_top_right = 4
corner_radius_bottom_right = 4
corner_radius_bottom_left = 4

[node name="EndOfYear_Popup" type="PanelContainer"]
custom_minimum_size = Vector2(400, 350)
anchors_preset = -1
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -200.0
offset_top = -175.0
offset_right = 200.0
offset_bottom = 175.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 4
size_flags_vertical = 4
theme_override_styles/panel = SubResource("StyleBoxFlat_5jo2q")
script = ExtResource("1_3kn8e")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="PayoutLabel" type="RichTextLabel" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_colors/default_color = Color(1, 1, 1, 1)
bbcode_enabled = true
text = "Results..."
fit_content = true

[node name="LootDistributionPanel" type="PanelContainer" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(0, 100)
layout_mode = 2
size_flags_vertical = 3
theme_override_styles/panel = SubResource("StyleBoxFlat_7yhkd")

[node name="@VBoxContainer@30028" type="VBoxContainer" parent="MarginContainer/VBoxContainer/LootDistributionPanel"]
layout_mode = 2

[node name="@Label@30029" type="Label" parent="MarginContainer/VBoxContainer/LootDistributionPanel/@VBoxContainer@30028"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0.84313726, 0, 1)
text = "Distribute Loot"
horizontal_alignment = 1

[node name="@HBoxContainer@30030" type="HBoxContainer" parent="MarginContainer/VBoxContainer/LootDistributionPanel/@VBoxContainer@30028"]
layout_mode = 2

[node name="@Label@30031" type="Label" parent="MarginContainer/VBoxContainer/LootDistributionPanel/@VBoxContainer@30028/@HBoxContainer@30030"]
layout_mode = 2
theme_override_colors/font_color = Color(0.827451, 0.827451, 0.827451, 1)
text = "Keep All"

[node name="LootSlider" type="HSlider" parent="MarginContainer/VBoxContainer/LootDistributionPanel/@VBoxContainer@30028/@HBoxContainer@30030"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 4
step = 10.0
tick_count = 5
ticks_on_borders = true

[node name="@Label@30032" type="Label" parent="MarginContainer/VBoxContainer/LootDistributionPanel/@VBoxContainer@30028/@HBoxContainer@30030"]
layout_mode = 2
theme_override_colors/font_color = Color(0.827451, 0.827451, 0.827451, 1)
text = "Share"

[node name="DistributionResultLabel" type="Label" parent="MarginContainer/VBoxContainer/LootDistributionPanel/@VBoxContainer@30028"]
unique_name_in_owner = true
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 1, 1)
text = "Result: ..."
horizontal_alignment = 1

[node name="CollectButton" type="Button" parent="MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(120, 40)
layout_mode = 2
text = "Collect"


--------------------------------------------------
FILE: res:///ui/Event_UI.gd
--------------------------------------------------
# res://ui/Event_UI.gd
#
# Controller script for the modal event window (Event_UI.tscn).
# This scene is responsible for displaying an EventData resource
# and returning the player's choice.
class_name EventUI
extends CanvasLayer

## Emitted when the player clicks a choice button.
## Passes the EventData and the chosen EventChoice.
signal choice_made(event: EventData, choice: EventChoice)

# Node References
@onready var title_label: Label = $PanelContainer/Margin/VBox/TitleLabel
@onready var description_label: Label = $PanelContainer/Margin/VBox/HBox/DescriptionLabel
@onready var portrait: TextureRect = %Portrait
@onready var choice_buttons_container: VBoxContainer = $PanelContainer/Margin/VBox/ChoiceButtonsContainer

var current_event: EventData

func _ready() -> void:
	# Start hidden. The EventManager will show this UI.
	hide()
	
	# Set process mode to "When Paused" so it works even if
	# the EventManager pauses the game to show the event.
	process_mode = Node.PROCESS_MODE_WHEN_PAUSED

func display_event(event_data: EventData) -> void:
	"""
	Configures and displays the event window based on an EventData resource.
	"""
	if not event_data:
		push_error("EventUI: Cannot display a null EventData resource.")
		return
		
	current_event = event_data
	
	# 1. Populate Text
	title_label.text = event_data.title
	description_label.text = event_data.description
	
	# 2. Populate Portrait
	if event_data.portrait:
		portrait.texture = event_data.portrait
		portrait.show()
	else:
		portrait.texture = null
		portrait.hide()
		
	# 3. Clear and Create Choice Buttons
	for child in choice_buttons_container.get_children():
		child.queue_free()
		
	if event_data.choices.is_empty():
		# Create a default "OK" button if no choices are provided
		var ok_button = Button.new()
		ok_button.text = "OK"
		ok_button.pressed.connect(_on_choice_button_pressed.bind(null))
		choice_buttons_container.add_child(ok_button)
	else:
		# Create a button for each choice
		for choice in event_data.choices:
			var choice_button = Button.new()
			choice_button.text = choice.choice_text
			choice_button.tooltip_text = choice.tooltip_text
			choice_button.pressed.connect(_on_choice_button_pressed.bind(choice))
			choice_buttons_container.add_child(choice_button)
			
	# 4. Show the UI
	show()
	
	# Grab focus so gamepad/keyboard input works
	# A CanvasLayer can't grab focus, so we focus the first button
	var first_button = choice_buttons_container.get_child(0) as Button
	if first_button:
		first_button.grab_focus()

func _on_choice_button_pressed(choice: EventChoice) -> void:
	"""
	Called when any choice button is pressed.
	Emits the signal and hides the window.
	"""
	hide()
	choice_made.emit(current_event, choice)
	current_event = null


--------------------------------------------------
FILE: res:///ui/Event_UI.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://ih62qkde7dru"]

[ext_resource type="Script" uid="uid://dk2fbryop7524" path="res://ui/Event_UI.gd" id="1_event_ui"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="2_xtfdx"]

[node name="Event_UI" type="CanvasLayer"]
process_mode = 2
layer = 20
script = ExtResource("1_event_ui")

[node name="PanelContainer" type="PanelContainer" parent="."]
custom_minimum_size = Vector2(500, 300)
anchors_preset = -1
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -78.5
offset_top = -105.5
offset_right = 78.5
offset_bottom = 105.5
grow_horizontal = 2
grow_vertical = 2

[node name="Margin" type="MarginContainer" parent="PanelContainer"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="VBox" type="VBoxContainer" parent="PanelContainer/Margin"]
layout_mode = 2

[node name="TitleLabel" type="Label" parent="PanelContainer/Margin/VBox"]
custom_minimum_size = Vector2(300, 30)
layout_mode = 2
size_flags_vertical = 1
text = "Event Title"
horizontal_alignment = 1
autowrap_mode = 3

[node name="HSeparator" type="HSeparator" parent="PanelContainer/Margin/VBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="HBox" type="HBoxContainer" parent="PanelContainer/Margin/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="Portrait" type="TextureRect" parent="PanelContainer/Margin/VBox/HBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(128, 128)
layout_mode = 2
texture = ExtResource("2_xtfdx")
expand_mode = 1
stretch_mode = 5

[node name="DescriptionLabel" type="Label" parent="PanelContainer/Margin/VBox/HBox"]
custom_minimum_size = Vector2(200, 100)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 1
text = "This is the event description text. It will be multiple lines long and explain the situation to the player, presenting them with a difficult choice."
autowrap_mode = 3
clip_text = true

[node name="HSeparator2" type="HSeparator" parent="PanelContainer/Margin/VBox"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="ChoiceButtonsContainer" type="VBoxContainer" parent="PanelContainer/Margin/VBox"]
layout_mode = 2
size_flags_vertical = 10
alignment = 2


--------------------------------------------------
FILE: res:///ui/PauseButton.gd
--------------------------------------------------
# res://ui/PauseButton.gd
extends Button

func _ready():
	# Connect button signal
	pressed.connect(_on_pause_pressed)
	
	# Also listen for the ui_pause input action
	set_process_unhandled_input(true)

func _unhandled_input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_pause"):
		_on_pause_pressed()
		get_viewport().set_input_as_handled()

func _on_pause_pressed():
	Loggie.info("Pause button pressed!", "PauseButton")
	
	# Try to access PauseManager if it exists
	if get_tree().has_group("pause_manager") or has_node("/root/PauseManager"):
		var pause_manager = get_node_or_null("/root/PauseManager")
		if pause_manager:
			Loggie.info("Found PauseManager autoload, calling request_pause()", "PauseButton")
			pause_manager.request_pause()
		else:
			Loggie.warn("PauseManager not found in autoload", "PauseButton")
	else:
		# Fallback: create a simple pause menu directly
		Loggie.info("PauseManager not available, creating simple pause overlay", "PauseButton")
		_create_simple_pause_menu()

func _create_simple_pause_menu():
	# Check if pause is already active
	if get_tree().paused:
		Loggie.info("Game already paused, unpausing instead", "PauseButton")
		get_tree().paused = false
		# Remove existing pause overlay
		var existing_overlay = get_tree().get_first_node_in_group("pause_overlay")
		if existing_overlay:
			existing_overlay.queue_free()
		return
	
	# Create a simple pause overlay
	var pause_overlay = ColorRect.new()
	pause_overlay.name = "PauseOverlay"
	pause_overlay.color = Color(0, 0, 0, 0.7)  # Semi-transparent black
	pause_overlay.mouse_filter = Control.MOUSE_FILTER_STOP
	pause_overlay.add_to_group("pause_overlay")
	
	# Make it fullscreen
	pause_overlay.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	
	# Create pause menu content
	var vbox = VBoxContainer.new()
	vbox.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	vbox.custom_minimum_size = Vector2(200, 150)
	
	var title_label = Label.new()
	title_label.text = "GAME PAUSED"
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.add_theme_font_size_override("font_size", 24)
	
	var resume_button = Button.new()
	resume_button.text = "Resume (ESC)"
	resume_button.pressed.connect(_resume_game)
	
	var quit_button = Button.new()
	quit_button.text = "Quit to Menu"
	quit_button.pressed.connect(_quit_to_menu)
	
	# Add to hierarchy
	vbox.add_child(title_label)
	vbox.add_child(resume_button)
	vbox.add_child(quit_button)
	pause_overlay.add_child(vbox)
	
	# Add to scene tree (at root level to ensure it's on top)
	get_tree().root.add_child(pause_overlay)
	
	# Pause the game
	get_tree().paused = true
	Loggie.info("Simple pause menu created and game paused", "PauseButton")

func _resume_game():
	Loggie.info("Resuming game from simple pause menu", "PauseButton")
	get_tree().paused = false
	
	# Remove pause overlay
	var existing_overlay = get_tree().get_first_node_in_group("pause_overlay")
	if existing_overlay:
		existing_overlay.queue_free()

func _quit_to_menu():
	Loggie.info("Quit to menu requested from pause", "PauseButton")
	get_tree().paused = false
	# You can implement scene switching here if needed
	get_tree().quit()


--------------------------------------------------
FILE: res:///ui/RaidPrepWindow.gd
--------------------------------------------------
# res://ui/RaidPrepWindow.gd
class_name RaidPrepWindow
extends PanelContainer

signal raid_launched(target: RaidTargetData, warbands: Array[WarbandData], provision_level: int)
signal closed

# --- UI References ---
@onready var target_name_label: Label = $MarginContainer/MainVBox/ContentHBox/LeftCol/TargetNameLabel
@onready var description_label: RichTextLabel = $MarginContainer/MainVBox/ContentHBox/LeftCol/DescriptionLabel
@onready var val_diff: Label = $MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid/ValDiff
@onready var val_cost: Label = $MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid/ValCost
@onready var capacity_label: Label = $MarginContainer/MainVBox/ContentHBox/RightCol/CapacityLabel
@onready var warband_list: VBoxContainer = $MarginContainer/MainVBox/ContentHBox/RightCol/ScrollContainer/WarbandList
@onready var provision_slider: HSlider = $MarginContainer/MainVBox/ProvisionsPanel/HBox/ProvisionSlider
@onready var cost_label: Label = $MarginContainer/MainVBox/ProvisionsPanel/HBox/CostLabel
@onready var effect_label: Label = $MarginContainer/MainVBox/ProvisionsPanel/HBox/EffectLabel
@onready var launch_button: Button = $MarginContainer/MainVBox/ActionButtons/LaunchButton
@onready var cancel_button: Button = $MarginContainer/MainVBox/ActionButtons/CancelButton

# --- BONDI REFS ---
@onready var bondi_slider: HSlider = $MarginContainer/MainVBox/ContentHBox/RightCol/BondiPanel/BondiVBox/BondiSliderBox/BondiSlider
@onready var bondi_count_label: Label = $MarginContainer/MainVBox/ContentHBox/RightCol/BondiPanel/BondiVBox/BondiSliderBox/BondiCountLabel
# ----------------------

# --- State ---
var current_target: RaidTargetData
var selected_warbands: Array[WarbandData] = []
var max_capacity: int = 0
var current_provision_level: int = 1
var calculated_food_cost: int = 0
var available_idle_peasants: int = 0

const FOOD_COST_PER_HEAD_WELL_FED = 25
const BONDI_UNIT_DATA_PATH = "res://data/units/Unit_Bondi.tres"

func _ready() -> void:
	launch_button.pressed.connect(_on_launch_pressed)
	cancel_button.pressed.connect(_on_cancel_pressed)
	provision_slider.value_changed.connect(_on_provision_slider_changed)
	
	# Bondi Connections
	bondi_slider.value_changed.connect(_on_bondi_slider_changed)
	
	# Default UI state
	provision_slider.value = 1
	_update_provision_ui()
	hide()

func setup(target: RaidTargetData) -> void:
	if not target or not SettlementManager.has_current_settlement():
		Loggie.msg("RaidPrepWindow: Setup failed.").domain(LogDomains.UI).error()
		return
		
	current_target = target
	selected_warbands.clear()
	
	# 1. Update Target Info
	target_name_label.text = target.display_name
	description_label.text = target.description
	val_diff.text = "%d Stars" % target.difficulty_rating
	
	var auth_cost = target.raid_cost_authority
	if target.authority_cost_override > -1:
		auth_cost = target.authority_cost_override
	val_cost.text = "%d" % auth_cost
	
	val_cost.modulate = Color.SALMON if not DynastyManager.can_spend_authority(auth_cost) else Color.WHITE

	# --- FIX START: Use SettlementManager as Source of Truth ---
	# Old: max_capacity = SettlementManager.current_settlement.get_fleet_capacity()
	max_capacity = SettlementManager.get_total_ship_capacity_squads()
	# --- FIX END ---
	
	available_idle_peasants = SettlementManager.get_idle_peasants()
	
	# 3. Setup Bondi Slider
	bondi_slider.min_value = 0
	bondi_slider.max_value = available_idle_peasants
	bondi_slider.value = 0
	_update_bondi_ui()
	
	# 4. Populate Warbands
	_populate_warband_list()
	
	# 5. Reset & Open
	current_provision_level = 1
	provision_slider.value = 1
	_update_provision_ui()
	_update_capacity_ui()
	show()

func _populate_warband_list() -> void:
	for child in warband_list.get_children():
		child.queue_free()
		
	var warbands = SettlementManager.current_settlement.warbands
	for wb in warbands:
		# Don't list Bondi if they somehow persisted (safety)
		if wb.is_bondi: continue
		
		var checkbox = CheckBox.new()
		checkbox.text = "%s (%d/%d)" % [wb.custom_name, wb.current_manpower, WarbandData.MAX_MANPOWER]
		checkbox.toggled.connect(_on_warband_toggled.bind(wb, checkbox))
		warband_list.add_child(checkbox)

func _on_warband_toggled(is_checked: bool, warband: WarbandData, checkbox_node: CheckBox) -> void:
	if is_checked:
		if _get_total_fleet_usage() >= max_capacity:
			checkbox_node.set_pressed_no_signal(false)
			_shake_capacity_label()
			return
		selected_warbands.append(warband)
	else:
		selected_warbands.erase(warband)
	
	_update_capacity_ui()
	_update_provision_cost()

func _on_bondi_slider_changed(_value: float) -> void:
	_update_bondi_ui()
	_update_capacity_ui() # Bondi consume slots!
	_update_provision_cost() # Bondi need food!

func _update_bondi_ui() -> void:
	var count = int(bondi_slider.value)
	bondi_count_label.text = "%d / %d" % [count, available_idle_peasants]
	
	if count > 0:
		bondi_count_label.modulate = Color.YELLOW
	else:
		bondi_count_label.modulate = Color.WHITE

func _get_total_fleet_usage() -> int:
	var slots = selected_warbands.size()
	
	# Calculate Bondi Warbands needed
	var bondi_count = int(bondi_slider.value)
	if bondi_count > 0:
		var bondi_bands = ceil(float(bondi_count) / WarbandData.MAX_MANPOWER)
		slots += int(bondi_bands)
		
	return slots

func _update_capacity_ui() -> void:
	var usage = _get_total_fleet_usage()
	capacity_label.text = "Fleet Capacity: %d / %d" % [usage, max_capacity]
	
	if usage > max_capacity:
		capacity_label.modulate = Color.SALMON
		launch_button.disabled = true
	elif usage == max_capacity:
		capacity_label.modulate = Color.YELLOW
		_validate_launch_readiness()
	else:
		capacity_label.modulate = Color.WHITE
		_validate_launch_readiness()

func _validate_launch_readiness() -> void:
	# 1. Check Usage vs Capacity
	if _get_total_fleet_usage() > max_capacity:
		launch_button.disabled = true
		launch_button.tooltip_text = "Fleet Over capacity!"
		return
		
	# 2. Check Troops (Need at least 1 regular OR some bondi)
	if selected_warbands.is_empty() and bondi_slider.value <= 0:
		launch_button.disabled = true
		launch_button.tooltip_text = "Must select at least one Warband or Bondi."
		return
		
	# 3. Check Authority
	var cost = current_target.raid_cost_authority
	if current_target.authority_cost_override > -1:
		cost = current_target.authority_cost_override
		
	if not DynastyManager.can_spend_authority(cost):
		launch_button.disabled = true
		launch_button.tooltip_text = "Not enough Authority."
		return
		
	# 4. Check Food
	var current_food = SettlementManager.current_settlement.treasury.get(GameResources.FOOD, 0)
	if current_food < calculated_food_cost:
		launch_button.disabled = true
		launch_button.tooltip_text = "Not enough food!"
		return

	launch_button.disabled = false
	launch_button.tooltip_text = "Ready to sail!"

func _on_launch_pressed() -> void:
	# Handle Bondi Creation
	var bondi_count = int(bondi_slider.value)
	if bondi_count > 0:
		_create_and_append_bondi(bondi_count)
	
	# Handle Purchase
	if calculated_food_cost > 0:
		SettlementManager.attempt_purchase({GameResources.FOOD: calculated_food_cost})
			
	raid_launched.emit(current_target, selected_warbands, current_provision_level)
	hide()

func _create_and_append_bondi(count: int) -> void:
	var unit_data = load(BONDI_UNIT_DATA_PATH)
	if not unit_data:
		Loggie.msg("RaidPrep: Missing Bondi Unit Data!").domain(LogDomains.UI).error()
		return
		
	# Deduct Population (They are now soldiers)
	if SettlementManager.current_settlement:
		SettlementManager.current_settlement.population_peasants -= count
	
	# Distribute into Warbands of 10
	var remaining = count
	while remaining > 0:
		var batch_size = min(remaining, WarbandData.MAX_MANPOWER)
		
		var bondi_band = WarbandData.new(unit_data)
		bondi_band.is_bondi = true
		bondi_band.current_manpower = batch_size
		bondi_band.custom_name = "The Bondi"
		
		# Add to selection AND settlement warbands (so they persist if saved)
		if SettlementManager.current_settlement:
			SettlementManager.current_settlement.warbands.append(bondi_band)
			
		selected_warbands.append(bondi_band)
		
		remaining -= batch_size
		
	Loggie.msg("Drafted %d peasants into Bondi." % count).domain(LogDomains.UI).info()

func _on_cancel_pressed() -> void:
	hide()
	closed.emit()

func _update_provision_cost() -> void:
	# Recalculate total men including Bondi
	var total_men = 0
	for wb in selected_warbands:
		total_men += wb.current_manpower
	
	# Add Bondi from slider if not yet created
	if bondi_slider.value > 0:
		total_men += int(bondi_slider.value)

	if current_provision_level == 2:
		calculated_food_cost = total_men * FOOD_COST_PER_HEAD_WELL_FED
	else:
		calculated_food_cost = 0
		
	cost_label.text = "%d Food" % calculated_food_cost
	_validate_launch_readiness()

func _on_provision_slider_changed(value: float) -> void:
	current_provision_level = int(value)
	_update_provision_ui()
	_update_provision_cost()

func _update_provision_ui() -> void:
	match current_provision_level:
		0:
			effect_label.text = "High Attrition Risk!"
			effect_label.modulate = Color.SALMON
		1:
			effect_label.text = "Standard Risk"
			effect_label.modulate = Color.WHITE
		2:
			effect_label.text = "Risk Reduced (-15%)"
			effect_label.modulate = Color.GREEN

func _shake_capacity_label() -> void:
	var tween = create_tween()
	var original_pos = capacity_label.position.x
	tween.tween_property(capacity_label, "position:x", original_pos + 5, 0.05)
	tween.tween_property(capacity_label, "position:x", original_pos - 5, 0.05)
	tween.tween_property(capacity_label, "position:x", original_pos, 0.05)


--------------------------------------------------
FILE: res:///ui/RaidPrepWindow.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://ciue5kdakyr78"]

[ext_resource type="Script" uid="uid://dsb5s7kg7ce80" path="res://ui/RaidPrepWindow.gd" id="1_tdrb5"]

[node name="RaidPrepWindow" type="PanelContainer"]
script = ExtResource("1_tdrb5")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="MainVBox" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="HeaderLabel" type="Label" parent="MarginContainer/MainVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Muster the Leidang"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="MarginContainer/MainVBox"]
layout_mode = 2

[node name="ContentHBox" type="HBoxContainer" parent="MarginContainer/MainVBox"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 20

[node name="LeftCol" type="VBoxContainer" parent="MarginContainer/MainVBox/ContentHBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="TargetNameLabel" type="Label" parent="MarginContainer/MainVBox/ContentHBox/LeftCol"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 0, 0, 1)
theme_override_font_sizes/font_size = 20
text = "Target Name"

[node name="DescriptionLabel" type="RichTextLabel" parent="MarginContainer/MainVBox/ContentHBox/LeftCol"]
layout_mode = 2
size_flags_vertical = 3
text = "Description goes here..."
fit_content = true

[node name="StatsGrid" type="GridContainer" parent="MarginContainer/MainVBox/ContentHBox/LeftCol"]
layout_mode = 2
columns = 2

[node name="LabelDiff" type="Label" parent="MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid"]
modulate = Color(0.827451, 0.827451, 0.827451, 1)
layout_mode = 2
text = "Difficulty:"

[node name="ValDiff" type="Label" parent="MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid"]
layout_mode = 2
text = "1 Star"

[node name="LabelCost" type="Label" parent="MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid"]
modulate = Color(0.827451, 0.827451, 0.827451, 1)
layout_mode = 2
text = "Auth Cost:"

[node name="ValCost" type="Label" parent="MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid"]
layout_mode = 2
text = "1"

[node name="LabelTravel" type="Label" parent="MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid"]
modulate = Color(0.827451, 0.827451, 0.827451, 1)
layout_mode = 2
text = "Travel Time:"

[node name="ValTravel" type="Label" parent="MarginContainer/MainVBox/ContentHBox/LeftCol/StatsGrid"]
layout_mode = 2
text = "Medium"

[node name="VSeparator" type="VSeparator" parent="MarginContainer/MainVBox/ContentHBox"]
layout_mode = 2

[node name="RightCol" type="VBoxContainer" parent="MarginContainer/MainVBox/ContentHBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="CapacityLabel" type="Label" parent="MarginContainer/MainVBox/ContentHBox/RightCol"]
layout_mode = 2
text = "Fleet Capacity: 0/4"
horizontal_alignment = 2

[node name="ScrollContainer" type="ScrollContainer" parent="MarginContainer/MainVBox/ContentHBox/RightCol"]
layout_mode = 2
size_flags_vertical = 3

[node name="WarbandList" type="VBoxContainer" parent="MarginContainer/MainVBox/ContentHBox/RightCol/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="BondiPanel" type="PanelContainer" parent="MarginContainer/MainVBox/ContentHBox/RightCol"]
layout_mode = 2

[node name="BondiVBox" type="VBoxContainer" parent="MarginContainer/MainVBox/ContentHBox/RightCol/BondiPanel"]
layout_mode = 2

[node name="BondiLabel" type="Label" parent="MarginContainer/MainVBox/ContentHBox/RightCol/BondiPanel/BondiVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.029002039, 0.22655004, 0.21467707, 1)
text = "Recruit the Bondi (Farmers)"

[node name="BondiSliderBox" type="HBoxContainer" parent="MarginContainer/MainVBox/ContentHBox/RightCol/BondiPanel/BondiVBox"]
layout_mode = 2

[node name="BondiSlider" type="HSlider" parent="MarginContainer/MainVBox/ContentHBox/RightCol/BondiPanel/BondiVBox/BondiSliderBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 4
max_value = 10.0

[node name="BondiCountLabel" type="Label" parent="MarginContainer/MainVBox/ContentHBox/RightCol/BondiPanel/BondiVBox/BondiSliderBox"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "0 / 10"
horizontal_alignment = 2

[node name="HSeparator2" type="HSeparator" parent="MarginContainer/MainVBox"]
layout_mode = 2

[node name="ProvisionsPanel" type="PanelContainer" parent="MarginContainer/MainVBox"]
layout_mode = 2

[node name="HBox" type="HBoxContainer" parent="MarginContainer/MainVBox/ProvisionsPanel"]
layout_mode = 2

[node name="Label" type="Label" parent="MarginContainer/MainVBox/ProvisionsPanel/HBox"]
layout_mode = 2
text = "Supplies:"

[node name="ProvisionSlider" type="HSlider" parent="MarginContainer/MainVBox/ProvisionsPanel/HBox"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
size_flags_vertical = 4
max_value = 2.0
value = 1.0
tick_count = 3
ticks_on_borders = true

[node name="CostLabel" type="Label" parent="MarginContainer/MainVBox/ProvisionsPanel/HBox"]
layout_mode = 2
text = "0 Food"

[node name="EffectLabel" type="Label" parent="MarginContainer/MainVBox/ProvisionsPanel/HBox"]
layout_mode = 2
size_flags_horizontal = 3
text = "Normal Risk"
horizontal_alignment = 2

[node name="ActionButtons" type="HBoxContainer" parent="MarginContainer/MainVBox"]
layout_mode = 2
theme_override_constants/separation = 20
alignment = 2

[node name="CancelButton" type="Button" parent="MarginContainer/MainVBox/ActionButtons"]
custom_minimum_size = Vector2(100, 40)
layout_mode = 2
text = "Cancel"

[node name="LaunchButton" type="Button" parent="MarginContainer/MainVBox/ActionButtons"]
custom_minimum_size = Vector2(120, 40)
layout_mode = 2
text = "Set Sail"


--------------------------------------------------
FILE: res:///ui/SelectionBox.gd
--------------------------------------------------
# res://ui/SelectionBox.gd
# This Control node covers the entire screen.
# It listens for
# raw input, draws the selection box, and emits clean,
# intent-based signals to the EventBus.
# It also uses
# accept_event() to stop input from passing through the UI.
extends Control
var is_dragging := false
var start_pos := Vector2.ZERO
var is_command_dragging := false
var command_start_pos := Vector2.ZERO
# ---------------------------

func _ready() -> void:
	# Allow unused mouse events (like Zoom) to pass to the Camera
	# but DON'T consume mouse events here; let other UI handle them
	mouse_filter = Control.MOUSE_FILTER_PASS


func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.is_pressed():
				# 1. Try to pick a building first
				if _try_select_building(get_local_mouse_position()):
					accept_event()
					return
				
				# 2. If no building, start drag selection
				is_dragging = true
				start_pos = get_local_mouse_position()
				accept_event()
				
				# Clear previous building selection when clicking ground
				EventBus.building_deselected.emit()
				
			elif is_dragging: # Release
				is_dragging = false
				var end_pos := get_local_mouse_position()
				var rect := Rect2(start_pos, end_pos - start_pos).abs()
				var is_box_select = rect.size.length_squared() > 100
				EventBus.select_command.emit(rect, is_box_select)
				queue_redraw()
				accept_event()
		
	# Right Click Handling
		if event.button_index == MOUSE_BUTTON_RIGHT:
			if event.is_pressed():
				is_command_dragging = true
				command_start_pos = get_local_mouse_position()
				accept_event()
			else: # On Release
				if not is_command_dragging: return
				is_command_dragging = false
				
				var end_pos = get_local_mouse_position()
				var drag_vector = end_pos - command_start_pos
				
				# Check for drag vs click
				if drag_vector.length_squared() > 225:
					# Drag Logic (Formation)
					var main_camera = get_viewport().get_camera_2d()
					if main_camera:
						var world_end = main_camera.get_global_mouse_position()
						var world_start = world_end - (drag_vector / main_camera.zoom)
						var dir = (world_end - world_start).normalized()
						EventBus.formation_move_command.emit(world_start, dir)
				else:
					# Click Logic (Smart Command)
					_handle_smart_command(end_pos)
					
				queue_redraw()
				accept_event()
				
	elif event is InputEventMouseMotion:
		if is_dragging or is_command_dragging:
			# Update the draw loop as the mouse moves
			queue_redraw()
			accept_event()

func _handle_smart_command(_screen_pos: Vector2) -> void:
	var world_space: PhysicsDirectSpaceState2D = get_world_2d().direct_space_state
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	
	if not main_camera: return
		
	var world_pos: Vector2 = main_camera.get_global_mouse_position()
	
	var query := PhysicsPointQueryParameters2D.new()
	query.position = world_pos
	query.collide_with_areas = true
	query.collide_with_bodies = true
	query.collision_mask = 13 # Layers 1, 4, 8
	
	var results: Array = world_space.intersect_point(query)
	
	if not results.is_empty():
		var hit_object = results[0].collider
		
		# Bubble up from Hitbox
		var final_target = hit_object
		if hit_object.name == "Hitbox" and hit_object.get_parent() is BaseBuilding:
			final_target = hit_object.get_parent()
		
		# 1. Friendly Building -> INTERACT
		if final_target.collision_layer == 1 and final_target is BaseBuilding:
			Loggie.msg("SelectionBox: Friendly interact.").domain("UI").debug()
			EventBus.interact_command.emit(final_target)
			
		# 2. Enemy Building -> CHECK MODIFIER
		elif final_target is BaseBuilding:
			if Input.is_key_pressed(KEY_CTRL):
				# CTRL Held: BURN (Attack)
				Loggie.msg("SelectionBox: CTRL held -> BURN command.").domain("UI").info()
				EventBus.attack_command.emit(final_target)
			else:
				# Normal Click: PILLAGE
				Loggie.msg("SelectionBox: Normal click -> PILLAGE command.").domain("UI").info()
				EventBus.pillage_command.emit(final_target)
				
		# 3. Enemy Unit -> ALWAYS ATTACK
		else:
			EventBus.attack_command.emit(final_target)
			
	else:
		EventBus.move_command.emit(world_pos)

func _try_select_building(screen_pos: Vector2) -> bool:
	var world_space = get_world_2d().direct_space_state
	var main_camera = get_viewport().get_camera_2d()
	if not main_camera: return false
	
	var world_pos = main_camera.get_global_mouse_position()
	
	var query = PhysicsPointQueryParameters2D.new()
	query.position = world_pos
	query.collide_with_bodies = true
	query.collide_with_areas = true
	# Layer 1 (Player Building) + 9 (Hitboxes) usually. 
	# We check for objects that have the 'data' property or are BaseBuilding.
	query.collision_mask = 1 # Layer 1 is Environment/Player Buildings
	
	var results = world_space.intersect_point(query)
	
	for res in results:
		var collider = res.collider
		# Bubble up from Hitbox if needed
		if collider.name == "Hitbox" and collider.get_parent() is BaseBuilding:
			collider = collider.get_parent()
			
		if collider is BaseBuilding:
			EventBus.building_selected.emit(collider)
			return true
			
	return false
		
func _draw() -> void:
	# This function draws the selection box
	if is_dragging:
		var current_pos := get_local_mouse_position()
		var rect := Rect2(start_pos, current_pos - start_pos).abs()
		
		# Draw a semi-transparent fill
		draw_rect(rect, Color(0.8, 0.8, 1.0, 0.2), true)
		# Draw a solid outline
		draw_rect(rect, Color(0.8, 0.8, 1.0, 1.0), false, 1.0)
	
	# --- NEW: Draw command drag line ---
	if is_command_dragging:
		var current_pos := get_local_mouse_position()
		draw_line(command_start_pos, current_pos, Color.GREEN, 2.0)
		draw_circle(command_start_pos, 5.0, Color.GREEN)
		draw_circle(current_pos, 3.0, Color.GREEN)
	# ----------------------------------


--------------------------------------------------
FILE: res:///ui/SelectionBox.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://1ly65bng2mep"]

[ext_resource type="Script" uid="uid://cl00k8pr5pe01" path="res://ui/SelectionBox.gd" id="1_3dxp5"]
[ext_resource type="Theme" uid="uid://63duv3n1vwhg" path="res://ui/themes/VikingDynastyTheme.tres" id="2_theme"]

[node name="SelectionBox" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_theme")
script = ExtResource("1_3dxp5")


--------------------------------------------------
FILE: res:///ui/StorefrontUI.gd
--------------------------------------------------
extends Control

const LegacyUpgradeData = preload("res://data/legacy/LegacyUpgradeData.gd")
const RICH_TOOLTIP_SCRIPT = preload("res://ui/components/RichTooltipButton.gd")

# --- UI LOGIC CONSTANTS (Winter Forecast) ---
const WINTER_FOOD_PER_PEASANT: int = 1
const WINTER_FOOD_PER_WARBAND: int = 5
const WINTER_WOOD_BASE_COST: int = 20

# --- Window References ---
@onready var build_window: Control = %BuildWindow
@onready var recruit_window: Control = %RecruitWindow
@onready var legacy_window: Control = %LegacyWindow

# --- Content Containers ---
@onready var build_grid: Container = %BuildGrid
@onready var recruit_list: Container = %RecruitList
@onready var legacy_list: Container = %LegacyList

# --- Legacy Stats ---
@onready var renown_label: Label = %RenownLabel
@onready var authority_label: Label = %AuthorityLabel

# --- Dock Buttons ---
@onready var btn_build: Button = %Btn_Build
@onready var btn_recruit: Button = %Btn_Recruit
@onready var btn_upgrades: Button = %Btn_LegacyUpgrades
@onready var btn_family: Button = %Btn_Family
@onready var btn_map: Button = %Btn_Map
@onready var btn_end_year: Button = %Btn_EndYear
@onready var btn_allocation: Button = %Btn_Allocation
@onready var date_label: Label = %DateLabel

# --- Data ---
## List of buildings available for construction.
@export var available_buildings: Array[BuildingData] = []
## List of units available for recruitment.
@export var available_units: Array[UnitData] = []
## If true, units are loaded from the file system automatically.
@export var auto_load_units_from_directory: bool = true

# --- State for Refunds ---
# Relaxed type to generic Dictionary to accept data from Resources
var pending_cost: Dictionary = {} 

func _ready() -> void:
	mouse_filter = Control.MOUSE_FILTER_IGNORE

	EventBus.purchase_successful.connect(_on_purchase_successful)
	EventBus.purchase_failed.connect(_on_purchase_failed)
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	
	# Listen for Selection Changes to toggle Build Button
	EventBus.units_selected.connect(_on_units_selected)
	# Listen for Season Changes
	EventBus.season_changed.connect(_on_season_changed)
	
	DynastyManager.jarl_stats_updated.connect(_update_jarl_stats_display)
	DynastyManager.year_ended.connect(_on_year_ended)
	
	_apply_theme_overrides()
	_setup_dock_icons()
	_setup_window_logic()
	
	_load_building_data()
	_load_unit_data()
	
	if DynastyManager.current_jarl:
		_update_jarl_stats_display(DynastyManager.get_current_jarl())
	
	# Default State: Hide Build Button until Villager is selected
	if btn_build: btn_build.hide()
	
	# Allocation Button Logic
	if btn_allocation:
		btn_allocation.pressed.connect(func(): get_tree().call_group("seasonal_ui", "toggle_interface", "allocation"))
	
	# Initialize the Season Button Text
	_on_season_changed(DynastyManager.get_current_season_name())
	_update_date_display(DynastyManager.get_current_season_name())
	_refresh_all()

# --- CONTEXT SENSITIVE UI LOGIC ---

func _on_units_selected(selected_units: Array) -> void:
	var has_builder = false
	for unit in selected_units:
		if is_instance_valid(unit) and unit.is_in_group("civilians"):
			has_builder = true
			break
	
	if has_builder:
		if btn_build and not btn_build.visible:
			btn_build.show()
	else:
		if btn_build and btn_build.visible:
			btn_build.hide()
			if build_window.visible:
				build_window.hide()
				EventBus.camera_input_lock_requested.emit(false)

# --- WINTER FORECAST LOGIC ---

func _update_end_year_tooltip(season_name: String) -> void:
	if not btn_end_year: return
	
	# 1. Determine "Next" Season for projection
	var next_season_name = "Spring"
	if season_name == "Spring": next_season_name = "Summer"
	elif season_name == "Summer": next_season_name = "Autumn"
	elif season_name == "Autumn": next_season_name = "Winter"
	
	var action_text = "Advance to %s" % next_season_name
	var tooltip = "[b]%s[/b]" % action_text
	
	if SettlementManager.current_settlement:
		var s = SettlementManager.current_settlement
		
		# --- A. INCOME PROJECTION ---
		tooltip += "\n\n[b]Projected Gains (%s):[/b]" % next_season_name
		
		# Strict typing: Get projection from EconomyManager
		var yearly: Dictionary[String, int] = EconomyManager.get_projected_income()
		var has_gains = false
		var has_potential_but_no_workers = false
		
		# Calculate Potential (to detect missing workers)
		if yearly.is_empty() and not s.placed_buildings.is_empty():
			has_potential_but_no_workers = true

		for res in yearly:
			var amount = 0
			# Special Food Rule (Only Autumn)
			if res == "food":
				if next_season_name == "Autumn":
					amount = yearly[res]
				else:
					amount = 0
			else:
				# Quarterly for others
				amount = int(yearly[res] / 4.0)
			
			if amount > 0:
				has_gains = true
				
				# --- CAP CHECK ---
				var is_full = EconomyManager.is_storage_full(res)
				var display_text = ""
				
				if is_full:
					# Show red warning if capped
					display_text = "[color=red]+%d (Capped!)[/color]" % amount
				else:
					# Normal Green
					var color = "green"
					if res == "gold": color = "yellow"
					display_text = "[color=%s]+%d[/color]" % [color, amount]
				
				tooltip += "\n%s: %s" % [res.capitalize(), display_text]
			else:
				# Show 0s if it's not food growing season, to avoid confusion
				if res != "food":
					tooltip += "\n%s: +0 (Assign Workers!)" % res.capitalize()
		
		if not has_gains:
			if has_potential_but_no_workers:
				tooltip += "\n[color=red]No Income (Assign Workers to Buildings)[/color]"
			else:
				tooltip += "\n[color=gray]None (Build production buildings)[/color]"
		
		# --- B. WINTER CONSUMPTION WARNING ---
		if next_season_name == "Winter":
			# Get forecast from Single Source of Truth
			var forecast = EconomyManager.get_winter_forecast()
			var food_demand = forecast["food"]
			var wood_demand = forecast["wood"]
			
			tooltip += "\n\n[b]Winter Consumption:[/b]"
			
			var current_food = s.treasury.get("food", 0)
			var food_col = "orange"
			if current_food < food_demand: food_col = "red"
			tooltip += "\nFood: [color=%s]-%d[/color]" % [food_col, food_demand]
			
			var current_wood = s.treasury.get("wood", 0)
			var wood_col = "orange"
			if current_wood < wood_demand: wood_col = "red"
			tooltip += "\nWood: [color=%s]-%d[/color]" % [wood_col, wood_demand]
			
			if current_food < food_demand:
				tooltip += "\n\n[color=red][b]WARNING: Starvation Risk![/b][/color]"
	
	btn_end_year.tooltip_text = tooltip

func _on_season_changed(season_name: String) -> void:
	# Update Allocation Button Visibility
	if btn_allocation:
		btn_allocation.visible = (season_name == "Summer")

	if not btn_end_year: return
	
	# Update Button Text
	if season_name == "Summer": 
		btn_end_year.text = "Autumn"
		btn_end_year.modulate = Color.WHITE
	if season_name == "Autumn":
		btn_end_year.text = "Winter"
		btn_end_year.modulate = Color(0.8, 0.8, 1.0)
	elif season_name == "Winter":
		btn_end_year.text = "Spring"
		btn_end_year.modulate = Color.WHITE
	else:
		btn_end_year.text = "Next Season"
		btn_end_year.modulate = Color.WHITE
		
	_update_end_year_tooltip(season_name)
	_update_date_display(season_name)
	_update_end_year_tooltip(season_name)
# --- BUILD TAB ---

func _update_date_display(season_name: String) -> void:
	if date_label:
		var year = DynastyManager.current_year
		date_label.text = "%s, %d AD" % [season_name, year]

func _populate_build_grid() -> void:
	for child in build_grid.get_children(): child.queue_free()
	
	for b_data in available_buildings:
		var btn = Button.new()
		
		if RICH_TOOLTIP_SCRIPT:
			btn.set_script(RICH_TOOLTIP_SCRIPT)
		
		btn.custom_minimum_size = Vector2(110, 110) 
		btn.icon_alignment = HORIZONTAL_ALIGNMENT_CENTER
		btn.vertical_icon_alignment = VERTICAL_ALIGNMENT_TOP
		btn.expand_icon = true
		btn.text_overrun_behavior = TextServer.OVERRUN_TRIM_ELLIPSIS
		btn.clip_text = true
		
		if b_data.icon:
			btn.icon = b_data.icon
		else:
			btn.text = b_data.display_name 
			
		var details = ""
		if b_data is EconomicBuildingData:
			var eco = b_data as EconomicBuildingData
			details = "[color=green]Production:[/color] %d %s / Year\n" % [eco.base_passive_output, eco.resource_type.capitalize()]
			details += "Capacity: %d Workers" % eco.peasant_capacity
		elif b_data.is_defensive_structure:
			details = "[color=salmon]Defense:[/color] %d Dmg | Range: %.0f" % [b_data.attack_damage, b_data.attack_range]
		
		if b_data.is_territory_hub:
			details += "\n[color=cyan]Territory Hub[/color]"
		elif b_data.extends_territory:
			details += "\n[color=cyan]Extends Territory[/color]"
			
		btn.tooltip_text = "[b]%s[/b]\n[i]%s[/i]\n\n%s\n\n[color=gold]Cost:[/color] %s" % [
			b_data.display_name, 
			b_data.description,
			details,
			# FIX: Pass Dictionary directly, now accepted
			_format_cost(b_data.build_cost)
		]
		
		btn.pressed.connect(func():
			if EconomyManager.attempt_purchase(b_data.build_cost):
				pending_cost = b_data.build_cost.duplicate()
				EventBus.building_ready_for_placement.emit(b_data)
				_close_all_windows()
				
				var cursor = get_tree().get_first_node_in_group("building_preview_cursor")
				if cursor and not cursor.placement_cancelled.is_connected(_on_placement_cancelled):
					cursor.placement_cancelled.connect(_on_placement_cancelled, CONNECT_ONE_SHOT)
					cursor.placement_completed.connect(_on_placement_completed, CONNECT_ONE_SHOT)
		)
		build_grid.add_child(btn)

func _on_placement_cancelled() -> void:
	if not pending_cost.is_empty():
		EconomyManager.add_resources(pending_cost)
		EventBus.purchase_successful.emit("Refunded")
		pending_cost.clear()

func _on_placement_completed() -> void:
	pending_cost.clear()

# --- DOCK & WINDOW LOGIC ---

func _setup_dock_icons() -> void:
	_set_btn_icon(btn_build, "res://ui/assets/icon_build.png")
	_set_btn_icon(btn_recruit, "res://ui/assets/icon_army.png")
	_set_btn_icon(btn_upgrades, "res://ui/assets/icon_crown.png")
	_set_btn_icon(btn_family, "res://ui/assets/icon_family.png")
	_set_btn_icon(btn_map, "res://ui/assets/icon_map.png")
	_set_btn_icon(btn_end_year, "res://ui/assets/icon_time.png")
	# Allocation button relies on text for now, or generic icon if available

func _set_btn_icon(btn: Button, path: String) -> void:
	if btn and ResourceLoader.exists(path):
		btn.icon = load(path)
		btn.expand_icon = true
		btn.custom_minimum_size = Vector2(80, 80) 
		btn.icon_alignment = HORIZONTAL_ALIGNMENT_CENTER
		btn.vertical_icon_alignment = VERTICAL_ALIGNMENT_TOP

func _setup_window_logic() -> void:
	btn_build.pressed.connect(_toggle_window.bind(build_window))
	btn_recruit.pressed.connect(_toggle_window.bind(recruit_window))
	btn_upgrades.pressed.connect(_toggle_window.bind(legacy_window))
	
	btn_family.pressed.connect(func(): EventBus.dynasty_view_requested.emit())
	btn_map.pressed.connect(func(): EventBus.scene_change_requested.emit(GameScenes.WORLD_MAP))
	
	# Emit new Season signal instead of direct End Year
	if btn_end_year.is_connected("pressed", func(): EventBus.end_year_requested.emit()):
		btn_end_year.disconnect("pressed", func(): EventBus.end_year_requested.emit())
		
	btn_end_year.pressed.connect(func(): EventBus.advance_season_requested.emit())
	
	var windows = [build_window, recruit_window, legacy_window]
	for win in windows:
		if win:
			win.mouse_entered.connect(func(): EventBus.camera_input_lock_requested.emit(true))
			win.mouse_exited.connect(func(): EventBus.camera_input_lock_requested.emit(false))
	
	_close_all_windows()

func _toggle_window(target_window: Control) -> void:
	if not target_window.visible:
		_close_all_windows()
		target_window.show()
	else:
		target_window.hide()

func _close_all_windows() -> void:
	if build_window: build_window.hide()
	if recruit_window: recruit_window.hide()
	if legacy_window: legacy_window.hide()
	EventBus.camera_input_lock_requested.emit(false)

func _refresh_all() -> void:
	_populate_build_grid()
	_update_garrison_display()
	_populate_legacy_buttons()
	# Update the Forecast using current season context
	_update_end_year_tooltip(DynastyManager.get_current_season_name())
	
func _on_purchase_successful(_item: String) -> void:
	_refresh_all()

func _on_purchase_failed(reason: String) -> void:
	_show_toast(reason, Color.SALMON)

func _show_toast(text: String, color: Color) -> void:
	var label = Label.new()
	label.text = text
	label.add_theme_color_override("font_color", color)
	label.add_theme_font_size_override("font_size", 32)
	label.add_theme_color_override("font_outline_color", Color.BLACK)
	label.add_theme_constant_override("outline_size", 6)
	add_child(label)
	label.position = get_viewport_rect().size / 2.0 - Vector2(100, 50)
	var tween = create_tween()
	tween.set_parallel(true)
	tween.tween_property(label, "position:y", label.position.y - 100, 1.5).set_trans(Tween.TRANS_EXPO).set_ease(Tween.EASE_OUT)
	tween.tween_property(label, "modulate:a", 0.0, 1.5).set_ease(Tween.EASE_IN)
	tween.chain().tween_callback(label.queue_free)

func _on_settlement_loaded(_data: SettlementData) -> void:
	_refresh_all()

func _on_year_ended() -> void:
	_update_garrison_display()
	_refresh_all()

func _update_jarl_stats_display(jarl_data: JarlData) -> void:
	if not jarl_data: return
	if renown_label: renown_label.text = "Renown: %d" % jarl_data.renown
	if authority_label: authority_label.text = "Auth: %d/%d" % [jarl_data.current_authority, jarl_data.max_authority]
	_populate_legacy_buttons()

func _update_garrison_display() -> void:
	if recruit_list:
		for child in recruit_list.get_children(): child.queue_free()
		
		var header = Label.new()
		header.text = "Active Warbands"
		header.add_theme_color_override("font_color", Color("#c5a54e")) 
		recruit_list.add_child(header)
		
		if SettlementManager.current_settlement:
			for warband in SettlementManager.current_settlement.warbands:
				_create_warband_entry(warband)
		
		var sep = HSeparator.new()
		recruit_list.add_child(sep)
		var header2 = Label.new()
		header2.text = "Recruit New"
		header2.add_theme_color_override("font_color", Color("#c5a54e"))
		recruit_list.add_child(header2)
		
		for u_data in available_units:
			var btn = Button.new()
			btn.text = "%s (%s)" % [u_data.display_name, _format_cost(u_data.spawn_cost)]
			btn.alignment = HORIZONTAL_ALIGNMENT_LEFT
			if u_data.icon:
				btn.icon = u_data.icon
				btn.expand_icon = true
				btn.custom_minimum_size = Vector2(0, 48)
				
			btn.pressed.connect(func():
				if EconomyManager.attempt_purchase(u_data.spawn_cost):
					SettlementManager.recruit_unit(u_data)
					_refresh_all()
			)
			recruit_list.add_child(btn)

func _create_warband_entry(warband: WarbandData) -> void:
	var row = HBoxContainer.new()
	recruit_list.add_child(row)
	
	var lbl = RichTextLabel.new()
	lbl.bbcode_enabled = true
	lbl.fit_content = true
	lbl.custom_minimum_size = Vector2(250, 40)
	
	var jarl_name = "Jarl"
	if DynastyManager.current_jarl: jarl_name = DynastyManager.current_jarl.display_name
	
	lbl.text = "[b]%s[/b] (Lvl %d)\n%s" % [warband.custom_name, warband.get_level(), warband.get_loyalty_description(jarl_name)]
	row.add_child(lbl)
	
	if warband.gear_tier < WarbandData.MAX_GEAR_TIER:
		var btn = Button.new()
		btn.text = "^ %d G" % warband.get_gear_cost()
		btn.pressed.connect(SettlementManager.upgrade_warband_gear.bind(warband))
		row.add_child(btn)
		
	var guard = Button.new()
	guard.text = "G"
	guard.tooltip_text = "Toggle Hearth Guard"
	if warband.is_hearth_guard: guard.modulate = Color.CYAN
	guard.pressed.connect(SettlementManager.toggle_hearth_guard.bind(warband))
	row.add_child(guard)

func _populate_legacy_buttons() -> void:
	if not legacy_list: return
	for child in legacy_list.get_children(): child.queue_free()
	
	if DynastyManager.loaded_legacy_upgrades.is_empty():
		var label = Label.new()
		label.text = "No upgrades available."
		legacy_list.add_child(label)
		return
	
	var jarl = DynastyManager.get_current_jarl()
	if not jarl: return
	var is_pious = jarl.has_trait("Pious")

	for upgrade_data in DynastyManager.loaded_legacy_upgrades:
		var current_renown_cost = upgrade_data.renown_cost
		if is_pious and upgrade_data.effect_key == "UPG_BUILD_CHAPEL":
			current_renown_cost = max(0, upgrade_data.renown_cost - 25)

		var btn = Button.new()
		var cost_text = "Cost: %d Renown, %d Auth" % [current_renown_cost, upgrade_data.authority_cost]
		btn.text = "%s\n%s" % [upgrade_data.display_name, cost_text]
		btn.alignment = HORIZONTAL_ALIGNMENT_LEFT
		
		if upgrade_data.is_purchased:
			btn.disabled = true
			btn.text = "%s (Owned)" % upgrade_data.display_name
			
		btn.pressed.connect(func():
			if DynastyManager.spend_renown(upgrade_data.renown_cost) and DynastyManager.spend_authority(upgrade_data.authority_cost):
				DynastyManager.purchase_legacy_upgrade(upgrade_data.effect_key)
				_refresh_all()
		)
		legacy_list.add_child(btn)

func _load_building_data() -> void:
	available_buildings.clear()
	_scan_directory_for_buildings("res://data/buildings/")
	_scan_directory_for_buildings("res://data/buildings/generated/")

func _scan_directory_for_buildings(path: String) -> void:
	if not DirAccess.dir_exists_absolute(path): return
	
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file = dir.get_next()
		while file != "":
			if file.ends_with(".tres"):
				var full_path = path + file
				var data = load(full_path)
				if data is BuildingData and data.is_player_buildable: 
					available_buildings.append(data)
			file = dir.get_next()

func _load_unit_data() -> void:
	var dir = DirAccess.open("res://data/units/")
	if dir:
		dir.list_dir_begin()
		var file = dir.get_next()
		while file != "":
			if file.ends_with(".tres"):
				var data = load("res://data/units/" + file)
				if data and "Player" in data.resource_path: available_units.append(data)
			file = dir.get_next()

# Relaxed typing to accept untyped Dictionaries from Resources
func _format_cost(cost: Dictionary) -> String:
	var s: PackedStringArray = []
	for k in cost:
		var display_name = GameResources.get_display_name(k)
		# Use default formatting to handle potentially non-int types gracefully, though likely ints
		s.append("%d %s" % [cost[k], display_name])
	return ", ".join(s)

func _apply_theme_overrides() -> void:
	var tooltip_bg_path = "res://ui/assets/tooltip_bg.png"
	var default_theme_path = "res://ui/themes/VikingDynastyTheme.tres"
	
	if ResourceLoader.exists(tooltip_bg_path):
		var tooltip_tex = load(tooltip_bg_path)
		var style_tooltip = StyleBoxTexture.new()
		style_tooltip.texture = tooltip_tex
		style_tooltip.content_margin_left = 12
		style_tooltip.content_margin_right = 12
		style_tooltip.content_margin_top = 8
		style_tooltip.content_margin_bottom = 8
		
		if theme == null:
			if ResourceLoader.exists(default_theme_path):
				theme = load(default_theme_path)
			else:
				theme = Theme.new()

		theme = theme.duplicate() 
		self.theme = theme
		
		theme.set_stylebox("panel", "TooltipPanel", style_tooltip)
		theme.set_color("font_color", "TooltipLabel", Color.WHITE)
		theme.set_font_size("font_size", "TooltipLabel", 18)


--------------------------------------------------
FILE: res:///ui/Storefront_UI.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://btovbm7r6nern"]

[ext_resource type="Script" uid="uid://t708tcf43ayu" path="res://ui/StorefrontUI.gd" id="1_ht1qg"]
[ext_resource type="PackedScene" uid="uid://gyu45fs0qg5m" path="res://ui/components/TreasuryHud.tscn" id="2_5jinl"]

[node name="Storefront_UI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_ht1qg")

[node name="TreasuryHUD" parent="." instance=ExtResource("2_5jinl")]
layout_mode = 1
anchors_preset = 5
anchor_left = 0.5
anchor_right = 0.5
offset_left = -425.5
offset_right = 425.5
offset_bottom = 80.0

[node name="Windows" type="Control" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_bottom = -78.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="BuildWindow" type="PanelContainer" parent="Windows"]
unique_name_in_owner = true
custom_minimum_size = Vector2(360, 350)
layout_mode = 1
anchors_preset = -1
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -350.0
offset_right = 300.0
grow_vertical = 0

[node name="MarginContainer" type="MarginContainer" parent="Windows/BuildWindow"]
layout_mode = 2

[node name="ScrollContainer" type="ScrollContainer" parent="Windows/BuildWindow/MarginContainer"]
layout_mode = 2

[node name="BuildGrid" type="GridContainer" parent="Windows/BuildWindow/MarginContainer/ScrollContainer"]
unique_name_in_owner = true
layout_mode = 2
columns = 3

[node name="RecruitWindow" type="PanelContainer" parent="Windows"]
unique_name_in_owner = true
custom_minimum_size = Vector2(400, 500)
layout_mode = 1
anchors_preset = -1
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -40.0
offset_right = 40.0
grow_vertical = 0

[node name="MarginContainer" type="MarginContainer" parent="Windows/RecruitWindow"]
layout_mode = 2

[node name="ScrollContainer" type="ScrollContainer" parent="Windows/RecruitWindow/MarginContainer"]
layout_mode = 2
horizontal_scroll_mode = 0

[node name="RecruitList" type="VBoxContainer" parent="Windows/RecruitWindow/MarginContainer/ScrollContainer"]
unique_name_in_owner = true
layout_mode = 2

[node name="LegacyWindow" type="PanelContainer" parent="Windows"]
unique_name_in_owner = true
custom_minimum_size = Vector2(400, 500)
layout_mode = 1
anchors_preset = -1
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -500.0
offset_right = 400.0
grow_vertical = 0

[node name="MarginContainer" type="MarginContainer" parent="Windows/LegacyWindow"]
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="Windows/LegacyWindow/MarginContainer"]
layout_mode = 2

[node name="JarlStats" type="HBoxContainer" parent="Windows/LegacyWindow/MarginContainer/VBoxContainer"]
layout_mode = 2
alignment = 1

[node name="RenownLabel" type="Label" parent="Windows/LegacyWindow/MarginContainer/VBoxContainer/JarlStats"]
unique_name_in_owner = true
layout_mode = 2

[node name="AuthorityLabel" type="Label" parent="Windows/LegacyWindow/MarginContainer/VBoxContainer/JarlStats"]
unique_name_in_owner = true
layout_mode = 2

[node name="HSeparator" type="HSeparator" parent="Windows/LegacyWindow/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="ScrollContainer" type="ScrollContainer" parent="Windows/LegacyWindow/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="LegacyList" type="VBoxContainer" parent="Windows/LegacyWindow/MarginContainer/VBoxContainer/ScrollContainer"]
unique_name_in_owner = true
layout_mode = 2

[node name="BottomDeck" type="PanelContainer" parent="."]
layout_mode = 1
anchors_preset = -1
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -20.0
offset_top = -40.0
offset_right = 20.0
grow_horizontal = 2
grow_vertical = 0

[node name="HBoxContainer" type="HBoxContainer" parent="BottomDeck"]
layout_mode = 2

[node name="Btn_Build" type="Button" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Build"

[node name="Btn_Allocation" type="Button" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Allocation"

[node name="Btn_Recruit" type="Button" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Army"

[node name="Btn_LegacyUpgrades" type="Button" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Legacy"

[node name="Btn_Family" type="Button" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Family"

[node name="VSeparator" type="VSeparator" parent="BottomDeck/HBoxContainer"]
layout_mode = 2

[node name="Btn_Map" type="Button" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "World Map"

[node name="Btn_EndYear" type="Button" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "End Year"

[node name="DateLabel" type="Label" parent="BottomDeck/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Spring, 867 AD"


--------------------------------------------------
FILE: res:///ui/Succession_Crisis_UI.gd
--------------------------------------------------
# res://ui/Succession_Crisis_UI.gd
extends CanvasLayer

# --- Node Refs ---
@onready var panel_container: PanelContainer = $PanelContainer # Added for centering logic
@onready var desc_label = $PanelContainer/MarginContainer/VBoxContainer/DescriptionLabel
@onready var legit_label = $PanelContainer/MarginContainer/VBoxContainer/LegitimacyLabel
@onready var renown_desc = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxDescription
@onready var gold_desc = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxDescription
@onready var pay_renown_btn = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons/PayRenownButton
@onready var refuse_renown_btn = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons/RefuseRenownButton
@onready var pay_gold_btn = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons/PayGoldButton
@onready var refuse_gold_btn = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons/RefuseGoldButton
@onready var confirm_btn = $PanelContainer/MarginContainer/VBoxContainer/ConfirmButton

# --- State ---
var renown_tax: int = 0
var gold_tax: int = 0
var renown_choice: String = "pay"
var gold_choice: String = "pay"

func _ready() -> void:
	# --- NEW: Pause and Center Logic ---
	# 1. Ensure this UI continues running while the game is paused
	process_mode = Node.PROCESS_MODE_ALWAYS
	
	# 2. Pause the Game
	get_tree().paused = true
	Loggie.msg("Succession Crisis Started. Game Paused.").domain("UI").info()
	
	# 3. Force Centering
	if panel_container:
		panel_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	# -----------------------------------

	# Create ButtonGroups
	var renown_group = ButtonGroup.new()
	pay_renown_btn.button_group = renown_group
	refuse_renown_btn.button_group = renown_group
	
	var gold_group = ButtonGroup.new()
	pay_gold_btn.button_group = gold_group
	refuse_gold_btn.button_group = gold_group
	
	pay_renown_btn.pressed.connect(_on_renown_choice.bind("pay"))
	refuse_renown_btn.pressed.connect(_on_renown_choice.bind("refuse"))
	pay_gold_btn.pressed.connect(_on_gold_choice.bind("pay"))
	refuse_gold_btn.pressed.connect(_on_gold_choice.bind("refuse"))
	confirm_btn.pressed.connect(_on_confirm)

func display_crisis(jarl: JarlData, settlement: SettlementData) -> void:
	var legitimacy = jarl.legitimacy
	legit_label.text = "New Legitimacy: %d/100" % legitimacy
	
	# --- Calculate Taxes (Higher legitimacy = lower taxes) ---
	var tax_multiplier = 1.0 - (legitimacy / 100.0) # 100 legit = 0x, 20 legit = 0.8x
	
	# Renown Tax
	renown_tax = int(max(50, DynastyManager.get_current_jarl().renown * 0.2) * tax_multiplier)
	pay_renown_btn.text = "Pay %d Renown" % renown_tax
	refuse_renown_btn.text = "Refuse (Risk Project Setbacks)"
	
	renown_desc.text = "Pay %d Renown to protect your legacy, or refuse and risk setbacks." % renown_tax

	# Gold Tax
	gold_tax = int(max(200, settlement.treasury.get("gold", 0) * 0.3) * tax_multiplier)
	pay_gold_btn.text = "Pay %d Gold" % gold_tax
	refuse_gold_btn.text = "Refuse (Risk Instability)"
	
	gold_desc.text = "Pay %d Gold to ensure loyalty, or refuse and risk instability." % gold_tax

	# Check affordability
	if jarl.renown < renown_tax:
		pay_renown_btn.disabled = true
		refuse_renown_btn.button_pressed = true
		renown_choice = "refuse"
	else:
		pay_renown_btn.button_pressed = true
		renown_choice = "pay"
	
	if settlement.treasury.get("gold", 0) < gold_tax:
		pay_gold_btn.disabled = true
		refuse_gold_btn.button_pressed = true
		gold_choice = "refuse"
	else:
		pay_gold_btn.button_pressed = true
		gold_choice = "pay"
	
	show()

func _on_renown_choice(choice: String) -> void:
	renown_choice = choice

func _on_gold_choice(choice: String) -> void:
	gold_choice = choice

func _on_confirm() -> void:
	# 1. Apply costs
	if renown_choice == "pay":
		DynastyManager.spend_renown(renown_tax)
	if gold_choice == "pay":
		SettlementManager.attempt_purchase({"gold": gold_tax})
	
	# 2. Emit choices to EventManager/DynastyManager for consequences
	EventBus.succession_choices_made.emit(renown_choice, gold_choice)
	
	# --- NEW: Unpause Game ---
	get_tree().paused = false
	# -------------------------
	
	# 3. Close the window
	queue_free()


--------------------------------------------------
FILE: res:///ui/Succession_Crisis_UI.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://c4itkcu7ufe5j"]

[ext_resource type="Script" uid="uid://delu7kfefwd5r" path="res://ui/Succession_Crisis_UI.gd" id="1_e844v"]

[node name="Succession_Crisis_UI" type="CanvasLayer"]
script = ExtResource("1_e844v")

[node name="PanelContainer" type="PanelContainer" parent="."]
anchors_preset = -1
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -255.5
offset_top = -151.0
offset_right = 255.5
offset_bottom = 249.0
grow_horizontal = 2
grow_vertical = 2

[node name="MarginContainer" type="MarginContainer" parent="PanelContainer"]
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="PanelContainer/MarginContainer"]
layout_mode = 2

[node name="TitleLabel" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Succession Crisis"

[node name="DescriptionLabel" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "The Jarl is dead. Your rule is fragile..."

[node name="LegitimacyLabel" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "New Legitimacy: 20/100"

[node name="HSeparator" type="HSeparator" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="RenownTaxTitle" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Legacy Projects"

[node name="RenownTaxDescription" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Pay 50 Renown to protect your legacy, or refuse and risk setbacks."

[node name="RenownTaxButtons" type="HBoxContainer" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="PayRenownButton" type="Button" parent="PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons"]
layout_mode = 2
toggle_mode = true
text = "Pay Renown"

[node name="RefuseRenownButton" type="Button" parent="PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons"]
layout_mode = 2
toggle_mode = true
text = "Refuse"

[node name="HSeparator2" type="HSeparator" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="GoldTaxTitle" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Garrison Stability"

[node name="GoldTaxDescription" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Pay 1000 Gold to ensure loyalty, or refuse and risk instability."

[node name="GoldTaxButtons" type="HBoxContainer" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="PayGoldButton" type="Button" parent="PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons"]
layout_mode = 2
toggle_mode = true
text = "Pay Gold"

[node name="RefuseGoldButton" type="Button" parent="PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons"]
layout_mode = 2
toggle_mode = true
text = "Refuse"

[node name="HSeparator3" type="HSeparator" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="ConfirmButton" type="Button" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "Confirm"


--------------------------------------------------
FILE: res:///ui/WorkAssignment_UI.gd
--------------------------------------------------
# res://ui/WorkAssignment_UI.gd
extends CanvasLayer

signal assignments_confirmed(assignments: Dictionary)

@onready var total_pop_label: Label = $PanelContainer/MarginContainer/VBoxContainer/Header/TotalPopLabel
@onready var available_pop_label: Label = $PanelContainer/MarginContainer/VBoxContainer/Header/AvailablePopLabel
@onready var sliders_container: VBoxContainer = $PanelContainer/MarginContainer/VBoxContainer/SlidersContainer
@onready var confirm_button: Button = $PanelContainer/MarginContainer/VBoxContainer/ConfirmButton

var prediction_label: RichTextLabel

var current_settlement: SettlementData
var temp_assignments: Dictionary = {}
var total_population: int = 0
var available_population: int = 0

# --- NEW: Capacity Tracking ---
var labor_capacities: Dictionary = {} 
# ------------------------------

var sliders: Dictionary = {} 
var labels: Dictionary = {}  

func _ready() -> void:
	confirm_button.pressed.connect(_on_confirm_pressed)
	confirm_button.text = "Confirm Assignments"
	
	prediction_label = RichTextLabel.new()
	prediction_label.name = "PredictionLabel"
	prediction_label.fit_content = true
	prediction_label.bbcode_enabled = true
	prediction_label.custom_minimum_size = Vector2(0, 60)
	
	var container = $PanelContainer/MarginContainer/VBoxContainer
	container.add_child(prediction_label)
	container.move_child(prediction_label, container.get_child_count() - 2)
	
	hide()

func setup(settlement: SettlementData) -> void:
	current_settlement = settlement
	total_population = settlement.population_peasants
	
	# --- NEW: Fetch Capacities ---
	if SettlementManager.has_method("get_labor_capacities"):
		labor_capacities = SettlementManager.get_labor_capacities()
	else:
		labor_capacities = {"construction": 100, "food": 100, "wood": 100, "stone": 100}
	# -----------------------------
	
	# Initialize temp assignments (Gold Removed)
	temp_assignments = {
		"construction": 0,
		"food": 0,
		"wood": 0,
		"stone": 0
	}
	
	# Restore saved values if valid
	for key in temp_assignments:
		if current_settlement.worker_assignments.has(key):
			# Clamp to current capacity in case buildings were lost
			temp_assignments[key] = min(current_settlement.worker_assignments[key], labor_capacities.get(key, 0))
	
	_rebuild_ui()
	_update_calculations()
	show()

func _rebuild_ui() -> void:
	for child in sliders_container.get_children():
		child.queue_free()
	sliders.clear()
	labels.clear()
	
	# --- MODIFIED: Gold Removed ---
	var categories = ["construction", "food", "wood", "stone"]
	
	for category in categories:
		_create_slider_row(category)

func _create_slider_row(category: String) -> void:
	var row = HBoxContainer.new()
	
	var name_label = Label.new()
	name_label.text = category.capitalize()
	name_label.custom_minimum_size = Vector2(100, 0)
	row.add_child(name_label)
	
	# --- NEW: Capacity Logic ---
	var capacity = labor_capacities.get(category, 0)
	# The absolute max is capped by BOTH total population AND building capacity
	var max_assignable = min(total_population, capacity)
	
	var slider = HSlider.new()
	slider.min_value = 0
	slider.max_value = max_assignable
	slider.value = temp_assignments.get(category, 0)
	slider.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	# Disable slider if no capacity (e.g., no blueprints for construction)
	if max_assignable == 0:
		slider.editable = false
		slider.modulate = Color(0.5, 0.5, 0.5)
	
	slider.value_changed.connect(_on_slider_changed.bind(category))
	row.add_child(slider)
	sliders[category] = slider
	
	var value_label = Label.new()
	# Display as "Assigned / Capacity"
	value_label.text = "%d / %d" % [slider.value, capacity]
	value_label.custom_minimum_size = Vector2(60, 0)
	value_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	row.add_child(value_label)
	labels[category] = value_label
	
	sliders_container.add_child(row)

func _on_slider_changed(value: float, category: String) -> void:
	var new_val = int(value)
	var current_usage = 0
	for key in temp_assignments:
		if key != category:
			current_usage += temp_assignments[key]
	
	# Check Global Pop Limit
	if current_usage + new_val > total_population:
		new_val = total_population - current_usage
		sliders[category].set_value_no_signal(new_val)
	
	temp_assignments[category] = new_val
	_update_calculations()

func _update_calculations() -> void:
	var assigned_count = 0
	for key in temp_assignments:
		assigned_count += temp_assignments[key]
		if labels.has(key):
			var capacity = labor_capacities.get(key, 0)
			labels[key].text = "%d / %d" % [temp_assignments[key], capacity]
	
	available_population = total_population - assigned_count
	
	total_pop_label.text = "Total Population: %d" % total_population
	available_pop_label.text = "Idle: %d" % available_population
	
	if available_population < 0:
		available_pop_label.modulate = Color.RED
		confirm_button.disabled = true
	else:
		available_pop_label.modulate = Color.GREEN
		confirm_button.disabled = false

	if SettlementManager.has_method("simulate_turn"):
		var prediction = SettlementManager.simulate_turn(temp_assignments)
		_update_prediction_display(prediction)

func _update_prediction_display(data: Dictionary) -> void:
	if not prediction_label: return
	
	var text = "[b]Estimated Outcome:[/b]\n"
	var res = data.get("resources_gained", {})
	var res_str = ""
	
	for r in res:
		if res[r] > 0:
			var color_tag = "[color=white]"
			if r == "food": color_tag = "[color=salmon]"
			elif r == "wood": color_tag = "[color=burlywood]"
			
			res_str += "%s+%d %s[/color]  " % [color_tag, res[r], r.capitalize()]
	
	if res_str != "":
		text += res_str + "\n"
	else:
		text += "[color=gray]No resource gain[/color]\n"
		
	var completed = data.get("buildings_completing", [])
	if not completed.is_empty():
		text += "[color=green]Completing: " + ", ".join(completed) + "[/color]"
	
	prediction_label.text = text

func _on_confirm_pressed() -> void:
	hide()
	assignments_confirmed.emit(temp_assignments)


--------------------------------------------------
FILE: res:///ui/WorkAssignment_UI.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://kae7o13aq1uu"]

[ext_resource type="Script" uid="uid://cv15lf72go8se" path="res://ui/WorkAssignment_UI.gd" id="1_rf2xp"]

[node name="WorkAssignment_UI" type="CanvasLayer"]
script = ExtResource("1_rf2xp")

[node name="PanelContainer" type="PanelContainer" parent="."]
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 4
size_flags_vertical = 4

[node name="MarginContainer" type="MarginContainer" parent="PanelContainer"]
custom_minimum_size = Vector2(20, 20)
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="PanelContainer/MarginContainer"]
layout_mode = 2

[node name="Header" type="HBoxContainer" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="TotalPopLabel" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer/Header"]
layout_mode = 2

[node name="AvailablePopLabel" type="Label" parent="PanelContainer/MarginContainer/VBoxContainer/Header"]
layout_mode = 2

[node name="HSeparator" type="HSeparator" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="SlidersContainer" type="VBoxContainer" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="HSeparator2" type="HSeparator" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="ConfirmButton" type="Button" parent="PanelContainer/MarginContainer/VBoxContainer"]
layout_mode = 2
text = "End Year"


--------------------------------------------------
FILE: res:///ui/components/BuildingInfoHUD.gd
--------------------------------------------------
# res://ui/components/BuildingInfoHUD.gd
extends Control
class_name BuildingInfoHUD

@onready var name_label: Label = $Background/MarginContainer/NameLabel
@onready var health_bar: ProgressBar = $HealthBar
@onready var background: PanelContainer = $Background
@onready var status_icon: TextureRect = $StatusIcon

# Store the styleboxes so we can tween colors
var style_fill: StyleBoxFlat

func _ready() -> void:
	# Cache the stylebox for dynamic coloring
	if health_bar.has_theme_stylebox("fill"):
		style_fill = health_bar.get_theme_stylebox("fill").duplicate()
		health_bar.add_theme_stylebox_override("fill", style_fill)
	
	# --- NEW: Thin Styling ---
	health_bar.custom_minimum_size.y = 8
	health_bar.size.y = 8
	health_bar.show_percentage = false
	# -------------------------
	
	hide_progress()

func setup(display_name: String, size_pixels: Vector2) -> void:
	name_label.text = display_name
	set_anchors_preset(Control.PRESET_TOP_LEFT)
	custom_minimum_size = size_pixels
	size = size_pixels
	# Center the pivot for nice animations
	pivot_offset = size / 2.0
	
	# Adjust background size
	background.custom_minimum_size = size
	
	# --- NEW: Floating Position ---
	# Position the bar slightly above the building top
	health_bar.position.x = 0
	health_bar.position.y = -15 
	health_bar.size.x = size.x 
	# ------------------------------

func update_health(current: int, max_hp: int) -> void:
	health_bar.max_value = max_hp
	health_bar.value = current
	
	# --- NEW: Smart Visibility ---
	# Only show if damaged
	if current < max_hp:
		health_bar.show()
	else:
		health_bar.hide()
	# -----------------------------
	
	# Green for Health
	if style_fill: style_fill.bg_color = Color(0.2, 0.8, 0.2)

func update_construction(current: int, required: int) -> void:
	health_bar.max_value = required
	health_bar.value = current
	health_bar.show() # Always show during construction
	
	# Blue for Construction
	if style_fill: style_fill.bg_color = Color(0.2, 0.6, 1.0)
	
	var percent = int((float(current) / required) * 100)
	name_label.text = "Constructing\n%d%%" % percent

func set_blueprint_mode() -> void:
	modulate = Color(1, 1, 1, 0.6) # Ghostly
	name_label.text = "(Blueprint)"
	health_bar.hide()

func set_active_mode(display_name: String) -> void:
	modulate = Color.WHITE
	name_label.text = display_name
	# --- FIX: Removed forced show() here. let update_health decide. ---

func hide_progress() -> void:
	health_bar.hide()


--------------------------------------------------
FILE: res:///ui/components/BuildingInfoHud.tscn
--------------------------------------------------
[gd_scene load_steps=4 format=3 uid="uid://bmhvmiqrv2qs8"]

[ext_resource type="Script" uid="uid://dvjlsckwii3qe" path="res://ui/components/BuildingInfoHUD.gd" id="1_ht0l1"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_g1bat"]
content_margin_left = 2.0
content_margin_top = 2.0
content_margin_right = 2.0
content_margin_bottom = 2.0
bg_color = Color(0, 0, 0, 1)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6
corner_detail = 6

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ht0l1"]
content_margin_left = 2.0
content_margin_top = 2.0
content_margin_right = 2.0
content_margin_bottom = 2.0
bg_color = Color(0.2, 0.8, 0.2, 1)
corner_radius_top_left = 6
corner_radius_top_right = 6
corner_radius_bottom_right = 6
corner_radius_bottom_left = 6
corner_detail = 6

[node name="BuildingInfoHUD" type="Control"]
custom_minimum_size = Vector2(128, 128)
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
script = ExtResource("1_ht0l1")

[node name="Background" type="PanelContainer" parent="."]
layout_mode = 0
offset_right = 40.0
offset_bottom = 40.0

[node name="MarginContainer" type="MarginContainer" parent="Background"]
layout_mode = 2

[node name="NameLabel" type="Label" parent="Background/MarginContainer"]
layout_mode = 2
horizontal_alignment = 1
vertical_alignment = 1

[node name="HealthBar" type="ProgressBar" parent="."]
layout_mode = 0
offset_right = 4.0
offset_bottom = 31.0
theme_override_styles/background = SubResource("StyleBoxFlat_g1bat")
theme_override_styles/fill = SubResource("StyleBoxFlat_ht0l1")
show_percentage = false

[node name="StatusIcon" type="TextureRect" parent="."]
layout_mode = 0
offset_right = 40.0
offset_bottom = 40.0


--------------------------------------------------
FILE: res:///ui/components/BuildingInspector.gd
--------------------------------------------------
# res://ui/components/BuildingInspector.gd
extends PanelContainer

# Refs - Unique names used for portability
@onready var icon_rect: TextureRect = %Icon
@onready var name_label: Label = %NameLabel
@onready var stats_label: RichTextLabel = %StatsLabel
@onready var worker_count_label: Label = %WorkerCountLabel
@onready var btn_add: Button = %BtnAdd
@onready var btn_remove: Button = %BtnRemove

var current_building: BaseBuilding
var current_entry: Dictionary 

func _ready() -> void:
	hide()
	EventBus.building_selected.connect(_on_building_selected)
	EventBus.building_deselected.connect(hide)
	EventBus.settlement_loaded.connect(func(_s): _refresh_data())
	
	btn_add.pressed.connect(_on_add_worker)
	btn_remove.pressed.connect(_on_remove_worker)

func _on_building_selected(building: BaseBuilding) -> void:
	if not building:
		hide()
		return
	
	current_building = building
	_refresh_data()
	show()

func _refresh_data() -> void:
	if not is_instance_valid(current_building): 
		hide()
		return
		
	var data = current_building.data
	if not data: return
	
	current_entry = SettlementManager._find_entry_for_building(current_building)
	
	if current_entry.is_empty():
		hide()
		return
	
	# 1. Determine Current & Max Workers
	var p_count = current_entry.get("peasant_count", 0)
	var capacity = 0
	
	if current_building.current_state == BaseBuilding.BuildingState.ACTIVE:
		if data is EconomicBuildingData:
			capacity = (data as EconomicBuildingData).peasant_capacity
		else:
			capacity = 0 # Defensive buildings usually don't have workers
	else:
		# Construction / Blueprint
		capacity = data.base_labor_capacity

	# 2. Update Headers & Counts
	name_label.text = data.display_name
	if data.icon: icon_rect.texture = data.icon
	
	# Display "Current / Max"
	worker_count_label.text = "%d / %d" % [p_count, capacity]
	
	# 3. Dynamic Stats Text
	var text = ""
	
	if current_building.current_state == BaseBuilding.BuildingState.ACTIVE:
		if data is EconomicBuildingData:
			var eco = data as EconomicBuildingData
			var production = (eco.base_passive_output * p_count) 
			text += "[b]Yield:[/b] %d %s / Year\n" % [production, eco.resource_type.capitalize()]
		else:
			text += "Defensive Structure\nNo Production."
			
	else: # Construction / Blueprint
		var progress = current_entry.get("progress", 0)
		var req = data.construction_effort_required
		var pct = 0
		if req > 0:
			pct = int((float(progress) / req) * 100)
		
		text += "[b]Status:[/b] Constructing (%d%%)\n" % pct
		text += "[b]Progress:[/b] %d / %d\n" % [progress, req]
		
		# --- Time Estimate Calculation ---
		# Uses the global constant for accuracy
		var labor_per_year = p_count * EconomyManager.BUILDER_EFFICIENCY
		
		if labor_per_year > 0:
			var remaining = req - progress
			# Ceil ensures 0.1 years displays as "1 Year"
			var years = ceil(float(remaining) / labor_per_year)
			text += "[color=blue]Est. Time: %d Year(s)[/color]" % years
		else:
			text += "[color=red]Est. Time: NO WORKERS ASSIGNED![/color]"
		# ---------------------------------
			
	stats_label.text = text
	
	# 4. Button State
	var can_add = p_count < capacity
	
	btn_add.disabled = not can_add
	btn_remove.disabled = p_count <= 0

func _on_add_worker() -> void:
	EventBus.request_worker_assignment.emit(current_building)

func _on_remove_worker() -> void:
	# --- REPLACED LEGACY LOGIC WITH SIGNAL ---
	EventBus.request_worker_removal.emit(current_building)
	# -----------------------------------------
	
	# We don't need to manually refresh here because SettlementManager 
	# will emit 'settlement_loaded' which triggers our _refresh_data listener.


--------------------------------------------------
FILE: res:///ui/components/BuildingInspector.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://dhobag8h7m8ip"]

[ext_resource type="Script" uid="uid://dsypa2f0q7g5" path="res://ui/components/BuildingInspector.gd" id="1_sbhxe"]

[node name="BuildingInspector" type="PanelContainer"]
custom_minimum_size = Vector2(280, 0)
script = ExtResource("1_sbhxe")

[node name="@MarginContainer@48133" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 16
theme_override_constants/margin_top = 16
theme_override_constants/margin_right = 16
theme_override_constants/margin_bottom = 16

[node name="@VBoxContainer@48134" type="VBoxContainer" parent="@MarginContainer@48133"]
layout_mode = 2
theme_override_constants/separation = 12

[node name="@HBoxContainer@48135" type="HBoxContainer" parent="@MarginContainer@48133/@VBoxContainer@48134"]
layout_mode = 2
alignment = 1

[node name="Icon" type="TextureRect" parent="@MarginContainer@48133/@VBoxContainer@48134/@HBoxContainer@48135"]
unique_name_in_owner = true
custom_minimum_size = Vector2(48, 48)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="NameLabel" type="Label" parent="@MarginContainer@48133/@VBoxContainer@48134/@HBoxContainer@48135"]
unique_name_in_owner = true
layout_mode = 2
theme_type_variation = &"HeaderLabel"
text = "Building Name"

[node name="@HSeparator@48136" type="HSeparator" parent="@MarginContainer@48133/@VBoxContainer@48134"]
layout_mode = 2

[node name="StatsLabel" type="RichTextLabel" parent="@MarginContainer@48133/@VBoxContainer@48134"]
unique_name_in_owner = true
layout_mode = 2
mouse_filter = 2
theme_override_colors/default_color = Color(0.16862746, 0.13333334, 0.105882354, 1)
bbcode_enabled = true
text = "Production: 100
Workers: 0/5"
fit_content = true
scroll_active = false

[node name="@HBoxContainer@48138" type="HBoxContainer" parent="@MarginContainer@48133/@VBoxContainer@48134"]
layout_mode = 2
alignment = 1

[node name="@Label@48139" type="Label" parent="@MarginContainer@48133/@VBoxContainer@48134/@HBoxContainer@48138"]
layout_mode = 2
text = "Assign Worker:"

[node name="BtnRemove" type="Button" parent="@MarginContainer@48133/@VBoxContainer@48134/@HBoxContainer@48138"]
unique_name_in_owner = true
custom_minimum_size = Vector2(32, 32)
layout_mode = 2
text = " - "

[node name="WorkerCountLabel" type="Label" parent="@MarginContainer@48133/@VBoxContainer@48134/@HBoxContainer@48138"]
unique_name_in_owner = true
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "0 / 5"
horizontal_alignment = 1

[node name="BtnAdd" type="Button" parent="@MarginContainer@48133/@VBoxContainer@48134/@HBoxContainer@48138"]
unique_name_in_owner = true
custom_minimum_size = Vector2(32, 32)
layout_mode = 2
text = " + "


--------------------------------------------------
FILE: res:///ui/components/HeirCard.gd
--------------------------------------------------
extends PanelContainer
class_name HeirCard

signal card_clicked(heir_data: JarlHeirData, global_pos: Vector2)

# Ensure these paths match your Scene Tree names exactly
@onready var portrait_rect: TextureRect = $VBox/PortraitContainer/Portrait
@onready var status_icon: TextureRect = $VBox/PortraitContainer/StatusIcon
@onready var heir_crown_icon: TextureRect = $VBox/PortraitContainer/HeirCrown
@onready var name_label: Label = $VBox/NameLabel
@onready var stats_label: Label = $VBox/StatsLabel

var heir_data: JarlHeirData

func setup(data: JarlHeirData) -> void:
	heir_data = data
	
	# 1. Basic Info
	name_label.text = "%s (%d)" % [data.display_name, data.age]
	name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	
	# 2. Portrait
	if data.portrait:
		portrait_rect.texture = data.portrait
	else:
		portrait_rect.modulate = Color.GRAY 
	
	# 3. Crown Overlay (Active Heir)
	heir_crown_icon.visible = data.is_designated_heir
	
	# 4. Status Overlay
	_update_status_visuals()
	
	# 5. Stats
	var trait_text = "None"
	if data.genetic_trait:
		trait_text = data.genetic_trait.display_name
		
	stats_label.text = "Prowess: %d\nSteward: %d\nTrait: %s" % [data.prowess, data.stewardship, trait_text]
	stats_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER

func _update_status_visuals() -> void:
	# Reset visuals
	modulate = Color.WHITE
	status_icon.texture = null
	status_icon.visible = false
	
	match heir_data.status:
		JarlHeirData.HeirStatus.OnExpedition:
			modulate = Color(0.7, 0.7, 0.7) # Dim the card
			status_icon.visible = true
			
		JarlHeirData.HeirStatus.MarriedOff:
			modulate = Color(0.5, 0.5, 0.5) # Darker
			status_icon.visible = true
			
		JarlHeirData.HeirStatus.Maimed:
			status_icon.visible = true

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		card_clicked.emit(heir_data, get_global_mouse_position())


--------------------------------------------------
FILE: res:///ui/components/HeirCard.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://cq1d0chfy34ni"]

[ext_resource type="Script" uid="uid://bo6x8gym1ygtq" path="res://ui/components/HeirCard.gd" id="1_4levn"]

[node name="HeirCard" type="PanelContainer"]
script = ExtResource("1_4levn")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 2

[node name="PortraitContainer" type="Control" parent="VBox"]
custom_minimum_size = Vector2(128, 128)
layout_mode = 2
size_flags_horizontal = 4

[node name="Portrait" type="TextureRect" parent="VBox/PortraitContainer"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
expand_mode = 1

[node name="HeirCrown" type="TextureRect" parent="VBox/PortraitContainer"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -1.0
grow_horizontal = 0

[node name="StatusIcon" type="TextureRect" parent="VBox/PortraitContainer"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 1
offset_right = 1.0
expand_mode = 1

[node name="NameLabel" type="Label" parent="VBox"]
layout_mode = 2

[node name="StatsLabel" type="Label" parent="VBox"]
layout_mode = 2


--------------------------------------------------
FILE: res:///ui/components/RichTooltipButton.gd
--------------------------------------------------
# res://ui/components/RichTooltipButton.gd
class_name RichTooltipButton
extends Button

func _make_custom_tooltip(for_text: String) -> Object:
	# DEBUG: Check the Output console to see if this runs when you hover
	print("RichTooltipButton: Generating tooltip for ", name)
	
	# 1. Create the container
	var panel = PanelContainer.new()
	
	# CRITICAL: Force the theme to match your game theme
	# Otherwise it uses Godot's default grey theme
	if theme:
		panel.theme = theme
	else:
		# Walk up the parent chain to find a Control with a theme
		var ui_node: Node = self
		while ui_node and not (ui_node is Control and ui_node.theme):
			ui_node = ui_node.get_parent()
		
		if ui_node and ui_node is Control and ui_node.theme:
			panel.theme = ui_node.theme
		# If nothing is found, panel keeps default theme
	
	# Optional: Use your specific "TooltipPanel" style from the theme
	panel.theme_type_variation = "TooltipPanel" 
	
	# 2. Create the RichTextLabel
	var rtl = RichTextLabel.new()
	rtl.bbcode_enabled = true
	rtl.text = for_text
	
	# 3. Layout Settings (Crucial for visibility)
	rtl.fit_content = true
	rtl.autowrap_mode = TextServer.AUTOWRAP_OFF
	rtl.mouse_filter = Control.MOUSE_FILTER_IGNORE # Don't block mouse
	
	# Apply Theme Colors specifically to the text logic
	# (Ensures text isn't invisible)
	rtl.add_theme_color_override("default_color", Color.WHITE) 
	
	panel.add_child(rtl)
	return panel


--------------------------------------------------
FILE: res:///ui/components/TreasuryHUD.gd
--------------------------------------------------
class_name TreasuryHUD
extends PanelContainer

# --- UI References (Using Unique Names for portability) ---
# These look for nodes named "Label" inside containers named "%ResGold", etc.
@onready var gold_label: Label = %GoldLabel
@onready var wood_label: Label = %WoodLabel
@onready var food_label: Label = %FoodLabel
@onready var stone_label: Label = %StoneLabel
@onready var pop_label: Label = %PeasantLabel
@onready var thrall_label: Label = %ThrallLabel
@onready var unit_count_label: Label = %UnitCountLabel

func _ready() -> void:
	# 1. Connect to Global Signals
	EventBus.treasury_updated.connect(_update_treasury_display)
	
	# 2. Also refresh when a save is loaded or year ends
	EventBus.settlement_loaded.connect(func(_data): _refresh_from_manager())
	DynastyManager.year_ended.connect(_refresh_from_manager)
	
	# 3. Initial Update (Deferred to ensure Autoloads are ready)
	call_deferred("_refresh_from_manager")

func _refresh_from_manager() -> void:
	if SettlementManager.current_settlement:
		_update_treasury_display(SettlementManager.current_settlement.treasury)

# --- The Logic You Provided (Adapted for Self-Containment) ---
func _update_treasury_display(treasury: Dictionary) -> void:
	if not is_inside_tree(): return

	# Resources
	gold_label.text = "%d" % treasury.get(GameResources.GOLD, 0)
	wood_label.text = "%d" % treasury.get(GameResources.WOOD, 0)
	food_label.text = "%d" % treasury.get(GameResources.FOOD, 0)
	stone_label.text = "%d" % treasury.get(GameResources.STONE, 0)
	
	if SettlementManager.current_settlement:
		# Army Count
		if unit_count_label:
			unit_count_label.text = "%d" % SettlementManager.current_settlement.warbands.size()
		
		# Population Math
		var idle_p = SettlementManager.get_idle_peasants()
		var total_p = SettlementManager.current_settlement.population_peasants
		var idle_t = SettlementManager.get_idle_thralls()
		var total_t = SettlementManager.current_settlement.population_thralls
		
		# Update Labels
		if pop_label: pop_label.text = "%d/%d" % [idle_p, total_p]
		if thrall_label: thrall_label.text = "%d/%d" % [idle_t, total_t]


--------------------------------------------------
FILE: res:///ui/components/TreasuryHud.tscn
--------------------------------------------------
[gd_scene load_steps=9 format=3 uid="uid://gyu45fs0qg5m"]

[ext_resource type="Script" uid="uid://chex2khqaljgb" path="res://ui/components/TreasuryHud.gd" id="2_75jlc"]
[ext_resource type="Theme" uid="uid://63duv3n1vwhg" path="res://ui/themes/VikingDynastyTheme.tres" id="2_uwsq3"]
[ext_resource type="Texture2D" uid="uid://d08kc6hrja6ev" path="res://ui/assets/res_gold.png" id="3_7ds4s"]
[ext_resource type="Texture2D" uid="uid://m6tx1fv7imra" path="res://ui/assets/res_wood.png" id="4_atp58"]
[ext_resource type="Texture2D" uid="uid://ck3gpx751ywcw" path="res://ui/assets/res_food.png" id="5_ginhg"]
[ext_resource type="Texture2D" uid="uid://denkxl6ex742y" path="res://ui/assets/res_stone.png" id="6_6xg1l"]
[ext_resource type="Texture2D" uid="uid://cukqh3t2wkmua" path="res://ui/assets/res_peasant.png" id="7_fo3c6"]
[ext_resource type="Texture2D" uid="uid://day6g5ykwqgyb" path="res://ui/assets/res_thrall.png" id="8_w1kt5"]

[node name="TreasuryHUD" type="PanelContainer"]
modulate = Color(1, 1, 1, 0.8627451)
custom_minimum_size = Vector2(0, 60)
anchors_preset = -1
anchor_right = 1.0
offset_bottom = 40.0
grow_horizontal = 2
mouse_filter = 2
theme = ExtResource("2_uwsq3")
script = ExtResource("2_75jlc")

[node name="HBoxContainer" type="HBoxContainer" parent="."]
layout_mode = 2
theme_override_constants/separation = 40
alignment = 1

[node name="TreasuryDisplay" type="HBoxContainer" parent="HBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="GoldIcon" type="TextureRect" parent="HBoxContainer/TreasuryDisplay"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
texture = ExtResource("3_7ds4s")
expand_mode = 1
stretch_mode = 5

[node name="GoldLabel" type="Label" parent="HBoxContainer/TreasuryDisplay"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "Gold: 0"

[node name="WoodIcon" type="TextureRect" parent="HBoxContainer/TreasuryDisplay"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
texture = ExtResource("4_atp58")
expand_mode = 1
stretch_mode = 5

[node name="WoodLabel" type="Label" parent="HBoxContainer/TreasuryDisplay"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "Wood: 0"

[node name="FoodIcon" type="TextureRect" parent="HBoxContainer/TreasuryDisplay"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
texture = ExtResource("5_ginhg")
expand_mode = 1
stretch_mode = 5

[node name="FoodLabel" type="Label" parent="HBoxContainer/TreasuryDisplay"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "Food: 0"

[node name="StoneIcon" type="TextureRect" parent="HBoxContainer/TreasuryDisplay"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
texture = ExtResource("6_6xg1l")
expand_mode = 1
stretch_mode = 5

[node name="StoneLabel" type="Label" parent="HBoxContainer/TreasuryDisplay"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "Stone: 0"

[node name="VSeparator" type="VSeparator" parent="HBoxContainer/TreasuryDisplay"]
layout_mode = 2

[node name="PeasantIcon" type="TextureRect" parent="HBoxContainer/TreasuryDisplay"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
texture = ExtResource("7_fo3c6")
expand_mode = 1
stretch_mode = 5

[node name="PeasantLabel" type="Label" parent="HBoxContainer/TreasuryDisplay"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "Villagers: 0"

[node name="ThrallIcon" type="TextureRect" parent="HBoxContainer/TreasuryDisplay"]
custom_minimum_size = Vector2(40, 40)
layout_mode = 2
texture = ExtResource("8_w1kt5")
expand_mode = 1
stretch_mode = 5

[node name="ThrallLabel" type="Label" parent="HBoxContainer/TreasuryDisplay"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 14
text = "Thralls: 0"

[node name="VSeparator2" type="VSeparator" parent="HBoxContainer/TreasuryDisplay"]
layout_mode = 2

[node name="UnitCountLabel" type="Label" parent="HBoxContainer/TreasuryDisplay"]
unique_name_in_owner = true
layout_mode = 2
text = "Units: 0"


--------------------------------------------------
FILE: res:///ui/components/WorkerTag.gd
--------------------------------------------------
# res://ui/components/WorkerTag.gd
class_name WorkerTag
extends Control

var building_index: int = -1
var is_pending: bool = false # NEW FLAG
var caps = {"peasant": 0, "thrall": 0}

@onready var lbl_peasant = $Panel/VBox/HBox_Peasant/CountLabel
@onready var lbl_thrall = $Panel/VBox/HBox_Thrall/CountLabel

func _ready() -> void:
	# --- FIX: Allow mouse to pass through the empty root control ---
	# This ensures we don't block clicks for other tags or the map.
	mouse_filter = Control.MOUSE_FILTER_IGNORE
	if has_node("Panel"):
		$Panel.mouse_filter = Control.MOUSE_FILTER_STOP

# Update signature to accept is_pending
func setup(idx: int, p_count: int, p_cap: int, t_count: int, t_cap: int, _pending: bool = false) -> void:
	building_index = idx
	is_pending = _pending
	caps["peasant"] = p_cap
	caps["thrall"] = t_cap
	
	_update_labels(p_count, t_count)
	
	# Disconnect old connections if reused (safety)
	# Since we instantiate new tags every time, fresh connection is fine.
	
	$Panel/VBox/HBox_Peasant/Btn_Minus.pressed.connect(_on_mod.bind("peasant", -1))
	$Panel/VBox/HBox_Peasant/Btn_Plus.pressed.connect(_on_mod.bind("peasant", 1))
	$Panel/VBox/HBox_Thrall/Btn_Minus.pressed.connect(_on_mod.bind("thrall", -1))
	$Panel/VBox/HBox_Thrall/Btn_Plus.pressed.connect(_on_mod.bind("thrall", 1))

func _on_mod(type: String, amount: int) -> void:
	# --- FIX: Route to correct manager function ---
	if is_pending:
		SettlementManager.assign_construction_worker(building_index, type, amount)
	else:
		SettlementManager.assign_worker(building_index, type, amount)
	# ----------------------------------------------

func _update_labels(p_val: int, t_val: int) -> void:
	lbl_peasant.text = "Citizens: %d / %d" % [p_val, caps["peasant"]]
	lbl_thrall.text = "Thralls: %d / %d" % [t_val, caps["thrall"]]


--------------------------------------------------
FILE: res:///ui/components/WorkerTag.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://btsh08figkwts"]

[ext_resource type="Script" uid="uid://b7wywer60bc0a" path="res://ui/components/WorkerTag.gd" id="1_nr0dy"]
[ext_resource type="Theme" uid="uid://63duv3n1vwhg" path="res://ui/themes/VikingDynastyTheme.tres" id="2_fqgk7"]

[node name="WorkerTag" type="Control"]
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_nr0dy")

[node name="Panel" type="PanelContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = 218.0
offset_bottom = 126.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1
theme = ExtResource("2_fqgk7")

[node name="VBox" type="VBoxContainer" parent="Panel"]
layout_mode = 2

[node name="HBox_Peasant" type="HBoxContainer" parent="Panel/VBox"]
layout_mode = 2

[node name="Btn_Minus" type="Button" parent="Panel/VBox/HBox_Peasant"]
layout_mode = 2
text = "-"

[node name="CountLabel" type="Label" parent="Panel/VBox/HBox_Peasant"]
layout_mode = 2
text = "Villagers: 2/5"

[node name="Btn_Plus" type="Button" parent="Panel/VBox/HBox_Peasant"]
layout_mode = 2
text = "+"

[node name="HSeparator" type="HSeparator" parent="Panel/VBox"]
layout_mode = 2

[node name="HBox_Thrall" type="HBoxContainer" parent="Panel/VBox"]
layout_mode = 2

[node name="Btn_Minus" type="Button" parent="Panel/VBox/HBox_Thrall"]
layout_mode = 2
text = "-"

[node name="CountLabel" type="Label" parent="Panel/VBox/HBox_Thrall"]
layout_mode = 2
text = "Thralls: 2/5"

[node name="Btn_Plus" type="Button" parent="Panel/VBox/HBox_Thrall"]
layout_mode = 2
text = "+"


--------------------------------------------------
FILE: res:///ui/seasonal/AutumnLedgerUi.gd
--------------------------------------------------
## AutumnLedgerUI.gd
## Handles the end-of-season accounting logic and display.
## Automatically opens when Autumn begins via EventBus.
class_name AutumnLedgerUI
extends Control

# Nodes (using unique names for stability)
@onready var settlement_name_label: Label = %SettlementName
@onready var food_stock_label: Label = %FoodStock
@onready var food_status_label: Label = %FoodStatus
@onready var wood_stock_label: Label = %WoodStock
@onready var wood_status_label: Label = %WoodStatus
@onready var outlook_label: Label = %WinterOutlookLabel
@onready var sign_button: Button = %SignButton

# Color Constants for Status
const COLOR_OK = Color.DARK_GREEN
const COLOR_FAIL = Color.FIREBRICK

func _ready() -> void:
	_setup_connections()
	# UI is hidden by default until the season change or manual toggle
	visible = false

## Connects buttons and global signals via code.
func _setup_connections() -> void:
	if not sign_button.pressed.is_connected(_on_sign_pressed):
		sign_button.pressed.connect(_on_sign_pressed)
	
	if EventBus.has_signal("season_changed"):
		EventBus.season_changed.connect(_on_season_changed)
	else:
		Loggie.msg("EventBus missing season_changed signal").domain(LogDomains.SYSTEM).error()

## Triggered automatically by the DynastyManager via EventBus.
func _on_season_changed(new_season_name: String) -> void:
	if new_season_name == "Autumn":
		_show_ledger()

## Standard bridge toggle for manual opening (e.g., from a HUD button).
func toggle_interface(interface_name: String = "") -> void:
	if interface_name != "" and interface_name != "autumn_ledger": 
		return
	
	if visible:
		visible = false
	else:
		_show_ledger()

## Logic for displaying the ledger with fresh data.
func _show_ledger() -> void:
	# Guard: Only allow display if we are actually in Autumn
	if DynastyManager.get_current_season_name() != "Autumn":
		visible = false
		return
		
	visible = true
	_initialize_data()
	move_to_front()

## Aggregates data from Managers and updates UI elements.
func _initialize_data() -> void:
	var forecast: Dictionary = EconomyManager.get_winter_forecast()
	var settlement = SettlementManager.current_settlement
	
	if not settlement:
		Loggie.msg("No current settlement for ledger").domain(LogDomains.UI).error()
		return

	# IDENTITY: Derive settlement name from resource filename.
	var raw_name: String = settlement.resource_path.get_file().get_basename()
	if raw_name.is_empty():
		raw_name = "Home Base"
	
	var display_name: String = raw_name.replace("_", " ").capitalize()
	var current_year: int = DynastyManager.get_current_year()
	
	settlement_name_label.text = "%s - Year %d" % [display_name, current_year]

	var treasury: Dictionary = settlement.treasury
	
	# Food Calculation (Expected keys from EconomyManager)
	var food_req: int = forecast.get("food", 0)
	var food_held: int = treasury.get("food", 0)
	_update_row(food_stock_label, food_status_label, food_held, food_req)

	# Wood Calculation (Expected keys from EconomyManager)
	var wood_req: int = forecast.get("wood", 0)
	var wood_held: int = treasury.get("wood", 0)
	_update_row(wood_stock_label, wood_status_label, wood_held, wood_req)

	# Status Outlook: Determines the overall survival probability.
	var is_ready: bool = (food_held >= food_req) and (wood_held >= wood_req)
	outlook_label.text = "WINTER OUTLOOK: " + ("SECURE" if is_ready else "DANGEROUS")
	outlook_label.modulate = COLOR_OK if is_ready else COLOR_FAIL

	# LOGGING: Using the verified .add() method for fluent data attachment.
	Loggie.msg("Autumn ledger initialized for " + display_name)\
		.domain(LogDomains.UI)\
		.add(forecast)\
		.info()

## Helper to set text and colors for resource rows.
func _update_row(val_label: Label, status_label: Label, held: int, req: int) -> void:
	val_label.text = str(held) + " / " + str(req)
	status_label.text = "[ OK ]" if held >= req else "[ DEFICIT ]"
	status_label.modulate = COLOR_OK if held >= req else COLOR_FAIL

## Finalizes the phase and notifies the game loop.
func _on_sign_pressed() -> void:
	Loggie.msg("Ledger signed and sealed").domain(LogDomains.ECONOMY).info()
	
	# Emit to EventBus for WinterManager/SeasonManager to process phase end.
	EventBus.autumn_resolved.emit()
	
	visible = false


--------------------------------------------------
FILE: res:///ui/seasonal/AutumnLedger_UI.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://c6b0qegdltxvw"]

[ext_resource type="Script" uid="uid://ckmn1a1rkmohv" path="res://ui/seasonal/AutumnLedgerUi.gd" id="1_xs5d6"]
[ext_resource type="Texture2D" uid="uid://dy8bikbul4bne" path="res://ui/assets/scroll_bg.png" id="2_iyrqy"]

[node name="AutumnLedgerUI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_xs5d6")

[node name="ParchmentBackground" type="TextureRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
texture = ExtResource("2_iyrqy")
expand_mode = 1
stretch_mode = 6

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 80
theme_override_constants/margin_top = 80
theme_override_constants/margin_right = 80
theme_override_constants/margin_bottom = 80

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 25

[node name="Header" type="Label" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_font_sizes/font_size = 36
text = "THE HARVEST ACCOUNTING"
horizontal_alignment = 1

[node name="SettlementName" type="Label" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Settlement: [SETTLEMENT_NAME]"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="ScrollContainer" type="ScrollContainer" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="ListContainer" type="VBoxContainer" parent="MarginContainer/VBoxContainer/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 20

[node name="FoodRow" type="HBoxContainer" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer"]
layout_mode = 2

[node name="Icon" type="TextureRect" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/FoodRow"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/FoodRow"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "Food Stores"

[node name="FoodStock" type="Label" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/FoodRow"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
text = "0 / 0"
horizontal_alignment = 1

[node name="FoodStatus" type="Label" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/FoodRow"]
unique_name_in_owner = true
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "[ STATUS ]"
horizontal_alignment = 2

[node name="WoodRow" type="HBoxContainer" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer"]
layout_mode = 2

[node name="Icon" type="TextureRect" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/WoodRow"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="Label" type="Label" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/WoodRow"]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "Wood/Fuel"

[node name="WoodStock" type="Label" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/WoodRow"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
text = "0 / 0"
horizontal_alignment = 1

[node name="WoodStatus" type="Label" parent="MarginContainer/VBoxContainer/ScrollContainer/ListContainer/WoodRow"]
unique_name_in_owner = true
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
text = "[ STATUS ]"
horizontal_alignment = 2

[node name="Spacer" type="Control" parent="MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.2

[node name="WinterOutlookLabel" type="Label" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 28
text = "WINTER OUTLOOK: SECURE"
horizontal_alignment = 1

[node name="SignButton" type="Button" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(300, 60)
layout_mode = 2
size_flags_horizontal = 4
text = "Sign and Seal Ledger"


--------------------------------------------------
FILE: res:///ui/seasonal/SeasonalCardUi.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://d0px2w8n5r1lv"]

[ext_resource type="Script" uid="uid://eandsw8tdo6a" path="res://ui/seasonal/SeasonalCard_UI.gd" id="1_dvrso"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_nweke"]
bg_color = Color(0.8235294, 0.7058824, 0.54901963, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(1, 0.84313726, 0, 1)
corner_radius_top_left = 5
corner_radius_top_right = 5
corner_radius_bottom_right = 5
corner_radius_bottom_left = 5

[node name="SeasonalCard_UI" type="PanelContainer"]
custom_minimum_size = Vector2(200, 300)
offset_right = 40.0
offset_bottom = 40.0
theme_override_styles/panel = SubResource("StyleBoxFlat_nweke")
script = ExtResource("1_dvrso")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 5
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 5
theme_override_constants/margin_bottom = 5

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Title "
horizontal_alignment = 1

[node name="IconRect" type="TextureRect" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2

[node name="DescriptionLabel" type="Label" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(50, 50)
layout_mode = 2
text = "Description"
autowrap_mode = 3

[node name="CostContainer" type="HBoxContainer" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2

[node name="APCostLabel" type="Label" parent="MarginContainer/VBoxContainer/CostContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "AP Cost: 100"

[node name="GoldCostLabel" type="Label" parent="MarginContainer/VBoxContainer/CostContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Gold Cost:100"

[node name="SelectButton" type="Button" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Select"


--------------------------------------------------
FILE: res:///ui/seasonal/SeasonalCard_UI.gd
--------------------------------------------------
class_name SeasonalCard_UI
extends Control

## Visual representation of a SeasonalCardResource.
## Handles clicks and hover states.

# --- Signals ---
signal card_clicked(card_data: SeasonalCardResource)

# --- Nodes ---
# Ensure these exist in your scene tree with Unique Names (%)
# Suggested Tree: PanelContainer -> VBox -> (Icon, Title, Desc, CostContainer, SelectButton)
@onready var title_label: Label = %TitleLabel
@onready var description_label: Label = %DescriptionLabel
@onready var icon_rect: TextureRect = %IconRect
@onready var cost_container: HBoxContainer = %CostContainer
@onready var ap_cost_label: Label = %APCostLabel # Inside CostContainer
@onready var gold_cost_label: Label = %GoldCostLabel
@onready var select_button: Button = %SelectButton

# --- Data ---
var _card_data: SeasonalCardResource

func _ready() -> void:
	select_button.pressed.connect(_on_button_pressed)

## Configures the card visual based on the resource.
func setup(card: SeasonalCardResource, can_afford: bool = true) -> void:
	_card_data = card
	
	title_label.text = card.display_name
	description_label.text = card.description
	icon_rect.texture = card.icon
	
	# Handle Winter Costs (Hide if 0)
	if card.cost_ap > 0 or card.cost_gold > 0:
		cost_container.show()
		ap_cost_label.text = "AP: %d" % card.cost_ap
		gold_cost_label.text = "Gold: %d"# Add gold label handling here if needed
	else:
		cost_container.hide()
	
	# Handle Affordability
	select_button.disabled = not can_afford
	if not can_afford:
		modulate = Color(0.7, 0.7, 0.7, 0.8) # Dim out

func _on_button_pressed() -> void:
	if _card_data:
		card_clicked.emit(_card_data)


--------------------------------------------------
FILE: res:///ui/seasonal/SpringCouncilUI.tscn
--------------------------------------------------
[gd_scene load_steps=8 format=3 uid="uid://whql45nph2u8"]

[ext_resource type="Script" uid="uid://yqhbcg3i6ek6" path="res://ui/seasonal/SpringCouncil_UI.gd" id="1_kajfs"]
[ext_resource type="Script" uid="uid://cni5gdnpbb1v2" path="res://data/resources/SeasonalCardResource.gd" id="2_y8qc6"]
[ext_resource type="Resource" uid="uid://dt38bx8jkvrno" path="res://data/resources/Card_Spring_Expansion.tres" id="3_mjw2u"]
[ext_resource type="Resource" uid="uid://du2gsa2xinlrm" path="res://data/resources/Card_Focus_Raid.tres" id="4_eqjln"]
[ext_resource type="PackedScene" uid="uid://d0px2w8n5r1lv" path="res://ui/seasonal/SeasonalCardUi.tscn" id="5_0j8s8"]
[ext_resource type="Texture2D" uid="uid://dy8bikbul4bne" path="res://ui/assets/scroll_bg.png" id="6_a6awv"]
[ext_resource type="Script" uid="uid://4dc3bdnc40ht" path="res://ui/seasonal/SpringUiDiagnostics.gd" id="7_y8qc6"]

[node name="SpringCouncil_UI" type="Control" node_paths=PackedStringArray("card_container")]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_kajfs")
available_advisor_cards = Array[ExtResource("2_y8qc6")]([ExtResource("3_mjw2u"), ExtResource("4_eqjln")])
hand_size = 2
card_prefab = ExtResource("5_0j8s8")
card_container = NodePath("CardContainer")

[node name="Background" type="TextureRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
texture = ExtResource("6_a6awv")

[node name="Title" type="Label" parent="."]
layout_mode = 1
anchors_preset = 5
anchor_left = 0.5
anchor_right = 0.5
offset_left = -59.5
offset_right = 59.5
offset_bottom = 27.0
grow_horizontal = 2
theme_override_font_sizes/font_size = 40
text = "Spring Council"

[node name="CardContainer" type="HBoxContainer" parent="."]
custom_minimum_size = Vector2(200, 300)
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -100.0
offset_top = -150.0
offset_right = 100.0
offset_bottom = 150.0
grow_horizontal = 2
grow_vertical = 2

[node name="ConfirmPanel" type="Control" parent="."]
visible = false
anchors_preset = 0
offset_right = 40.0
offset_bottom = 40.0

[node name="ConfirmLabel" type="Label" parent="ConfirmPanel"]
layout_mode = 0
offset_right = 40.0
offset_bottom = 27.0

[node name="CommitButton" type="Button" parent="ConfirmPanel"]
layout_mode = 0
offset_right = 20.0
offset_bottom = 10.0

[node name="SpringUIDiagnostics" type="Node" parent="." node_paths=PackedStringArray("target_ui")]
script = ExtResource("7_y8qc6")
target_ui = NodePath("..")


--------------------------------------------------
FILE: res:///ui/seasonal/SpringCouncil_UI.gd
--------------------------------------------------
class_name SpringCouncil_UI
extends Control

## The Spring Seasonal Screen.
## REFACTORED VERSION: Uses Data-Driven Aggregator instead of String Keys.

# --- Configuration ---
@export_group("Deck Configuration")
@export var available_advisor_cards: Array[SeasonalCardResource] = []
@export var hand_size: int = 3

@export_group("References")
@export var card_prefab: PackedScene 
@export var card_container: HBoxContainer

# --- State ---
var _selected_card: SeasonalCardResource
var _has_activated: bool = false

func _ready() -> void:
	# Initial State Check
	Loggie.msg("SpringCouncil_UI Instantiated").domain(LogDomains.UI).info()
	
	# Connect Signals
	if not EventBus.season_changed.is_connected(_on_season_changed):
		EventBus.season_changed.connect(_on_season_changed)

	# Check current state immediately
	if DynastyManager.current_season == DynastyManager.Season.SPRING:
		_activate_spring_ui()
	
	get_tree().create_timer(5.0).timeout.connect(_on_diagnostic_timeout)

func _on_season_changed(season_name: String) -> void:
	if season_name.to_lower() == "spring":
		_activate_spring_ui()
	else:
		if visible:
			visible = false

func _activate_spring_ui() -> void:
	visible = true
	_deal_cards()
	_has_activated = true

func _on_diagnostic_timeout() -> void:
	if not _has_activated and DynastyManager.current_season == DynastyManager.Season.SPRING:
		Loggie.msg("FAILURE: SpringCouncil_UI failed to activate").domain(LogDomains.UI).error()

func _deal_cards() -> void:
	# 1. Cleanup
	for child in card_container.get_children():
		child.queue_free()

	# 2. Filter Deck
	var spring_deck: Array[SeasonalCardResource] = []
	for card in available_advisor_cards:
		if card and card.season == SeasonalCardResource.SeasonType.SPRING:
			spring_deck.append(card)
	
	if spring_deck.is_empty():
		return

	# 3. Deal
	spring_deck.shuffle()
	var cards_to_spawn = min(hand_size, spring_deck.size())
	
	for i in range(cards_to_spawn):
		var card_instance = card_prefab.instantiate() as SeasonalCard_UI
		card_container.add_child(card_instance)
		card_instance.setup(spring_deck[i], true) 
		card_instance.card_clicked.connect(_on_card_selected)

func _on_card_selected(card: SeasonalCardResource) -> void:
	_selected_card = card
	_commit_choice()

func _commit_choice() -> void:
	if not _selected_card: 
		return
	
	# 1. Aggregate Seasonal Stats
	# This adds all mod_* values from the card to the DynastyManager's active_year_stats
	DynastyManager.aggregate_card_effects(_selected_card)
		
	# 2. Immediate Rewards
	if _selected_card.grant_gold > 0:
		EconomyManager.deposit_resources({"gold": _selected_card.grant_gold})
	
	if _selected_card.grant_renown > 0:
		DynastyManager.award_renown(_selected_card.grant_renown)
	
	Loggie.msg("Spring Strategy Committed: %s" % _selected_card.display_name).domain(LogDomains.GAMEPLAY).info()

	# 3. Cleanup & Transition
	EventBus.advance_season_requested.emit()
	visible = false
	queue_free()


--------------------------------------------------
FILE: res:///ui/seasonal/SpringUiDiagnostics.gd
--------------------------------------------------
extends Node
class_name SpringUIDiagnostic

## A passive observer for the SpringCouncil_UI.
## specialized to handle dynamic card spawning and seasonal logic validation.

@export var target_ui: SpringCouncil_UI
@export var audit_interval: float = 1.0

var _timer: float = 0.0

func _ready() -> void:
	# Wait for parent setup
	await get_tree().process_frame
	
	if not target_ui:
		printerr("[DIAGNOSTIC CRITICAL] No Target UI assigned to SpringUIDiagnostic!")
		return

	Loggie.msg("--- STARTING SPRING UI DIAGNOSTICS ---").domain(LogDomains.UI).info()
	
	_validate_configuration()
	_hook_global_signals()
	_hook_container()
	_check_initial_state()

func _process(delta: float) -> void:
	_timer += delta
	if _timer >= audit_interval:
		_timer = 0.0
		_run_periodic_audit()

# --- 1. Startup Validation ---

func _validate_configuration() -> void:
	# Check References
	if not target_ui.card_container:
		_log_error("card_container is NOT assigned.")
	elif not target_ui.card_container.is_inside_tree():
		_log_error("card_container is assigned but not in Scene Tree.")
		
	if not target_ui.card_prefab:
		_log_error("card_prefab is missing.")
		
	# Check Data
	if target_ui.available_advisor_cards.is_empty():
		_log_warn("Deck Configuration is empty! No cards available to deal.")

func _check_initial_state() -> void:
	if not target_ui.visible and DynastyManager.current_season == DynastyManager.Season.SPRING:
		_log_warn("Logic Mismatch: Season IS Spring, but UI is Hidden.")

# --- 2. Dynamic Hooking (The Card Spy) ---

func _hook_container() -> void:
	if target_ui.card_container:
		# Watch for cards being added dynamically
		target_ui.card_container.child_entered_tree.connect(_on_card_spawned)

func _on_card_spawned(node: Node) -> void:
	# Verify it's a card and hook its input signal
	if node is SeasonalCard_UI:
		_log_info("Card Spawned: %s" % node.name)
		
		# Hook the signal to spy on clicks
		if node.has_signal("card_clicked"):
			node.card_clicked.connect(func(card): _log_input("Card Selected: %s (Gold: %d, Renown: %d)" % [
				card.display_name if "display_name" in card else "Unknown",
				card.grant_gold if "grant_gold" in card else 0,
				card.grant_renown if "grant_renown" in card else 0
			]))
		else:
			_log_error("Spawned object %s is missing 'card_clicked' signal!" % node.name)
	else:
		_log_warn("Non-Card object added to Container: %s" % node.name)

# --- 3. Global Flow Spying ---

func _hook_global_signals() -> void:
	# Monitor Season Changes
	EventBus.season_changed.connect(func(s): _log_info("Season Changed Signal Received: %s" % s))
	
	# Monitor the Output Signal
	EventBus.advance_season_requested.connect(func(): _log_info(">> OUTPUT: Advance Season Requested (Commit Successful)"))

# --- 4. Periodic Audit ---

func _run_periodic_audit() -> void:
	if not target_ui.visible: return

	# Validate Season Consistency
	if DynastyManager.current_season != DynastyManager.Season.SPRING:
		_log_error("CRITICAL: Spring UI is Visible, but Season is %s" % str(DynastyManager.current_season))

	# Validate Container State
	var child_count = target_ui.card_container.get_child_count()
	if child_count == 0 and target_ui._has_activated:
		# If we activated but have no cards, something failed in _deal_cards
		_log_error("UI Active but Card Container is Empty.")
		_debug_deck_failure() # TRIGGER DEEP DEBUG

func _debug_deck_failure() -> void:
	print_rich("[color=orange]--- [SPRING DEBUG] DECK ANALYSIS ---[/color]")
	
	# 1. Check Hand Size
	if target_ui.hand_size <= 0:
		print_rich("[color=red]FAIL: 'hand_size' is %d. No cards will ever spawn.[/color]" % target_ui.hand_size)
		return

	# 2. Check Prefab Instantiation
	if target_ui.card_prefab:
		var test_inst = target_ui.card_prefab.instantiate()
		if not test_inst:
			print_rich("[color=red]FAIL: 'card_prefab' failed to instantiate (Returned Null). Check the Scene file.[/color]")
		elif not (test_inst is SeasonalCard_UI):
			print_rich("[color=red]FAIL: 'card_prefab' root node is type '%s', expected 'SeasonalCard_UI'.[/color]" % test_inst.get_class())
		else:
			print_rich("[color=green]PASS: Prefab instantiates correctly.[/color]")
		test_inst.queue_free()
	
	# 3. Check Enum Matching & Stale Data
	var expected_enum = SeasonalCardResource.SeasonType.SPRING
	print_rich("[color=cyan]INFO: Target Season Enum is: %d (SPRING)[/color]" % expected_enum)
	print("Array Size: %d" % target_ui.available_advisor_cards.size())
	
	var valid_cards = 0
	for i in range(target_ui.available_advisor_cards.size()):
		var card = target_ui.available_advisor_cards[i]
		
		# Check for Null
		if not card:
			print_rich("[color=red]Slot %d: NULL RESOURCE[/color]" % i)
			continue
			
		# Check for Stale/Built-in Resources
		var is_external = card.resource_path != "" and not "::" in card.resource_path
		if not is_external:
			print_rich("[color=yellow]Slot %d WARN: Resource is internal/built-in. Inspector changes to file won't update this![/color]" % i)
			
		var card_season = card.season
		if card_season == expected_enum:
			valid_cards += 1
			print("Slot %d: MATCH (Int %d) - %s" % [i, card_season, card.resource_path.get_file()])
		else:
			# PRINT THE MISMATCHED VALUE
			print_rich("[color=pink]Slot %d: MISMATCH (Card has Int %d, Expected %d) - %s[/color]" % [i, card_season, expected_enum, card.resource_path.get_file()])

	if valid_cards == 0:
		print_rich("[color=red]FAIL: 0 cards matched. See Mismatches above.[/color]")
		print_rich("[color=yellow]TIP: If you see 'MISMATCH', the card property is wrong. If you see 'Resource is internal', clear the array in the Inspector and drag the files in again.[/color]")
	else:
		print_rich("[color=yellow]WARN: %d cards matched. If Prefab is OK, check for immediate queue_free() in 'setup()'.[/color]" % valid_cards)

# --- Helpers ---

func _log_info(msg: String) -> void:
	print_rich("[color=cyan][SPRING DIAG] %s[/color]" % msg)

func _log_warn(msg: String) -> void:
	print_rich("[color=yellow][SPRING WARN] %s[/color]" % msg)
	Loggie.msg(msg).domain(LogDomains.UI).warn()

func _log_error(msg: String) -> void:
	print_rich("[color=red][SPRING FAIL] %s[/color]" % msg)
	Loggie.msg(msg).domain(LogDomains.UI).error()

func _log_input(msg: String) -> void:
	print_rich("[color=green][SPRING INPUT] %s[/color]" % msg)


--------------------------------------------------
FILE: res:///ui/seasonal/SummerAllocation_UI.gd
--------------------------------------------------
extends Control

## SummerAllocation_UI
##
## Handles the distribution of villager labor during the Summer phase.
## Allows assigning peasants to Construction, Farming, and Raiding.
## Only visible when toggled via Storefront during "Summer".

# -- Configuration --
@export_group("Configuration")
@export var raider_template: UnitData ## The UnitData resource used for drafted peasants (e.g., Bondi).
@export var estimated_farm_yield: int = 100 ## Estimated yield per farmer if dynamic calculation fails.

# -- Constants --
const SEASONS_PER_YEAR: int = 4
const SEASON_NAMES: Array[String] = ["Spring", "Summer", "Autumn", "Winter"]
const WINTER_FOOD_PER_PEASANT: int = 1 # Used for live projection adjustments

# -- Nodes --
@onready var label_population: Label = %PopulationLabel
@onready var label_unassigned: Label = %UnassignedLabel

@onready var slider_construction: HSlider = %ConstructionSlider
@onready var slider_farming: HSlider = %FarmingSlider
@onready var slider_raiding: HSlider = %RaidingSlider

@onready var val_construction: Label = %ValConstruction
@onready var val_farming: Label = %ValFarming
@onready var val_raiding: Label = %ValRaiding

@onready var proj_construction: Label = %Proj_Construction
@onready var proj_food: Label = %Proj_Food
@onready var proj_raid: Label = %Proj_Raid

# Winter Forecast Nodes
@onready var lbl_current_stockpile: Label = %Lbl_Stockpile
@onready var lbl_winter_demand: Label = %Lbl_WinterDemand
@onready var lbl_winter_net: Label = %Lbl_WinterNet

@onready var btn_commit_raid: Button = %CommitRaidBtn
@onready var btn_confirm: Button = %ConfirmBtn

# -- State --
var total_peasants: int = 0
var total_construction_slots: int = 0
var total_farming_slots: int = 0
var allocations: Dictionary = {
	"construction": 0,
	"farming": 0,
	"raiding": 0
}

# Semaphore to prevent recursion during slider updates
var _updating_sliders: bool = false

func _ready() -> void:
	add_to_group("seasonal_ui")
	visible = false
	
	if not raider_template:
		Loggie.msg("SummerAllocation_UI: 'raider_template' is not assigned in Inspector!").domain(LogDomains.GAMEPLAY).error()
	
	_connect_signals()
	
	if DynastyManager.get_current_season_name() == "Summer":
		_initialize_data()

func _connect_signals() -> void:
	slider_construction.value_changed.connect(_on_allocation_changed)
	slider_farming.value_changed.connect(_on_allocation_changed)
	slider_raiding.value_changed.connect(_on_allocation_changed)
	
	btn_commit_raid.pressed.connect(_on_commit_raid_pressed)
	btn_confirm.pressed.connect(_on_confirm_pressed)
	
	EventBus.season_changed.connect(_on_season_changed)

func _on_season_changed(season_name: String) -> void:
	if season_name != "Summer":
		visible = false
	else:
		_initialize_data()

func toggle_interface(interface_name: String = "") -> void:
	if interface_name != "" and interface_name != "allocation": return
	if DynastyManager.get_current_season_name() != "Summer":
		Loggie.msg("Cannot open Summer Allocation: Wrong Season").domain(LogDomains.UI).warn()
		visible = false
		return
		
	visible = not visible
	if visible:
		_initialize_data()
		move_to_front()

func _initialize_data() -> void:
	if not SettlementManager.current_settlement: return
	
	total_peasants = SettlementManager.current_settlement.population_peasants
	
	# 2a. Construction Slots
	total_construction_slots = 0
	var pending = SettlementManager.current_settlement.pending_construction_buildings
	for entry in pending:
		if "resource_path" in entry:
			var b_data = load(entry["resource_path"]) as BuildingData
			if b_data:
				var cap = b_data.base_labor_capacity if "base_labor_capacity" in b_data else 3
				total_construction_slots += cap
				
	# 2b. Farming Slots
	total_farming_slots = 0
	var placed = SettlementManager.current_settlement.placed_buildings
	for entry in placed:
		if "resource_path" in entry:
			var b_data = load(entry["resource_path"])
			if b_data is EconomicBuildingData:
				total_farming_slots += b_data.peasant_capacity
	
	# Reset allocations to a safe state if opening fresh
	if allocations.construction == 0 and allocations.farming == 0 and allocations.raiding == 0:
		var initial_farm = min(int(total_farming_slots * 0.8), total_peasants)
		allocations.farming = initial_farm
		
		var remaining = total_peasants - initial_farm
		var initial_const = min(total_construction_slots, remaining)
		allocations.construction = initial_const
		
		allocations.raiding = 0
	
	# Force an update to sync sliders and set initial dynamic max values
	_sync_sliders_to_data()
	_recalculate_slider_limits()

func _sync_sliders_to_data() -> void:
	_updating_sliders = true
	slider_construction.set_value_no_signal(allocations.construction)
	slider_farming.set_value_no_signal(allocations.farming)
	slider_raiding.set_value_no_signal(allocations.raiding)
	_updating_sliders = false
	_update_ui()

# -- Logic --

func _on_allocation_changed(_value: float) -> void:
	if _updating_sliders: return
	
	allocations.construction = int(slider_construction.value)
	allocations.farming = int(slider_farming.value)
	allocations.raiding = int(slider_raiding.value)
	
	# Recalculate limits immediately to prevent over-allocation
	_recalculate_slider_limits()
	_update_ui()

func _recalculate_slider_limits() -> void:
	_updating_sliders = true
	
	var used = allocations.construction + allocations.farming + allocations.raiding
	var free_pop = total_peasants - used
	
	# Construction Limit
	var potential_const = allocations.construction + free_pop
	var final_max_const = min(potential_const, total_construction_slots)
	slider_construction.max_value = max(final_max_const, allocations.construction) 
	
	# Farming Limit
	var potential_farm = allocations.farming + free_pop
	var final_max_farm = min(potential_farm, total_farming_slots)
	slider_farming.max_value = max(final_max_farm, allocations.farming)
	
	# Raiding Limit (Only limit is total population)
	var potential_raid = allocations.raiding + free_pop
	slider_raiding.max_value = potential_raid
	
	_updating_sliders = false

func _update_ui() -> void:
	var used = allocations.construction + allocations.farming + allocations.raiding
	var unassigned = total_peasants - used
	
	label_population.text = "Available Villagers: %d" % total_peasants
	val_construction.text = str(allocations.construction)
	val_farming.text = str(allocations.farming)
	val_raiding.text = str(allocations.raiding)
	
	if unassigned < 0:
		label_unassigned.text = "OVER-ALLOCATED: %d" % unassigned
		label_unassigned.add_theme_color_override("font_color", Color.RED)
		btn_commit_raid.disabled = true
		btn_confirm.disabled = true
	else:
		label_unassigned.text = "Unassigned: %d" % unassigned
		label_unassigned.add_theme_color_override("font_color", Color.WHITE)
		btn_commit_raid.disabled = (allocations.raiding <= 0 or raider_template == null)
		btn_confirm.disabled = false 
	
	_update_projections()
	_update_winter_forecast()

func _update_projections() -> void:
	# 1. Construction Projection (Detailed List)
	var pending = SettlementManager.current_settlement.pending_construction_buildings
	if pending.is_empty():
		proj_construction.text = "No pending construction"
		proj_construction.add_theme_color_override("font_color", Color.GRAY)
	else:
		proj_construction.remove_theme_color_override("font_color")
		var report = ""
		
		# Get simulated assignment to predict speeds
		var assignments = _get_builder_distribution(allocations.construction)
		
		for i in range(pending.size()):
			var entry = pending[i]
			var b_data = load(entry["resource_path"]) as BuildingData
			var assigned_workers = assignments[i]
			var b_name = b_data.display_name if b_data else "Building"
			
			if assigned_workers == 0:
				report += "%s: Paused (0 workers)\n" % b_name
			else:
				var total_effort = 100 
				if b_data and "construction_effort_required" in b_data:
					total_effort = b_data.construction_effort_required
				
				var remaining_effort = max(0, total_effort - entry.get("progress", 0))
				var seasonal_progress = assigned_workers * EconomyManager.BUILDER_EFFICIENCY
				
				if seasonal_progress > 0:
					var turns_needed = ceil(float(remaining_effort) / float(seasonal_progress))
					var date_str = _calculate_completion_date(int(turns_needed))
					report += "%s: %s (%d Turns)\n" % [b_name, date_str, turns_needed]
				else:
					report += "%s: Stalled\n" % b_name
					
		proj_construction.text = report
	
	# 2. Food / Resource Projection
	if total_farming_slots == 0:
		proj_food.text = "No resource buildings"
		proj_food.add_theme_color_override("font_color", Color.RED)
	else:
		var yields = EconomyManager.calculate_hypothetical_yields(allocations.farming)
		var food_amt = yields.get("food", 0)
		var other_text = ""
		
		for k in yields:
			if k != "food" and yields[k] > 0:
				other_text += ", +%d %s" % [yields[k], k.capitalize()]
				
		proj_food.text = "~%d Food%s" % [food_amt, other_text]
		proj_food.remove_theme_color_override("font_color")
	
	# 3. Raid Projection
	var men = allocations.raiding
	var bands = ceil(men / 10.0)
	proj_raid.text = "%d Men (%d Warbands)" % [men, bands]

func _update_winter_forecast() -> void:
	if not SettlementManager.current_settlement: return
	
	# 1. Get Base Forecast (Current State)
	var forecast = EconomyManager.get_winter_forecast()
	var base_food_demand = forecast.get("food", 0)
	var wood_demand = forecast.get("wood", 0)
	
	# 2. Adjust for Allocated Raiders (Simulate them leaving)
	var raiders = allocations.raiding
	var adjusted_food_demand = max(0, base_food_demand - (raiders * WINTER_FOOD_PER_PEASANT))
	
	# 3. Get Stockpiles
	var treasury = SettlementManager.current_settlement.treasury
	var current_food = treasury.get("food", 0)
	var current_wood = treasury.get("wood", 0)
	
	# 4. Get Projected Yields from Farming Slider (UPDATED)
	var estimated_yields = EconomyManager.calculate_hypothetical_yields(allocations.farming)
	var projected_food_yield = estimated_yields.get(GameResources.FOOD, 0)
	var projected_wood_yield = estimated_yields.get(GameResources.WOOD, 0)
	
	# 5. Total Available Calculation
	var total_food_available = current_food + projected_food_yield
	var total_wood_available = current_wood + projected_wood_yield
	
	# 6. Display Stockpile Info (Stockpile + Yield)
	lbl_current_stockpile.text = "Available: %d Food (%d + %d), %d Wood" % [total_food_available, current_food, projected_food_yield, total_wood_available]
	
	# 7. Display Projected Demand
	lbl_winter_demand.text = "Proj. Winter Demand: %d Food, %d Wood" % [adjusted_food_demand, wood_demand]
	
	# 8. Net Calculation
	var food_net = total_food_available - adjusted_food_demand
	var wood_net = total_wood_available - wood_demand
	
	var status_text = ""
	var color = Color.DARK_GREEN
	
	if food_net < 0 or wood_net < 0:
		color = Color.RED
		status_text = "WARNING: Deficit Predicted ("
		if food_net < 0: status_text += "%d Food " % food_net
		if wood_net < 0: status_text += "%d Wood" % wood_net
		status_text += ")"
	else:
		status_text = "Winter Secure (Surplus: +%d Food)" % food_net
		
	lbl_winter_net.text = status_text
	lbl_winter_net.add_theme_color_override("font_color", color)

func _calculate_completion_date(turns_needed: int) -> String:
	# Fallback to 867 if missing
	var current_year = 867
	if "current_year" in DynastyManager:
		current_year = DynastyManager.current_year
	elif "year" in DynastyManager:
		current_year = DynastyManager.year
	
	var current_season_idx = DynastyManager.current_season # Enum (0-3)
	
	var absolute_current_turn = (current_year * SEASONS_PER_YEAR) + current_season_idx
	var absolute_completion_turn = absolute_current_turn + turns_needed
	
	var future_year = floor(absolute_completion_turn / float(SEASONS_PER_YEAR))
	var future_season_idx = absolute_completion_turn % SEASONS_PER_YEAR
	
	var season_name = "Unknown"
	if future_season_idx >= 0 and future_season_idx < SEASON_NAMES.size():
		season_name = SEASON_NAMES[future_season_idx]
		
	return "%s, Year %d" % [season_name, future_year]

func _on_confirm_pressed() -> void:
	_apply_builder_distribution(allocations.construction)
	_distribute_farmers(allocations.farming)
	
	Loggie.msg("Summer allocations confirmed | Allocations: %s" % str(allocations)).domain(LogDomains.GAMEPLAY).info()
	visible = false

# -- Distribution Logic --

func _get_builder_distribution(total_pool: int) -> Array:
	var results = []
	if not SettlementManager.current_settlement: return results
	
	var remaining = total_pool
	var pending = SettlementManager.current_settlement.pending_construction_buildings
	
	for entry in pending:
		var b_data = load(entry["resource_path"]) as BuildingData
		var capacity = 3
		if b_data and "base_labor_capacity" in b_data:
			capacity = b_data.base_labor_capacity
			
		var to_assign = min(remaining, capacity)
		results.append(to_assign)
		remaining -= to_assign
		
	return results

func _apply_builder_distribution(total_pool: int) -> void:
	if not SettlementManager.current_settlement: return
	
	var assignments = _get_builder_distribution(total_pool)
	var pending = SettlementManager.current_settlement.pending_construction_buildings
	
	for i in range(pending.size()):
		if i < assignments.size():
			pending[i]["peasant_count"] = assignments[i]
			
	SettlementManager.save_settlement()


func _distribute_farmers(total_farmers: int) -> void:
	if not SettlementManager.current_settlement: return
	
	var remaining = total_farmers
	var placed = SettlementManager.current_settlement.placed_buildings
	
	var food_buildings = []
	var other_buildings = []
	
	for entry in placed:
		var b_data = load(entry["resource_path"])
		if b_data is EconomicBuildingData:
			entry["peasant_count"] = 0
			if b_data.resource_type == "food":
				food_buildings.append({"entry": entry, "cap": b_data.peasant_capacity})
			else:
				other_buildings.append({"entry": entry, "cap": b_data.peasant_capacity})
	
	for item in food_buildings:
		if remaining <= 0: break
		var to_assign = min(remaining, item.cap)
		item.entry["peasant_count"] = to_assign
		remaining -= to_assign
		
	for item in other_buildings:
		if remaining <= 0: break
		var to_assign = min(remaining, item.cap)
		item.entry["peasant_count"] = to_assign
		remaining -= to_assign

	SettlementManager.save_settlement()

func _on_commit_raid_pressed() -> void:
	if allocations.raiding <= 0: return
	if not raider_template: return
	
	var raid_count = allocations.raiding
	EconomyManager.draft_peasants_to_raiders(raid_count, raider_template)
	
	total_peasants -= raid_count
	allocations.raiding = 0
	
	_initialize_data() 
	_sync_sliders_to_data()
	_recalculate_slider_limits() # Force re-calc after pop change
	
	Loggie.msg("Summer allocation committed | Raiders: %d" % raid_count).domain(LogDomains.GAMEPLAY).info()
	EventBus.raid_committed.emit(raid_count)


--------------------------------------------------
FILE: res:///ui/seasonal/SummerAllocation_Ui.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://c8q4w2x5y301"]

[ext_resource type="Script" uid="uid://cms0bgtoscos8" path="res://ui/seasonal/SummerAllocation_UI.gd" id="1_logic"]
[ext_resource type="Resource" uid="uid://dpe2acwvvxthl" path="res://data/units/Unit_Bondi.tres" id="2_6xyy4"]

[node name="SummerAllocation_UI" type="PanelContainer"]
custom_minimum_size = Vector2(0, 450)
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
mouse_filter = 2
script = ExtResource("1_logic")
raider_template = ExtResource("2_6xyy4")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 30
theme_override_constants/margin_top = 30
theme_override_constants/margin_right = 30
theme_override_constants/margin_bottom = 30

[node name="ScrollContainer" type="ScrollContainer" parent="MarginContainer"]
layout_mode = 2
horizontal_scroll_mode = 0

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_constants/separation = 25

[node name="Header" type="HBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer"]
layout_mode = 2
alignment = 1

[node name="Title" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/Header"]
layout_mode = 2
size_flags_horizontal = 3
theme_type_variation = &"HeaderLarge"
text = "Summer Labor Allocation"

[node name="PopulationLabel" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/Header"]
unique_name_in_owner = true
visible = false
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Available Villagers: 0"

[node name="UnassignedLabel" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/Header"]
unique_name_in_owner = true
visible = false
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
text = " | Unassigned: 0"

[node name="CardContainer" type="HBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 15
alignment = 1

[node name="ConstructionCard" type="PanelContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard"]
layout_mode = 2
theme_override_constants/margin_left = 15
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 15
theme_override_constants/margin_bottom = 15

[node name="VBox" type="VBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="Title" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox"]
layout_mode = 2
theme_type_variation = &"HeaderMedium"
text = "Construction"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox"]
layout_mode = 2

[node name="HBox" type="HBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox"]
layout_mode = 2
alignment = 1

[node name="ValConstruction" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox/HBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(40, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "0"
horizontal_alignment = 1

[node name="Label" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox/HBox"]
layout_mode = 2
text = "Builders"

[node name="ConstructionSlider" type="HSlider" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 1

[node name="Spacer" type="Control" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="LabelProj" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.7, 0.7, 0.7, 1)
text = "Projected Progress:"
horizontal_alignment = 1

[node name="Proj_Construction" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/ConstructionCard/Margin/VBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 1, 1)
text = "+0 / day"
horizontal_alignment = 1
autowrap_mode = 3

[node name="FarmingCard" type="PanelContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard"]
layout_mode = 2
theme_override_constants/margin_left = 15
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 15
theme_override_constants/margin_bottom = 15

[node name="VBox" type="VBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="Title" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox"]
layout_mode = 2
theme_type_variation = &"HeaderMedium"
text = "Farming"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox"]
layout_mode = 2

[node name="HBox" type="HBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox"]
layout_mode = 2
alignment = 1

[node name="ValFarming" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox/HBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(40, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "0"
horizontal_alignment = 1

[node name="Label" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox/HBox"]
layout_mode = 2
text = "Farmers"

[node name="FarmingSlider" type="HSlider" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 1

[node name="Spacer" type="Control" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="LabelProj" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.7, 0.7, 0.7, 1)
text = "Est. Yield:"
horizontal_alignment = 1

[node name="Proj_Food" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/FarmingCard/Margin/VBox"]
unique_name_in_owner = true
layout_mode = 2
text = "0 Food"
horizontal_alignment = 1
autowrap_mode = 3

[node name="RaidingCard" type="PanelContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer"]
visible = false
layout_mode = 2
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard"]
layout_mode = 2
theme_override_constants/margin_left = 15
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 15
theme_override_constants/margin_bottom = 15

[node name="VBox" type="VBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="Title" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
layout_mode = 2
theme_type_variation = &"HeaderMedium"
text = "Raiding"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
layout_mode = 2

[node name="HBox" type="HBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
layout_mode = 2
alignment = 1

[node name="ValRaiding" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox/HBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(40, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "0"
horizontal_alignment = 1

[node name="Label" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox/HBox"]
layout_mode = 2
text = "Raiders"

[node name="RaidingSlider" type="HSlider" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 1

[node name="Spacer" type="Control" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="LabelProj" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.7, 0.7, 0.7, 1)
text = "Warband Size:"
horizontal_alignment = 1

[node name="Proj_Raid" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
unique_name_in_owner = true
layout_mode = 2
text = "0 Men"
horizontal_alignment = 1

[node name="CommitRaidBtn" type="Button" parent="MarginContainer/ScrollContainer/VBoxContainer/CardContainer/RaidingCard/Margin/VBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
disabled = true
text = "Commit Warband"

[node name="WinterForecastPanel" type="PanelContainer" parent="MarginContainer/ScrollContainer/VBoxContainer"]
visible = false
layout_mode = 2
theme_type_variation = &"PanelContainerDark"

[node name="Margin" type="MarginContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/WinterForecastPanel"]
layout_mode = 2
theme_override_constants/margin_left = 15
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 15
theme_override_constants/margin_bottom = 10

[node name="HBox" type="HBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer/WinterForecastPanel/Margin"]
layout_mode = 2
theme_override_constants/separation = 40
alignment = 1

[node name="Lbl_Stockpile" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/WinterForecastPanel/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
text = "Stockpile: 0 Food, 0 Wood"

[node name="VSeparator" type="VSeparator" parent="MarginContainer/ScrollContainer/VBoxContainer/WinterForecastPanel/Margin/HBox"]
layout_mode = 2

[node name="Lbl_WinterDemand" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/WinterForecastPanel/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
text = "Proj. Winter Demand: 0 Food"

[node name="VSeparator2" type="VSeparator" parent="MarginContainer/ScrollContainer/VBoxContainer/WinterForecastPanel/Margin/HBox"]
layout_mode = 2

[node name="Lbl_WinterNet" type="Label" parent="MarginContainer/ScrollContainer/VBoxContainer/WinterForecastPanel/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_colors/font_color = Color(0, 1, 0, 1)
text = "Winter Secure"

[node name="Footer" type="HBoxContainer" parent="MarginContainer/ScrollContainer/VBoxContainer"]
layout_mode = 2
alignment = 1

[node name="ConfirmBtn" type="Button" parent="MarginContainer/ScrollContainer/VBoxContainer/Footer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(250, 50)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "Confirm Allocations"


--------------------------------------------------
FILE: res:///ui/seasonal/SummerDiagnostics.gd
--------------------------------------------------
extends Node
class_name SummerUIDiagnostic

## A comprehensive diagnostic tool for the SummerWorkspace_UI.
## Validates connections, node assignments, and input handling.

@export var target_ui: SummerWorkspace_UI
@export var audit_interval: float = 1.0

var _timer: float = 0.0

func _ready() -> void:
	# Wait one frame to ensure parent UI _ready has completed
	await get_tree().process_frame 
	
	if not target_ui:
		printerr("[DIAGNOSTIC CRITICAL] No Target UI assigned to SummerUIDiagnostic!")
		return

	Loggie.msg("--- STARTING DEEP DIAGNOSTICS FOR SUMMER UI ---").domain(LogDomains.UI).info()
	
	_validate_node_assignments()
	_hook_inputs()
	_check_visibility_and_process()
	
	# Initial State Dump for Collapse Panel
	if target_ui.container_raid_command:
		_log_state("Initial Collapse State", target_ui.container_raid_command)

func _process(delta: float) -> void:
	_timer += delta
	if _timer >= audit_interval:
		_timer = 0.0
		_run_periodic_audit()

# --- 1. Startup Validation ---

func _validate_node_assignments() -> void:
	var nodes_to_check = {
		"btn_collapse_toggle": target_ui.btn_collapse_toggle,
		"btn_world_map": target_ui.btn_world_map,
		"btn_proceed": target_ui.btn_proceed,
		"job_row_farmers": target_ui.job_row_farmers,
		"job_row_builders": target_ui.job_row_builders,
		"job_row_raiders": target_ui.job_row_raiders,
		"container_raid_command": target_ui.container_raid_command
	}
	
	for name in nodes_to_check:
		var node = nodes_to_check[name]
		if node == null:
			_log_error("Node reference missing: target_ui.%s is NULL" % name)
		else:
			if not node.is_inside_tree():
				_log_error("Node %s is assigned but NOT in scene tree!" % name)

func _check_visibility_and_process() -> void:
	if not target_ui.visible:
		_log_warn("Target UI is currently HIDDEN (visible=false). Inputs will fail.")
	
	if target_ui.process_mode == Node.PROCESS_MODE_DISABLED:
		_log_warn("Target UI is DISABLED (process_mode=Disabled).")

	if target_ui.mouse_filter == Control.MOUSE_FILTER_IGNORE:
		_log_warn("Target UI root is ignoring mouse events (MOUSE_FILTER_IGNORE).")

# --- 2. Input Spying & Collapse Diagnostics ---

func _hook_inputs() -> void:
	# 1. Main Buttons
	if target_ui.btn_collapse_toggle:
		target_ui.btn_collapse_toggle.pressed.connect(_on_collapse_clicked_diagnostic)
	else:
		_log_error("Cannot hook Collapse Toggle (Node Missing)")

	if target_ui.btn_world_map:
		target_ui.btn_world_map.pressed.connect(func(): _log_input("World Map Clicked"))
		
	if target_ui.btn_proceed:
		target_ui.btn_proceed.pressed.connect(func(): _log_input("Proceed Clicked"))

	# 2. Job Rows
	var rows = {
		"Farmers": target_ui.job_row_farmers,
		"Builders": target_ui.job_row_builders, 
		"Raiders": target_ui.job_row_raiders
	}
	
	for key in rows:
		var row = rows[key]
		if row:
			row.change_requested.connect(func(amount): _log_input("%s Change Requested: %d" % [key, amount]))
			if row.btn_plus: row.btn_plus.pressed.connect(func(): _log_input("%s RAW PLUS Clicked" % key))
			if row.btn_minus: row.btn_minus.pressed.connect(func(): _log_input("%s RAW MINUS Clicked" % key))

func _on_collapse_clicked_diagnostic() -> void:
	_log_input("Collapse Toggle Clicked - Starting Transition Audit")
	var container = target_ui.container_raid_command
	var logic_state = target_ui.is_raid_panel_open
	
	print_rich("[color=orange]=== COLLAPSE TRANSITION START ===[/color]")
	print("Logic State (is_raid_panel_open): ", logic_state)
	_log_state("BEFORE Tween", container)
	
	# Wait for animation duration (0.2s) + buffer
	await get_tree().create_timer(0.3).timeout
	
	print_rich("[color=orange]=== COLLAPSE TRANSITION END ===[/color]")
	print("Logic State (is_raid_panel_open): ", target_ui.is_raid_panel_open)
	_log_state("AFTER Tween", container)
	
	# Logic Check
	if target_ui.is_raid_panel_open == false and container.visible == true:
		_log_error("COLLAPSE FAILURE: Logic says CLOSED, but Container is VISIBLE.")
	elif target_ui.is_raid_panel_open == true and container.modulate.a < 0.1:
		_log_error("COLLAPSE FAILURE: Logic says OPEN, but Container is INVISIBLE (Alpha ~0).")
	else:
		print_rich("[color=green]>> State Sync Logic OK[/color]")

func _log_state(prefix: String, node: Control) -> void:
	if not node: return
	print("%s >> Visible: %s | Modulate Alpha: %.2f | Size: %s" % [
		prefix, 
		str(node.visible), 
		node.modulate.a, 
		str(node.size)
	])

# --- 3. Periodic Audit ---

func _run_periodic_audit() -> void:
	if not target_ui.visible: return

	# Check Data Logic
	if SettlementManager.current_settlement:
		var real_idle = SettlementManager.get_idle_peasants()
		var planned = target_ui.planned_raiders
		var visual_idle = real_idle - planned
		
		if visual_idle > 0:
			if target_ui.job_row_farmers and target_ui.job_row_farmers.btn_plus.disabled:
				_log_warn("Logic Error: Idle peasants exist (%d), but Farmer Plus button is DISABLED." % visual_idle)

# --- Helpers ---

func _log_warn(msg: String) -> void:
	print_rich("[color=yellow][DIAGNOSTIC WARN] %s[/color]" % msg)
	Loggie.msg(msg).domain(LogDomains.UI).warn()

func _log_error(msg: String) -> void:
	print_rich("[color=red][DIAGNOSTIC FAIL] %s[/color]" % msg)
	Loggie.msg(msg).domain(LogDomains.UI).error()

func _log_input(msg: String) -> void:
	print_rich("[color=cyan][DIAGNOSTIC INPUT] %s[/color]" % msg)


--------------------------------------------------
FILE: res:///ui/seasonal/SummerJobSlider.gd
--------------------------------------------------
extends PanelContainer
class_name JobRow_UI

## A generic row for assigning labor.
## Configured via the Inspector (Solution 1).

signal change_requested(amount: int) # +1 or -1

# --- Inspector Configuration ---
@export_group("Configuration")
@export var role_title: String = "Worker":
	set(value):
		role_title = value
		if label_role: label_role.text = value
@export var icon: Texture2D

@export_group("Internal Nodes")
@export var label_role: Label
@export var label_count: Label
@export var btn_minus: Button
@export var btn_plus: Button
@export var icon_rect: TextureRect

# State
var current_count: int = 0
var max_count: int = -1 

func _ready() -> void:
	# Solution 1: Apply the exported title immediately on load
	if label_role:
		label_role.text = role_title
	if icon_rect and icon: 
		icon_rect.texture = icon
	
	_connect_signals()

# Optional setup for dynamic overrides (still available if needed)
func setup(title_override: String, _icon: Texture2D = null) -> void:
	role_title = title_override
	if _icon: icon = _icon
	
	if label_role: label_role.text = role_title
	if icon_rect and icon: icon_rect.texture = icon

func _connect_signals() -> void:
	if btn_plus:
		btn_plus.pressed.connect(func(): change_requested.emit(1))
	if btn_minus:
		btn_minus.pressed.connect(func(): change_requested.emit(-1))

func update_display(count: int, _max: int = -1) -> void:
	current_count = count
	max_count = _max
	
	if label_count:
		label_count.text = str(current_count)
	
	_update_button_states()

func _update_button_states() -> void:
	if btn_minus:
		btn_minus.disabled = (current_count <= 0)
	
	if btn_plus and max_count != -1:
		btn_plus.disabled = (current_count >= max_count)

func set_plus_enabled(enabled: bool) -> void:
	if btn_plus:
		if max_count != -1 and current_count >= max_count:
			btn_plus.disabled = true
		else:
			btn_plus.disabled = !enabled


--------------------------------------------------
FILE: res:///ui/seasonal/SummerJobSlider.tscn
--------------------------------------------------
[gd_scene load_steps=2 format=3 uid="uid://bhsqb83x1g3v0"]

[ext_resource type="Script" uid="uid://cl30v0wegwxd4" path="res://ui/seasonal/SummerJobSlider.gd" id="1_script"]

[node name="JobRow_UI" type="PanelContainer" node_paths=PackedStringArray("label_role", "label_count", "btn_minus", "btn_plus", "icon_rect")]
offset_right = 400.0
offset_bottom = 50.0
script = ExtResource("1_script")
label_role = NodePath("MarginContainer/HBoxContainer/Label_Role")
label_count = NodePath("MarginContainer/HBoxContainer/CountContainer/Label_Count")
btn_minus = NodePath("MarginContainer/HBoxContainer/CountContainer/Btn_Minus")
btn_plus = NodePath("MarginContainer/HBoxContainer/CountContainer/Btn_Plus")
icon_rect = NodePath("MarginContainer/HBoxContainer/Icon")

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 5
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 5

[node name="HBoxContainer" type="HBoxContainer" parent="MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 15

[node name="Icon" type="TextureRect" parent="MarginContainer/HBoxContainer"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="Label_Role" type="Label" parent="MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
text = "Role Name"
vertical_alignment = 1

[node name="VSeparator" type="VSeparator" parent="MarginContainer/HBoxContainer"]
layout_mode = 2

[node name="CountContainer" type="HBoxContainer" parent="MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="Btn_Minus" type="Button" parent="MarginContainer/HBoxContainer/CountContainer"]
custom_minimum_size = Vector2(30, 30)
layout_mode = 2
text = "-"

[node name="Label_Count" type="Label" parent="MarginContainer/HBoxContainer/CountContainer"]
custom_minimum_size = Vector2(40, 0)
layout_mode = 2
text = "0"
horizontal_alignment = 1

[node name="Btn_Plus" type="Button" parent="MarginContainer/HBoxContainer/CountContainer"]
custom_minimum_size = Vector2(30, 30)
layout_mode = 2
text = "+"


--------------------------------------------------
FILE: res:///ui/seasonal/SummerWorkspaceUI.tscn
--------------------------------------------------
[gd_scene load_steps=3 format=3 uid="uid://cv530nr365fv4"]

[ext_resource type="Script" uid="uid://dneudlbki6d61" path="res://ui/seasonal/SummerWorkspace_UI.gd" id="1_controller"]
[ext_resource type="PackedScene" uid="uid://c8q4w2x5y301" path="res://ui/seasonal/SummerAllocation_Ui.tscn" id="2_v2kwp"]

[node name="SummerWorkspace_UI" type="Control" node_paths=PackedStringArray("label_silver", "label_food", "label_wood", "label_pop_total", "label_pop_idle", "texture_winter_warning", "btn_hide_ui", "lbl_summary_farmers", "lbl_summary_builders", "lbl_summary_raiders", "btn_manage_allocation", "job_row_container", "container_raid_command", "btn_collapse_toggle", "label_authority", "label_bondi_count", "container_warbands", "btn_world_map", "btn_proceed", "btn_tab_construction", "btn_tab_completed", "grid_active_projects", "grid_completed_buildings")]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_controller")
label_silver = NodePath("LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/SilverWidget/Label_Value")
label_food = NodePath("LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/FoodWidget/Label_Value")
label_wood = NodePath("LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/WoodWidget/Label_Value")
label_pop_total = NodePath("LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/PopWidget/Label_Total")
label_pop_idle = NodePath("LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/PopWidget/Label_Idle")
texture_winter_warning = NodePath("LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/WinterWarning")
btn_hide_ui = NodePath("LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/CloseButton")
lbl_summary_farmers = NodePath("LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container/Label_Farmers")
lbl_summary_builders = NodePath("LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container/Label_Builders")
lbl_summary_raiders = NodePath("LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container/Label_Raiders")
btn_manage_allocation = NodePath("LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container/Btn_ManageAllocation")
job_row_container = NodePath("LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container")
allocation_view_scene = ExtResource("2_v2kwp")
container_raid_command = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container")
btn_collapse_toggle = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/CollapseToggle")
label_authority = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/CommandHeader/Label_Authority")
label_bondi_count = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/TroopBreakdown/BondiCount/Label_Value")
container_warbands = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/TroopBreakdown/WarbandList")
btn_world_map = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/WorldMapButton")
btn_proceed = NodePath("LayoutRoot/Footer_Commitment/MarginContainer/ProceedButton")
btn_tab_construction = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/ProjectTabs/Btn_ShowConstruction")
btn_tab_completed = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/ProjectTabs/Btn_ShowCompleted")
grid_active_projects = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/ActiveProjects_Grid")
grid_completed_buildings = NodePath("LayoutRoot/MainWorkspace/VisualizationColumn/CompletedBuildings_Grid")

[node name="BackgroundLayer" type="TextureRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
expand_mode = 1
stretch_mode = 6

[node name="LayoutRoot" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0

[node name="HUD_TopBar" type="PanelContainer" parent="LayoutRoot"]
layout_mode = 2
size_flags_vertical = 0

[node name="MarginContainer" type="MarginContainer" parent="LayoutRoot/HUD_TopBar"]
layout_mode = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 10

[node name="HBoxContainer" type="HBoxContainer" parent="LayoutRoot/HUD_TopBar/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 40

[node name="ResourceGroup" type="HBoxContainer" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="SilverWidget" type="HBoxContainer" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup"]
layout_mode = 2

[node name="Icon" type="TextureRect" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/SilverWidget"]
layout_mode = 2
expand_mode = 2

[node name="Label_Value" type="Label" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/SilverWidget"]
layout_mode = 2
text = "0"

[node name="FoodWidget" type="HBoxContainer" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup"]
layout_mode = 2

[node name="Icon" type="TextureRect" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/FoodWidget"]
layout_mode = 2
expand_mode = 2

[node name="Label_Value" type="Label" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/FoodWidget"]
layout_mode = 2
text = "0 / +0"

[node name="WoodWidget" type="HBoxContainer" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup"]
layout_mode = 2

[node name="Icon" type="TextureRect" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/WoodWidget"]
layout_mode = 2
expand_mode = 2

[node name="Label_Value" type="Label" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/ResourceGroup/WoodWidget"]
layout_mode = 2
text = "0"

[node name="PopWidget" type="HBoxContainer" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 10

[node name="Icon" type="TextureRect" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/PopWidget"]
layout_mode = 2
expand_mode = 2

[node name="Label_Total" type="Label" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/PopWidget"]
layout_mode = 2
text = "Pop: 10"

[node name="Label_Idle" type="Label" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer/PopWidget"]
layout_mode = 2
text = "(3 Idle)"

[node name="WinterWarning" type="TextureRect" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer"]
custom_minimum_size = Vector2(32, 32)
layout_mode = 2
expand_mode = 1
stretch_mode = 5

[node name="CloseButton" type="Button" parent="LayoutRoot/HUD_TopBar/MarginContainer/HBoxContainer"]
layout_mode = 2

[node name="MainWorkspace" type="HBoxContainer" parent="LayoutRoot"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 20

[node name="LaborColumn" type="VBoxContainer" parent="LayoutRoot/MainWorkspace"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.4

[node name="Header" type="Label" parent="LayoutRoot/MainWorkspace/LaborColumn"]
layout_mode = 2
text = "Summer Assignments"
horizontal_alignment = 1

[node name="HSeparator" type="HSeparator" parent="LayoutRoot/MainWorkspace/LaborColumn"]
layout_mode = 2

[node name="JobRow_Container" type="VBoxContainer" parent="LayoutRoot/MainWorkspace/LaborColumn"]
layout_mode = 2
size_flags_vertical = 3
theme_override_constants/separation = 15

[node name="Label_Farmers" type="Label" parent="LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container"]
layout_mode = 2
text = "Farming: 0"

[node name="Label_Builders" type="Label" parent="LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container"]
layout_mode = 2
text = "Construction: 0"

[node name="Label_Raiders" type="Label" parent="LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container"]
layout_mode = 2
text = "Raiding: 0"

[node name="Btn_ManageAllocation" type="Button" parent="LayoutRoot/MainWorkspace/LaborColumn/JobRow_Container"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
text = "ALLOCATION"

[node name="VisualizationColumn" type="VBoxContainer" parent="LayoutRoot/MainWorkspace"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.6

[node name="ProjectTabs" type="HBoxContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn"]
layout_mode = 2

[node name="Btn_ShowConstruction" type="Button" parent="LayoutRoot/MainWorkspace/VisualizationColumn/ProjectTabs"]
layout_mode = 2
size_flags_horizontal = 3
toggle_mode = true
text = "Under Construction"

[node name="Btn_ShowCompleted" type="Button" parent="LayoutRoot/MainWorkspace/VisualizationColumn/ProjectTabs"]
layout_mode = 2
size_flags_horizontal = 3
toggle_mode = true
text = "Completed"

[node name="ActiveProjects_Grid" type="GridContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn"]
layout_mode = 2
size_flags_vertical = 3
columns = 3

[node name="CompletedBuildings_Grid" type="GridContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn"]
visible = false
layout_mode = 2
size_flags_vertical = 3
columns = 3

[node name="RaidCommand_Section" type="VBoxContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn"]
layout_mode = 2
size_flags_vertical = 3
size_flags_stretch_ratio = 0.5
alignment = 2

[node name="CollapseToggle" type="Button" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section"]
layout_mode = 2
text = " War Council"

[node name="RaidCommand_Container" type="PanelContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section"]
layout_mode = 2
size_flags_vertical = 3

[node name="MarginContainer" type="MarginContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="VBoxContainer" type="VBoxContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer"]
layout_mode = 2

[node name="CommandHeader" type="HBoxContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="Label_Title" type="Label" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/CommandHeader"]
layout_mode = 2
text = "War Council"

[node name="Label_Authority" type="Label" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/CommandHeader"]
layout_mode = 2
size_flags_horizontal = 10
text = "Authority: 0"

[node name="HSeparator" type="HSeparator" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="TroopBreakdown" type="VBoxContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3

[node name="BondiCount" type="HBoxContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/TroopBreakdown"]
layout_mode = 2

[node name="Label_Title" type="Label" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/TroopBreakdown/BondiCount"]
layout_mode = 2
text = "Bondi (Villagers):"

[node name="Label_Value" type="Label" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/TroopBreakdown/BondiCount"]
layout_mode = 2
size_flags_horizontal = 10
text = "0"

[node name="WarbandList" type="VBoxContainer" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer/TroopBreakdown"]
layout_mode = 2

[node name="WorldMapButton" type="Button" parent="LayoutRoot/MainWorkspace/VisualizationColumn/RaidCommand_Section/RaidCommand_Container/MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2
text = "OPEN WORLD MAP"

[node name="Footer_Commitment" type="PanelContainer" parent="LayoutRoot"]
layout_mode = 2

[node name="MarginContainer" type="MarginContainer" parent="LayoutRoot/Footer_Commitment"]
layout_mode = 2
theme_override_constants/margin_left = 50
theme_override_constants/margin_top = 15
theme_override_constants/margin_right = 50
theme_override_constants/margin_bottom = 15

[node name="ProceedButton" type="Button" parent="LayoutRoot/Footer_Commitment/MarginContainer"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
text = "The Sun Sets. All Paths are Chosen."


--------------------------------------------------
FILE: res:///ui/seasonal/SummerWorkspace_UI.gd
--------------------------------------------------
extends Control
class_name SummerWorkspace_UI

## The Unified Dashboard for Summer Operations.
## Acts as a read-only summary and launcher for the embedded Allocation UI.

# --- Configuration ---
const SEASONS_PER_YEAR: int = 4
const SEASON_NAMES: Array[String] = ["Spring", "Summer", "Autumn", "Winter"]

# --- UI References ---
@export_group("HUD Components")
@export var label_silver: Label
@export var label_food: Label
@export var label_wood: Label
@export var label_pop_total: Label
@export var label_pop_idle: Label
@export var texture_winter_warning: TextureRect
@export var btn_hide_ui: Button 

@export_group("Labor Summary")
@export var lbl_summary_farmers: Label
@export var lbl_summary_builders: Label
@export var lbl_summary_raiders: Label
@export var btn_manage_allocation: Button
@export var job_row_container: VBoxContainer ## container where the allocation panel will be injected
@export var allocation_view_scene: PackedScene ## Assign 'SummerAllocation_UI.tscn' here

@export_group("War Council")
@export var container_raid_command: Control 
@export var btn_collapse_toggle: Button
@export var label_authority: Label
@export var label_bondi_count: Label
@export var container_warbands: VBoxContainer
@export var btn_world_map: Button
@export var btn_proceed: Button

@export_group("Project Management")
@export var btn_tab_construction: Button
@export var btn_tab_completed: Button
@export var grid_active_projects: GridContainer
@export var grid_completed_buildings: GridContainer

# --- Internal References ---
@onready var background_layer: TextureRect = $BackgroundLayer
@onready var layout_root: VBoxContainer = $LayoutRoot

# Runtime generated nodes
var btn_restore_ui: Button 
var allocation_instance: Control

# --- State ---
var is_raid_panel_open: bool = true
var _has_activated: bool = false

func _ready() -> void:
	visible = false
	
	_setup_mouse_filters()
	_setup_signals()
	_connect_buttons()
	_create_restore_button()
	
	if DynastyManager.current_season == DynastyManager.Season.SUMMER:
		_activate_summer_ui()
	
	_set_project_view(true)

func _create_restore_button() -> void:
	btn_restore_ui = Button.new()
	btn_restore_ui.text = "Open Summer Council"
	btn_restore_ui.visible = false
	btn_restore_ui.top_level = true
	btn_restore_ui.anchor_left = 1.0
	btn_restore_ui.anchor_top = 1.0
	btn_restore_ui.anchor_right = 1.0
	btn_restore_ui.anchor_bottom = 1.0
	btn_restore_ui.offset_left = -220
	btn_restore_ui.offset_top = -60
	btn_restore_ui.offset_right = -20
	btn_restore_ui.offset_bottom = -20
	btn_restore_ui.pressed.connect(_on_restore_ui_pressed)
	add_child(btn_restore_ui)

func _connect_buttons() -> void:
	if btn_collapse_toggle: btn_collapse_toggle.pressed.connect(_toggle_raid_panel)
	if btn_world_map: btn_world_map.pressed.connect(func(): EventBus.scene_change_requested.emit(GameScenes.WORLD_MAP)) 
	if btn_proceed: btn_proceed.pressed.connect(_on_proceed_pressed)
	if btn_tab_construction: btn_tab_construction.pressed.connect(func(): _set_project_view(true))
	if btn_tab_completed: btn_tab_completed.pressed.connect(func(): _set_project_view(false))
	if btn_hide_ui: btn_hide_ui.pressed.connect(_on_hide_ui_pressed)
	if btn_manage_allocation: btn_manage_allocation.pressed.connect(_on_manage_allocation_pressed)

func _activate_summer_ui() -> void:
	visible = true
	_initial_refresh() 
	_has_activated = true
	Loggie.msg("Summer UI Activated").domain(LogDomains.UI).info()

func _setup_mouse_filters() -> void:
	self.mouse_filter = Control.MOUSE_FILTER_IGNORE
	if layout_root:
		layout_root.mouse_filter = Control.MOUSE_FILTER_IGNORE
		for child in layout_root.get_children():
			if child is Control: child.mouse_filter = Control.MOUSE_FILTER_IGNORE
	if background_layer:
		background_layer.mouse_filter = Control.MOUSE_FILTER_IGNORE

func _setup_signals() -> void:
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	EventBus.treasury_updated.connect(_on_treasury_updated)
	EventBus.population_changed.connect(_on_population_changed)
	EventBus.season_changed.connect(_on_season_changed)

# --- Visibility Toggles ---

func _on_hide_ui_pressed() -> void:
	if layout_root: layout_root.visible = false
	if background_layer: background_layer.visible = false
	if btn_restore_ui: btn_restore_ui.visible = true

func _on_restore_ui_pressed() -> void:
	if layout_root: layout_root.visible = true
	if background_layer: background_layer.visible = true
	if btn_restore_ui: btn_restore_ui.visible = false

# --- Data & Logic Initialization ---

func _initial_refresh() -> void:
	if not EconomyManager or not SettlementManager or not DynastyManager: return
	if not SettlementManager.current_settlement: return

	_update_resources(EconomyManager.get_projected_income()) 
	_update_authority_display()
	_update_forecast_warning()
	
	_refresh_labor_summary()
	_update_population_display()
	_refresh_building_grids()

func _refresh_labor_summary() -> void:
	if not SettlementManager.current_settlement: return
	
	var placed = SettlementManager.current_settlement.placed_buildings
	var pending = SettlementManager.current_settlement.pending_construction_buildings
	
	var current_farmers = 0
	for b in placed: current_farmers += b.get("assigned_workers", 0)
	
	var current_builders = 0
	for b in pending: current_builders += b.get("peasant_count", 0)
	
	# Raiders are tracked by EconomyManager/RaidManager usually, assuming 0 for now if not tracked in a var
	# If you have a variable for this, replace 0 below.
	var current_raiders = 0 
	
	if lbl_summary_farmers: lbl_summary_farmers.text = "Farming: %d" % current_farmers
	if lbl_summary_builders: lbl_summary_builders.text = "Construction: %d" % current_builders
	if lbl_summary_raiders: lbl_summary_raiders.text = "Raiders: %d" % current_raiders
	
	if label_bondi_count: label_bondi_count.text = str(current_raiders)

func _update_population_display() -> void:
	if not SettlementManager.current_settlement: return
	
	var total = SettlementManager.current_settlement.population_peasants
	var idle = SettlementManager.get_idle_peasants()
	
	if label_pop_total: label_pop_total.text = "Pop: %d" % total
	if label_pop_idle: label_pop_idle.text = "(%d Idle)" % idle
	
	var no_labor = idle <= 0
	label_pop_idle.modulate = Color.RED if no_labor else Color.WHITE

# --- External Allocation UI (Embedded) ---

func _on_manage_allocation_pressed() -> void:
	if not allocation_view_scene:
		Loggie.msg("Allocation Scene not assigned in SummerWorkspace_UI!").domain(LogDomains.UI).error()
		return
	
	# If panel exists, just toggle it
	if allocation_instance:
		allocation_instance.visible = not allocation_instance.visible
		return

	# Otherwise, instantiate it embedded in the column
	if not job_row_container:
		Loggie.msg("JobRowContainer not assigned! Cannot embed Allocation UI.").domain(LogDomains.UI).error()
		return
		
	allocation_instance = allocation_view_scene.instantiate()
	allocation_instance.name = "AllocationPanel"
	
	# Add to the VBox (JobRow_Container) so it sits below the button
	job_row_container.add_child(allocation_instance)
	
	# Configure layout to fit nicely in the column
	allocation_instance.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	allocation_instance.size_flags_vertical = Control.SIZE_SHRINK_BEGIN
	
	# Connect refresh signal
	if allocation_instance.has_signal("allocation_committed"):
		allocation_instance.allocation_committed.connect(_on_allocation_committed)

func _on_allocation_committed() -> void:
	Loggie.msg("Allocation Committed - Refreshing Dashboard").domain(LogDomains.UI).info()
	_initial_refresh()
	# Optional: Hide panel on commit?
	# if allocation_instance: allocation_instance.visible = false

# --- Projections & Forecasts ---

func _update_resources(treasury: Dictionary) -> void:
	if label_silver: label_silver.text = str(treasury.get("gold", 0))
	if label_food: label_food.text = str(treasury.get("food", 0))
	if label_wood: label_wood.text = str(treasury.get("wood", 0))

func _update_authority_display() -> void:
	if not DynastyManager.current_jarl: return
	var auth = DynastyManager.current_jarl.current_authority
	if label_authority: label_authority.text = "Authority: %d" % auth

func _update_forecast_warning() -> void:
	if not SettlementManager.current_settlement: return
	
	var forecast = EconomyManager.get_winter_forecast()
	var base_food_demand = forecast.get("food", 0)
	var current_food = SettlementManager.current_settlement.treasury.get("food", 0)
	
	if current_food < base_food_demand:
		texture_winter_warning.modulate = Color.RED
		texture_winter_warning.tooltip_text = "Deficit Predicted! Demand: %d" % base_food_demand
	else:
		texture_winter_warning.modulate = Color.GREEN
		texture_winter_warning.tooltip_text = "Winter Secure."

func _refresh_building_grids() -> void:
	if not grid_active_projects or not grid_completed_buildings: return
	
	for child in grid_active_projects.get_children(): child.queue_free()
	for child in grid_completed_buildings.get_children(): child.queue_free()
	
	# Completed
	for b in SettlementManager.current_settlement.placed_buildings:
		var lbl = Label.new()
		var b_name = "Building"
		if "resource_path" in b:
			var b_data = load(b["resource_path"])
			if b_data:
				b_name = b_data.display_name if "display_name" in b_data else b_data.resource_name
		
		lbl.text = str(b_name).capitalize() + " (Complete)"
		grid_completed_buildings.add_child(lbl)
		
	# Construction
	var pending = SettlementManager.current_settlement.get("pending_construction_buildings")
	if pending and pending is Array:
		for i in range(pending.size()):
			var b = pending[i]
			var lbl = Label.new()
			var b_name = "Site"
			if "resource_path" in b:
				var b_data = load(b["resource_path"])
				if b_data:
					b_name = b_data.display_name if "display_name" in b_data else b_data.resource_name
			
			var assigned = b.get("peasant_count", 0)
			var status_str = "(Paused)" if assigned == 0 else "(Active: %d)" % assigned
			if assigned == 0: lbl.modulate = Color.GRAY
			
			lbl.text = "%s %s" % [str(b_name).capitalize(), status_str]
			grid_active_projects.add_child(lbl)

# --- Commit / Phase Logic ---

func _on_proceed_pressed() -> void:
	SettlementManager._validate_employment_levels()
	Loggie.msg("Summer Ended. Proceeding to Autumn.").domain(LogDomains.GAMEPLAY).info()
	queue_free()

# --- Standard Handlers ---

func _on_settlement_loaded(_data) -> void:
	if visible: _initial_refresh()

func _on_treasury_updated(new_treasury: Dictionary) -> void:
	if visible: _update_resources(new_treasury); _update_forecast_warning()

func _on_population_changed() -> void:
	if visible: _initial_refresh()

func _on_season_changed(new_season: String) -> void:
	if new_season == "Summer": _activate_summer_ui()
	else: visible = false

func _toggle_raid_panel() -> void:
	is_raid_panel_open = !is_raid_panel_open
	var tween = create_tween()
	tween.set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT).set_parallel(true)
	if is_raid_panel_open:
		container_raid_command.show()
		tween.tween_property(container_raid_command, "modulate:a", 1.0, 0.15)
		btn_collapse_toggle.text = " War Council"
	else:
		tween.tween_property(container_raid_command, "modulate:a", 0.0, 0.1)
		tween.chain().tween_callback(container_raid_command.hide)
		btn_collapse_toggle.text = " War Council"

func _set_project_view(show_construction: bool) -> void:
	if grid_active_projects: grid_active_projects.visible = show_construction
	if grid_completed_buildings: grid_completed_buildings.visible = !show_construction
	if btn_tab_construction: btn_tab_construction.set_pressed_no_signal(show_construction)
	if btn_tab_completed: btn_tab_completed.set_pressed_no_signal(!show_construction)


--------------------------------------------------
FILE: res:///ui/seasonal/WinterCourtUI.gd
--------------------------------------------------
extends Control
class_name WinterCourtUI

## WinterCourtUI - The Seasonal Workspace
##
## Organizes the Winter phase into three persistent strata:
## 1. Burden (Deficits & Severity) - Read Only
## 2. Great Hall (Actions & Cards) - Interactive
## 3. Bloodline (Dynasty Context) - Read Only

# ------------------------------------------------------------------------------
# Dependencies
# ------------------------------------------------------------------------------
# Expected Singletons: WinterManager, DynastyManager, EventBus, Loggie, EconomyManager

# ------------------------------------------------------------------------------
# Configuration
# ------------------------------------------------------------------------------
@export_group("Great Hall Stratum")
## The list of Seasonal Cards available this winter (Assigned by Game Design or Manager)
@export var available_court_cards: Array[SeasonalCardResource] = []
## The UI Prefab for a single card (SeasonalCardUi.tscn)
@export var card_prefab: PackedScene

# ------------------------------------------------------------------------------
# Node References (Unique Names)
# ------------------------------------------------------------------------------
# Stratum I: Burden
@onready var severity_label: Label = %SeverityLabel
@onready var deficit_container: VBoxContainer = %DeficitContainer

# Stratum II: Great Hall
@onready var action_points_label: Label = %ActionPointsLabel
@onready var cards_container: HBoxContainer = %CardsContainer
@onready var end_winter_button: Button = %EndWinterButton

# Stratum III: Bloodline
@onready var jarl_name_label: Label = %JarlNameLabel
@onready var jarl_status_label: Label = %JarlStatusLabel
@onready var heir_status_label: Label = %HeirStatusLabel

# ------------------------------------------------------------------------------
# State
# ------------------------------------------------------------------------------
var current_ap: int = 0
var max_ap: int = 0

# ------------------------------------------------------------------------------
# Lifecycle
# ------------------------------------------------------------------------------
func _ready() -> void:
	# Default to hidden as this is a Phase-specific UI
	visible = false
	
	# Connect internal signals
	end_winter_button.pressed.connect(_on_end_winter_pressed)
	
	# Connect global signals
	EventBus.hall_action_updated.connect(_on_ap_updated)
	
	# Listen for season changes to toggle visibility
	# We check for the signal's existence for safety, assuming standard EventBus
	if EventBus.has_signal("season_changed"):
		EventBus.season_changed.connect(_on_season_changed)
	elif EventBus.has_signal("winter_started"): 
		# Fallback if specific signal is used instead of generic season change
		EventBus.winter_started.connect(func(): _on_season_changed("Winter"))

func _on_season_changed(new_season: String) -> void:
	if new_season == "Winter":
		show()
		setup_winter_view()
	else:
		hide()

func _on_ap_updated(new_amount: int) -> void:
	current_ap = new_amount
	# Update label
	_update_hall_ui()
	# Update card interactivity (affordability may have changed)
	_refresh_stratum_hall()

# ------------------------------------------------------------------------------
# Public API
# ------------------------------------------------------------------------------
## Main entry point called when the Winter Phase begins
func setup_winter_view() -> void:
	Loggie.msg("Initializing Winter Court UI Strata").domain(LogDomains.UI).info()
	
	# 1. Fetch Jarl Context & Sync AP
	var jarl: JarlData = DynastyManager.get_current_jarl()
	
	if jarl:
		# TRUST THE MANAGER: We do not recalculate actions here. 
		current_ap = jarl.current_hall_actions
		max_ap = jarl.max_hall_actions
	else:
		current_ap = 0
		max_ap = 0
	
	# 2. Refresh Strata
	_refresh_stratum_burden()
	_refresh_stratum_bloodline()
	_refresh_stratum_hall()
	
	# 3. Update Visuals
	_update_hall_ui()

# ------------------------------------------------------------------------------
# STRATUM I: The Burden of Winter (Read-Only)
# ------------------------------------------------------------------------------
func _refresh_stratum_burden() -> void:
	var report: Dictionary = WinterManager.winter_consumption_report
	
	# 1. Severity Display
	# Use Enum for robust checking (Fallback to NORMAL = 1 if missing)
	var severity_enum: int = report.get("severity_enum", 1) 
	var severity_name: String = report.get("severity_name", "NORMAL")
	
	severity_label.text = "Winter Severity: %s" % severity_name
	
	# Color code severity using Manager constants if available, or implied logic
	# Assuming WinterManager has the Enum: NORMAL=1, HARSH=2, MILD=0 (Example)
	# Safest approach is to check the integer values we expect or the name
	if severity_name == "HARSH": # Or WinterManager.WinterSeverity.HARSH
		severity_label.modulate = Color.RED
	elif severity_name == "MILD":
		severity_label.modulate = Color.GREEN
	else:
		severity_label.modulate = Color.WHITE

	# 2. Deficit Visualization
	# Clear previous
	for child in deficit_container.get_children():
		child.queue_free()
	
	var food_deficit: int = report.get("food_deficit", 0)
	var wood_deficit: int = report.get("wood_deficit", 0)
	
	# TRUST THE MANAGER: We do not calculate is_crisis_active locally.
	# We only visualize the deficits provided by the report.
	
	if food_deficit > 0:
		_add_burden_entry("Starvation Risk", "-%d Food" % food_deficit, Color.RED)
		
	if wood_deficit > 0:
		_add_burden_entry("Freezing Risk", "-%d Wood" % wood_deficit, Color.ORANGE)
		
	if food_deficit <= 0 and wood_deficit <= 0:
		_add_burden_entry("Supplies Sufficient", "Stockpiles Holding", Color.GREEN)

func _add_burden_entry(title: String, value: String, color: Color) -> void:
	var entry = Label.new()
	entry.text = "%s: %s" % [title, value]
	entry.modulate = color
	deficit_container.add_child(entry)

# ------------------------------------------------------------------------------
# STRATUM II: The Great Hall (Interactive)
# ------------------------------------------------------------------------------
func _refresh_stratum_hall() -> void:
	# Clean up existing cards
	for child in cards_container.get_children():
		child.queue_free()
	
	# SAFETY CHECK: Prevent runtime errors if prefab is missing
	if not card_prefab:
		Loggie.msg("WinterCourtUI: No card_prefab assigned!").domain(LogDomains.UI).warn()
		return

	# Instantiate Cards from the Exported Array
	for card_data in available_court_cards:
		var card_instance = card_prefab.instantiate()
		cards_container.add_child(card_instance)
		
		# Check complete affordability (AP + Resources)
		var can_afford = _can_afford(card_data)
		
		# Attempt to pass data to the card UI with affordability context
		if card_instance.has_method("setup"):
			# Assuming setup signature is setup(resource, is_clickable/can_afford)
			card_instance.setup(card_data, can_afford)
		elif "resource" in card_instance:
			card_instance.resource = card_data
			if "is_disabled" in card_instance:
				card_instance.is_disabled = not can_afford
		else:
			Loggie.msg("WinterCourtUI: Card prefab missing 'setup()' or 'resource' property").domain(LogDomains.UI).error()
			
		# Connect interaction signal
		if card_instance.has_signal("card_clicked"):
			card_instance.card_clicked.connect(_on_card_clicked)

func _can_afford(card: SeasonalCardResource) -> bool:
	# 1. Check AP
	if current_ap < card.cost_ap:
		return false
		
	# 2. Check Resources via EconomyManager
	var costs = {}
	if card.cost_gold > 0: costs["gold"] = card.cost_gold
	if card.cost_food > 0: costs["food"] = card.cost_food
	# Note: SeasonalCardResource currently doesn't have cost_wood defined in provided snippets, 
	# but if it did: if card.cost_wood > 0: costs["wood"] = card.cost_wood
	
	if not costs.is_empty():
		# Ensure EconomyManager has this method (See Adjustment 2)
		if EconomyManager.has_method("can_afford"):
			return EconomyManager.can_afford(costs)
		return false # Fail safe if manager is outdated
	
	return true

func _update_hall_ui() -> void:
	action_points_label.text = "Dynastic Attention: %d / %d" % [current_ap, max_ap]
	
	# Update Button State based on Manager Truth
	if WinterManager.winter_crisis_active:
		end_winter_button.text = "Face the Crisis..."
		end_winter_button.modulate = Color(1.0, 0.5, 0.5) # Reddish tint
	else:
		end_winter_button.text = "The Ice Melts..."
		end_winter_button.modulate = Color.WHITE

func _on_card_clicked(card: SeasonalCardResource) -> void:
	# DELEGATION: Ask Manager to perform action.
	# The Manager handles AP deduction, Resource granting, and Renown awards.
	var success: bool = WinterManager.play_seasonal_card(card)
	
	if success:
		Loggie.msg("Played Winter Card: %s" % card.display_name).domain(LogDomains.GAMEPLAY).info()
		# UI refresh happens automatically via global signals 
		# (EventBus.hall_action_updated -> _on_ap_updated)
	else:
		Loggie.msg("Failed to play card (Cost or State invalid)").domain(LogDomains.UI).warn()

# ------------------------------------------------------------------------------
# STRATUM III: The Bloodline Thread (Read-Only)
# ------------------------------------------------------------------------------
func _refresh_stratum_bloodline() -> void:
	var jarl: JarlData = DynastyManager.get_current_jarl()
	
	if not jarl:
		jarl_name_label.text = "Interregnum (No Jarl)"
		jarl_status_label.text = "The throne is empty."
		heir_status_label.text = ""
		return
		
	# 1. Jarl Details
	jarl_name_label.text = "%s (Age %d)" % [jarl.display_name, jarl.age]
	
	# 2. Status Construction (Priority Order)
	var status_text: String = "Vigorous"
	var status_color: Color = Color.GREEN
	
	if jarl.is_in_exile:
		status_text = "In Exile"
		status_color = Color.GRAY
	elif jarl.is_wounded:
		status_text = "Wounded"
		status_color = Color.ORANGE
	elif jarl.age > 60:
		status_text = "Frail"
		status_color = Color.YELLOW
		
	jarl_status_label.text = status_text
	jarl_status_label.modulate = status_color
	
	# 3. Heir Context
	var heir_count: int = jarl.get_available_heir_count()
	if heir_count == 0:
		heir_status_label.text = "Succession: DANGEROUS (No Heirs)"
		heir_status_label.modulate = Color.RED
	elif heir_count == 1:
		heir_status_label.text = "Succession: Fragile (1 Heir)"
		heir_status_label.modulate = Color.YELLOW
	else:
		heir_status_label.text = "Succession: Secure (%d Heirs)" % heir_count
		heir_status_label.modulate = Color.GREEN

# ------------------------------------------------------------------------------
# Interaction
# ------------------------------------------------------------------------------
func _on_end_winter_pressed() -> void:
	if WinterManager.winter_crisis_active:
		Loggie.msg("Winter ended with unresolved crisis").domain(LogDomains.GAMEPLAY).warn()
		# This would trigger the specific crisis resolution modal
		EventBus.winter_crisis_triggered.emit()
	else:
		Loggie.msg("Winter passed peacefully").domain(LogDomains.GAMEPLAY).info()
		
		# Request the WinterManager to close the phase. 
		# WinterManager.end_winter_phase() calls DynastyManager.end_winter_cycle_complete() internally.
		WinterManager.end_winter_phase()


--------------------------------------------------
FILE: res:///ui/seasonal/WinterCourt_UI.tscn
--------------------------------------------------
[gd_scene load_steps=7 format=3 uid="uid://dnndecgdkcffm"]

[ext_resource type="Script" uid="uid://gvajp31vuy31" path="res://ui/seasonal/WinterCourtUI.gd" id="1_cn012"]
[ext_resource type="Script" uid="uid://cni5gdnpbb1v2" path="res://data/resources/SeasonalCardResource.gd" id="2_agvwj"]
[ext_resource type="PackedScene" uid="uid://d0px2w8n5r1lv" path="res://ui/seasonal/SeasonalCardUi.tscn" id="2_xo3mn"]
[ext_resource type="Resource" uid="uid://dg10eqygin8xg" path="res://data/resources/Winter Cards/Card_Winter_Feast.tres" id="3_q5t2d"]
[ext_resource type="Resource" uid="uid://dcppndmvmf63e" path="res://data/resources/Winter Cards/Card_Winter_Recruit.tres" id="4_4y4fd"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_burden"]
bg_color = Color(0.12, 0.15, 0.2, 0.9)
border_width_bottom = 2
border_color = Color(0.3, 0.4, 0.5, 1)

[node name="WinterCourtUI" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_cn012")
available_court_cards = Array[ExtResource("2_agvwj")]([ExtResource("3_q5t2d"), ExtResource("4_4y4fd")])
card_prefab = ExtResource("2_xo3mn")

[node name="Background" type="Panel" parent="."]
self_modulate = Color(0.16, 0.22, 0.3, 0.98)
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="MainLayout" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 10

[node name="Stratum1_Burden" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
theme_override_styles/panel = SubResource("StyleBoxFlat_burden")

[node name="Margin" type="MarginContainer" parent="MainLayout/Stratum1_Burden"]
layout_mode = 2
theme_override_constants/margin_left = 30
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 30
theme_override_constants/margin_bottom = 10

[node name="HBox" type="HBoxContainer" parent="MainLayout/Stratum1_Burden/Margin"]
layout_mode = 2
theme_override_constants/separation = 40

[node name="SeverityLabel" type="Label" parent="MainLayout/Stratum1_Burden/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_colors/font_color = Color(0.9739297, 0.96263725, 0.95415837, 1)
theme_override_font_sizes/font_size = 20
text = "Winter Severity: Normal"

[node name="VSeparator" type="VSeparator" parent="MainLayout/Stratum1_Burden/Margin/HBox"]
layout_mode = 2

[node name="DeficitContainer" type="VBoxContainer" parent="MainLayout/Stratum1_Burden/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
alignment = 1

[node name="Stratum2_Hall" type="PanelContainer" parent="MainLayout"]
layout_mode = 2
size_flags_vertical = 3

[node name="VBox" type="VBoxContainer" parent="MainLayout/Stratum2_Hall"]
layout_mode = 2
theme_override_constants/separation = 15
alignment = 1

[node name="ActionPointsLabel" type="Label" parent="MainLayout/Stratum2_Hall/VBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.7, 0.5, 1)
theme_override_font_sizes/font_size = 28
text = "Dynastic Attention: 2 / 2"
horizontal_alignment = 1

[node name="CardScroll" type="ScrollContainer" parent="MainLayout/Stratum2_Hall/VBox"]
layout_mode = 2
size_flags_vertical = 3
vertical_scroll_mode = 3

[node name="Centerer" type="CenterContainer" parent="MainLayout/Stratum2_Hall/VBox/CardScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CardsContainer" type="HBoxContainer" parent="MainLayout/Stratum2_Hall/VBox/CardScroll/Centerer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_constants/separation = 25
alignment = 1

[node name="Stratum3_Bloodline" type="PanelContainer" parent="MainLayout"]
layout_mode = 2

[node name="Margin" type="MarginContainer" parent="MainLayout/Stratum3_Bloodline"]
layout_mode = 2
theme_override_constants/margin_left = 30
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 30
theme_override_constants/margin_bottom = 10

[node name="HBox" type="HBoxContainer" parent="MainLayout/Stratum3_Bloodline/Margin"]
layout_mode = 2
theme_override_constants/separation = 40
alignment = 1

[node name="JarlNameLabel" type="Label" parent="MainLayout/Stratum3_Bloodline/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
text = "Jarl Bjorn (Age 54)"

[node name="JarlStatusLabel" type="Label" parent="MainLayout/Stratum3_Bloodline/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
text = "Vigorous"

[node name="VSeparator" type="VSeparator" parent="MainLayout/Stratum3_Bloodline/Margin/HBox"]
layout_mode = 2

[node name="HeirStatusLabel" type="Label" parent="MainLayout/Stratum3_Bloodline/Margin/HBox"]
unique_name_in_owner = true
layout_mode = 2
text = "Succession Secure"

[node name="BottomBar" type="MarginContainer" parent="MainLayout"]
layout_mode = 2
theme_override_constants/margin_left = 50
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 50
theme_override_constants/margin_bottom = 20

[node name="EndWinterButton" type="Button" parent="MainLayout/BottomBar"]
unique_name_in_owner = true
custom_minimum_size = Vector2(0, 50)
layout_mode = 2
theme_override_font_sizes/font_size = 18
text = "The Ice Melts..."


--------------------------------------------------
FILE: res:///ui/themes/VikingDynastyTheme.tres
--------------------------------------------------
[gd_resource type="Theme" load_steps=14 format=3 uid="uid://63duv3n1vwhg"]

[ext_resource type="Texture2D" uid="uid://c1wkuqa0tk15t" path="res://ui/assets/wood_bg.png" id="1_6a3oa"]
[ext_resource type="FontFile" uid="uid://dlawpo1w7brpl" path="res://assets/fonts/UncialAntiqua-Regular.ttf" id="1_ox2i8"]
[ext_resource type="Texture2D" uid="uid://cnp6fol6lgqv2" path="res://ui/assets/parchment_bg.png" id="2_0uau4"]
[ext_resource type="FontFile" uid="uid://b32srse7cc2qj" path="res://assets/fonts/CrimsonText-Regular.ttf" id="4_ek7ex"]
[ext_resource type="Texture2D" uid="uid://duvteutwnf4kf" path="res://ui/assets/resource_tag.png" id="4_jrdf5"]
[ext_resource type="Texture2D" uid="uid://cki8xtuhom1v" path="res://ui/assets/tooltip_bg.png" id="5_jrdf5"]

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_2hruv"]
content_margin_left = 10.0
content_margin_top = 5.0
content_margin_right = 10.0
content_margin_bottom = 5.0
texture = ExtResource("1_6a3oa")
modulate_color = Color(0.5, 0.5, 0.5, 1)

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_jgwtn"]
content_margin_left = 10.0
content_margin_top = 5.0
content_margin_right = 10.0
content_margin_bottom = 5.0
texture = ExtResource("1_6a3oa")
modulate_color = Color(1.2, 1.2, 1.2, 1)

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_cqbx0"]
content_margin_left = 10.0
content_margin_top = 5.0
content_margin_right = 10.0
content_margin_bottom = 5.0
texture = ExtResource("1_6a3oa")

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_vt14t"]
content_margin_left = 10.0
content_margin_top = 5.0
content_margin_right = 10.0
content_margin_bottom = 5.0
texture = ExtResource("1_6a3oa")
modulate_color = Color(0.8, 0.8, 0.8, 1)

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_6ali3"]
content_margin_left = 20.0
content_margin_top = 20.0
content_margin_right = 20.0
content_margin_bottom = 20.0
texture = ExtResource("2_0uau4")
axis_stretch_horizontal = 1
axis_stretch_vertical = 1

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_6c0re"]
content_margin_left = 12.0
content_margin_top = 8.0
content_margin_right = 12.0
content_margin_bottom = 4.0
texture = ExtResource("4_jrdf5")

[sub_resource type="StyleBoxTexture" id="StyleBoxTexture_yurw3"]
content_margin_left = 10.0
content_margin_top = 5.0
content_margin_right = 10.0
content_margin_bottom = 5.0
texture = ExtResource("5_jrdf5")

[resource]
default_font = ExtResource("4_ek7ex")
default_font_size = 20
Button/colors/font_color = Color(0.9607843, 0.9019608, 0.827451, 1)
Button/colors/font_hover_color = Color(1, 1, 1, 1)
Button/font_sizes/font_size = 20
Button/fonts/font = ExtResource("1_ox2i8")
Button/styles/disabled = SubResource("StyleBoxTexture_2hruv")
Button/styles/hover = SubResource("StyleBoxTexture_jgwtn")
Button/styles/normal = SubResource("StyleBoxTexture_cqbx0")
Button/styles/pressed = SubResource("StyleBoxTexture_vt14t")
HeaderLabel/colors/font_color = Color(0.16862746, 0.13333334, 0.105882354, 1)
HeaderLabel/font_sizes/font_size = 24
HeaderLabel/fonts/font = ExtResource("1_ox2i8")
Label/colors/font_color = Color(0.16862746, 0.13333334, 0.105882354, 1)
PanelContainer/styles/panel = SubResource("StyleBoxTexture_6ali3")
ResourceLabel/colors/font_color = Color(0.9607843, 0.9019608, 0.827451, 1)
ResourceLabel/font_sizes/font_size = 24
ResourceLabel/fonts/font = ExtResource("1_ox2i8")
ResourceLabel/styles/normal = SubResource("StyleBoxTexture_6c0re")
RichTextLabel/colors/default_color = Color(0.16862746, 0.13333334, 0.105882354, 1)
TooltipLabel/colors/font_color = Color(1, 1, 1, 1)
TooltipLabel/font_sizes/font_size = 18
TooltipPanel/styles/panel = SubResource("StyleBoxTexture_yurw3")

