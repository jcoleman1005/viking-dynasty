GDD v1.77 (Phase 3 Planned)

Viking Dynasty

1. High-Level Concept & Vision

Viking Dynasty is a strategy game that blends the dynastic ambition and grand strategy of Crusader Kings with the tactical, real-time battles of Age of Empires II.

Players will manage a Viking dynasty, not just a single character. They will forge alliances, declare wars, and manage their growing family on a strategic world map (the Macro layer). When battles occur or raids are launched, the game will transition into a real-time strategy mission (the Micro layer). The bridge between these two layers is the player's persistent, grid-based Settlement, which they will build, upgrade, and defend.

The core tension is balancing the long-term needs of your dynasty (geopolitics, heirs) with the immediate, visceral needs of combat (resources, unit control), all while protecting your home from rival Jarls.

Target Audience: Players who enjoy deep strategic systems (e.g., Paradox titles) but also crave tactical, skill-based RTS combat (e.g., Age of Empires, Company of Heroes).

Genre: Grand Strategy / Real-Time Strategy (RTS) Hybrid.

Theme: Viking Age, focusing on the grit, ambition, and legacy of a Norse dynasty.

2. Core Gameplay Loop: The Three Layers

The gameplay is built on three interconnected layers: the Macro (Dynasty), the Micro (RTS), and the Bridge (Settlement).

2.A. The Macro (Dynasty Layer)

This is the "Crusader Kings" layer. It is the top-level grand strategy map of Scandinavia and beyond.

Gameplay: Turn-based or pausable real-time.

Player Actions: Managing family and heirs, diplomacy with AI Jarls, managing traits and succession, triggering events, and directing armies on a geopolitical map.

Consequence: Declaring war on a rival Jarl (Macro) triggers an offensive "Micro" mission. A rival attacking the player triggers a defensive "Micro" mission.

2.B. The Micro (RTS Layer)

This is the "Age of Empires" layer. It is the real-time, grid-based combat mission.

Gameplay: Real-time strategy.

Player Actions: Commanding units, using special abilities, and achieving mission objectives (e.g., "Destroy the enemy's Great Hall," "Survive for 10 minutes").

Consequence: Winning a battle (Micro) results in loot and prestige (Macro). Losing a defensive battle (Micro) results in your Settlement being "Sacked" (Bridge).

2.C. The Bridge (Settlement Layer)

This is the player's persistent home base, which connects the two layers.

Gameplay: Grid-based city-builder (e.g., RimWorld, Stronghold).

Player Actions: Placing buildings, upgrading structures, assigning workers, and managing resources.

Consequence: The layout of your Settlement becomes the map for all defensive "Micro" missions. A well-designed base provides a massive tactical advantage.

3. The Player's Journey (NEW)

This section describes the intended narrative and emotional arc for the player, serving as a "North Star" for development.

First 5 Minutes (The Builder): The player starts as a new Jarl with only a Great Hall on a patch of land. They are guided to build their first economic buildings (e.g., Lumber Yard) and a simple wall. The feeling is one of fresh starts and potential.

First 30 Minutes (The Defender): The player has a small, functional settlement with a basic economy. They are now facing their first "Sacked" attack, where a small rival band attacks. The goal is to survive and understand the importance of defensive layouts. The feeling is one of vulnerability and the drive to protect what's theirs.

First Hour (The Raider): Having survived and invested in their economy, the player has now built a small garrison. They launch their first "Offensive Raid" (Phase 3) on a nearby camp. The feeling is one of empowerment, agency, and seeing the direct payoff for their investments as they return with loot.

Long-Term Arc (The Jarl): The player is now balancing all three layers: expanding their settlement, launching bigger raids for more loot, and engaging in the high-level politics and family management of the Macro layer. The feeling is one of dynastic ambition and strategic depth.

4. Key Features

(This section will be expanded as we implement Phases 3-4)

Build a persistent settlement and manage its 'Raid-and-Spend' economy.

(Future: Phase 3) Command your warband in tactical RTS combat to raid rival settlements.

(Future: Phase 4) Guide your dynasty through generations of war, politics, and intrigue.

5. Technical Stack & Philosophy

Engine: Godot 4.4

Scripting: GDScript

Architecture:

Data-Driven: All game stats (unit HP, building cost, etc.) must be custom Resource files (.tres) to empower design and balancing without code changes.

Singleton (Autoload) Managers: Global systems (EventBus, SettlementManager) are implemented as Autoloads for easy access and clear separation of concerns.

Event Bus: All communication between major, decoupled systems (e.g., UI, AI, Game Loop) must go through the EventBus singleton. No direct references.

Finite State Machines (FSMs): All entities with 3+ states (like AI units) must use an FSM.

5.A. Exported Resources Implementation (GDD Reference)

This section details how the "Data-Driven" philosophy is implemented using exported variables in key scripts. This allows designers to configure, balance, and test content directly in the Godot inspector without code changes.

1. StorefrontUI (res://ui/StorefrontUI.gd)

@export var available_buildings: Array[BuildingData] - Buildings available for purchase

@export var available_units: Array[UnitData] - Units available for recruitment

@export var defaulttreasurydisplay: Dictionary - Default treasury values when no settlement loaded

@export var autoloadunitsfromdirectory: bool - Whether to auto-scan unit directory

Usage: Configure shop inventory and behavior per scene. Enables A/B testing different building sets.

2. SettlementBridge (res://scripts/buildings/SettlementBridge.gd)

@export var homebasedata: SettlementData - Settlement data for the level

@export var testbuildingdata: BuildingData - Building spawned on click (testing)

@export var raider_scene: PackedScene - Enemy unit scene for testing combat

@export var welcomepopupscene: PackedScene - Popup UI scene for payouts

Usage: Configure different settlements per level. Customize enemy types and UI components.

3. RaidMission (res://scenes/missions/RaidMission.gd)

@export var enemybasedata: SettlementData - Enemy settlement to raid

@export var defaultenemybase_path: String - Fallback enemy base path

@export var victorybonusloot: Dictionary - Extra loot for mission completion

@export var playerspawnformation: Dictionary - Unit formation settings

@export var mission_difficulty: float - Difficulty multiplier

@export var allow_retreat: bool - Whether players can retreat

Usage: Design custom raid missions with different enemy bases, difficulty, and rewards.

Benefits for Game Design:

Designer Control - Non-programmers can configure game content

Easy Balancing - Tweak values without code changes

A/B Testing - Compare different configurations easily

Reusable Scenes - Same scene, different configurations

Rapid Iteration - Quick testing of new content combinations

Inspector Usage:

Empty exports = Uses default/fallback values (current behavior maintained)

Assigned exports = Uses custom inspector values

Drag & Drop = Assign .tres resources directly from FileSystem dock

Create New = Use inspector dropdown to create new resources inline

This system provides maximum flexibility while maintaining backward compatibility with existing functionality.

6. Art Style & Mood

(Placeholder section for future development)

7. Core Entities & Data Structures

7.A. Overview

All game entities are defined by a Resource script (.gd) and then implemented as one or more .tres files.

7.B. BuildingData.gd (AMENDED)

Defines the stats for all static structures in the game.

Path: res://data/buildings/BuildingData.gd

Extends: Resource

class_name BuildingData

Key Properties:

@export var display_name: String  (e.g., "Stone Wall")
@export var scene_to_spawn: PackedScene  (The .tscn file to instance)
@export var icon: Texture2D  (For the build menu)
@export var build_cost: Dictionary  (e.g., {"stone": 25})
@export var max_health: int
@export var blocks_pathfinding: bool  (If true, updates the A* grid)
@export var grid_size: Vector2i  (Size in grid cells)
@export_group("Defensive Stats")
@export var is_defensive_structure: bool
@export var attack_damage: int
@export var attack_range: float
@export var attack_speed: float


7.C. UnitData.gd (AMENDED)

Defines the stats for all mobile units in the game.

Path: res://data/units/UnitData.gd

Extends: Resource

class_name UnitData

Key Properties:

@export var display_name: String  (e.g., "Viking Raider")
@export var scene_to_spawn: PackedScene
@export var icon: Texture2D  (For the training menu)
@export var spawn_cost: Dictionary (e.g., {"food": 50, "gold": 20})
@export_group("Combat Stats")
@export var max_health: int
@export var move_speed: float
@export var attack_damage: int
@export var attack_range: float
@export var attack_speed: float


7.D. EconomicBuildingData.gd (NEW)

Extends BuildingData with properties for resource generation.

Path: res://data/buildings/EconomicBuildingData.gd

Extends: BuildingData

class_name EconomicBuildingData

Key Properties:

@export_group("Economic Stats")
## The type of resource this building generates (e.g., "wood", "food", "gold").
@export var resource_type: String = "wood"

## The fixed amount of resources generated after each successful attack.
@export var fixed_payout_amount: int = 10

## The maximum amount of the resource that can be stored before collection.
@export var storage_cap: int = 100


7.E. SettlementData.gd (NEW)

A Resource file that holds all persistent data for a single settlement. This allows for scalability (e.g., multiple colonies).

Path: res://data/settlements/SettlementData.gd

Extends: Resource

class_name SettlementData

Key Properties:

## Stores current "Loot" resources (e.g., {"gold": 1000, "wood": 500})
@export var treasury: Dictionary

## Stores all placed buildings for persistence.
## Array of Dictionaries: [{"resource_path": "res://...", "grid_position": Vector2i(x, y)}]
@export var placed_buildings: Array[Dictionary]

## Stores all recruited units available for deployment.
## Array of resource paths: ["res://data/units/Unit_Axeman.tres", ...]
@export var garrisoned_units: Array[String] 
## Note: Storing paths (String) is often safer for persistence than the full resource.
## We will confirm and finalize this during Phase 3 implementation.


8. Core Implemented Systems

This section describes the major gameplay loops and architectural patterns that are currently implemented and functional in the game.

8.A. "Sacked" Loop (Defense-First)

The "Defense-First" MVP loop is complete and functional.

Systems: SettlementManager, AStarGrid2D Pathfinding, EventBus, FSM.

Core Loop:

SettlementBridge.gd loads home_base.tres (a SettlementData resource).

SettlementManager.load_settlement() reads this data, instantiates the "Great Hall" and any other saved buildings, and configures the AStarGrid2D.

Player can place "Stone Wall" obstacles.

Player clicks "Start Attack," which spawns an enemy "Viking Raider".

Raider AI (UnitFSM) paths around walls to the Great Hall.

Raider attacks and destroys the Hall.

Hall's building_destroyed signal is caught by SettlementBridge.gd.

UI shows "SACKED" message and a RestartButton.

8.B. Core Architecture (Refactored)

This section defines the current architecture after the Phase 2 refactor, which supports the economy and future scalability. The monolithic SettlementManager has been split.

Persistent Data Resource (SettlementData.gd)

This is a Resource script (.gd) that holds all persistent data for one settlement.

A .tres file (e.g., home_base.tres) represents a unique, saveable settlement.

It is responsible for storing:

treasury: Dictionary (e.g., {"gold": 1000, "wood": 10})

placed_buildings: Array[Dictionary]

garrisoned_units: Array[String]

Singleton Runtime Manager (SettlementManager.gd)

This is the Autoload singleton. It is a runtime manager and holds no persistent data itself.

Responsibilities:

Load/Save: Loads a SettlementData resource (e.g., load_settlement(home_base_data)) and saves it (save_settlement()).

Pathfinding: Manages the global AStarGrid2D and provides get_astar_path().

Runtime Logic: Processes runtime requests (e.g., attempt_purchase, calculate_payout, add_unit_to_garrison).

Scene Management: Holds the BuildingContainer node to parent all instanced buildings.

Conductor Scene (SettlementBridge.gd)

This is the main "Conductor" scene.

Responsibilities:

Telling SettlementManager which settlement to load.

Managing the UI layer (Storefront, Payout Popup).

Spawning units (both enemy Raiders for defense and player units for offense).

Connecting signals (e.g., great_hall.building_destroyed).

8.C. "Reinvestment" Economy (Phase 2)

This implements the core "Raid-and-Spend" economic engine.

Pillar 1: The 'Treasury' & 'Storefront' (Implemented)

Treasury: The treasury Dictionary in SettlementData.gd tracks all "Loot" resources (Gold, Wood, Stone, etc.).

Storefront: Storefront_UI.tscn allows the player to spend Treasury resources.

Build Cost: All buildable items (buildings, units) have their cost defined as a Dictionary in their data resource (e.g., build_cost = {"stone": 25} or spawn_cost = {"food": 50, "gold": 10}). SettlementManager.attempt_purchase() handles this logic.

Pillar 2: The 'Active' Loop (Raiding for Loot) (Partial)

Concept: This is the primary income generator, designed to connect to the Phase 3 (Offensive Raids) loop.

Function: Upon completing an "Offensive Raid" (Phase 3), the player will be awarded a lump sum of Loot. For now, this is simulated with a debug key.

Pillar 3: The 'Reinvestment' Loop (Implemented)

Concept: This is the secondary economic loop. Players spend loot on "Economic Buildings" (e.g., LumberYard.tres) as a long-term investment.

Function (The "Fixed" Payout): These buildings do not generate resources passively over time. Instead, they provide a fixed, lump-sum resource payout after each attack mission. This "one attack = one payout" model respects the player's effort and is highly predictable.

Payout Mechanism:

The player returns to the SettlementBridge scene (simulating a return from a raid).

SettlementBridge.gd calls SettlementManager.calculate_payout().

This function iterates all EconomicBuildingData buildings owned by the player and sums their fixed_payout_amount property.

The total payout is displayed on the WelcomeHome_Popup.tscn.

The player must click "Collect" to deposit the resources into the Treasury, providing a tangible feedback loop.

Strategic Layer: This creates the central economic choice:

Spend Loot: On immediate military power (e.g., better troops for the next raid).

Invest Loot: On economic buildings for long-term, compounding resource growth.

9. Development Roadmap

This section outlines the next major phases of development, building upon the implemented systems.

9.A. Phase 3: The "Offensive Raid" (The 'Micro' Loop) (Next)

1. Spirit & Core Concept

Phase Spirit: "From Builder to Raider"

This phase is the direct payoff for all the player's work in Phase 2. If Phase 2 was about strategic, long-term investment, Phase 3 is about immediate, aggressive action.

This is where we build the "active" half of the RTS "Micro" layer. We are empowering the player with the agency they've been missing. They will transition from a reactive defender (in the MVP) to a proactive raider, taking direct control of a hand-picked army.

This phase is the primary "income generator" for the "Reinvestment Economy" (Phase 2, Pillar 3) and completes our core gameplay loop:
Spend Loot (Phase 2) -> Build Army (Phase 3) -> Go Raiding (Phase 3) -> Get Loot (Phase 2)

2. Goals & Key Pillars

The goal of this phase is to allow the player to recruit an army, deploy it on an offensive mission, and control it with standard RTS commands to win loot.

Pillar 1: The 'Garrison' (Army Creation)

This pillar connects the Phase 2 economy directly to the player's military.

Concept: The player needs to be able to spend their "Loot" to recruit units for their army. This system will reuse the "Storefront" architecture from Phase 2.

Architecture:

UI Extension: The Storefront_UI will be updated with a new "Recruit" or "Barracks" tab. This UI will read from a new set of UnitData.tres files (e.g., Axeman.tres, Archer.tres).

UnitData Update: The UnitData resource will be expanded to include a spawn_cost: Dictionary (e.g., {"gold": 50, "food": 25}). (Self-correction: This is already implemented per Section 7.C, so this is just confirming its use).

SettlementData Update: The SettlementData.gd resource will get a new variable: var garrisoned_units: Array[String]. (See Section 7.E).

The Loop: When the player "buys" an Axeman from the UI, the exact same attempt_purchase(cost) function from Phase 2 is called. On success, instead of placing a building, the Axeman.tres resource path is added to the garrisoned_units array via a new SettlementManager.add_unit_to_garrison(unit_path) function, and the settlement is saved.

Pillar 2: The 'RTS Controller' (Player Agency)

This is the core new technical system of Phase 3. It gives the player direct control over their units.

Concept: We will build a player-centric RTSController.gd script to handle classic real-time strategy inputs. This script will be active during the "Offensive Raid" mission.

Architecture:

Selection: The controller must handle multi-unit selection (click-and-drag box select) and single-unit selection (click). It will manage a var selected_units: Array of all currently selected units.

Commands (The "Smart" Right-Click): The controller will detect the right_mouse_click input and perform a "smart" command:

If Click on Ground: It will loop through all selected_units and tell their FSMs to move_to(target_position).

If Click on Enemy: It will loop through all selected_units and tell their FSMs to attack(target_enemy).

UnitFSM Refactor: The UnitFSM.gd (from the MVP) must be refactored. It can no longer just "seek the Great Hall." It will need new states: IDLE (waiting for a command), MOVING (following a player's move command), and ATTACKING (following a player's attack command).

Pillar 3: The 'Raid Mission' (Completing the Loop)

This pillar creates the mission structure that uses Pillars 1 & 2 to generate the "Loot" for Phase 2.

Concept: We will create the "Offensive Raid" mission loader. To avoid getting stuck on Phase 4, we will use a temporary WorldMap_Stub.tscn as a placeholder.

Architecture (The "Stub" Loader):

WorldMap_Stub.tscn: A new, simple scene containing a background image and buttons. One button will be "Raid: Nearby Monastery."

The "Raid Loader": Clicking the "Raid" button (likely on the SettlementBridge UI for now) triggers a new function. This function:
A. Loads the DefensiveMicro.tscn scene (the same one from the MVP).
B. Loads an enemy's SettlementData (e.g., monastery_base.tres) and uses your existing SettlementManager.load_settlement() to procedurally build their base.
C. Reads the player's home_base.tres garrisoned_units array and spawns all those units at a PlayerStartPosition node.
D. Attaches the RTSController.gd script to the player's camera.

The Payout: When the enemy's "Great Hall" is destroyed, its building_destroyed signal is caught by a new function, _on_raid_successful(). This function calculates a Loot payload (e.g., {"gold": 500, "food": 200}), adds it to the player's Treasury (using the deposit_resources() function from Phase 2), and returns the player to the SettlementBridge.tscn.

3. Verification & Test Plan

[ ] Test (Pillar 1): Can I go to the "Recruit" tab in my settlement, "buy" three Axemen, and verify that the home_base.tres file now contains three entries in its garrisoned_units array?

[ ] Test (Pillar 2): In a test scene with 3 allied units, can I "box select" all of them? Can I right-click the ground and have all 3 move to that position?

[ ] Test (Pillar 3): Can I click the "Raid" button? Does it correctly load the enemy base and spawn my 3 garrisoned Axemen?

[ ] Test (Full Loop): After destroying the enemy's Great Hall in the raid, am I returned to my SettlementBridge? Does my "Treasury" UI now show the correct loot (e.g., "Gold: +500")?

9.B. Phase 4: Integrate the "Macro" (The Dynasty Layer) (Future)

Goal: To build the "Crusader Kings" DNA that connects all the loops into a single, compelling narrative.

Key Features:

Dynasty & Trait System: Implement the family tree, character inheritance, and traits.

Geopolitical Map: Build the high-level map where the player interacts with other AI Jarls.

Event Triggers: A rival Jarl declaring war (Macro) will trigger the "Sacked" defensive loop (Micro). The player deciding to attack (Macro) will trigger the "Offensive Raid" loop (Micro).

Why last? This system provides the ultimate context, but it relies on the other two pillars (Economy and Combat) to have meaningful consequences.

10. Controls & UI/UX Philosophy (NEW)

This section defines the core principles for how the player interacts with each of the three layers.

Bridge Layer (Settlement):

Feel: Relaxed, strategic, "god-game" city builder.

Controls: 100% mouse-driven. Left-click to select from the UI, left-click to place on the grid, right-click to cancel placement. Camera is panned with WASD or middle-mouse drag.

UI: Non-intrusive. The "Storefront" is a modal window, not a persistent HUD, reinforcing that building is a deliberate, strategic choice, not a frantic, real-time action.

Micro Layer (RTS Combat):

Feel: Fast, responsive, tactical, and familiar.

Controls: Classic RTS scheme. Left-click to select, click-and-drag for box selection. Right-click is the "smart" command (move on ground, attack on enemy). Hotkeys for unit groups (Ctrl+1) will be essential.

UI: A minimal, persistent HUD is required here, showing selected unit(s), their HP, and any abilities. Must be readable at a glance.

Macro Layer (Dynasty Map):

Feel: Deliberate, thoughtful, "board game" or grand strategy.

Controls: Turn-based or pausable real-time. Entirely mouse-driven, interacting with menus, map provinces, and character portraits.

UI: Information-dense. The UI is the game. Heavy use of nested tooltips and clear iconography (e.g., Crusader Kings) to manage complex information (family trees, diplomacy, traits).
