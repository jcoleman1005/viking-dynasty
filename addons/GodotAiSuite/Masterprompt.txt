### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. Project Context`**: The technical project dump, including:
    *   `2.1. Project Settings`
    *   `2.2. Resource Files`
    *   `2.3. Scene Structures`
    *   `2.4. Codebase`

---
### **2. Project Context**

#### **2.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Viking Dynasty"
run/main_scene="uid://caqoqfrq0wwlq"
config/features=PackedStringArray("4.5", "GL Compatibility")

[autoload]

EventBus="*res://autoload/EventBus.gd"
SettlementManager="*res://autoload/SettlementManager.tscn"

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg")

[rendering]

renderer/rendering_method="gl_compatibility"
renderer/rendering_method.mobile="gl_compatibility"
--- END OF PROJECT SETTINGS ---

#### **2.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://data/buildings/Bldg_GreatHall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = 500
max_health = 50
grid_size = Vector2i(3, 2)
metadata/_custom_type_script = "uid://js4bbqgeyd6c"

--- RESOURCE: res://data/buildings/Bldg_Wall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0
metadata/_custom_type_script = "uid://js4bbqgeyd6c"

--- RESOURCE: res://data/units/Unit_Raider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=2 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_tcvvg"]

[resource]
script = ExtResource("1_tcvvg")
display_name = "Viking Raider"
metadata/_custom_type_script = "uid://cq155t20ujb2j"

--- RESOURCE: res://placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 32
height = 32
noise = SubResource("FastNoiseLite_cemhj")
--- END OF RESOURCE FILES ---

#### **2.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://autoload/SettlementManager.tscn ---
SettlementManager (Node)
> script: res://autoload/SettlementManager.gd
> scene: res://autoload/SettlementManager.tscn
> BuildingContainer (Node2D)

--- SCENE: res://main_test.tscn ---
Main Test (Node2D)
> scene: res://main_test.tscn

--- SCENE: res://scenes/buildings/Base_Building.tscn ---
Base_Building (StaticBody2D)
> script: res://data/buildings/Base_Building.gd
> scene: res://scenes/buildings/Base_Building.tscn
> Sprite2D (Sprite2D)
> > texture = res://placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/buildings/Base_Building.tscn::RectangleShape2D_b5w0v

--- SCENE: res://scenes/levels/DefensiveMicro.tscn ---
DefensiveMicro (Node2D)
> scene: res://scenes/levels/DefensiveMicro.tscn
> TileMap (TileMap)
> > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc

--- SCENE: res://scenes/levels/SettlementBridge.tscn ---
SettlementBridge (Node)
> script: res://scripts/buildings/SettlementBridge.gd
> scene: res://scenes/levels/SettlementBridge.tscn
> DefensiveMicro (Node2D)
>   scene: res://scenes/levels/DefensiveMicro.tscn
>   TileMap (TileMap)
>   > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
> UnitContainer (Node2D)
> UI (CanvasLayer)
>   Label (Label)
>   > offset_left = 19.0
>   > offset_top = 16.0
>   > offset_right = 328.0
>   > offset_bottom = 39.0
>   > text = "Click to build a Wall. Defend the Great Hall!"

--- SCENE: res://scenes/units/Base_Unit.tscn ---
Base_Unit (CharacterBody2D)
> script: res://scripts/units/Base_Unit.gd
> scene: res://scenes/units/Base_Unit.tscn
> Sprite2D (Sprite2D)
> > texture = res://placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/VikingRaider.tscn ---
VikingRaider (CharacterBody2D)
> script: res://scripts/units/VikingRaider.gd
> scene: res://scenes/units/VikingRaider.tscn
> data = res://data/units/Unit_Raider.tres
> Sprite2D (Sprite2D)
> > texture = res://placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
--- END OF SCENE STRUCTURES ---

#### **2.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://autoload/EventBus.gd ---
# res://autoload/EventBus.gd
#
# A global Singleton (Autoload) that acts as a central "switchboard"
# for decoupled signal communication between major systems.


extends Node

# Emitted by the UI, listened for by the SettlementManager.
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)

# --- ADDED ---
# Emitted by the SettlementManager when a wall is placed.
# Listened for by any unit's FSM to trigger a re-path.
signal pathfinding_grid_updated(grid_position: Vector2i)

--- SCRIPT: res://autoload/SettlementManager.gd ---
# res://autoload/SettlementManager.gd
#
# --- MODIFIED: Added GDD-required function 'update_building_status' ---


extends Node

var astar_grid: AStarGrid2D
@onready var building_container: Node2D = $BuildingContainer

const TILE_SIZE: int = 32
const GRID_WIDTH: int = 50
const GRID_HEIGHT: int = 30

func _ready() -> void:
	astar_grid = AStarGrid2D.new()
	EventBus.build_request_made.connect(place_building, CONNECT_DEFERRED)
	_initialize_grid()

func _exit_tree() -> void:
	if EventBus.is_connected("build_request_made", place_building):
		EventBus.build_request_made.disconnect(place_building)

func _initialize_grid() -> void:
	print("Initializing Settlement Grid...")
	var playable_rect := Rect2i(0, 0, GRID_WIDTH, GRID_HEIGHT)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(TILE_SIZE, TILE_SIZE)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar_grid.update()
	print("Settlement Grid Initialized: %d x %d" % [GRID_WIDTH, GRID_HEIGHT])

func place_building(building_data: BuildingData, grid_position: Vector2i) -> void:
	if not building_data or not building_data.scene_to_spawn:
		push_error("Build request failed: BuildingData or scene_to_spawn is null.")
		return
	
	print("Placing '%s' at grid position %s" % [building_data.display_name, grid_position])
	
	var new_building: BaseBuilding = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	
	var world_pos_top_left: Vector2 = Vector2(grid_position) * astar_grid.cell_size
	var half_cell_offset: Vector2 = astar_grid.cell_size / 2.0
	new_building.global_position = world_pos_top_left + half_cell_offset
	
	building_container.add_child(new_building)
	
	if building_data.blocks_pathfinding:
		# TODO: This should loop over the building's grid_size
		astar_grid.set_point_solid(grid_position, true)
		astar_grid.update()
		print("Updated A* grid. Point %s is now solid." % grid_position)
		EventBus.pathfinding_grid_updated.emit(grid_position)

# --- ADDED ---
# As required by GDD
func update_building_status(grid_position: Vector2i, new_status: String) -> void:
	"""
	Updates the status of a building in the settlement grid.
	This is the hook for the 'Macro' layer's save data.
	"""
	# For now, we just print. In the future, this would
	# update a dictionary or save file.
	print("SETTLEMENT_MANAGER: Building at %s status set to '%s'" % [grid_position, new_status])


func get_astar_path(start_pos: Vector2, end_pos: Vector2) -> PackedVector2Array:
	var start_id: Vector2i = Vector2i(start_pos / astar_grid.cell_size)
	var end_id: Vector2i = Vector2i(end_pos / astar_grid.cell_size)
	
	var world_path: PackedVector2Array = astar_grid.get_point_path(start_id, end_id)
	return world_path

--- SCRIPT: res://data/buildings/Base_Building.gd ---
# res://scenes/buildings/Base_Building.gd
#
# --- MODIFIED: Added 'building_destroyed' signal ---

class_name BaseBuilding
extends StaticBody2D

## This signal is emitted when health reaches zero.
## GDD Ref:
signal building_destroyed(building: BaseBuilding)

@export var data: BuildingData
var current_health: int = 100

func _ready() -> void:
	if not data:
		push_warning("BaseBuilding scene is missing its BuildingData resource.")
		return
	
	current_health = data.max_health

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been destroyed." % data.display_name)
	
	# --- ADDED ---
	# Emit the signal *before* queue_free() so listeners
	# can react before the node is deleted.
	building_destroyed.emit(self)
	
	queue_free()

--- SCRIPT: res://data/buildings/BuildingData.gd ---
# res://data/buildings/BuildingData.gd
#
# Defines the core data for any building in the game.
#
# --- MODIFIED: Added 'class_name BuildingData' ---

class_name BuildingData
extends Resource

## The name displayed in the UI (e.g., "Stone Wall", "Watchtower").
@export var display_name: String = "New Building"

## The scene that will be instanced when this building is placed.
@export var scene_to_spawn: PackedScene

## The icon shown in the build menu.
@export var icon: Texture2D

## The cost in 'Resources' (e.g., wood, gold) to build this.
@export var build_cost: int = 10

## The building's maximum hit points.
@export var max_health: int = 100

## If true, this building blocks enemy pathfinding.
@export var blocks_pathfinding: bool = true

## The size of the building on the AStarGrid2D.
@export var grid_size: Vector2i = Vector2i.ONE


@export_group("Defensive Stats")
## If true, this building can attack enemies (e.g., Watchtower).
@export var is_defensive_structure: bool = false

## Damage dealt per attack (if defensive).
@export var attack_damage: int = 5

## Range in pixels (if defensive).
@export var attack_range: float = 200.0

## Attacks per second (if defensive).
@export var attack_speed: float = 1.0

--- SCRIPT: res://data/units/UnitData.gd ---
# res://data/units/UnitData.gd
#
# Defines the core data for any unit in the game.
# This resource is used by Base_Unit.tscn to configure instances.
# GDD Ref: 7.C.1.b

class_name UnitData
extends Resource

## The name displayed in the UI (e.g., "Viking Raider").
@export var display_name: String = "New Unit"

## The scene that will be instanced when this unit is spawned.
@export var scene_to_spawn: PackedScene

## The icon shown in the training menu.
@export var icon: Texture2D

## The cost in 'Resources' to train this unit.
@export var spawn_cost: int = 25


@export_group("Combat Stats")
## The unit's maximum hit points.
@export var max_health: int = 50

## Movement speed in pixels per second.
@export var move_speed: float = 75.0

## Damage dealt per attack.
@export var attack_damage: int = 8

## Range in pixels. (e.g., 10 for melee, 300 for archer).
@export var attack_range: float = 10.0

## Attacks per second.
@export var attack_speed: float = 1.2

--- SCRIPT: res://scripts/ai/UnitFSM.gd ---
# res://scripts/ai/UnitFSM.gd
#
# --- MODIFIED: Implemented full ATTACK state logic ---

class_name UnitFSM

enum State { IDLE, MOVE, ATTACK }

# Unit References
var unit: BaseUnit
var attack_timer: Timer

# State Data
var current_state: State = State.IDLE
var path: Array = []

# Target Data
var target_position: Vector2 = Vector2.ZERO
var target_node: BaseBuilding = null # The building we want to attack

func _init(p_unit: BaseUnit, p_timer: Timer) -> void:
	unit = p_unit
	attack_timer = p_timer
	
	# Connect the timer's timeout signal to our attack function
	attack_timer.timeout.connect(_on_attack_timer_timeout)

func change_state(new_state: State) -> void:
	if current_state == new_state:
		return
	
	_exit_state(current_state)
	current_state = new_state
	_enter_state(current_state)

func _enter_state(state: State) -> void:
	match state:
		State.MOVE:
			recalculate_path()
		
		State.ATTACK:
			print("%s entering ATTACK state." % unit.data.display_name)
			# Set timer wait time based on unit's attack speed
			attack_timer.wait_time = 1.0 / unit.data.attack_speed
			attack_timer.start()
			# Attack immediately on entering state
			_on_attack_timer_timeout()

func _exit_state(state: State) -> void:
	match state:
		State.MOVE:
			path.clear()
		State.ATTACK:
			attack_timer.stop()

func recalculate_path() -> void:
	path = SettlementManager.get_astar_path(unit.global_position, target_position)
	if path.is_empty():
		print("Raider at %s failed to find a path to %s." % [unit.global_position, target_position])
		# If we can't find a path, check if we're already at the target
		if unit.global_position.distance_to(target_position) < (unit.data.attack_range + 16):
			change_state(State.ATTACK)
		else:
			change_state(State.IDLE)
	else:
		print("Raider found new path. Waypoints: %d" % path.size())

func update(delta: float) -> void:
	match current_state:
		State.IDLE:
			_idle_state(delta)
		State.MOVE:
			_move_state(delta)
		State.ATTACK:
			_attack_state(delta)

# --- State Logic Functions ---

func _idle_state(_delta: float) -> void:
	# In a full game, would look for a new target
	pass

func _move_state(delta: float) -> void:
	if path.is_empty():
		# Path is done, check if we're at the target
		if target_node and is_instance_valid(target_node):
			change_state(State.ATTACK)
		else:
			change_state(State.IDLE)
		return
	
	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	unit.move_and_slide()
	
	var arrival_radius: float = 8.0 
	if unit.global_position.distance_to(next_waypoint) < arrival_radius:
		path.pop_front()
		
	# Check if we've arrived at the final target
	if path.is_empty():
		if target_node:
			change_state(State.ATTACK)
		else:
			change_state(State.IDLE)
		
func _attack_state(_delta: float) -> void:
	# Check if target is still valid
	if not is_instance_valid(target_node):
		print("%s target destroyed. Returning to IDLE." % unit.data.display_name)
		change_state(State.IDLE)
		return
	
	# Check if target moved out of range (e.g., for moving targets)
	# For a building, this is less important, but good practice.
	if unit.global_position.distance_to(target_node.global_position) > unit.data.attack_range + 16:
		print("%s target moved out of range. Re-engaging." % unit.data.display_name)
		target_position = target_node.global_position
		change_state(State.MOVE)

# --- Signal Callback ---

func _on_attack_timer_timeout() -> void:
	"""
	This is called every time the AttackTimer finishes.
	"""
	if is_instance_valid(target_node):
		print("%s attacks %s!" % [unit.data.display_name, target_node.data.display_name])
		target_node.take_damage(unit.data.attack_damage)
	else:
		# Target was destroyed by something else
		change_state(State.IDLE)

--- SCRIPT: res://scripts/buildings/SettlementBridge.gd ---
# res://scripts/buildings/SettlementBridge.gd
#
# Main script for the settlement defense scene, now including unit spawning.
#
# --- MODIFIED: Fixed _ready() order-of-operations bug ---

extends Node

# Pre-load resources needed for testing
var test_building_data: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
var raider_scene: PackedScene = preload("res://scenes/units/VikingRaider.tscn")

@onready var defensive_micro: Node2D = $DefensiveMicro # Reference to the level instance

func _ready() -> void:
	spawn_raider_for_test()

func spawn_raider_for_test() -> void:
	# Spawn the raider
	var raider_instance = raider_scene.instantiate()
	
	# --- FIX ---
	# Add the child to the scene *FIRST*. This calls its _ready()
	# function and initializes the FSM.
	defensive_micro.add_child(raider_instance)
	
	# Now that it's in the scene, *THEN* set its position.
	raider_instance.global_position = Vector2(50, 50) 
	# --- END FIX ---
	
	print("TEST: Spawned Viking Raider at (50, 50).")


func _unhandled_input(event: InputEvent) -> void:
	# Left-click building placement test (from Task 3)
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed():
		
		if not test_building_data:
			push_error("Test data 'Bldg_Wall.tres' not found or invalid.")
			return

		var mouse_pos: Vector2 = get_viewport().get_mouse_position()
		var grid_pos: Vector2i = Vector2i(mouse_pos / SettlementManager.astar_grid.cell_size)
		
		# Emit the signal to place the wall
		EventBus.build_request_made.emit(test_building_data, grid_pos)
		
		get_viewport().set_input_as_handled()

--- SCRIPT: res://scripts/units/Base_Unit.gd ---
# res://scenes/units/Base_Unit.gd
#
# --- MODIFIED: Added AttackTimer reference ---

class_name BaseUnit
extends CharacterBody2D

@export var data: UnitData
var fsm: UnitFSM
var current_health: int = 50

# --- ADDED ---
@onready var attack_timer: Timer = $AttackTimer

func _ready() -> void:
	if not data:
		push_warning("BaseUnit scene is missing its BuildingData resource.")
		return
	
	current_health = data.max_health
	
	# --- MODIFIED ---
	# Pass the timer reference to the FSM
	fsm = UnitFSM.new(self, attack_timer)
	
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	if fsm and fsm.current_state == UnitFSM.State.MOVE:
		fsm.recalculate_path()

func _physics_process(delta: float) -> void:
	if fsm:
		fsm.update(delta)
	
	if not fsm or fsm.current_state != UnitFSM.State.MOVE:
		velocity = Vector2.ZERO
		move_and_slide()

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been killed." % data.display_name)
	queue_free()

--- SCRIPT: res://scripts/units/VikingRaider.gd ---
# res://scenes/units/VikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Removed test code, added 'set_attack_target' ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set both the node (for attacking) and position (for moving)
	fsm.target_node = target
	fsm.target_position = target.global_position
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVE)
	print("Viking Raider initialized and moving to target: %s" % target.data.display_name)
--- END OF CODEBASE ---

---
