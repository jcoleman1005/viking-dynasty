### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. Project Context`**: The technical project dump, including:
    *   `2.1. Project Settings`
    *   `2.2. Resource Files`
    *   `2.3. Scene Structures`
    *   `2.4. Codebase`

---
### **2. Project Context**

#### **2.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Viking Dynasty"
run/main_scene="uid://c53k15q2w8c1a"
config/features=PackedStringArray("4.5", "GL Compatibility")

[autoload]

EventBus="*res://autoload/EventBus.gd"
SettlementManager="*res://autoload/SettlementManager.gd"
PauseManager="*res://autoload/PauseManager.tscn"
DynastyManager="*res://autoload/DynastyManager.gd"
SceneManager="*res://autoload/SceneManager.tscn"

[editor]

naming/scene_name_casing=1
naming/script_name_casing=1

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg")

[input]

debug_time_travel="{\"deadzone\": 0.5, \"events\": [{\"physical_keycode\": 84, \"type\": \"key\"}]}"
ui_pause={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}

[plugins]

enemy_base_editor/enabled=true
--- END OF PROJECT SETTINGS ---

#### **2.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://assets/placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 100
height = 100
noise = SubResource("FastNoiseLite_cemhj")

--- RESOURCE: res://data/buildings/Bldg_Wall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=4 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Texture2D" uid="uid://csni4uyao275g" path="res://textures/placeholders/wall_stone_texture.png" id="1_n45a8"]
[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
building_texture = ExtResource("1_n45a8")
build_cost = {
"stone": 25
}
dev_color = Color(0.4, 0.4, 0.8, 1)
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/GreatHall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 100,
"wood": 250
}
max_health = 50
grid_size = Vector2i(4, 4)
is_player_buildable = true

--- RESOURCE: res://data/buildings/LumberYard.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://drx4sih8numo1"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="Texture2D" uid="uid://cvtmpipin3j4" path="res://textures/placeholders/lumber_mill_placeholder.png" id="1_plclm"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
display_name = "Lumber Yard"
scene_to_spawn = ExtResource("2_fghij")
building_texture = ExtResource("1_plclm")
build_cost = {
"wood": 50
}
max_health = 75
grid_size = Vector2i(2, 2)
is_player_buildable = true

--- RESOURCE: res://data/buildings/Monastery_Chapel.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b7p70u4vm3uem"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 25
storage_cap = 200
display_name = "Monastery Chapel"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 100,
"stone": 80,
"wood": 40
}
max_health = 120
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Granary.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bscr3flprg5ts"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "food"
fixed_payout_amount = 20
storage_cap = 300
display_name = "Monastery Granary"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 60,
"stone": 40,
"wood": 100
}
max_health = 90
grid_size = Vector2i(2, 3)

--- RESOURCE: res://data/buildings/Monastery_Library.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bfb0hbf1m2lgf"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 35
storage_cap = 250
display_name = "Monastery Library"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 150,
"stone": 60,
"wood": 80
}
max_health = 80
grid_size = Vector2i(3, 2)

--- RESOURCE: res://data/buildings/Monastery_Scriptorium.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b6dkpjrewc1q6"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 30
storage_cap = 180
display_name = "Monastery Scriptorium"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 120,
"stone": 30,
"wood": 90
}
max_health = 70
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Watchtower.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://ckedcnw210a8k"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Monastery Watchtower"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 80,
"stone": 120,
"wood": 60
}
max_health = 150
dev_color = Color(0.8, 0.2, 0.2, 1)
is_defensive_structure = true
attack_damage = 15
attack_range = 250.0
attack_speed = 1.5

--- RESOURCE: res://data/buildings/Player_Barracks.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=4 format=3 uid="uid://c0ih7mriv2h1g"]

[ext_resource type="Texture2D" uid="uid://csni4uyao275g" path="res://textures/placeholders/wall_stone_texture.png" id="1_e5dmt"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_n2ory"]
[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="3_yutc8"]

[resource]
script = ExtResource("3_yutc8")
display_name = "Barracks"
scene_to_spawn = ExtResource("2_n2ory")
building_texture = ExtResource("1_e5dmt")
build_cost = {
"stone": 50,
"wood": 100
}
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/Player_Farm.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://y7xhmemltm28"]

[ext_resource type="Texture2D" uid="uid://cvtmpipin3j4" path="res://textures/placeholders/lumber_mill_placeholder.png" id="1_lr1ah"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_mixjq"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="3_svyis"]

[resource]
script = ExtResource("3_svyis")
resource_type = "food"
fixed_payout_amount = 75
display_name = "Farm"
scene_to_spawn = ExtResource("2_mixjq")
building_texture = ExtResource("1_lr1ah")
build_cost = {
"wood": 75
}
max_health = 75
grid_size = Vector2i(2, 2)
dev_color = Color(0.2, 0.8, 0.2, 1)
is_player_buildable = true

--- RESOURCE: res://data/buildings/Test_Large_Building.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bk4qd2jfm3kgp"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Large Test Building"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"wood": 100
}
max_health = 200
grid_size = Vector2i(3, 3)
dev_color = Color(0.8, 0.6, 0.2, 1)
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/characters/PlayerJarl.tres ---
[gd_resource type="Resource" script_class="JarlData" load_steps=3 format=3]

[ext_resource type="Script" path="res://data/characters/JarlData.gd" id="1_jarl_data"]
[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="2_3vd45"]

[resource]
script = ExtResource("1_jarl_data")
display_name = "Jarl Bjorn"
age = 30
renown = 25
current_authority = 1
command = 12
stewardship = 11
learning = 9
prowess = 14
spouse_name = "Lagertha"
heirs = Array[String](["Ragnar"])
has_valid_heir = true
children_count = 1
battles_fought = 2
battles_won = 2
successful_raids = 2
metadata/_custom_type_script = "uid://bm8qe8d38a1il"

--- RESOURCE: res://data/settlements/economic_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://chtd3i4qtdv31"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_e06fl"]

[resource]
script = ExtResource("1_e06fl")
treasury = {
"food": 315,
"gold": 1600,
"stone": 150,
"wood": 520
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 8),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(8, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 8
}

--- RESOURCE: res://data/settlements/fortress_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c2nrib7nroeas"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 150,
"gold": 1200,
"stone": 500,
"wood": 600
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 8
}

--- RESOURCE: res://data/settlements/home_base_fixed.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://cr75f5mo2ac1u"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 170,
"gold": 3715,
"stone": 600,
"wood": 40
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(11, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(11, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(17, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(20, 7),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(15, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(22, 7),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 16
}
metadata/_custom_type_script = "uid://hlb8s5g0yp6k"

--- RESOURCE: res://data/settlements/monastery_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://okf2novkg804"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_pnvr3"]

[resource]
script = ExtResource("1_pnvr3")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/monastery_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://6kk36f5nlwns"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 300,
"gold": 800,
"stone": 200,
"wood": 400
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/sample_fortress_gui.tres ---
[gd_resource type="SettlementData" script_class="SettlementData" load_steps=2 format=3 uid="uid://cl3pbg7tiqyng"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1"]

[resource]
resource_local_to_scene = false
resource_name = ""
script = ExtResource("1")
treasury = {
"food": 300,
"gold": 1000,
"stone": 400,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(30, 20),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(29, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(29, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(28, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(28, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(27, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(33, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 4,
"res://data/units/Unit_Raider.tres": 8
}

--- RESOURCE: res://data/settlements/small_defensive.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c5wkbqulshkqe"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_mtb34"]

[resource]
script = ExtResource("1_mtb34")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(11, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(4, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(14, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(6, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/traits/Trait_Cowardly.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bivw1rejl06qi"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Cowardly"
description = "This character has shown cowardice in battle, losing the respect of their people."
is_visible = true
command_modifier = -3
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -2.0
vassal_opinion_modifier = -10
alliance_cost_modifier = 1.2
is_wounded_trait = false
is_dishonorable_trait = true

--- RESOURCE: res://data/traits/Trait_Legendary.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://c6a8qce5fgub0"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Legendary"
description = "This character has achieved legendary status through glorious deeds and successful raids."
is_visible = true
command_modifier = 5
stewardship_modifier = 2
intrigue_modifier = 3
renown_per_year_modifier = 5.0
vassal_opinion_modifier = 20
alliance_cost_modifier = 0.8
is_wounded_trait = false
is_dishonorable_trait = false

--- RESOURCE: res://data/traits/Trait_Maimed.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bbiwlkmmne5md"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Maimed"
description = "This character has suffered a permanent injury that affects their combat ability."
is_visible = true
command_modifier = -2
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -1.0
vassal_opinion_modifier = -5
alliance_cost_modifier = 1.1
is_wounded_trait = true
is_dishonorable_trait = false

--- RESOURCE: res://data/units/Unit_PlayerRaider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=4 format=3 uid="uid://ejxn3hg8xcu6"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_tcvvg"]
[ext_resource type="PackedScene" uid="uid://cfanwutbtfcp2" path="res://scenes/units/PlayerVikingRaider.tscn" id="2_spawn_scene"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="3_6go6j"]

[resource]
script = ExtResource("1_tcvvg")
display_name = "Player Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
spawn_cost = {
"food": 25,
"gold": 10
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 80.0
attack_speed = 1.0
visual_texture = ExtResource("3_6go6j")

--- RESOURCE: res://data/units/Unit_Raider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=3 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://dsv0s4yq8c8m5" path="res://scenes/units/VikingRaider.tscn" id="2_spawn_scene"]

[resource]
script = ExtResource("1_abcde")
display_name = "Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
spawn_cost = {
"food": 30,
"gold": 15
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 50.0
attack_speed = 1.0

--- RESOURCE: res://data/world_map/Region_Monastery.tres ---
[gd_resource type="Resource" script_class="WorldRegionData" load_steps=3 format=3 uid="uid://dbhfg3lfhe6tw"]

[ext_resource type="Resource" uid="uid://okf2novkg804" path="res://data/settlements/monastery_base.tres" id="1_settlement"]
[ext_resource type="Script" uid="uid://dqlbgeegli821" path="res://data/world_map/WorldRegionData.gd" id="2_world_region"]

[resource]
script = ExtResource("2_world_region")
display_name = "Nearby Monastery"
description = "A wealthy but poorly-defended monastery. An easy target for a quick grab."
target_settlement_data = ExtResource("1_settlement")
metadata/_custom_type_script = "uid://dqlbgeegli821"

--- RESOURCE: res://textures/placeholders/building_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://ds2w780g4nf1t"]

[resource]
size = Vector2(128, 128)

--- RESOURCE: res://textures/placeholders/defensive_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://db3pfgf4u4pql"]

[resource]
size = Vector2(96, 96)

--- RESOURCE: res://textures/placeholders/unit_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://bg2e08mncpjg1"]

[resource]
size = Vector2(64, 64)

--- RESOURCE: res://textures/placeholders/unit_texture.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://cybqs3wt5wpg3"]

[resource]

--- RESOURCE: res://ui/themes/VikingDynastyTheme.tres ---
[gd_resource type="Theme" load_steps=0 format=3 uid="uid://63duv3n1vwhg"]

[resource]
--- END OF RESOURCE FILES ---

#### **2.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://autoload/PauseManager.tscn ---
PauseManager (Node)
> script: res://autoload/PauseManager.gd
> scene: res://autoload/PauseManager.tscn
> pause_menu_scene = res://scripts/ui/PauseMenu.tscn

--- SCENE: res://autoload/SceneManager.tscn ---
SceneManager (Node)
> script: res://autoload/SceneManager.gd
> scene: res://autoload/SceneManager.tscn
> settlement_scene = res://scenes/levels/SettlementBridge.tscn
> world_map_scene = res://scenes/world_map/MacroMap.tscn
> raid_mission_scene = res://scenes/missions/RaidMission.tscn

--- SCENE: res://player/RTSController.tscn ---
RTSController (Node)
> script: res://player/RTSController.gd
> scene: res://player/RTSController.tscn

--- SCENE: res://scenes/buildings/Base_Building.tscn ---
Base_Building (StaticBody2D)
> script: res://data/buildings/Base_Building.gd
> scene: res://scenes/buildings/Base_Building.tscn
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/buildings/Base_Building.tscn::RectangleShape2D_b5w0v
> ColorRect (ColorRect)
> > custom_minimum_size = (25.0, 25.0)
> > anchors_preset = -1
> > offset_right = 40.0
> > offset_bottom = 40.0
> > size_flags_horizontal = 3
> > color = (0.7373, 0.7373, 0.7373, 1.0)
>   Label (Label)
>   > layout_mode = 0
>   > offset_right = 114.0
>   > offset_bottom = 23.0
>   > text = "Building Name"
>   > horizontal_alignment = 1

--- SCENE: res://scenes/levels/DefensiveMicro.tscn ---
DefensiveMicro (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/levels/DefensiveMicro.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> TileMap (TileMap)
> > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]

--- SCENE: res://scenes/levels/SettlementBridge.tscn ---
SettlementBridge (Node)
> script: res://scripts/buildings/SettlementBridge.gd
> scene: res://scenes/levels/SettlementBridge.tscn
> home_base_data = res://data/settlements/home_base_fixed.tres
> welcome_popup_scene = res://ui/WelcomeHome_Popup.tscn
> world_map_scene_path = "res://scenes/world_map/MacroMap.tscn"
> UnitContainer (Node2D)
> UI (CanvasLayer)
>   Label (Label)
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_right = 0.5
>   > offset_left = -319.0
>   > offset_right = 319.0
>   > offset_bottom = 23.0
>   > grow_horizontal = 2
>   > text = "Purchase buildings from the storefront below, then place them on your settlement"
>   > horizontal_alignment = 1
>   Storefront_UI (Control)
>     script: res://ui/StorefrontUI.gd
>     scene: res://ui/Storefront_UI.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > available_buildings = []
>   > available_units = []
>   > default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
>   > auto_load_units_from_directory = true
>     PanelContainer (PanelContainer)
>     > layout_mode = 1
>     > anchors_preset = -1
>     > anchor_top = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = 20.0
>     > offset_top = -140.0
>     > offset_right = 480.0
>     > offset_bottom = -20.0
>     > grow_vertical = 0
>       MarginContainer (MarginContainer)
>       > layout_mode = 2
>         TabContainer (TabContainer)
>         > layout_mode = 2
>         > current_tab = 0
>           BuildTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             TreasuryDisplay (HBoxContainer)
>             > layout_mode = 2
>               GoldLabel (Label)
>               > layout_mode = 2
>               > text = "Gold: 0"
>               WoodLabel (Label)
>               > layout_mode = 2
>               > text = "Wood: 0"
>               FoodLabel (Label)
>               > layout_mode = 2
>               > text = "Food: 0"
>               StoneLabel (Label)
>               > layout_mode = 2
>               > text = "Stone: 0"
>             BuildButtonsContainer (VBoxContainer)
>             > layout_mode = 2
>           RecruitTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             RecruitButtons (VBoxContainer)
>             > layout_mode = 2
>             GarrisonList (VBoxContainer)
>             > layout_mode = 2
>   RestartButton (Button)
>   > visible = false
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -84.0
>   > offset_top = -15.5
>   > offset_right = 84.0
>   > offset_bottom = 15.5
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "Return to Settlement"
>   StartRaidButton (Button)
>   > anchors_preset = -1
>   > anchor_left = 1.0
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -150.0
>   > offset_top = -40.0
>   > grow_horizontal = 0
>   > grow_vertical = 0
>   > text = "World Map"
> BuildingCursor (Node2D)
>   script: res://scripts/ui/BuildingPreviewCursor.gd
> BuildingContainer (Node2D)
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
>   scene: res://scripts/utility/GridManager.tscn
> > grid_width = 60
> > grid_height = 40
> > cell_size = 32

--- SCENE: res://scenes/missions/RaidMission.tscn ---
RaidMission (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/missions/RaidMission.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> CanvasLayer (CanvasLayer)
>   SelectionBox (Control)
>     script: res://ui/SelectionBox.gd
>     scene: res://ui/SelectionBox.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://ui/themes/VikingDynastyTheme.tres
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
>   scene: res://scripts/utility/GridManager.tscn
> > grid_width = 120
> > grid_height = 80
> > cell_size = 32
> BuildingContainer (Node2D)
> RaidObjectiveManager (Node)
>   script: res://scenes/missions/RaidObjectiveManager.gd
> > victory_bonus_loot = {"gold":200}
> > settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> > is_defensive_mission = false

--- SCENE: res://scenes/units/Base_Unit.tscn ---
Base_Unit (CharacterBody2D)
> script: res://scripts/units/Base_Unit.gd
> scene: res://scenes/units/Base_Unit.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/PlayerVikingRaider.tscn ---
PlayerVikingRaider (CharacterBody2D)
> script: res://scripts/units/PlayerVikingRaider.gd
> scene: res://scenes/units/PlayerVikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > scale = (0.058594, 0.061523)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/VikingRaider.tscn ---
VikingRaider (CharacterBody2D)
> script: res://scripts/units/EnemyVikingRaider.gd
> scene: res://scenes/units/VikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/world_map/MacroCamera.tscn ---
MacroCamera (Camera2D)
> script: res://scenes/world_map/MacroCamera.gd
> scene: res://scenes/world_map/MacroCamera.tscn
> camera_speed = 500.0
> bounds_enabled = true
> bounds_rect = [P: (0.0, 0.0), S: (1920.0, 1080.0)]

--- SCENE: res://scenes/world_map/MacroMap.tscn ---
MacroMap (Node2D)
> script: res://scenes/world_map/MacroMap.gd
> scene: res://scenes/world_map/MacroMap.tscn
> position = (131.0, 23.0)
> raid_mission_scene_path = "res://scenes/missions/RaidMission.tscn"
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> MapBackground (ColorRect)
> > modulate = (0.7354, 0.7354, 0.7354, 1.0)
> > custom_minimum_size = (1920.0, 1080.0)
> > anchors_preset = -1
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_left = -703.000061035156
> > offset_top = -262.0
> > offset_right = 1217.0
> > offset_bottom = 818.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > scale = (60.0, 34.0)
> > mouse_filter = 2
> > color = (0.8314, 0.7725, 0.6275, 1.0)
> Regions (Node2D)
>   Region (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > position = (392.0, 139.0)
>   > data = res://data/world_map/Region_Monastery.tres
>     Sprite2D (Sprite2D)
>     > modulate = (1.0, 1.0, 1.0, 0.2)
>     > texture = res://assets/placeholder_tile.tres
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://scenes/world_map/Region.tscn::RectangleShape2D_y5hem
> MacroCamera (Camera2D)
>   script: res://scenes/world_map/MacroCamera.gd
>   scene: res://scenes/world_map/MacroCamera.tscn
> > camera_speed = 500.0
> > bounds_enabled = true
> > bounds_rect = [P: (0.0, 0.0), S: (1920.0, 1080.0)]
> UI (CanvasLayer)
> > layer = 10
>   JarlInfo (PanelContainer)
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_right = 0.5
>   > offset_left = -20.0
>   > offset_right = 20.0
>   > offset_bottom = 40.0
>   > grow_horizontal = 2
>   > mouse_filter = 1
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       AuthorityLabel (Label)
>       > layout_mode = 2
>       > size_flags_horizontal = 4
>       > text = "Authority: 3/3"
>       > horizontal_alignment = 1
>       RenownLabel (Label)
>       > layout_mode = 2
>       > text = "Renown: 25"
>       > horizontal_alignment = 1
>   Actions (PanelContainer)
>   > anchors_preset = -1
>   > anchor_left = 1.0
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -40.0
>   > offset_top = -40.0
>   > grow_horizontal = 0
>   > grow_vertical = 0
>   > mouse_filter = 2
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       EndYearButton (Button)
>       > layout_mode = 2
>       > text = "End Year"
>       SettlementButton (Button)
>       > layout_mode = 2
>       > text = "Return to Settlement"
>   RegionInfo (PanelContainer)
>   > visible = false
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -20.0
>   > offset_top = -40.0
>   > offset_right = 20.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > mouse_filter = 1
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       RegionNameLabel (Label)
>       > layout_mode = 2
>       > horizontal_alignment = 1
>       LaunchRaidButton (Button)
>       > layout_mode = 2
>       > disabled = true
>       > text = "Launch Raid"
>   Tooltip (PanelContainer)
>   > visible = false
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -51.5
>   > offset_top = -58.0
>   > offset_right = 98.5
>   > offset_bottom = -28.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > mouse_filter = 2
>     Label (Label)
>     > layout_mode = 2
>     > text = "Region Name"
>     > horizontal_alignment = 1

--- SCENE: res://scenes/world_map/Region.tscn ---
Region (Area2D)
> script: res://scenes/world_map/Region.gd
> scene: res://scenes/world_map/Region.tscn
> Sprite2D (Sprite2D)
> > modulate = (1.0, 1.0, 1.0, 0.2)
> > texture = res://assets/placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/world_map/Region.tscn::RectangleShape2D_y5hem

--- SCENE: res://scenes/world_map/WorldMap_Stub.tscn ---
WorldMapStub (Control)
> script: res://scenes/world_map/WorldMap_Stub.gd
> scene: res://scenes/world_map/WorldMap_Stub.tscn
> raid_mission_scene_path = "res://scenes/missions/RaidMission.tscn"
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> Background (ColorRect)
> > layout_mode = 0
> > color = (0.0, 0.0, 0.0, 1.0)
> TitleLabel (Label)
> > layout_mode = 0
> > offset_top = 50.0
> > offset_right = 141.0
> > offset_bottom = 73.0
> > text = "Select Your Target"
> > horizontal_alignment = 1
> ButtonContainer (VBoxContainer)
> > layout_mode = 0
> > offset_top = 150.0
> > offset_right = 190.0
> > offset_bottom = 216.0
> > alignment = 1
>   RaidMonasteryButton (Button)
>   > layout_mode = 2
>   > text = "Raid: Nearby Monastery"
>   Spacer (HSeparator)
>   > layout_mode = 2
>   BackButton (Button)
>   > layout_mode = 2
>   > text = "Return to Settlement"
> Phase3Test (Node)
>   script: res://tools/test_phase3.gd

--- SCENE: res://scripts/ui/PauseMenu.tscn ---
PauseMenu (CanvasLayer)
> script: res://scripts/ui/PauseMenu.gd
> scene: res://scripts/ui/PauseMenu.tscn
> process_mode = 2
> PanelContainer (PanelContainer)
> > anchors_preset = -1
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -20.0
> > offset_top = -20.0
> > offset_right = 20.0
> > offset_bottom = 20.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     ResumeButton (Button)
>     > layout_mode = 2
>     > text = "Resume"
>     SaveButton (Button)
>     > layout_mode = 2
>     > text = "Save Game"
>     QuitButton (Button)
>     > layout_mode = 2
>     > text = "Quit Game"

--- SCENE: res://scripts/utility/GridManager.tscn ---
GridManager (Node)
> script: res://scripts/utility/GridManager.gd
> scene: res://scripts/utility/GridManager.tscn
> grid_width = 60
> grid_height = 40
> cell_size = 32

--- SCENE: res://tools/main_test.tscn ---
Main Test (Node2D)
> scene: res://tools/main_test.tscn

--- SCENE: res://tools/Phase1_TestRunner.tscn ---
Node (Node)
> script: res://tools/Phase1TestRunner.gd
> scene: res://tools/Phase1_TestRunner.tscn

--- SCENE: res://ui/BuildingPreviewCursor.tscn ---
BuildingPreviewCursor (Node2D)
> script: res://scripts/ui/BuildingPreviewCursor.gd
> scene: res://ui/BuildingPreviewCursor.tscn

--- SCENE: res://ui/SelectionBox.tscn ---
SelectionBox (Control)
> script: res://ui/SelectionBox.gd
> scene: res://ui/SelectionBox.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> theme = res://ui/themes/VikingDynastyTheme.tres

--- SCENE: res://ui/Storefront_UI.tscn ---
Main (Control)
> script: res://ui/StorefrontUI.gd
> scene: res://ui/Storefront_UI.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> available_buildings = []
> available_units = []
> default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
> auto_load_units_from_directory = true
> PanelContainer (PanelContainer)
> > layout_mode = 1
> > anchors_preset = -1
> > anchor_top = 1.0
> > anchor_bottom = 1.0
> > offset_left = 20.0
> > offset_top = -140.0
> > offset_right = 480.0
> > offset_bottom = -20.0
> > grow_vertical = 0
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     TabContainer (TabContainer)
>     > layout_mode = 2
>     > current_tab = 0
>       BuildTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         TreasuryDisplay (HBoxContainer)
>         > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           > text = "Gold: 0"
>           WoodLabel (Label)
>           > layout_mode = 2
>           > text = "Wood: 0"
>           FoodLabel (Label)
>           > layout_mode = 2
>           > text = "Food: 0"
>           StoneLabel (Label)
>           > layout_mode = 2
>           > text = "Stone: 0"
>         BuildButtonsContainer (VBoxContainer)
>         > layout_mode = 2
>       RecruitTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         RecruitButtons (VBoxContainer)
>         > layout_mode = 2
>         GarrisonList (VBoxContainer)
>         > layout_mode = 2

--- SCENE: res://ui/WelcomeHome_Popup.tscn ---
Main (PanelContainer)
> script: res://ui/WelcomeHomePopup.gd
> scene: res://ui/WelcomeHome_Popup.tscn
> anchor_left = 0.5
> anchor_top = 0.5
> anchor_right = 0.5
> anchor_bottom = 0.5
> offset_left = -150.0
> offset_top = -75.0
> offset_right = 150.0
> offset_bottom = 75.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 4
> size_flags_vertical = 4
> theme = res://ui/themes/VikingDynastyTheme.tres
> MarginContainer (MarginContainer)
> > layout_mode = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     PayoutLabel (Label)
>     > layout_mode = 2
>     > text = "Welcome home! ..."
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     CollectButton (Button)
>     > custom_minimum_size = (120.0, 40.0)
>     > layout_mode = 2
>     > text = "Collect"
--- END OF SCENE STRUCTURES ---

#### **2.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://autoload/DynastyManager.gd ---
# res://autoload/DynastyManager.gd
#
# A global Singleton (Autoload) that acts as a pure data manager
# for the player's Jarl and dynasty state.
# This is the "Core Pacing Engine" as defined in the GDD.
# It is the single source of truth for all Jarl data.

extends Node

## Emitted when Jarl data changes (e.g., spent Authority, ended year)
signal jarl_stats_updated(jarl_data: JarlData)

var current_jarl: JarlData
var current_raid_target: SettlementData

# Path to the player's persistent Jarl data
const PLAYER_JARL_PATH = "res://data/characters/PlayerJarl.tres"

func _ready() -> void:
	_load_player_jarl()

func _load_player_jarl() -> void:
	if ResourceLoader.exists(PLAYER_JARL_PATH):
		current_jarl = load(PLAYER_JARL_PATH)
		print("DynastyManager: PlayerJarl.tres loaded successfully.")
	else:
		push_error("DynastyManager: Failed to load Jarl data from %s. File not found!" % PLAYER_JARL_PATH)
		# Create a fallback in-memory Jarl to prevent crashes
		current_jarl = JarlData.new()
		current_jarl.display_name = "Fallback Jarl"
		current_jarl.current_authority = 3
		current_jarl.max_authority = 3
		
	# Emit initial stats
	jarl_stats_updated.emit(current_jarl)

func get_current_jarl() -> JarlData:
	if not current_jarl:
		_load_player_jarl()
	return current_jarl

func can_spend_authority(cost: int) -> bool:
	if not current_jarl:
		return false
	return current_jarl.can_take_action(cost) #

func spend_authority(cost: int) -> bool:
	if not current_jarl:
		return false
		
	if current_jarl.spend_authority(cost):
		_save_jarl_data()
		jarl_stats_updated.emit(current_jarl) #
		print("DynastyManager: Spent %d authority. %d remaining." % [cost, current_jarl.current_authority])
		return true
	
	print("DynastyManager: Failed to spend %d authority. %d remaining." % [cost, current_jarl.current_authority])
	return false

func end_year() -> void:
	if not current_jarl:
		return
		
	current_jarl.reset_authority() #
	# TODO: Hook in Renown Decay and other end-of-year events here
	
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("DynastyManager: Year ended. Authority reset to %d." % current_jarl.max_authority)

func set_current_raid_target(data: SettlementData) -> void:
	current_raid_target = data #
	print("DynastyManager: Raid target set to %s" % data.resource_path)

func get_current_raid_target() -> SettlementData:
	var target = current_raid_target
	current_raid_target = null # Clear the target after getting it
	return target

func _save_jarl_data() -> void:
	if not current_jarl:
		push_error("DynastyManager: Cannot save, current_jarl is null.")
		return
		
	if current_jarl.resource_path.is_empty():
		current_jarl.resource_path = PLAYER_JARL_PATH
		
	var error = ResourceSaver.save(current_jarl, current_jarl.resource_path)
	if error != OK:
		push_error("DynastyManager: Failed to save Jarl data to %s. Error: %s" % [current_jarl.resource_path, error])
	else:
		print("DynastyManager: Jarl data saved to %s" % current_jarl.resource_path)

func award_renown(amount: int) -> void:
	if not current_jarl:
		return
	
	current_jarl.award_renown(amount) #
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("DynastyManager: Awarded %d renown. Total: %d" % [amount, current_jarl.renown])

--- SCRIPT: res://autoload/EventBus.gd ---
# res://autoload/EventBus.gd
#
# A global Singleton (Autoload) that acts as a central "switchboard"
# for decoupled signal communication between major systems.

extends Node

# --- Build System Signals ---
# TODO: Connect this signal when implementing advanced building system
# @warning_ignore("unused_signal")
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)

# --- Pathfinding Signals ---
signal pathfinding_grid_updated(grid_position: Vector2i)

# --- Treasury & Economy Signals (Phase 2) ---
signal treasury_updated(new_treasury: Dictionary)
signal purchase_successful(item_name: String)
signal purchase_failed(reason: String)

# --- Navigation Signals (Phase 3) ---
# MODIFIED: Now emits a string KEY name, not a full path.
signal scene_change_requested(scene_key: String)
signal world_map_opened()
signal raid_mission_started(target_type: String)

# --- Settlement Management Signals ---
signal settlement_loaded(settlement_data: SettlementData)

# --- Unit Management Signals ---
signal player_unit_died(unit: Node2D)

# --- NEW: RTS Command Signals (GDD Section 10) ---
# Emitted by SelectionBox.gd, consumed by RTSController.gd

# Emitted on left-click or drag-release
signal select_command(select_rect: Rect2, is_box_select: bool)

# Emitted on right-click on the ground
signal move_command(target_position: Vector2)

# Emitted on right-click on an enemy
signal attack_command(target_node: Node2D)

# --- NEW: Building Cursor System Signals ---
# Emitted when a building is purchased and ready for cursor placement
signal building_ready_for_placement(building_data: BuildingData)

# Emitted when building placement is cancelled (should refund cost)
signal building_placement_cancelled(building_data: BuildingData)

--- SCRIPT: res://autoload/PauseManager.gd ---
# res://autoload/PauseManager.gd
#
# This is a global autoload script that listens for the 'ui_pause'
# input to pause the game.
# It is only responsible for *pausing* and instancing the menu.
# The menu itself is responsible for unpausing.

extends Node

# We will assign this scene in the Project Settings Autoload menu
@export var pause_menu_scene: PackedScene


func _unhandled_input(event: InputEvent) -> void:
	# We only listen for the pause input
	# We only pause if the game is NOT already paused
	if event.is_action_pressed("ui_pause") and not get_tree().paused:
		
		if not pause_menu_scene:
			push_error("PauseManager: 'pause_menu_scene' is not set in Project Settings!")
			return
		
		# Consume the event so nothing else (like the menu) can use it
		get_viewport().set_input_as_handled()
		
		# Pause the game
		get_tree().paused = true
		
		# Create the menu
		var menu = pause_menu_scene.instantiate()
		get_tree().root.add_child(menu)

--- SCRIPT: res://autoload/SceneManager.gd ---
# res://autoload/SceneManager.gd
#
# A global Singleton (Autoload) that handles all scene transitions.
# It listens for a signal on the EventBus and performs the change.
# This decouples all scenes from each other, preventing circular dependencies.
extends Node

# --- Phase 1 Refactor: PackedScene Exports ---
# Assign these in the Godot Editor (Project > Project Settings > Autoload > SceneManager)
@export var settlement_scene: PackedScene
@export var world_map_scene: PackedScene
@export var raid_mission_scene: PackedScene
# ---------------------------------------------

func _ready() -> void:
	# Connect to the EventBus signal that all other scenes will use 
	EventBus.scene_change_requested.connect(_on_scene_change_requested)

func _on_scene_change_requested(scene_key: String) -> void:
	if scene_key.is_empty():
		push_error("SceneManager: scene_change_requested received an empty key.")
		return

	var target_scene: PackedScene = null
	
	# Match the string key to the exported PackedScene
	match scene_key.to_lower():
		"settlement":
			target_scene = settlement_scene
		"world_map":
			target_scene = world_map_scene
		"raid_mission":
			target_scene = raid_mission_scene
		_:
			push_error("SceneManager: Unknown scene key '%s'. No scene transition will occur." % scene_key)
			return

	if not target_scene:
		push_error("SceneManager: Scene key '%s' is valid, but its PackedScene is not assigned in the Inspector!" % scene_key)
		return

	print("SceneManager: Changing to scene: %s (Key: %s)" % [target_scene.resource_path, scene_key])
	var error = get_tree().change_scene_to_packed(target_scene)
	
	if error != OK:
		push_error("SceneManager: Failed to change to scene '%s'. Error code: %s" % [target_scene.resource_path, error])

--- SCRIPT: res://autoload/SettlementManager.gd ---
# res://autoload/SettlementManager.gd
#
# A global Singleton (Autoload) that acts as a pure data manager
# for the player's current settlement.
#
# --- REFACTORED (The "Proper Fix") ---
# This script is now data-only and has no scene dependencies.
# All node instantiation, container management, and AStarGrid logic
# has been moved to the scenes that need it (e.g., SettlementBridge.gd
# and RaidMission.gd).

extends Node

var current_settlement: SettlementData

# --- NEW: Scene Registry ---
# These variables hold references to nodes in the *active* scene
# (e.g., SettlementBridge or RaidMission).
# This lets us fix the "buildings in raid" bug while minimizing
# refactoring of other scripts, which can still call SettlementManager.
var active_astar_grid: AStarGrid2D = null
var active_building_container: Node2D = null
# ---------------------------


# --- Scene Management ---

func register_active_scene_nodes(grid: AStarGrid2D, container: Node2D) -> void:
	"""
	Called by the active scene (e.g., SettlementBridge) to register
	its local pathfinding grid and building container.
	"""
	if not is_instance_valid(grid) or not is_instance_valid(container):
		push_error("SettlementManager: Failed to register invalid scene nodes.")
		return
	active_astar_grid = grid
	active_building_container = container
	print("SettlementManager: Active scene nodes registered.")

func unregister_active_scene_nodes() -> void:
	"""Called by the active scene when it exits to clear references."""
	active_astar_grid = null
	active_building_container = null
	print("SettlementManager: Active scene nodes unregistered.")


# --- Settlement Data ---

func load_settlement(data: SettlementData) -> void:
	if not data:
		push_error("SettlementManager: load_settlement called with null data.")
		return
	
	current_settlement = data
	
	if not current_settlement.resource_path or current_settlement.resource_path.is_empty():
		if data.resource_path and not data.resource_path.is_empty():
			current_settlement.resource_path = data.resource_path
		else:
			current_settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
			print("SettlementManager: Set fallback resource_path to: %s" % current_settlement.resource_path)
	
	print("SettlementManager: Settlement data loaded - %s" % current_settlement.resource_path)
	print("SettlementManager: Garrison units: %s" % current_settlement.garrisoned_units)
	
	EventBus.settlement_loaded.emit(current_settlement)


func save_settlement() -> void:
	if not current_settlement:
		push_error("Attempted to save a null settlement.")
		return
	
	if current_settlement.resource_path and not current_settlement.resource_path.is_empty():
		if not current_settlement.get_script():
			current_settlement.set_script(preload("res://data/settlements/SettlementData.gd"))
		
		var error = ResourceSaver.save(current_settlement, current_settlement.resource_path)
		if error == OK:
			print("Settlement data saved successfully to: %s" % current_settlement.resource_path)
		else:
			push_error("Failed to save settlement data to path: %s. Error code: %s" % [current_settlement.resource_path, error])
	else:
		push_warning("SettlementData has no resource_path, cannot save settlement.")

func has_current_settlement() -> bool:
	return current_settlement != null


# --- Treasury & Economy ---

func deposit_resources(loot: Dictionary) -> void:
	if not current_settlement: return
	for resource_type in loot:
		if current_settlement.treasury.has(resource_type):
			current_settlement.treasury[resource_type] += loot[resource_type]
		else:
			current_settlement.treasury[resource_type] = loot[resource_type]
	EventBus.treasury_updated.emit(current_settlement.treasury)
	print("Loot deposited. New treasury: %s" % current_settlement.treasury)
	save_settlement()

func attempt_purchase(item_cost: Dictionary) -> bool:
	if not current_settlement: return false
	
	for resource_type in item_cost:
		if not current_settlement.treasury.has(resource_type) or \
		current_settlement.treasury[resource_type] < item_cost[resource_type]:
			var reason = "Insufficient %s" % resource_type
			print("Purchase failed. %s." % reason)
			EventBus.purchase_failed.emit(reason)
			return false
			
	for resource_type in item_cost:
		current_settlement.treasury[resource_type] -= item_cost[resource_type]
	
	EventBus.treasury_updated.emit(current_settlement.treasury)
	EventBus.purchase_successful.emit("Unnamed Item") # Placeholder
	print("Purchase successful. New treasury: %s" % current_settlement.treasury)
	return true

func calculate_payout() -> Dictionary:
	if not current_settlement:
		return {}

	var total_payout: Dictionary = {}

	for building_entry in current_settlement.placed_buildings:
		var building_data: BuildingData = load(building_entry["resource_path"])
		if building_data is EconomicBuildingData:
			var eco_data: EconomicBuildingData = building_data
			var resource_type: String = eco_data.resource_type
			
			if not total_payout.has(resource_type):
				total_payout[resource_type] = 0
			
			total_payout[resource_type] += eco_data.fixed_payout_amount

	if not total_payout.is_empty():
		print("Calculated fixed payout: %s" % total_payout)
	return total_payout

# --- Unit Management ---

func recruit_unit(unit_data: UnitData) -> void:
	if not current_settlement:
		push_error("Cannot recruit unit: no current settlement")
		return
	
	if not unit_data:
		push_error("Cannot recruit: UnitData is null")
		return
	
	var unit_path: String = unit_data.resource_path
	if unit_path.is_empty():
		push_error("Cannot recruit: UnitData has no resource_path")
		return
	
	if current_settlement.garrisoned_units.has(unit_path):
		current_settlement.garrisoned_units[unit_path] += 1
	else:
		current_settlement.garrisoned_units[unit_path] = 1
	
	print("Recruited %s. Garrison count: %d" % [unit_data.display_name, current_settlement.garrisoned_units[unit_path]])
	
	save_settlement()
	EventBus.purchase_successful.emit(unit_data.display_name)


# --- Building & Pathfinding (Delegated) ---

func get_active_grid_cell_size() -> Vector2:
	"""
	Returns the cell size of the currently registered AStarGrid.
	Used by Base_Building to scale itself correctly.
	"""
	if is_instance_valid(active_astar_grid):
		return active_astar_grid.cell_size
	
	# Fallback in case no grid is registered
	push_warning("SettlementManager: get_active_grid_cell_size() called, but no grid is active. Returning default (32,32).")
	return Vector2(32, 32)

func place_building(building_data: BuildingData, grid_position: Vector2i) -> BaseBuilding:
	if not is_instance_valid(active_astar_grid) or not is_instance_valid(active_building_container):
		push_error("Place building failed: Active scene nodes are not registered.")
		return null

	if not building_data or not building_data.scene_to_spawn:
		push_error("Build request failed: BuildingData or scene_to_spawn is null.")
		return null
	
	if not is_placement_valid(grid_position, building_data.grid_size):
		push_error("Cannot place building at %s: position is invalid, out of bounds, or occupied." % grid_position)
		return null
	
	var new_building: BaseBuilding = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	
	# Calculate the center position of the building's entire footprint
	var world_pos_top_left: Vector2 = Vector2(grid_position) * active_astar_grid.cell_size
	var building_footprint_size: Vector2 = Vector2(building_data.grid_size) * active_astar_grid.cell_size
	var building_center_offset: Vector2 = building_footprint_size / 2.0
	new_building.global_position = world_pos_top_left + building_center_offset
	
	active_building_container.add_child(new_building)
	
	if building_data.blocks_pathfinding:
		for x in range(building_data.grid_size.x):
			for y in range(building_data.grid_size.y):
				var cell_pos = grid_position + Vector2i(x, y)
				if _is_cell_within_bounds(cell_pos): # Use local helper
					active_astar_grid.set_point_solid(cell_pos, true)
		
		active_astar_grid.update()
		EventBus.pathfinding_grid_updated.emit(grid_position)
		
	return new_building

func is_placement_valid(grid_position: Vector2i, building_size: Vector2i) -> bool:
	if not is_instance_valid(active_astar_grid):
		push_error("is_placement_valid: AStarGrid is not registered!")
		return false
	
	for x in range(building_size.x):
		for y in range(building_size.y):
			var cell_pos = grid_position + Vector2i(x, y)
			
			if not _is_cell_within_bounds(cell_pos):
				return false
			
			if active_astar_grid.is_point_solid(cell_pos):
				return false
	
	return true

func _is_cell_within_bounds(grid_position: Vector2i) -> bool:
	if not is_instance_valid(active_astar_grid):
		return false
	
	var bounds = active_astar_grid.region
	return grid_position.x >= bounds.position.x and grid_position.x < bounds.end.x and \
		   grid_position.y >= bounds.position.y and grid_position.y < bounds.end.y

func get_astar_path(start_pos: Vector2, end_pos: Vector2) -> PackedVector2Array:
	if not is_instance_valid(active_astar_grid):
		push_error("AStarGrid is not registered!")
		return PackedVector2Array()

	if active_astar_grid.region.size.x <= 0 or active_astar_grid.region.size.y <= 0:
		push_error("AStarGrid region is invalid: %s." % active_astar_grid.region)
		return PackedVector2Array()
	
	var start_id: Vector2i = Vector2i(start_pos / active_astar_grid.cell_size)
	var end_id: Vector2i = Vector2i(end_pos / active_astar_grid.cell_size)
	
	if not _is_cell_within_bounds(start_id):
		push_error("Start position (%s) -> grid_id (%s) is out of bounds." % [start_pos, start_id])
		return PackedVector2Array()
	
	if not _is_cell_within_bounds(end_id):
		push_error("End position (%s) -> grid_id (%s) is out of bounds." % [end_pos, end_id])
		return PackedVector2Array()
	
	return active_astar_grid.get_point_path(start_id, end_id)

func set_astar_point_solid(grid_position: Vector2i, solid: bool) -> void:
	if not is_instance_valid(active_astar_grid):
		push_warning("AStarGrid not registered")
		return
	
	if not _is_cell_within_bounds(grid_position):
		push_warning("Grid position %s is out of bounds" % grid_position)
		return
	
	active_astar_grid.set_point_solid(grid_position, solid)

--- SCRIPT: res://data/buildings/Base_Building.gd ---
# res://data/buildings/Base_Building.gd
#
# --- MODIFIED: (Dev Art Fix) ---
# Now uses a ColorRect and Label instead of a Sprite2D.
class_name BaseBuilding
extends StaticBody2D

## This signal is emitted when health reaches zero.
signal building_destroyed(building: BaseBuilding)

@export var data: BuildingData
var current_health: int = 100

# Get a reference to the new nodes
@onready var background: ColorRect = $ColorRect
@onready var label: Label = $ColorRect/Label
@onready var collision_shape: CollisionShape2D = $CollisionShape2D

# Development visual enhancements
var health_bar: ProgressBar
var border_rect: ColorRect

func _ready() -> void:
	if not data:
		push_warning("BaseBuilding: Node is missing its 'BuildingData' resource. Cannot initialize.")
		return
	
	current_health = data.max_health
	
	# --- Apply Data and Scaling ---
	_apply_data_and_scale()
	
	# --- Create Development Visuals ---
	_create_dev_visuals()

func _apply_data_and_scale() -> void:
	"""
	Applies the data from the .tres file and scales the
	ColorRect and collision shape to match the 'data.grid_size'.
	"""
	
	# 1. Validate SettlementManager and get the cell size
	if not SettlementManager:
		push_error("BaseBuilding: SettlementManager not ready. Cannot scale '%s'." % data.display_name)
		return
	
	var cell_size: Vector2 = SettlementManager.get_active_grid_cell_size()
	if cell_size.x <= 0 or cell_size.y <= 0:
		push_error("BaseBuilding: SettlementManager returned invalid cell_size (%s). Cannot scale '%s'." % [cell_size, data.display_name])
		return
		
	# 2. Get the target size based on grid
	var target_size: Vector2 = Vector2(data.grid_size) * cell_size
	
	if target_size.x <= 0 or target_size.y <= 0:
		push_warning("BaseBuilding: '%s' has a grid_size of %s, resulting in an invalid target_size." % [data.display_name, data.grid_size])
		return

	# 3. Apply and Scale the Background
	background.custom_minimum_size = target_size
	
	# --- THIS IS THE FIX (PART 1) ---
	# Shift the background's position so it's centered on the node's origin,
	# just like the collision shape.
	background.position = -target_size / 2.0
	
	# 4. Apply Enhanced Visual Styling
	_apply_visual_styling(target_size)

	# 5. Scale the Collision Shape
	if collision_shape and collision_shape.shape is RectangleShape2D:
		# Set size to match the target size (Godot 4.x uses 'size', not 'extents')
		collision_shape.shape.size = target_size
	else:
		# --- THIS IS THE BUG FIX ---
		# The '%' format string now correctly uses brackets [].
		push_warning("BaseBuilding: '%s' is missing its CollisionShape2D node or its shape is not a RectangleShape2D. Collision will not match visuals." % [data.display_name])
		# --- END BUG FIX ---

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	
	# Update health bar if it exists
	if health_bar:
		health_bar.value = current_health
	
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been destroyed." % data.display_name)
	
	_show_destruction_effect()
	
	building_destroyed.emit(self)
	
	remove_from_group("enemy_buildings")
	
	print("Building %s queued for removal from scene" % data.display_name)
	queue_free()

func _show_destruction_effect() -> void:
	"""Add a simple visual destruction effect"""
	var tween = create_tween()
	
	tween.parallel().tween_property(self, "scale", Vector2(0.1, 0.1), 0.3)
	tween.parallel().tween_property(self, "modulate", Color.TRANSPARENT, 0.3)
	tween.parallel().tween_property(self, "rotation", randf() * TAU, 0.3)

func _apply_visual_styling(target_size: Vector2) -> void:
	"""Enhanced visual styling with color coding and improved label"""
	# Apply building name
	label.text = data.display_name
	label.custom_minimum_size = target_size
	
	# Enhanced label properties
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	
	# Adjust font size based on building size
	if target_size.x < 64:
		label.add_theme_font_size_override("font_size", 10)
	elif target_size.x < 128:
		label.add_theme_font_size_override("font_size", 12)
	else:
		label.add_theme_font_size_override("font_size", 14)
	
	# Apply color coding based on building type
	_apply_color_coding()

func _apply_color_coding() -> void:
	"""Apply colors based on building type and properties"""
	var base_color: Color
	
	# Use custom color if set, otherwise use type-based colors
	if data.dev_color != Color.TRANSPARENT and data.dev_color != Color.GRAY:
		base_color = data.dev_color
	else:
		# Color coding by building type
		if data.is_defensive_structure:
			base_color = Color.CRIMSON * 0.8
		elif data.is_player_buildable:
			base_color = Color.ROYAL_BLUE * 0.8
		else:
			base_color = Color.GRAY * 0.8
	
	background.color = base_color

func _create_dev_visuals() -> void:
	"""Create additional development visual aids"""
	if not data:
		return
		
	var target_size: Vector2 = Vector2(data.grid_size) * SettlementManager.get_active_grid_cell_size()
	
	# Create border for defensive structures
	if data.is_defensive_structure:
		_create_border(target_size)
	
	# Create health bar for all buildings
	_create_health_bar(target_size)

func _create_border(target_size: Vector2) -> void:
	"""Create a border rect for defensive buildings"""
	border_rect = ColorRect.new()
	border_rect.color = Color.DARK_RED
	border_rect.custom_minimum_size = target_size + Vector2(4, 4)
	border_rect.position = -border_rect.custom_minimum_size / 2.0
	add_child(border_rect)
	move_child(border_rect, 0)  # Behind main background

func _create_health_bar(target_size: Vector2) -> void:
	"""Create a health bar above the building"""
	health_bar = ProgressBar.new()
	health_bar.custom_minimum_size = Vector2(target_size.x, 6)
	health_bar.position = Vector2(-target_size.x/2, -target_size.y/2 - 10)
	health_bar.max_value = data.max_health
	health_bar.value = current_health
	
	# Style the health bar
	health_bar.modulate = Color.WHITE
	add_child(health_bar)

--- SCRIPT: res://data/buildings/BuildingData.gd ---
# res://data/buildings/BuildingData.gd
#
# Defines the core data for any building in the game.
#
# --- MODIFIED: Added 'class_name BuildingData' ---

class_name BuildingData
extends Resource

## The name displayed in the UI (e.g., "Stone Wall", "Watchtower").
@export var display_name: String = "New Building"

## The scene that will be instanced when this building is placed.
@export var scene_to_spawn: PackedScene

## The icon shown in the build menu.
@export var icon: Texture2D

## Texture shown on screen
@export var building_texture: Texture2D

## The cost in 'Resources' (e.g., wood, gold) to build this.
@export var build_cost: Dictionary

## The building's maximum hit points.
@export var max_health: int = 100

## If true, this building blocks enemy pathfinding.
@export var blocks_pathfinding: bool = true

## The size of the building on the AStarGrid2D.
@export var grid_size: Vector2i = Vector2i.ONE

## Development visual color for the building rectangle.
@export var dev_color: Color = Color.GRAY

## If true, this building will appear in the player's Storefront UI.
@export var is_player_buildable: bool = false

@export_group("Defensive Stats")
## If true, this building can attack enemies (e.g., Watchtower).
@export var is_defensive_structure: bool = false

## Damage dealt per attack (if defensive).
@export var attack_damage: int = 5

## Range in pixels (if defensive).
@export var attack_range: float = 200.0

## Attacks per second (if defensive).
@export var attack_speed: float = 1.0

--- SCRIPT: res://data/buildings/EconomicBuildingData.gd ---
# res://data/buildings/EconomicBuildingData.gd
extends BuildingData
class_name EconomicBuildingData

@export_group("Economic Stats")
## The type of resource this building generates (e.g., "wood", "food", "gold").
@export var resource_type: String = "wood"

## The fixed amount of resources generated after each successful attack.
@export var fixed_payout_amount: int = 10

## The maximum amount of the resource that can be stored before collection.
@export var storage_cap: int = 100

--- SCRIPT: res://data/characters/JarlData.gd ---
# res://data/characters/JarlData.gd
#
# Defines the persistent data for a Jarl character in Viking Dynasty.
# This resource stores all the attributes that persist across the dynasty layer.
# GDD Ref: Section 2.A (Macro Layer), Appendix A.2 (Renown & Succession Loop)

class_name JarlData
extends Resource

## The Jarl's name displayed in the UI
@export var display_name: String = "New Jarl"

## The Jarl's portrait/icon for the UI
@export var portrait: Texture2D

## The Jarl's age in years
@export var age: int = 25

## The Jarl's gender (affects marriage and succession options)
@export var gender: String = "Male"  # "Male", "Female"


@export_group("Dynasty & Authority")
## Total Renown accumulated by this Jarl (persistent XP/Legacy score)
@export var renown: int = 0

## Current Renown Tier (determines Authority cap per year)
## Tiers: 0="Petty Jarl", 1="High Jarl", 2="Kingmaker", etc.
@export var renown_tier: int = 0

## Authority remaining for this year (action points for Macro layer)
@export var current_authority: int = 3

## Maximum Authority this Jarl can generate per year (based on Renown Tier)
@export var max_authority: int = 3

## Years since last offensive action (for Renown Decay calculations)
@export var years_since_action: int = 0


@export_group("Base Skills")
## Combat leadership and personal prowess
@export var command: int = 10

## Diplomatic skills and charm
@export var diplomacy: int = 10

## Strategic planning and administration
@export var stewardship: int = 10

## Religious knowledge and mysticism
@export var learning: int = 10

## Personal combat skill and courage
@export var prowess: int = 10

## Ability to inspire and lead
@export var charisma: int = 10


@export_group("Traits")
## Array of JarlTraitData resources that modify the Jarl's abilities and story
@export var traits: Array[JarlTraitData] = []

## Legacy trait names for backward compatibility (can be removed later)
@export var legacy_trait_names: Array[String] = []

## Whether this Jarl is currently wounded (affects stats temporarily)
@export var is_wounded: bool = false

## Number of turns remaining for wound recovery
@export var wound_recovery_turns: int = 0


@export_group("Family & Succession")
## The Jarl's spouse (if any)
@export var spouse_name: String = ""

## Array of heir names in order of succession priority
@export var heirs: Array[String] = []

## Whether this Jarl has a designated heir
@export var has_valid_heir: bool = false

## Number of living children
@export var children_count: int = 0


@export_group("Political Status")
## Current title/rank in the political hierarchy
@export var title: String = "Jarl"

## Number of vassals under this Jarl's rule
@export var vassal_count: int = 0

## Overall diplomatic reputation with other Jarls
@export var reputation: int = 0

## Whether this Jarl is currently in exile or displaced
@export var is_in_exile: bool = false


@export_group("Combat & Mission State")
## Whether the Jarl is currently leading a raid (affects vulnerability)
@export var is_on_mission: bool = false

## Number of battles this Jarl has fought
@export var battles_fought: int = 0

## Number of battles this Jarl has won
@export var battles_won: int = 0

## Total successful raids completed
@export var successful_raids: int = 0


## Get the effective skill value including trait modifiers
func get_effective_skill(skill_name: String) -> int:
	var base_value: int = 0
	
	match skill_name.to_lower():
		"command":
			base_value = command
		"diplomacy":
			base_value = diplomacy
		"stewardship":
			base_value = stewardship
		"learning":
			base_value = learning
		"prowess":
			base_value = prowess
		"charisma":
			base_value = charisma
		_:
			return 0
	
	# Apply trait modifiers
	var trait_modifier: int = 0
	for jarl_trait in traits:
		if jarl_trait == null:
			continue
		
		match skill_name.to_lower():
			"command":
				trait_modifier += jarl_trait.command_modifier
			"stewardship":
				trait_modifier += jarl_trait.stewardship_modifier
			"intrigue":
				trait_modifier += jarl_trait.intrigue_modifier
	
	return base_value + trait_modifier


## Add a trait to the Jarl (if not already present)
func add_trait(trait_data: JarlTraitData) -> void:
	if trait_data == null:
		return
	# Check if we already have this trait (by display name)
	for existing_trait in traits:
		if existing_trait != null and existing_trait.display_name == trait_data.display_name:
			return
	traits.append(trait_data)


## Check if Jarl has a specific trait by display name
func has_trait(trait_name: String) -> bool:
	for jarl_trait in traits:
		if jarl_trait != null and jarl_trait.display_name == trait_name:
			return true
	return false


## Get the Jarl's Authority cap based on Renown Tier (GDD reference)
func get_authority_cap() -> int:
	match renown_tier:
		0: return 3  # Petty Jarl
		1: return 5  # High Jarl
		2: return 7  # Kingmaker
		_: return 3 + renown_tier  # Future tiers


## Check if the Jarl can take an action (has Authority remaining)
func can_take_action(authority_cost: int = 1) -> bool:
	return current_authority >= authority_cost


## Spend Authority for an action
func spend_authority(cost: int = 1) -> bool:
	if can_take_action(cost):
		current_authority -= cost
		return true
	return false


## Award Renown for completing a major action
func award_renown(amount: int) -> void:
	renown += amount
	years_since_action = 0
	_update_renown_tier()


## Update Renown Tier based on current Renown
func _update_renown_tier() -> void:
	if renown >= 1000:
		renown_tier = 3
	elif renown >= 500:
		renown_tier = 2
	elif renown >= 200:
		renown_tier = 1
	else:
		renown_tier = 0


## Reset Authority at the start of a new year
func reset_authority() -> void:
	max_authority = get_authority_cap()
	current_authority = max_authority


## Apply aging effects to the Jarl
func age_jarl(years: int = 1) -> void:
	age += years
	years_since_action += years
	
	# Apply age-related skill changes
	if age > 60:
		# Older Jarls lose prowess but gain wisdom
		prowess = max(1, prowess - 1)
		learning = min(20, learning + 1)


## Get a summary string of the Jarl's current status
func get_status_summary() -> String:
	var status_parts: Array[String] = []
	
	status_parts.append("Age: %d" % age)
	status_parts.append("Renown: %d (Tier %d)" % [renown, renown_tier])
	status_parts.append("Authority: %d/%d" % [current_authority, max_authority])
	
	if is_wounded:
		status_parts.append("WOUNDED (%d turns)" % wound_recovery_turns)
	
	if is_on_mission:
		status_parts.append("ON MISSION")
	
	return " | ".join(status_parts)


## Remove a trait by display name
func remove_trait(trait_name: String) -> bool:
	for i in range(traits.size()):
		if traits[i] != null and traits[i].display_name == trait_name:
			traits.remove_at(i)
			return true
	return false


## Get all trait names as a string array (for easy saving/display)
func get_trait_names() -> Array[String]:
	var trait_names: Array[String] = []
	for jarl_trait in traits:
		if jarl_trait != null:
			trait_names.append(jarl_trait.display_name)
	return trait_names

--- SCRIPT: res://data/missions/RaidLootData.gd ---
# res://data/missions/RaidLootData.gd
# Resource for tracking loot collected during raids
# GDD Ref: Phase 3 Task 7 - Resource-Driven Payout

extends Resource
class_name RaidLootData

@export var collected_loot: Dictionary = {}

func _init() -> void:
	# Initialize with default resource types
	collected_loot = {
		"gold": 0,
		"wood": 0,
		"food": 0,
		"stone": 0
	}

func add_loot(resource_type: String, amount: int) -> void:
	"""Add loot to the collection"""
	if collected_loot.has(resource_type):
		collected_loot[resource_type] += amount
	else:
		collected_loot[resource_type] = amount
	
	print("Loot added: %d %s (Total: %d)" % [amount, resource_type, collected_loot[resource_type]])

func add_loot_from_building(building_data: BuildingData) -> void:
	"""Extract loot from a destroyed building"""
	if not building_data:
		return
	
	# For EconomicBuildingData, give loot based on the resource type
	if building_data is EconomicBuildingData:
		var eco_data: EconomicBuildingData = building_data
		var loot_amount = eco_data.fixed_payout_amount * 3  # 3x the daily payout as loot
		add_loot(eco_data.resource_type, loot_amount)
	else:
		# Default loot for other buildings
		add_loot("gold", 50)

func get_total_loot() -> Dictionary:
	"""Get a copy of the collected loot"""
	return collected_loot.duplicate()

func clear_loot() -> void:
	"""Reset all loot to zero"""
	for resource_type in collected_loot:
		collected_loot[resource_type] = 0

func get_loot_summary() -> String:
	"""Get a formatted string of collected loot"""
	var summary_parts: Array[String] = []
	for resource_type in collected_loot:
		if collected_loot[resource_type] > 0:
			summary_parts.append("%d %s" % [collected_loot[resource_type], resource_type])
	
	if summary_parts.is_empty():
		return "No loot collected"
	else:
		return "Loot: " + ", ".join(summary_parts)

--- SCRIPT: res://data/settlements/SettlementData.gd ---
extends Resource
class_name SettlementData

@export var treasury: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}

# Stores building data and position. Structure:
# {"resource_path": "res://...", "grid_position": Vector2i(x, y)}
@export var placed_buildings: Array[Dictionary] = []

# Stores unit type (path) and count (int)
# Example: {"res://data/units/Unit_Raider.tres": 3}
@export var garrisoned_units: Dictionary = {}

--- SCRIPT: res://data/traits/JarlTraitData.gd ---
# res://data/traits/JarlTraitData.gd
#
# This resource defines the statistical and diplomatic impact of a single trait.
# Renamed to JarlTraitData to avoid keyword conflict with Godot's internal 'Trait'.
class_name JarlTraitData
extends Resource

## General Information
@export var display_name: String = ""
@export var description: String = ""
@export var is_visible: bool = true # Should the player/AI know about this trait?

## Character Skill Modifiers (Permanent)
# Used to adjust the Jarl's base skills (Command, Stewardship, Intrigue)
@export_group("Skill Modifiers")
@export var command_modifier: int = 0
@export var stewardship_modifier: int = 0
@export var intrigue_modifier: int = 0

## Macro Layer Modifiers (Diplomacy/Renown)
@export_group("Macro Modifiers")
@export var renown_per_year_modifier: float = 0.0 # Used for passive Renown gain/loss
@export var vassal_opinion_modifier: int = 0  # Global change to vassal opinion of Jarl
@export var alliance_cost_modifier: float = 1.0 # Multiplier for alliance Authority cost

## Behavioral Flags (For AI and Event Triggers)
@export_group("Behavior Flags")
@export var is_wounded_trait: bool = false # e.g., Maimed, Crippled
@export var is_dishonorable_trait: bool = false # e.g., Betrayer, Cowardly

--- SCRIPT: res://data/units/UnitData.gd ---
# res://data/units/UnitData.gd
#
# Defines the core data for any unit in the game.
# This resource is used by Base_Unit.tscn to configure instances.
# GDD Ref: 7.C.1.b

class_name UnitData
extends Resource

## The name displayed in the UI (e.g., "Viking Raider").
@export var display_name: String = "New Unit"

## The scene that will be instanced when this unit is spawned.
@export var scene_to_spawn: PackedScene

## The icon shown in the training menu.
@export var icon: Texture2D

## The cost in 'Resources' to train this unit.
@export var spawn_cost: Dictionary = {"food": 25}


@export_group("Combat Stats")
## The unit's maximum hit points.
@export var max_health: int = 50

## Movement speed in pixels per second.
@export var move_speed: float = 75.0

## Damage dealt per attack.
@export var attack_damage: int = 8

## Range in pixels. (e.g., 10 for melee, 300 for archer).
@export var attack_range: float = 10.0

## Attacks per second.
@export var attack_speed: float = 1.2


@export_group("Visuals")
## The texture to use for the unit's sprite.
@export var visual_texture: Texture2D

## The target gameplay size in pixels (e.g., 32x32).
@export var target_pixel_size: Vector2 = Vector2(32, 32)

--- SCRIPT: res://data/world_map/WorldRegionData.gd ---
# res://data/world_map/WorldRegionData.gd
#
# Defines the data for a single clickable region on the Macro Map. 
# This allows the map to be data-driven.
class_name WorldRegionData
extends Resource

## The name displayed in tooltips and UI [cite: 424]
@export var display_name: String = "New Region"

## The flavor text description shown when selected
@export_multiline var description: String = "A description of this region." # [cite: 425]

## The SettlementData.tres file to load for the RaidMission
@export var target_settlement_data: SettlementData # [cite: 426]

## The base Authority cost to launch a raid here [cite: 427]
@export var base_authority_cost: int = 1

## Flag for future conquest loop (GDD 4.D) [cite: 428, 534]
@export var is_conquered: bool = false

--- SCRIPT: res://player/RTSCamera.gd ---
# res://player/RTSCamera.gd
# Basic RTS-style camera controller for Phase 3
# Provides WASD movement and mouse edge panning
# Keeps camera controls simple and focused on tactical gameplay

extends Camera2D
class_name RTSCamera

@export var camera_speed: float = 400.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_wasd_movement: bool = true

# Movement bounds to keep camera on battlefield
@export var bounds_enabled: bool = false
@export var bounds_rect: Rect2 = Rect2(-500, -500, 1500, 1200)

func _ready() -> void:
	# Make this the current camera
	make_current()

func _process(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	
	# WASD camera movement (as specified in GDD Phase 3)
	if enable_wasd_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Mouse edge panning (common RTS feature)
	if enable_edge_panning:
		var mouse_pos = get_viewport().get_mouse_position()
		var viewport_size = get_viewport().get_visible_rect().size
		
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
			
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		global_position += movement_vector * camera_speed * delta
		
		# Apply bounds if enabled
		if bounds_enabled:
			global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.position.x + bounds_rect.size.x)
			global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.position.y + bounds_rect.size.y)

--- SCRIPT: res://player/RTSController.gd ---
# res://player/RTSController.gd
#
# --- REFACTORED ---
# This script is now decoupled from input.
# It listens for clean signals from the EventBus
# (which are fired by SelectionBox.gd).
# It also correctly cleans up dead units.

extends Node
class_name RTSController

var selected_units: Array[BaseUnit] = []
var controllable_units: Array[BaseUnit] = []
var current_formation: SquadFormation.FormationType = SquadFormation.FormationType.LINE

func _ready() -> void:
	# Connect to the clean signals from our new EventBus/SelectionBox
	EventBus.select_command.connect(_on_select_command)
	EventBus.move_command.connect(_on_move_command)
	EventBus.attack_command.connect(_on_attack_command)

func _input(event: InputEvent) -> void:
	# Formation hotkeys
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_1:
				current_formation = SquadFormation.FormationType.LINE
				print("Formation: LINE")
			KEY_2:
				current_formation = SquadFormation.FormationType.COLUMN
				print("Formation: COLUMN")
			KEY_3:
				current_formation = SquadFormation.FormationType.WEDGE
				print("Formation: WEDGE")
			KEY_4:
				current_formation = SquadFormation.FormationType.BOX
				print("Formation: BOX")

# --- PUBLIC API ---

func add_unit_to_group(unit: Node2D) -> void:
	# Verify the unit is a BaseUnit (which has 'destroyed' signal)
	if not unit is BaseUnit:
		push_error("RTSController: Tried to add unit '%s' that doesn't extend BaseUnit." % unit.name)
		return
		
	if unit in controllable_units:
		return

	controllable_units.append(unit)
	
	# --- THIS IS THE DEAD UNIT CRASH FIX ---
	# Connect to this unit's 'destroyed' signal.
	# When it's destroyed, we'll clean it up.
	# We use CONNECT_DEFERRED to avoid race conditions.
	if unit.has_signal("destroyed"):
		unit.destroyed.connect(remove_unit.bind(unit), CONNECT_DEFERRED)
	else:
		# This check is vital. Our old debug units will fail this.
		push_warning("Unit %s does not have 'destroyed' signal!" % unit.name)

func remove_unit(unit: BaseUnit) -> void:
	"""Removes a unit from tracking. Called by the unit's 'destroyed' signal."""
	print("RTSController: Unit %s was destroyed/removed." % unit.name)
	
	if unit in selected_units:
		selected_units.erase(unit)
		if is_instance_valid(unit):
			# set_selected is a function on BaseUnit
			unit.set_selected(false)
			
	if unit in controllable_units:
		controllable_units.erase(unit)
		
	# Check if this was the last unit
	if controllable_units.is_empty():
		print("RTSController: All units are gone.")

# --- REMOVED ---
# _on_global_input, _draw, _process, _handle_selection,
# and _handle_command are all removed.
# They are replaced by the functions below.
# -----------------

# --- NEW: EVENTBUS HANDLERS ---

func _on_select_command(select_rect: Rect2, is_box_select: bool) -> void:
	_clear_selection()
	
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	if not main_camera:
		push_error("RTSController: No Camera2D found to perform selection.")
		return
	
	if is_box_select:
		# Box select - convert screen rect to world coordinates instead
		# This is more reliable than converting world to screen for each unit
		var camera_pos = main_camera.get_screen_center_position()
		var camera_zoom = main_camera.zoom
		var viewport_size = get_viewport().get_visible_rect().size
		
		# Convert screen rectangle to world coordinates
		var world_rect_min = camera_pos - (viewport_size / (2.0 * camera_zoom)) + (select_rect.position / camera_zoom)
		var world_rect_max = world_rect_min + (select_rect.size / camera_zoom)
		var world_rect = Rect2(world_rect_min, world_rect_max - world_rect_min)
		
		for unit in controllable_units:
			if world_rect.has_point(unit.global_position):
				selected_units.append(unit)
				unit.set_selected(true)
	else:
		# Single select (find closest unit to the click)
		# We must get the world position from the camera
		var click_world_pos := main_camera.get_global_mouse_position()
		var closest_unit: BaseUnit = null
		var min_dist_sq = INF
		
		for unit in controllable_units:
			var dist_sq = unit.global_position.distance_squared_to(click_world_pos)
			# 40px click radius
			if dist_sq < min_dist_sq and dist_sq < (40 * 40): 
				min_dist_sq = dist_sq
				closest_unit = unit
				
		if closest_unit:
			selected_units.append(closest_unit)
			closest_unit.set_selected(true)

func _on_move_command(target_position: Vector2) -> void:
	if selected_units.is_empty():
		return
	
	if selected_units.size() == 1:
		# Single unit - direct movement
		selected_units[0].command_move_to(target_position)
	else:
		# Multiple units - use formation
		var units_as_node2d: Array[Node2D] = []
		for unit in selected_units:
			units_as_node2d.append(unit)
		
		var formation = SquadFormation.new(units_as_node2d)
		formation.formation_type = current_formation
		formation.unit_spacing = 45.0
		formation.move_to_position(target_position)

func _on_attack_command(target_node: Node2D) -> void:
	if selected_units.is_empty():
		return
		
	for unit in selected_units:
		unit.command_attack(target_node)

func _clear_selection() -> void:
	for unit in selected_units:
		# Check if it's valid, it might have been destroyed
		if is_instance_valid(unit):
			unit.set_selected(false)
	selected_units.clear()

--- SCRIPT: res://scenes/missions/RaidMission.gd ---
# res://scenes/missions/RaidMission.gd
# Raid Mission Controller for Phase 3
# GDD Ref: Phase 3 Task 7
#
# --- REFACTORED (The "God Object" Fix) ---
# This script is now just a "level loader."
# It loads the map, spawns buildings/units, and then
# passes control to the RaidObjectiveManager node.

extends Node2D

# --- Exported Mission Configuration ---
@export var enemy_base_data: SettlementData
@export var default_enemy_base_path: String = "res://data/settlements/monastery_base.tres"
@export_group("Enemy Base Presets")
@export var available_enemy_bases: Array[String] = [
	"res://data/settlements/monastery_base.tres",
	"res://data/settlements/fortress_base.tres"
]
@export var player_spawn_formation: Dictionary = {"units_per_row": 5, "spacing": 40}
@export var mission_difficulty: float = 1.0
@export var allow_retreat: bool = true

# --- REMOVED: These vars were moved to RaidObjectiveManager ---
# @export var settlement_bridge_scene_path: String
# @export var is_defensive_mission: bool
# @export var victory_bonus_loot: Dictionary

# --- Node References ---
@onready var player_spawn_pos: Marker2D = $PlayerStartPosition
@onready var rts_controller: RTSController = $RTSController
@onready var grid_manager: Node = $GridManager
@onready var building_container: Node2D = $BuildingContainer
@onready var objective_manager: Node = $RaidObjectiveManager # New reference

# --- State Variables ---
var enemy_hall: BaseBuilding = null
# --- REMOVED: var raid_loot: RaidLootData = null ---


func _ready() -> void:
	EventBus.settlement_loaded.connect(_on_settlement_ready_for_mission)
	
	if not SettlementManager.has_current_settlement():
		print("RaidMission: No current settlement - loading test settlement for standalone mode")
		_load_test_settlement()
		call_deferred("initialize_mission")
	else:
		print("RaidMission: Settlement already loaded - initializing mission")
		call_deferred("initialize_mission")

func _exit_tree() -> void:
	SettlementManager.unregister_active_scene_nodes()
	
	if EventBus.is_connected("settlement_loaded", _on_settlement_ready_for_mission):
		EventBus.settlement_loaded.disconnect(_on_settlement_ready_for_mission)


func _load_test_settlement() -> void:
	"""Load a test settlement with garrison units for standalone testing"""
	var test_settlement_path = "res://data/settlements/home_base_fixed.tres"
	var test_settlement = load(test_settlement_path) as SettlementData
	
	if test_settlement:
		print("RaidMission: Loading test settlement: %s" % test_settlement_path)
		SettlementManager.load_settlement(test_settlement)
	else:
		push_error("RaidMission: Failed to load test settlement from %s" % test_settlement_path)

func _on_settlement_ready_for_mission(_settlement_data: SettlementData) -> void:
	"""Called when settlement is loaded - only initialize if we haven't already"""
	# Check if objective_manager has been initialized (as a proxy for mission start)
	if not is_instance_valid(objective_manager.rts_controller): 
		print("RaidMission: Settlement loaded - initializing mission")
		initialize_mission()


func initialize_mission() -> void:
	print("RaidMission starting...")
	
	if rts_controller == null or objective_manager == null:
		push_error("RaidMission: Critical error! RTSController or RaidObjectiveManager node not found.")
		get_tree().quit()
		return
	
	if not enemy_base_data:
		enemy_base_data = load(default_enemy_base_path)
		if not enemy_base_data:
			push_error("Could not load enemy base data from default path.")
			return
	
	# 1. Register local grid
	if not is_instance_valid(grid_manager) or not "astar_grid" in grid_manager:
		push_error("RaidMission: GridManager node is missing or invalid!")
		return
	var local_astar_grid = grid_manager.astar_grid
	SettlementManager.register_active_scene_nodes(local_astar_grid, building_container)
	
	# 2. Load buildings and grid
	_load_enemy_base()
	_update_astar_grid_for_enemy_base()
	
	# 3. Spawn units
	_spawn_player_garrison()
	
	# 4. Hand off to Objective Manager
	if is_instance_valid(enemy_hall):
		objective_manager.initialize(rts_controller, enemy_hall, building_container)
	else:
		push_error("RaidMission: Could not find Enemy Hall! Objectives will not function.")

func _load_enemy_base() -> void:
	print("Loading enemy base...")
	
	if not enemy_base_data:
		push_error("No enemy base data provided")
		return
	
	for building_entry in enemy_base_data.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if not building_data:
			push_error("Failed to load building resource as BuildingData: %s" % building_res_path)
			continue
		
		if not building_data.scene_to_spawn:
			push_error("Failed to load building: %s" % building_res_path)
			continue
		
		var building_instance: BaseBuilding = building_data.scene_to_spawn.instantiate()
		building_instance.name = building_data.display_name + "_Enemy"
		
		if "data" in building_instance:
			building_instance.data = building_data
		
		var world_pos: Vector2 = Vector2(grid_pos) * grid_manager.cell_size + (Vector2.ONE * grid_manager.cell_size / 2.0)
		building_instance.global_position = world_pos
		
		building_instance.add_to_group("enemy_buildings")
		
		if building_instance.has_method("set_collision_layer"):
			building_instance.set_collision_layer(4)
			building_instance.set_collision_mask(0)
		
		building_instance.set_meta("building_data", building_data)
		building_instance.set_meta("is_enemy_building", true)
		
		# Find the hall
		if building_data.display_name.to_lower().contains("hall"):
			enemy_hall = building_instance
			print("Found enemy hall: %s" % building_data.display_name)
		
		# Connect signal for GRID CLEARING (loot is handled by objective manager)
		if building_instance.has_signal("building_destroyed"):
			building_instance.building_destroyed.connect(_on_enemy_building_destroyed_grid_clear)
		
		building_container.add_child(building_instance)

func _update_astar_grid_for_enemy_base() -> void:
	print("Updating A* grid for enemy base...")
	
	if not enemy_base_data:
		return
	
	for building_entry in enemy_base_data.placed_buildings:
		var building_data: BuildingData = load(building_entry["resource_path"])
		if not building_data:
			continue
		
		if building_data.blocks_pathfinding:
			var grid_size: Vector2i = building_data.grid_size
			var grid_pos: Vector2i = building_entry["grid_position"]
			
			for x in range(grid_size.x):
				for y in range(grid_size.y):
					var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
					SettlementManager.set_astar_point_solid(cell_pos, true)
	
	if is_instance_valid(grid_manager) and is_instance_valid(grid_manager.astar_grid):
		grid_manager.astar_grid.update()
		print("A* grid updated for enemy base with %d buildings" % enemy_base_data.placed_buildings.size())

func _spawn_player_garrison() -> void:
	print("=== SPAWNING PLAYER GARRISON ===")
	
	if not SettlementManager.current_settlement:
		print("No current settlement found - spawning test units for demo")
		_spawn_test_units() 
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	if garrison.is_empty():
		print("No units in garrison to spawn")
		# We must still check for a loss condition
		if not objective_manager.is_defensive_mission:
			# Defer the call to the objective manager
			objective_manager.call_deferred("_check_loss_condition")
		return
	
	var units_per_row: int = player_spawn_formation.get("units_per_row", 5)
	var spacing: float = player_spawn_formation.get("spacing", 40.0)
	var current_row: int = 0
	var current_col: int = 0
	
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if not unit_data or not unit_data.scene_to_spawn:
			push_error("Failed to load unit data: %s" % unit_path)
			continue
		
		for i in range(unit_count):
			var unit_instance: Node2D = unit_data.scene_to_spawn.instantiate()
			
			if not unit_instance is BaseUnit:
				push_error("Unit scene %s does not extend BaseUnit!" % unit_data.scene_to_spawn.get_path())
				continue
				
			unit_instance.name = unit_data.display_name + "_" + str(i)
			if "data" in unit_instance:
				unit_instance.data = unit_data
			
			var spawn_pos: Vector2 = player_spawn_pos.global_position
			spawn_pos.x += current_col * spacing
			spawn_pos.y += current_row * spacing
			unit_instance.global_position = spawn_pos
			
			unit_instance.add_to_group("player_units")
			rts_controller.add_unit_to_group(unit_instance)
			add_child(unit_instance)
			
			current_col += 1
			if current_col >= units_per_row:
				current_col = 0
				current_row += 1


func _spawn_test_units() -> void:
	# This function is for debug only and does not need refactoring
	print("Spawning test units for box selection demo...")
	var units_per_row: int = 3
	var current_row: int = 0
	var current_col: int = 0
	
	for i in range(6):
		var test_unit = CharacterBody2D.new()
		var script_source = """
extends CharacterBody2D
var is_selected: bool = false; var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0; var is_moving: bool = false
func set_selected(selected: bool) -> void: is_selected = selected; queue_redraw()
func _draw() -> void:
	if is_selected: draw_circle(Vector2.ZERO, 15.0, Color(1,1,0,0.8), false, 2.0)
func command_move_to(target_pos: Vector2) -> void: target_position = target_pos; is_moving = true
func command_attack(target: Node2D) -> void: print('%s attacking %s' % [name, target.name])
func set_target_position(pos: Vector2) -> void: target_position = pos; is_moving = true
func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var dir = (target_position - global_position).normalized()
		if global_position.distance_to(target_position) < 5.0:
			is_moving = false; velocity = Vector2.ZERO
		else: velocity = dir * move_speed
		move_and_slide()
"""
		var temp_script = GDScript.new(); temp_script.source_code = script_source
		temp_script.reload(); test_unit.set_script(temp_script)
		
		var spawn_pos: Vector2 = player_spawn_pos.global_position
		spawn_pos.x += current_col * 60
		spawn_pos.y += current_row * 60
		test_unit.global_position = spawn_pos
		test_unit.add_to_group("player_units")
		add_child(test_unit)

		if test_unit is BaseUnit:
			rts_controller.add_unit_to_group(test_unit)
		else:
			push_warning("Test unit '%s' is not a BaseUnit. Skipping add to RTSController." % test_unit.name)
		
		current_col += 1
		if current_col >= units_per_row:
			current_col = 0
			current_row += 1


func _on_enemy_building_destroyed_grid_clear(building: BaseBuilding) -> void:
	"""
	Called when any enemy building is destroyed.
	This function's ONLY job is to clear the pathfinding grid.
	Loot is handled by RaidObjectiveManager.
	"""
	_clear_building_from_pathfinding_grid(building)

func _clear_building_from_pathfinding_grid(building: BaseBuilding) -> void:
	"""Remove building's collision from pathfinding grid"""
	if not building.data or not is_instance_valid(grid_manager):
		return
		
	var cell_size = grid_manager.cell_size
	var half_cell = Vector2.ONE * cell_size / 2.0
	
	var world_pos = building.global_position
	var grid_pos = Vector2i((world_pos - half_cell) / cell_size) 
	var grid_size = building.data.grid_size
	
	for x in range(grid_size.x):
		for y in range(grid_size.y):
			var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
			SettlementManager.set_astar_point_solid(cell_pos, false)
	
	if is_instance_valid(grid_manager.astar_grid):
		grid_manager.astar_grid.update()
		print("RaidMission: Cleared pathfinding for destroyed building at %s (size: %s)" % [grid_pos, grid_size])

# --- ALL WIN/LOSS FUNCTIONS REMOVED ---
# _setup_win_loss_conditions()
# _check_loss_condition()
# _on_mission_failed()
# _show_failure_message()
# _on_enemy_hall_destroyed()

--- SCRIPT: res://scenes/missions/RaidObjectiveManager.gd ---
# res://scenes/missions/RaidObjectiveManager.gd
#
# Manages all mission-specific logic for a raid, including
# loot, win conditions, and loss conditions.
# Decoupled from RaidMission.gd (which is now just a level loader).
extends Node

# --- Mission Configuration ---
# These will be set in the Inspector on this node.
@export var victory_bonus_loot: Dictionary = {"gold": 200}
# MODIFIED: This is no longer used, but we leave it to avoid breaking the .tscn file
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
@export var is_defensive_mission: bool = false

# --- Internal State ---
var raid_loot: RaidLootData
var rts_controller: RTSController
var enemy_hall: BaseBuilding
var building_container: Node2D

func _ready() -> void:
	raid_loot = RaidLootData.new()

func initialize(
	p_rts_controller: RTSController, 
	p_enemy_hall: BaseBuilding, 
	p_building_container: Node2D
) -> void:
	"""
	Called by RaidMission.gd after the level is loaded
	to pass in all necessary scene references.
	"""
	self.rts_controller = p_rts_controller
	self.enemy_hall = p_enemy_hall
	self.building_container = p_building_container
	
	if not is_instance_valid(rts_controller) or \
	   not is_instance_valid(enemy_hall) or \
	   not is_instance_valid(building_container):
		push_error("RaidObjectiveManager: Failed to initialize. Received invalid node references.")
		return
	
	print("RaidObjectiveManager: Initialized and tracking objectives.")
	
	# Connect to all necessary signals
	_connect_to_building_signals()
	_setup_win_loss_conditions()


func _connect_to_building_signals() -> void:
	# Connect to the Great Hall for the win condition
	if enemy_hall.has_signal("building_destroyed"):
		enemy_hall.building_destroyed.connect(_on_enemy_hall_destroyed)
	
	# Connect to *all* buildings for loot collection
	for building in building_container.get_children():
		if building is BaseBuilding and building.has_signal("building_destroyed"):
			building.building_destroyed.connect(_on_enemy_building_destroyed_for_loot)

# --- Objective Logic ---

func _on_enemy_building_destroyed_for_loot(building: BaseBuilding) -> void:
	"""Called when any enemy building is destroyed - collect loot."""
	var building_data = building.data as BuildingData
	
	if raid_loot and building_data:
		raid_loot.add_loot_from_building(building_data)
		print("RaidObjectiveManager: Building destroyed: %s | %s" % [building_data.display_name, raid_loot.get_loot_summary()])
	
	# Count remaining buildings for mission tracking
	var remaining_buildings = building_container.get_children().size() - 1 # -1 for the one just destroyed
	print("RaidObjectiveManager: Buildings remaining: %d" % remaining_buildings)

func _setup_win_loss_conditions() -> void:
	"""Setup win/loss condition monitoring"""
	if not is_defensive_mission:
		# Start periodic check for loss condition
		_check_loss_condition()
	else:
		print("RaidObjectiveManager: Skipping 'all units destroyed' loss check for defensive mission.")

func _check_loss_condition() -> void:
	"""Check if all player units are destroyed (loss condition)"""
	await get_tree().create_timer(1.0).timeout
	
	var remaining_units = 0
	if is_instance_valid(rts_controller):
		remaining_units = rts_controller.controllable_units.size()
	
	print("Loss check: %d units remaining" % remaining_units)
	
	if remaining_units == 0:
		_on_mission_failed()
		return # Stop the loop
	
	# Continue checking if mission is still active
	if is_instance_valid(enemy_hall):
		_check_loss_condition()
	else:
		print("Loss condition checking stopped - enemy hall destroyed")

func _on_mission_failed() -> void:
	"""Called when all player units are destroyed"""
	print("Mission Failed! All units destroyed.")
	
	_show_failure_message()
	
	await get_tree().create_timer(3.0).timeout
	
	# --- MODIFICATION ---
	EventBus.scene_change_requested.emit("settlement")
	# --- END MODIFICATION ---


func _show_failure_message() -> void:
	"""Display the mission failure message to the player"""
	var failure_popup = Control.new()
	failure_popup.name = "FailurePopup"
	failure_popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	
	var bg_panel = Panel.new()
	bg_panel.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg_panel.modulate = Color(0, 0, 0, 0.7)
	failure_popup.add_child(bg_panel)
	
	var message_container = VBoxContainer.new()
	message_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	
	var failure_label = Label.new()
	failure_label.text = "RAID FAILED!"
	failure_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(failure_label)
	
	var subtitle_label = Label.new()
	subtitle_label.text = "All units destroyed"
	subtitle_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(subtitle_label)
	
	var return_label = Label.new()
	return_label.text = "Returning to settlement..."
	return_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(return_label)
	
	failure_popup.add_child(message_container)
	# Add to the root of the scene tree to ensure it's visible
	get_tree().current_scene.add_child(failure_popup)
	print("Failure message displayed")

func _on_enemy_hall_destroyed(_building: BaseBuilding = null) -> void:
	"""Called when the enemy's Great Hall is destroyed"""
	print("Enemy Hall destroyed! Mission success!")
	
	# Add bonus loot
	raid_loot.add_loot("gold", victory_bonus_loot.get("gold", 200))
	var total_loot = raid_loot.get_total_loot()
	
	SettlementManager.deposit_resources(total_loot)
	print("Mission Complete! %s" % raid_loot.get_loot_summary())
	
	await get_tree().create_timer(2.0).timeout
	
	# --- MODIFICATION ---
	EventBus.scene_change_requested.emit("settlement")
	# --- END MODIFICATION ---

--- SCRIPT: res://scenes/world_map/MacroCamera.gd ---
# res://scenes/world_map/MacroCamera.gd
#
# Camera controller for the Macro Map.
# Implements WASD and Middle-Mouse-Drag panning [cite: 471, 472]
# with boundaries.
extends Camera2D # [cite: 468]
class_name MacroCamera

@export var camera_speed: float = 500.0
@export var bounds_enabled: bool = true 
@export var bounds_rect: Rect2 = Rect2(0, 0, 1920, 1080)

var is_dragging: bool = false
var drag_start_pos: Vector2

func _ready() -> void:
	make_current()

func _process(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	
	# WASD camera movement [cite: 471]
	if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
		movement_vector.x -= 1
	if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
		movement_vector.x += 1
	if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
		movement_vector.y -= 1
	if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
		movement_vector.y += 1
	
	if movement_vector != Vector2.ZERO:
		global_position += movement_vector.normalized() * camera_speed * delta
		
	# Apply clamping
	_clamp_camera_to_bounds()

func _unhandled_input(event: InputEvent) -> void:
	# Middle-Mouse-Drag Panning [cite: 472]
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_MIDDLE:
			if event.is_pressed():
				is_dragging = true
				drag_start_pos = get_global_mouse_position() - global_position
				get_viewport().set_input_as_handled()
			else:
				is_dragging = false
				get_viewport().set_input_as_handled()
				
	elif event is InputEventMouseMotion and is_dragging:
		global_position = get_global_mouse_position() - drag_start_pos
		_clamp_camera_to_bounds()
		get_viewport().set_input_as_handled()

func _clamp_camera_to_bounds() -> void:
	if bounds_enabled:
		global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.end.x)
		global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.end.y)

--- SCRIPT: res://scenes/world_map/MacroMap.gd ---
# res://scenes/world_map/MacroMap.gd
#
# Main controller for the Macro Map scene.
# Connects UI to the DynastyManager and handles region selection.
extends Node2D # [cite: 164]

# Scene paths for navigation (DEPRECATED, but kept to avoid breaking .tscn)
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"

# UI Node References
@onready var authority_label: Label = $UI/JarlInfo/VBoxContainer/AuthorityLabel # [cite: 164]
@onready var renown_label: Label = $UI/JarlInfo/VBoxContainer/RenownLabel # [cite: 164]
@onready var end_year_button: Button = $UI/Actions/VBoxContainer/EndYearButton # [cite: 164]
@onready var region_info_panel: PanelContainer = $UI/RegionInfo # [cite: 164]
@onready var region_name_label: Label = $UI/RegionInfo/VBoxContainer/RegionNameLabel # [cite: 164]
@onready var launch_raid_button: Button = $UI/RegionInfo/VBoxContainer/LaunchRaidButton # [cite: 164]
@onready var settlement_button: Button = $UI/Actions/VBoxContainer/SettlementButton # [cite: 164]
@onready var tooltip: PanelContainer = $UI/Tooltip # [cite: 164]
@onready var tooltip_label: Label = $UI/Tooltip/Label

@onready var regions_container: Node2D = $Regions # [cite: 165]

var selected_region_data: WorldRegionData # [cite: 165]
var selected_region_node: Region = null

func _ready() -> void:
	# Connect to the DynastyManager
	DynastyManager.jarl_stats_updated.connect(_update_jarl_ui) # [cite: 165]
	
	# Connect to all child regions [cite: 165]
	for region in regions_container.get_children():
		if region is Region:
			region.region_hovered.connect(_on_region_hovered)
			region.region_exited.connect(_on_region_exited)
			region.region_selected.connect(_on_region_selected)
			
	# Connect local UI buttons [cite: 165]
	launch_raid_button.pressed.connect(_on_launch_raid_pressed)
	end_year_button.pressed.connect(_on_end_year_pressed)
	settlement_button.pressed.connect(_on_settlement_pressed)
	
	# Initialize UI
	_update_jarl_ui(DynastyManager.get_current_jarl()) # [cite: 165]
	region_info_panel.hide()
	tooltip.hide()

func _update_jarl_ui(jarl: JarlData) -> void: # [cite: 165]
	if not jarl:
		return
		
	authority_label.text = "Authority: %d / %d" % [jarl.current_authority, jarl.max_authority] # [cite: 165]
	renown_label.text = "Renown: %d" % jarl.renown # [cite: 165]
	
	# Re-check if we can still afford the selected raid
	if selected_region_data:
		_on_region_selected(selected_region_data)

# --- Region Signal Handlers ---

func _on_region_hovered(data: WorldRegionData, _screen_position: Vector2) -> void: # [cite: 165]
	tooltip_label.text = data.display_name # [cite: 165]
	var mouse_pos = get_viewport().get_mouse_position()
	tooltip.position = mouse_pos + Vector2(15, 15)
	tooltip.show()

func _on_region_exited() -> void: # [cite: 166]
	tooltip.hide() # [cite: 166]

func _on_region_selected(data: WorldRegionData) -> void: # [cite: 166]
	# De-select the previously selected region, if any
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
		
	# Find the new region node
	for region in regions_container.get_children():
		if region is Region and region.data == data:
			selected_region_node = region
			selected_region_node.is_selected = true
			selected_region_node.set_visual_state(false) # Update visual state (hover will be false)
			break
			
	selected_region_data = data # [cite: 166]
	
	# Update the UI panel [cite: 166]
	region_name_label.text = data.display_name
	launch_raid_button.text = "Raid: %s (Cost: %d)" % [data.display_name, data.base_authority_cost] # [cite: 166]
	
	# Check if Jarl can afford this action [cite: 166]
	var can_afford = DynastyManager.can_spend_authority(data.base_authority_cost)
	launch_raid_button.disabled = not can_afford
	
	if not can_afford:
		launch_raid_button.text += "\nNot Enough Authority"
		
	region_info_panel.show()

# --- UI Button Handlers ---

func _on_launch_raid_pressed() -> void: # [cite: 167]
	if not selected_region_data:
		return
		
	# 1. Set the target for the RaidMission [cite: 167]
	DynastyManager.set_current_raid_target(selected_region_data.target_settlement_data)
	
	# 2. Spend the Authority [cite: 167]
	var success = DynastyManager.spend_authority(selected_region_data.base_authority_cost)
	
	# 3. Change scene 
	if success:
		# --- MODIFICATION ---
		EventBus.scene_change_requested.emit("raid_mission") # [cite: 167]
		# --- END MODIFICATION ---
	else:
		# This shouldn't happen if the button is disabled, but as a fallback:
		push_error("MacroMap: LaunchRaid button was pressed but authority check failed.")
		DynastyManager.set_current_raid_target(null) # Clear the target

func _on_end_year_pressed() -> void: # [cite: 167]
	DynastyManager.end_year() # [cite: 167]
	
	# Deselect region as actions may no longer be valid
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	
	selected_region_data = null
	selected_region_node = null
	region_info_panel.hide()

func _on_settlement_pressed() -> void: # [cite: 167]
	# --- MODIFICATION ---
	EventBus.scene_change_requested.emit("settlement") # [cite: 167]
	# --- END MODIFICATION ---

func _input(event: InputEvent) -> void: # [cite: 167]
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		print("MacroMap received click - this means nothing blocked it yet")

--- SCRIPT: res://scenes/world_map/Region.gd ---
# res://scenes/world_map/Region.gd
#
# Attached to an Area2D node to make a map province
# clickable and interactive.
class_name Region
extends Area2D

signal region_hovered(data: WorldRegionData, screen_position: Vector2)
signal region_exited()
signal region_selected(data: WorldRegionData)

@export var data: WorldRegionData

# Normally, we'd use a Sprite2d, but for now we'll just use a colorrect
@onready var sprite = $Sprite2D

var default_color: Color = Color(1.0, 1.0, 1.0, 0.2)
var hover_color: Color = Color(1.0, 1.0, 1.0, 0.6)
var selected_color: Color = Color(1.0, 0.9, 0.2, 0.8) # Yellow

var is_selected: bool = false

func _ready() -> void:
	if not data:
		push_error("Region node '%s' has no WorldRegionData assigned!" % name)
		queue_free()
		return
	
	# Debug collision shape
	var collision_shape = get_node_or_null("CollisionShape2D")
	if collision_shape:
		print("Region '%s' - CollisionShape2D found!" % name)
		print("  Shape: %s" % collision_shape.shape)
		if collision_shape.shape:
			print("  Shape type: %s" % collision_shape.shape.get_class())
			# Check the actual size
			if collision_shape.shape is RectangleShape2D:
				print("  Rectangle size: %s" % collision_shape.shape.size)
			elif collision_shape.shape is CircleShape2D:
				print("  Circle radius: %s" % collision_shape.shape.radius)
		else:
			push_error("  ERROR: Shape is NULL!")
	else:
		push_error("Region '%s' - CollisionShape2D NOT FOUND!" % name)
	
	print("Region '%s' initialized at position: %s" % [name, global_position])
	print("  - Input Pickable: %s" % input_pickable)
	print("  - Monitoring: %s" % monitoring)
	print("  - Monitorable: %s" % monitorable)
	
	# Connect to our own signals
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	input_event.connect(_on_input_event)
	
	if sprite:
		sprite.material = CanvasItemMaterial.new()
		sprite.material.blend_mode = CanvasItemMaterial.BLEND_MODE_MIX
		set_visual_state(false)
	else:
		push_warning("Region node '%s' is missing its $Sprite2D child." % name)

# Debug: Track ALL mouse clicks globally
func _input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		var screen_pos = get_viewport().get_mouse_position()
		var world_pos = get_global_mouse_position()
		var canvas_pos = get_canvas_transform().affine_inverse() * screen_pos
		print("=== LEFT CLICK DETECTED ===")
		print("  Screen position: %s" % screen_pos)
		print("  World position (get_global_mouse): %s" % world_pos)
		print("  Canvas position (corrected): %s" % canvas_pos)
		print("  Region '%s' position: %s" % [name, global_position])
		print("  Distance to region (world): %s" % global_position.distance_to(world_pos))
		print("  Distance to region (canvas): %s" % global_position.distance_to(canvas_pos))

func set_visual_state(is_hovered: bool) -> void:
	if not sprite:
		return
		
	var target_color: Color
	if is_selected:
		target_color = selected_color
	elif is_hovered:
		target_color = hover_color
	else:
		target_color = default_color
		
	var tween = create_tween()
	tween.tween_property(sprite, "modulate", target_color, 0.1).set_trans(Tween.TRANS_SINE)

func _on_mouse_entered() -> void:
	# --- DEBUGGING CODE ---
	print("DEBUG: Mouse ENTERED region: %s" % data.display_name)
	# --- END DEBUGGING ---
	
	set_visual_state(true)
	emit_signal("region_hovered", data, get_global_mouse_position())

func _on_mouse_exited() -> void:
	# --- DEBUGGING CODE ---
	print("DEBUG: Mouse EXITED region: %s" % data.display_name)
	# --- END DEBUGGING ---
	
	set_visual_state(false)
	emit_signal("region_exited")

func _on_input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	print("Input event in region: %s, event: %s" % [data.display_name, event])
	# Check for left mouse button click
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		print("Region clicked: %s" % data.display_name)
		is_selected = true
		set_visual_state(true)
		emit_signal("region_selected", data)
		get_viewport().set_input_as_handled()

--- SCRIPT: res://scenes/world_map/WorldMap_Stub.gd ---
# res://scenes/world_map/WorldMap_Stub.gd
# World map interface for selecting raid targets
# GDD Ref: Phase 3 Task 6

extends Control

# --- MODIFIED: Use String paths, not PackedScene ---
## The main raid mission scene to load (e.g., RaidMission.tscn)
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"

## The scene to return to (e.g., SettlementBridge.tscn)
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
# --- END MODIFICATION ---

@onready var raid_monastery_button: Button = $ButtonContainer/RaidMonasteryButton
@onready var back_button: Button = $ButtonContainer/BackButton

func _ready() -> void:
	raid_monastery_button.pressed.connect(_on_raid_monastery_pressed)
	back_button.pressed.connect(_on_back_pressed)
	
	# Validate that we can actually raid (have settlement & units)
	_validate_raid_capability()

func _validate_raid_capability() -> void:
	"""Ensure the player can actually start a raid"""
	if not SettlementManager.current_settlement:
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Settlement Loaded"
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Units Available"
		return
	
	raid_monastery_button.disabled = false

func _on_raid_monastery_pressed() -> void:
	"""Launch the raid mission"""
	print("Starting raid on nearby monastery...")
	
	# Additional validation before starting raid
	if not SettlementManager.current_settlement:
		push_error("Cannot start raid: No settlement loaded")
		return
	
	# --- MODIFIED: Emit signal ---
	if not raid_mission_scene_path.is_empty():
		EventBus.scene_change_requested.emit(raid_mission_scene_path)
	else:
		push_error("WorldMap_Stub: raid_mission_scene_path is not set! Cannot start raid.")
	# --- END MODIFICATION ---

func _on_back_pressed() -> void:
	"""Return to the settlement"""
	print("Returning to settlement...")
	
	# --- MODIFIED: Emit signal ---
	if not settlement_bridge_scene_path.is_empty():
		EventBus.scene_change_requested.emit(settlement_bridge_scene_path)
	else:
		push_error("WorldMap_Stub: settlement_bridge_scene_path is not set! Cannot return.")
	# --- END MODIFICATION ---

--- SCRIPT: res://scripts/ai/SentryAI.gd ---
# res://scripts/ai/SentryAI.gd
# Simple Sentry AI for enemy defenders in Phase 3
# GDD Ref: Phase 3 - Enemy MVP (Simple Sentry AI)

extends Node2D
class_name SentryAI

@export var detection_radius: float = 80.0
@export var attack_damage: int = 25
@export var attack_cooldown: float = 1.5

var detection_area: Area2D
var attack_timer: float = 0.0
var current_target: Node2D = null

signal enemy_detected(target: Node2D)
signal attack_executed(target: Node2D, damage: int)

func _ready() -> void:
	_setup_detection_area()
	set_process(true)

func _setup_detection_area() -> void:
	"""Create detection area for sentry"""
	detection_area = Area2D.new()
	detection_area.name = "DetectionArea"
	
	var collision_shape = CollisionShape2D.new()
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = detection_radius
	collision_shape.shape = circle_shape
	
	detection_area.add_child(collision_shape)
	add_child(detection_area)
	
	# Connect signals
	detection_area.body_entered.connect(_on_body_entered)
	detection_area.body_exited.connect(_on_body_exited)
	
	# Set collision mask to detect player units (layer 1)
	detection_area.collision_mask = 1

func _process(delta: float) -> void:
	# Update attack timer
	if attack_timer > 0:
		attack_timer -= delta
	
	# Check for and attack valid targets
	if current_target and is_instance_valid(current_target):
		if attack_timer <= 0:
			_attack_target(current_target)
			attack_timer = attack_cooldown
	else:
		current_target = null

func _on_body_entered(body: Node2D) -> void:
	"""Handle detection of player units"""
	if body.is_in_group("player_units") and not current_target:
		current_target = body
		enemy_detected.emit(body)
		print("%s detected enemy: %s" % [get_parent().name, body.name])

func _on_body_exited(body: Node2D) -> void:
	"""Handle player units leaving detection range"""
	if body == current_target:
		current_target = null
		print("%s lost target: %s" % [get_parent().name, body.name])

func _attack_target(target: Node2D) -> void:
	"""Execute attack on target"""
	if not target or not is_instance_valid(target):
		return
	
	# Check if target is still in range
	var distance = global_position.distance_to(target.global_position)
	if distance > detection_radius:
		current_target = null
		return
	
	print("%s attacking %s for %d damage" % [get_parent().name, target.name, attack_damage])
	
	# Apply damage if target has take_damage method
	if target.has_method("take_damage"):
		target.take_damage(attack_damage)
	elif target.has_method("receive_damage"):
		target.receive_damage(attack_damage)
	else:
		# Fallback: just remove the target for demo purposes
		print("Target %s destroyed by sentry attack" % target.name)
		target.queue_free()
	
	attack_executed.emit(target, attack_damage)

func get_detection_radius() -> float:
	"""Get current detection radius"""
	return detection_radius

func set_detection_radius(new_radius: float) -> void:
	"""Update detection radius"""
	detection_radius = new_radius
	if detection_area:
		var collision_shape = detection_area.get_child(0) as CollisionShape2D
		if collision_shape and collision_shape.shape is CircleShape2D:
			collision_shape.shape.radius = detection_radius

func is_actively_defending() -> bool:
	"""Check if sentry is currently engaged with a target"""
	return current_target != null and is_instance_valid(current_target)

--- SCRIPT: res://scripts/ai/UnitFSM.gd ---
# res://scripts/ai/UnitFSM.gd
# Refactored UnitFSM for Phase 3 RTS commands
# GDD Ref: Phase 3 Task 4

class_name UnitFSM

enum State { IDLE, MOVING, ATTACKING }
enum Stance { DEFENSIVE, HOLD_POSITION } # Future-proofed for other stances

# Unit References
var unit: BaseUnit
var attack_timer: Timer

# State Data
var current_state: State = State.IDLE
var stance: Stance = Stance.DEFENSIVE
var path: Array = []

# Target Data
var target_position: Vector2 = Vector2.ZERO
var target_unit: Node2D = null # Can be BaseBuilding or BaseUnit
var move_command_position: Vector2 = Vector2.ZERO

func _init(p_unit: BaseUnit, p_timer: Timer) -> void:
	unit = p_unit
	attack_timer = p_timer
	
	# Connect the timer's timeout signal to our attack function
	attack_timer.timeout.connect(_on_attack_timer_timeout)

func change_state(new_state: State) -> void:
	if current_state == new_state:
		return
	
	_exit_state(current_state)
	current_state = new_state
	# Notify unit visuals of state change
	if unit and unit.has_method("on_state_changed"):
		unit.on_state_changed(current_state)
	_enter_state(current_state)

func _enter_state(state: State) -> void:
	match state:
		State.IDLE:
			print("%s entering IDLE state." % unit.data.display_name)
			unit.velocity = Vector2.ZERO
			
		State.MOVING:
			print("%s entering MOVING state to %s." % [unit.data.display_name, target_position])
			_recalculate_path()
			
		State.ATTACKING:
			print("%s entering ATTACKING state." % unit.data.display_name)
			unit.velocity = Vector2.ZERO
			# Set timer wait time based on unit's attack speed
			attack_timer.wait_time = 1.0 / unit.data.attack_speed
			attack_timer.start()
			# Attack immediately on entering state
			_on_attack_timer_timeout()

func _exit_state(state: State) -> void:
	match state:
		State.MOVING:
			path.clear()
		State.ATTACKING:
			attack_timer.stop()

func _recalculate_path() -> void:
	path = SettlementManager.get_astar_path(unit.global_position, target_position)
	if path.is_empty():
		print("Unit at %s failed to find a path to %s." % [unit.global_position, target_position])
		# Visual error feedback
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		# If we can't find a path, check if we're already close to the target
		if unit.global_position.distance_to(target_position) < (unit.data.attack_range + 16):
			if target_unit:
				change_state(State.ATTACKING)
			else:
				change_state(State.IDLE)
		else:
			change_state(State.IDLE)
	else:
		print("Unit found new path. Waypoints: %d" % path.size())

# --- RTS Command Functions ---

func command_move_to(target_pos: Vector2) -> void:
	"""Command the unit to move to a specific position"""
	target_position = target_pos
	move_command_position = target_pos
	target_unit = null # Clear any attack target
	change_state(State.MOVING)

func command_attack(target: Node2D) -> void:
	"""Command the unit to attack a specific target"""
	print("DEBUG: %s received attack command on target: %s" % [unit.data.display_name, target.name])
	
	if not is_instance_valid(target):
		print("Cannot attack invalid target")
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		return
		
	target_unit = target
	target_position = target.global_position
	
	# Check if we're already in range
	var distance: float = unit.global_position.distance_to(target.global_position)
	print("DEBUG: Current distance to target: %s, attack range: %s" % [distance, unit.data.attack_range])
	
	if distance <= unit.data.attack_range:
		print("DEBUG: Target in range, transitioning to ATTACKING")
		change_state(State.ATTACKING)
	else:
		print("DEBUG: Target out of range, transitioning to MOVING")
		change_state(State.MOVING)

# --- State Machine Update ---

func update(delta: float) -> void:
	match current_state:
		State.IDLE:
			_idle_state(delta)
		State.MOVING:
			_move_state(delta)
		State.ATTACKING:
			_attack_state(delta)

# --- State Logic Functions ---

func _idle_state(_delta: float) -> void:
	# In idle state, unit stands still
	unit.velocity = Vector2.ZERO

func _move_state(delta: float) -> void:
	# First priority: Check if we have a valid attack target and are in range
	if is_instance_valid(target_unit):
		var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
		print("DEBUG MOVE: %s distance to %s: %.1f (range: %.1f)" % [
			unit.data.display_name, 
			target_unit.name, 
			distance_to_target, 
			unit.data.attack_range
		])
		if distance_to_target <= unit.data.attack_range:
			print("Unit in attack range, switching to ATTACKING.")
			change_state(State.ATTACKING)
			return
		else:
			# Update target position if target moved
			target_position = target_unit.global_position
	
	# Handle defensive stance: Check for nearby enemies if being attacked
	if stance == Stance.DEFENSIVE:
		_check_defensive_response()
	
	# If we're not in range, check if our path is empty
	if path.is_empty():
		# If we have an attack target but no path, try to recalculate
		if is_instance_valid(target_unit):
			_recalculate_path()
			return
		else:
			# No target and no path, we've reached our destination
			print("Unit reached destination.")
			change_state(State.IDLE)
			return
	
	# Move along the path
	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	unit.move_and_slide()
	
	# Check if we've reached the current waypoint
	var arrival_radius: float = 8.0 
	if unit.global_position.distance_to(next_waypoint) < arrival_radius:
		path.pop_front()
		
		# If that was the last waypoint, check what to do next
		if path.is_empty():
			if is_instance_valid(target_unit):
				var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
				if distance_to_target <= unit.data.attack_range:
					change_state(State.ATTACKING)
				else:
					# Target moved, recalculate path
					_recalculate_path()
			else:
				# Just a move command, we're done
				change_state(State.IDLE)

func _attack_state(_delta: float) -> void:
	# Debug output for attack state
	print("DEBUG: %s in ATTACKING state - timer running: %s" % [unit.data.display_name, not attack_timer.is_stopped()])
	
	# Check if target is still valid
	if not is_instance_valid(target_unit):
		print("%s target destroyed or invalid. Returning to IDLE." % unit.data.display_name)
		change_state(State.IDLE)
		return
	
	# Check if target moved out of range
	var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
	print("DEBUG: Distance to target: %s, Attack range: %s" % [distance_to_target, unit.data.attack_range])
	
	if distance_to_target > unit.data.attack_range + 8: # Reduced buffer to avoid oscillation
		print("%s target moved out of range. Re-engaging." % unit.data.display_name)
		target_position = target_unit.global_position
		change_state(State.MOVING)

func _check_defensive_response() -> void:
	"""Check if unit should respond defensively to being attacked"""
	# This is a placeholder for future implementation
	# In a real implementation, this might check for nearby enemies
	# or respond to damage events
	pass

# --- Signal Callback ---

func _on_attack_timer_timeout() -> void:
	"""Called every time the AttackTimer finishes"""
	if current_state != State.ATTACKING:
		return
		
	if is_instance_valid(target_unit):
		print("%s attacks %s!" % [unit.data.display_name, target_unit.name])
		
		# Check if target has a take_damage method
		if target_unit.has_method("take_damage"):
			target_unit.take_damage(unit.data.attack_damage)
		else:
			print("Target %s does not have take_damage method" % target_unit.name)
	else:
		print("Attack timer fired but no valid target")
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		change_state(State.IDLE)

--- SCRIPT: res://scripts/buildings/SettlementBridge.gd ---
# res://scripts/buildings/SettlementBridge.gd
#
# --- REFACTORED (The "Proper Fix" + GridManager) ---
# This scene now instances a GridManager node for all grid logic.
# It gets the grid from that child and registers it with the SettlementManager.

extends Node

# --- Exported Resources ---
@export var home_base_data: SettlementData
@export var test_building_data: BuildingData
@export var raider_scene: PackedScene
@export var welcome_popup_scene: PackedScene
@export var world_map_scene_path: String = "res://scenes/world_map/WorldMap_Stub.tscn"

# --- DEPRECATED: Grid config is now on the GridManager node ---
# @export var cell_size: int = 32
# @export var grid_width: int = 60
# @export var grid_height: int = 40

# --- Default Assets (fallback) ---
var default_test_building: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
var default_raider_scene: PackedScene 
var default_welcome_popup: PackedScene = preload("res://ui/WelcomeHome_Popup.tscn")

# --- Scene Node References ---
@onready var unit_container: Node2D = $UnitContainer
@onready var ui_layer: CanvasLayer = $UI
@onready var restart_button: Button = $UI/RestartButton
@onready var start_raid_button: Button = $UI/StartRaidButton
@onready var storefront_ui: Control = $UI/Storefront_UI
@onready var building_cursor: Node2D = $BuildingCursor
var welcome_popup: PanelContainer

# --- Local Node References ---
@onready var building_container: Node2D = $BuildingContainer
@onready var grid_manager: Node = $GridManager # Reference to our new scene

# --- State Variables ---
var great_hall_instance: BaseBuilding = null
var game_is_over: bool = false
var awaiting_placement: BuildingData = null


func _ready() -> void:
	_setup_default_resources()
	_initialize_settlement() 
	_setup_ui()
	_connect_signals()
	_handle_welcome_payout()

func _exit_tree() -> void:
	SettlementManager.unregister_active_scene_nodes()

func _setup_default_resources() -> void:
	if not test_building_data:
		test_building_data = default_test_building
	if not raider_scene:
		raider_scene = load("res://scenes/units/VikingRaider.tscn")
	if not welcome_popup_scene: 
		welcome_popup_scene = default_welcome_popup

func _initialize_settlement() -> void:
	"""Initialize data, then grid, then spawn buildings."""
	if not home_base_data:
		home_base_data = _create_default_settlement()
		print("SettlementBridge: Created default settlement data")
	else:
		if not home_base_data is SettlementData:
			push_warning("SettlementBridge: Inspector data is not SettlementData, creating default")
			home_base_data = _create_default_settlement()
		else:
			print("SettlementBridge: Using inspector settlement data")
	
	if home_base_data and (not home_base_data.resource_path or home_base_data.resource_path.is_empty()):
		home_base_data.resource_path = "res://data/settlements/home_base_fixed.tres"
		print("SettlementBridge: Set resource_path to: %s" % home_base_data.resource_path)
	
	# 1. Load data into the manager
	SettlementManager.load_settlement(home_base_data)
	
	# 2. Get the grid from our new GridManager child
	if not is_instance_valid(grid_manager) or not "astar_grid" in grid_manager:
		push_error("SettlementBridge: GridManager node is missing or invalid!")
		return
	var local_astar_grid = grid_manager.astar_grid
	
	# 3. Register our local nodes with the manager
	SettlementManager.register_active_scene_nodes(local_astar_grid, building_container)
	
	# 4. Spawn buildings into our local container
	_spawn_placed_buildings()
	
	# 5. Emit signal for other nodes (like StorefrontUI)
	EventBus.settlement_loaded.emit(home_base_data)

# --- REMOVED _initialize_local_grid() ---
# This logic is now inside GridManager.gd

func _spawn_placed_buildings() -> void:
	"""
	Instantiates buildings from the loaded settlement data
	using the (now delegated) SettlementManager.place_building function.
	"""
	if not SettlementManager.current_settlement:
		push_error("SettlementBridge: Cannot spawn buildings, no settlement data loaded.")
		return
	
	for child in building_container.get_children():
		child.queue_free()

	for building_entry in SettlementManager.current_settlement.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if building_data:
			var new_building = SettlementManager.place_building(building_data, grid_pos)
			if new_building and new_building.data.display_name == "Great Hall":
				_setup_great_hall(new_building)
		else:
			push_error("Failed to load building resource from path: %s" % building_res_path)
	
	# Update grid once after all buildings are placed
	if is_instance_valid(SettlementManager.active_astar_grid):
		SettlementManager.active_astar_grid.update()
	
	print("SettlementBridge: Spawned %d buildings." % building_container.get_child_count())


func _create_default_settlement() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 100, "stone": 200}
	var empty_buildings: Array[Dictionary] = []
	settlement.placed_buildings = empty_buildings
	settlement.garrisoned_units = {}
	settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
	return settlement

func _setup_ui() -> void:
	welcome_popup = welcome_popup_scene.instantiate()
	ui_layer.add_child(welcome_popup)
	welcome_popup.collect_button_pressed.connect(_on_payout_collected)

func _connect_signals() -> void:
	restart_button.pressed.connect(_on_restart_pressed)
	start_raid_button.pressed.connect(_on_start_raid_pressed)
	
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	EventBus.building_ready_for_placement.connect(_on_building_ready_for_placement)
	EventBus.building_placement_cancelled.connect(_on_building_placement_cancelled)
	
	if building_cursor:
		building_cursor.placement_completed.connect(_on_building_placement_completed)
		building_cursor.placement_cancelled.connect(_on_building_placement_cancelled_by_cursor)

func _handle_welcome_payout() -> void:
	var payout = SettlementManager.calculate_payout()
	if not payout.is_empty():
		welcome_popup.display_payout(payout)
		storefront_ui.hide()

func _on_settlement_loaded(_settlement_data: SettlementData) -> void:
	pass

func _unhandled_input(event: InputEvent) -> void:
	if game_is_over or (welcome_popup and welcome_popup.visible):
		return
	
	if event.is_action_pressed("ui_accept") and not awaiting_placement:
		if is_instance_valid(grid_manager) and "astar_grid" in grid_manager:
			var mouse_pos = get_viewport().get_mouse_position()
			var cell_size = grid_manager.cell_size
			var grid_coord = Vector2i(int(mouse_pos.x / cell_size), int(mouse_pos.y / cell_size)) 
			print("CLICKED GRID COORDINATE: ", grid_coord)
			get_viewport().set_input_as_handled()
		else:
			print("Cannot find coordinate: GridManager not initialized")

func _on_payout_collected(payout: Dictionary) -> void:
	SettlementManager.deposit_resources(payout)
	storefront_ui.show()

func _setup_great_hall(hall_instance: BaseBuilding) -> void:
	if not is_instance_valid(hall_instance):
		push_error("SettlementBridge: Invalid Great Hall instance provided.")
		return
	
	great_hall_instance = hall_instance
	great_hall_instance.building_destroyed.connect(_on_great_hall_destroyed)
	print("Great Hall found and connected.")

func _on_great_hall_destroyed(_building: BaseBuilding) -> void:
	print("GAME OVER: The Great Hall has been destroyed!")
	game_is_over = true
	var label : Label = $UI/Label
	label.text = "YOU HAVE BEEN SACKED."
	restart_button.show()
	_destroy_all_enemies()

func _destroy_all_enemies() -> void:
	for enemy in unit_container.get_children():
		enemy.queue_free()
	print("All surviving enemies have been removed.")

func _on_restart_pressed() -> void:
	get_tree().reload_current_scene()

func _on_start_raid_pressed() -> void:
	print("Opening world map...")
	
	if not SettlementManager.current_settlement:
		push_error("Cannot open world map: No settlement loaded")
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		print("Warning: No units in garrison. Adding test unit.")
		var test_unit_path = "res://data/units/Unit_Raider.tres"
		SettlementManager.current_settlement.garrisoned_units[test_unit_path] = 2
		SettlementManager.save_settlement()
	
	print("Settlement loaded with garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
	
	if not world_map_scene_path.is_empty():
		EventBus.scene_change_requested.emit("world_map")
	else:
		push_error("world_map_scene_path is not set! Cannot change scene.")

# --- Building Cursor System Functions ---

func _on_building_ready_for_placement(building_data: BuildingData) -> void:
	awaiting_placement = building_data
	# Pass the cell_size from our GridManager to the cursor
	building_cursor.cell_size = grid_manager.cell_size
	building_cursor.set_building_preview(building_data)
	print("Building ready for placement: %s" % building_data.display_name)

func _on_building_placement_cancelled(building_data: BuildingData) -> void:
	print("Building placement cancelled: %s" % building_data.display_name)

func _on_building_placement_completed() -> void:
	print("Building placement completed successfully. Saving settlement.")
	
	if awaiting_placement and SettlementManager.current_settlement:
		var snapped_grid_pos = Vector2i(building_cursor.global_position / grid_manager.cell_size)
		
		var building_entry = {
			"resource_path": awaiting_placement.resource_path,
			"grid_position": snapped_grid_pos
		}
		SettlementManager.current_settlement.placed_buildings.append(building_entry)
		SettlementManager.save_settlement()
		print("Added %s to settlement data at %s" % [awaiting_placement.display_name, snapped_grid_pos])
	
	awaiting_placement = null

func _on_building_placement_cancelled_by_cursor() -> void:
	if awaiting_placement:
		SettlementManager.deposit_resources(awaiting_placement.build_cost)
		print("Building placement cancelled by cursor, refunded: %s" % awaiting_placement.build_cost)
		
		awaiting_placement = null

--- SCRIPT: res://scripts/formations/SquadFormation.gd ---
# res://scripts/formations/SquadFormation.gd
# Squad Formation Manager - Company of Heroes style formations
# Handles formation positioning and movement for multiple units

class_name SquadFormation

enum FormationType {
	LINE,      # Horizontal line formation  
	COLUMN,    # Vertical column formation
	WEDGE,     # V-shaped formation
	BOX,       # Rectangular formation
	CIRCLE     # Circular formation
}

# Formation settings
var formation_type: FormationType = FormationType.LINE
var unit_spacing: float = 40.0
var max_units_per_row: int = 4

# Squad data
var units: Array[Node2D] = []
var leader_position: Vector2 = Vector2.ZERO
var target_position: Vector2 = Vector2.ZERO
var formation_center: Vector2 = Vector2.ZERO

# Movement state
var is_moving: bool = false
var move_speed: float = 100.0

func _init(squad_units: Array[Node2D] = []) -> void:
	units = squad_units
	if not units.is_empty():
		formation_center = _calculate_center_position()

func add_unit(unit: Node2D) -> void:
	"""Add a unit to the squad"""
	if unit not in units:
		units.append(unit)
		_update_formation_positions()

func remove_unit(unit: Node2D) -> void:
	"""Remove a unit from the squad"""
	units.erase(unit)
	_update_formation_positions()

func set_formation_type(new_type: FormationType) -> void:
	"""Change the formation type"""
	formation_type = new_type
	_update_formation_positions()

func move_to_position(target_pos: Vector2) -> void:
	"""Command the entire squad to move to a target position"""
	target_position = target_pos
	is_moving = true
	
	# Calculate formation positions around the target
	var formation_positions = _calculate_formation_positions(target_pos)
	
	# Assign each unit a position in the formation
	for i in range(min(units.size(), formation_positions.size())):
		var unit = units[i]
		var target_formation_pos = formation_positions[i]
		
		# Move the unit to its formation position
		_move_unit_to_position(unit, target_formation_pos)
	
	print("Squad moving to %s in %s formation with %d units" % [target_pos, FormationType.keys()[formation_type], units.size()])

func _calculate_formation_positions(center_pos: Vector2) -> Array[Vector2]:
	"""Calculate formation positions based on formation type"""
	var positions: Array[Vector2] = []
	var unit_count = units.size()
	
	match formation_type:
		FormationType.LINE:
			positions = _calculate_line_formation(center_pos, unit_count)
		FormationType.COLUMN:
			positions = _calculate_column_formation(center_pos, unit_count)
		FormationType.WEDGE:
			positions = _calculate_wedge_formation(center_pos, unit_count)
		FormationType.BOX:
			positions = _calculate_box_formation(center_pos, unit_count)
		FormationType.CIRCLE:
			positions = _calculate_circle_formation(center_pos, unit_count)
	
	return positions

func _calculate_line_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate horizontal line formation positions"""
	var positions: Array[Vector2] = []
	var start_x = center_pos.x - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(start_x + i * unit_spacing, center_pos.y)
		positions.append(pos)
	
	return positions

func _calculate_column_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate vertical column formation positions"""
	var positions: Array[Vector2] = []
	var start_y = center_pos.y - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(center_pos.x, start_y + i * unit_spacing)
		positions.append(pos)
	
	return positions

func _calculate_wedge_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate V-shaped wedge formation positions"""
	var positions: Array[Vector2] = []
	
	# Leader at the front
	positions.append(center_pos)
	
	# Place remaining units in V formation behind the leader
	var side_offset = unit_spacing * 0.7  # 70% spacing for tighter formation
	var rear_offset = unit_spacing
	
	for i in range(1, unit_count):
		var row = (i + 1) / 2  # Which row behind the leader
		var side = 1 if i % 2 == 1 else -1  # Left or right side
		
		var pos = Vector2(
			center_pos.x + side * side_offset * row,
			center_pos.y + rear_offset * row
		)
		positions.append(pos)
	
	return positions

func _calculate_box_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate rectangular box formation positions"""
	var positions: Array[Vector2] = []
	
	var rows = int(ceil(float(unit_count) / max_units_per_row))
	var cols = min(unit_count, max_units_per_row)
	
	var start_x = center_pos.x - (cols - 1) * unit_spacing * 0.5
	var start_y = center_pos.y - (rows - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var row = i / max_units_per_row
		var col = i % max_units_per_row
		
		# Center the last row if it has fewer units
		var row_unit_count = min(max_units_per_row, unit_count - row * max_units_per_row)
		var row_start_x = center_pos.x - (row_unit_count - 1) * unit_spacing * 0.5
		
		var pos = Vector2(
			row_start_x + col * unit_spacing,
			start_y + row * unit_spacing
		)
		positions.append(pos)
	
	return positions

func _calculate_circle_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate circular formation positions"""
	var positions: Array[Vector2] = []
	var radius = max(unit_spacing, unit_count * unit_spacing / (2 * PI))
	
	for i in range(unit_count):
		var angle = (2 * PI * i) / unit_count
		var pos = Vector2(
			center_pos.x + cos(angle) * radius,
			center_pos.y + sin(angle) * radius
		)
		positions.append(pos)
	
	return positions

func _move_unit_to_position(unit: Node2D, target_pos: Vector2) -> void:
	"""Move a specific unit to a target position"""
	if not is_instance_valid(unit):
		return
	
	# Check if unit has FSM (proper unit system)
	if "fsm" in unit and unit.fsm != null:
		unit.fsm.command_move_to(target_pos)
	# Check if unit has direct movement method
	elif unit.has_method("command_move_to"):
		unit.command_move_to(target_pos)
	# Fallback: simple movement for test units
	else:
		_simple_unit_movement(unit, target_pos)

func _simple_unit_movement(unit: Node2D, target_pos: Vector2) -> void:
	"""Simple movement system for test units without FSM"""
	if not unit.has_method("set_target_position"):
		# Add simple movement script to unit if it doesn't have one
		var movement_script = """
var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0
var is_moving: bool = false

func set_target_position(pos: Vector2) -> void:
	target_position = pos
	is_moving = true

func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var direction = (target_position - global_position).normalized()
		var distance = global_position.distance_to(target_position)
		
		if distance < 5.0:
			is_moving = false
			velocity = Vector2.ZERO
		else:
			velocity = direction * move_speed
		
		move_and_slide()
"""
		# Create and attach movement behavior
		var script = GDScript.new()
		script.source_code = unit.get_script().source_code + "\n" + movement_script
		script.reload()
		unit.set_script(script)
	
	# Set the target position
	unit.set_target_position(target_pos)

func _update_formation_positions() -> void:
	"""Update formation positions for current units"""
	if not units.is_empty():
		formation_center = _calculate_center_position()

func _calculate_center_position() -> Vector2:
	"""Calculate the center position of all units"""
	if units.is_empty():
		return Vector2.ZERO
	
	var total_pos = Vector2.ZERO
	for unit in units:
		if is_instance_valid(unit):
			total_pos += unit.global_position
	
	return total_pos / units.size()

func get_unit_count() -> int:
	"""Get the number of units in the squad"""
	return units.size()

func is_squad_moving() -> bool:
	"""Check if the squad is currently moving"""
	return is_moving

func get_formation_info() -> Dictionary:
	"""Get information about the current formation"""
	return {
		"type": FormationType.keys()[formation_type],
		"unit_count": units.size(),
		"spacing": unit_spacing,
		"center": formation_center,
		"is_moving": is_moving
	}

--- SCRIPT: res://scripts/ui/BuildingPreviewCursor.gd ---
# BuildingPreviewCursor.gd - RTS-style building placement system
extends Node2D
class_name BuildingPreviewCursor

# Building preview components
var current_building_data: BuildingData
var preview_sprite: Sprite2D
var is_active: bool = false

# Grid and placement
var cell_size: int = 32 # This is now SET by the scene (e.g., SettlementBridge)
var grid_overlay: Node2D
var can_place: bool = false

# Visual feedback
var valid_color: Color = Color(0.0, 1.0, 0.0, 0.7)    # Green for valid placement
var invalid_color: Color = Color(1.0, 0.0, 0.0, 0.7)  # Red for invalid placement

signal placement_completed
signal placement_cancelled

func _ready() -> void:
	# Ensure we're always on top for visibility
	z_index = 100
	
	# Create grid overlay for visual feedback
	grid_overlay = Node2D.new()
	grid_overlay.name = "GridOverlay"
	add_child(grid_overlay)
	
	# --- THIS IS THE FIX ---
	# Removed dependency on SettlementManager.tile_size
	# The 'cell_size' var will be set externally by SettlementBridge.gd
	# -----------------------
	print("BuildingPreviewCursor ready. Waiting for cell_size to be set.")

func set_building_preview(building_data: BuildingData) -> void:
	"""Start building placement mode with the specified building"""
	if not building_data:
		print("ERROR: No building data provided to set_building_preview")
		return
	
	if cell_size <= 0:
		push_error("BuildingPreviewCursor: cell_size is not set! Cannot create preview.")
		return
	
	print("Setting building preview for: %s" % building_data.display_name)
	current_building_data = building_data
	
	# Clean up any existing preview
	_cleanup_preview()
	
	# Create new preview sprite
	preview_sprite = Sprite2D.new()
	preview_sprite.name = "PreviewSprite"
	
	# Set up the building texture
	if building_data.building_texture:
		preview_sprite.texture = building_data.building_texture
	else:
		# Create a simple colored rectangle if no texture
		var texture = _create_building_texture(building_data)
		preview_sprite.texture = texture
		print("Created fallback texture for preview")
	
	
	# --- Automatic Scaling Logic ---
	
	# 1. Get the target size based on grid
	var target_size: Vector2 = Vector2(building_data.grid_size) * cell_size
	
	# 2. Scale the Sprite (if texture exists)
	if preview_sprite.texture:
		var texture_size: Vector2 = preview_sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			var new_scale: Vector2 = target_size / texture_size
			preview_sprite.scale = new_scale
		else:
			push_warning("BuildingPreviewCursor: Texture for '%s' has invalid size %s. Cannot scale preview." % [building_data.display_name, texture_size])
	else:
		push_warning("BuildingPreviewCursor: No texture for '%s' preview." % building_data.display_name)
			
	# --- END SCALING LOGIC ---

	
	# Set semi-transparent
	preview_sprite.modulate = valid_color
	add_child(preview_sprite)
	
	# Create grid outline to show building footprint
	_create_grid_outline(building_data.grid_size)
	
	# Activate placement mode
	is_active = true
	visible = true

func _create_building_texture(building_data: BuildingData) -> ImageTexture:
	"""Create a simple colored texture for buildings without textures"""
	var size = Vector2i(
		building_data.grid_size.x * cell_size,
		building_data.grid_size.y * cell_size
	)
	
	var image = Image.create(size.x, size.y, false, Image.FORMAT_RGBA8)
	var color = _get_building_color(building_data)
	image.fill(color)
	
	var texture = ImageTexture.new()
	texture.set_image(image)
	return texture

func _create_grid_outline(grid_size: Vector2i) -> void:
	"""Create a visual outline showing the building's grid footprint"""
	_clear_grid_overlay()
	
	var outline_color = Color.WHITE
	var line_width = 2.0
	
	# This var 'rect_size' now correctly uses the synced 'cell_size'
	var rect_size = Vector2(grid_size.x * cell_size, grid_size.y * cell_size)
	
	# Create outline using Line2D nodes for each edge
	var lines = []
	
	# Top line
	var top_line = Line2D.new()
	top_line.add_point(Vector2(0, 0))
	top_line.add_point(Vector2(rect_size.x, 0))
	top_line.width = line_width
	top_line.default_color = outline_color
	lines.append(top_line)
	
	# Right line
	var right_line = Line2D.new()
	right_line.add_point(Vector2(rect_size.x, 0))
	right_line.add_point(Vector2(rect_size.x, rect_size.y))
	right_line.width = line_width
	right_line.default_color = outline_color
	lines.append(right_line)
	
	# Bottom line
	var bottom_line = Line2D.new()
	bottom_line.add_point(Vector2(rect_size.x, rect_size.y))
	bottom_line.add_point(Vector2(0, rect_size.y))
	bottom_line.width = line_width
	bottom_line.default_color = outline_color
	lines.append(bottom_line)
	
	# Left line
	var left_line = Line2D.new()
	left_line.add_point(Vector2(0, rect_size.y))
	left_line.add_point(Vector2(0, 0))
	left_line.width = line_width
	left_line.default_color = outline_color
	lines.append(left_line)
	
	# Add lines to grid overlay
	for line in lines:
		grid_overlay.add_child(line)

func _clear_grid_overlay() -> void:
	"""Clear the grid overlay visual elements"""
	for child in grid_overlay.get_children():
		child.queue_free()

func _get_building_color(building_data: BuildingData) -> Color:
	"""Get a representative color for the building type"""
	var name = building_data.display_name.to_lower()
	if "wall" in name:
		return Color(0.7, 0.5, 0.3, 1.0) # Brown
	elif "hall" in name:
		return Color(0.8, 0.8, 0.2, 1.0) # Yellow
	elif "tower" in name or "watchtower" in name:
		return Color(0.5, 0.5, 0.8, 1.0) # Blue
	elif "lumber" in name:
		return Color(0.3, 0.8, 0.3, 1.0) # Green
	elif "granary" in name:
		return Color(0.9, 0.6, 0.2, 1.0) # Orange
	elif "chapel" in name or "library" in name or "scriptorium" in name:
		return Color(0.8, 0.4, 0.8, 1.0) # Purple
	else:
		return Color(0.6, 0.6, 0.6, 1.0) # Gray

func _process(_delta: float) -> void:
	"""Update cursor position and placement validity"""
	if not is_active or not current_building_data:
		return
	
	# Get mouse position and snap to grid
	var mouse_pos = get_global_mouse_position()
	var grid_pos = _world_to_grid(mouse_pos)
	var snapped_world_pos = _grid_to_world(grid_pos)
	
	# Update cursor position
	global_position = snapped_world_pos
	
	# Check placement validity
	can_place = _can_place_at_position(grid_pos)
	
	# Update visual feedback
	_update_visual_feedback()

func _world_to_grid(world_pos: Vector2) -> Vector2i:
	"""Convert world position to grid coordinates"""
	if cell_size <= 0: return Vector2i.ZERO # Safety check
	return Vector2i(int(world_pos.x / cell_size), int(world_pos.y / cell_size))

func _grid_to_world(grid_pos: Vector2i) -> Vector2:
	"""Convert grid coordinates to world position (centered on cell)"""
	return Vector2(grid_pos.x * cell_size, grid_pos.y * cell_size)

func _can_place_at_position(grid_pos: Vector2i) -> bool:
	"""Check if building can be placed by asking the SettlementManager."""
	if not SettlementManager or not current_building_data:
		return false
	
	# This call still works because SettlementManager delegates
	# to the registered AStarGrid object.
	return SettlementManager.is_placement_valid(grid_pos, current_building_data.grid_size)

func _update_visual_feedback() -> void:
	"""Update the visual appearance based on placement validity"""
	if not preview_sprite:
		return
	
	# Change color based on placement validity
	if can_place:
		preview_sprite.modulate = valid_color
		_set_grid_overlay_color(Color.GREEN)
	else:
		preview_sprite.modulate = invalid_color
		_set_grid_overlay_color(Color.RED)

func _set_grid_overlay_color(color: Color) -> void:
	"""Set the color of the grid overlay lines"""
	for child in grid_overlay.get_children():
		if child is Line2D:
			child.default_color = color

func place_building() -> bool:
	"""Attempt to place the building at current position"""
	if not is_active or not current_building_data or not can_place:
		print("Cannot place building: not active (%s), no data (%s), or invalid position (%s)" % [is_active, current_building_data != null, can_place])
		return false
	
	var grid_pos = _world_to_grid(global_position)
	
	print("Attempting to place %s at grid position %s" % [current_building_data.display_name, grid_pos])
	
	# This call still works!
	var new_building = SettlementManager.place_building(current_building_data, grid_pos)
	
	if new_building:
		print("Successfully placed building: %s" % current_building_data.display_name)
		placement_completed.emit()
		cancel_preview()
		return true
	else:
		print("Failed to place building through SettlementManager")
		return false

func cancel_preview() -> void:
	"""Cancel building placement and clean up"""
	print("Cancelling building preview")
	
	is_active = false
	visible = false
	current_building_data = null
	can_place = false
	
	_cleanup_preview()
	placement_cancelled.emit()

func _cleanup_preview() -> void:
	"""Clean up preview visual elements"""
	if preview_sprite:
		preview_sprite.queue_free()
		preview_sprite = null
	
	_clear_grid_overlay()

func _input(event: InputEvent) -> void:
	"""Handle input for building placement"""
	if not is_active:
		return
	
	if event is InputEventMouseButton and event.is_pressed():
		if event.button_index == MOUSE_BUTTON_LEFT:
			# Attempt to place building
			if place_building():
				print("Building placed successfully")
			else:
				print("Failed to place building")
			get_viewport().set_input_as_handled()
		
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			# Cancel placement
			print("Building placement cancelled by right click")
			cancel_preview()
			get_viewport().set_input_as_handled()

--- SCRIPT: res://scripts/ui/PauseMenu.gd ---
# res://ui/PauseMenu.gd
#
# This script controls the pause menu itself.
# It runs while the game is paused (Process Mode = "When Paused").
# It is responsible for unpausing the game.

extends CanvasLayer

@onready var resume_button: Button = $PanelContainer/VBoxContainer/ResumeButton
@onready var save_button: Button = $PanelContainer/VBoxContainer/SaveButton
@onready var quit_button: Button = $PanelContainer/VBoxContainer/QuitButton


func _ready() -> void:
	# Connect signals in code
	resume_button.pressed.connect(_on_resume_pressed)
	save_button.pressed.connect(_on_save_pressed)
	quit_button.pressed.connect(_on_quit_pressed)


func _unhandled_input(event: InputEvent) -> void:
	# Also allow 'Escape' to close the pause menu
	if event.is_action_pressed("ui_pause"):
		get_viewport().set_input_as_handled() # Consume the event
		_on_resume_pressed()


func _on_resume_pressed() -> void:
	"""Unpauses the game and removes the menu."""
	get_tree().paused = false
	queue_free() # Destroy the menu


func _on_save_pressed() -> void:
	"""Saves the game state via the SettlementManager."""
	if SettlementManager.has_current_settlement():
		SettlementManager.save_settlement()
		print("Game saved from pause menu.")
	else:
		print("Pause Menu: No settlement loaded, cannot save.")


func _on_quit_pressed() -> void:
	"""Quits the game."""
	get_tree().quit()

--- SCRIPT: res://scripts/units/Base_Unit.gd ---
# res://scripts/units/Base_Unit.gd
#
# --- MODIFIED: Added auto-scaling for texture and collision ---

class_name BaseUnit
extends CharacterBody2D

signal destroyed

@export var data: UnitData
var fsm: UnitFSM
var current_health: int = 50

# Node refs
@onready var attack_timer: Timer = $AttackTimer
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision_shape: CollisionShape2D = $CollisionShape2D

# Color tweening
var _color_tween: Tween
const STATE_COLORS := {
	UnitFSM.State.IDLE: Color(0.3, 0.6, 1.0),     # Blue
	UnitFSM.State.MOVING: Color(0.4, 1.0, 0.4),   # Green
	UnitFSM.State.ATTACKING: Color(1.0, 0.3, 0.3) # Red
}
const ERROR_COLOR := Color(0.7, 0.3, 1.0)         # Purple

func _ready() -> void:
	if not data:
		push_warning("BaseUnit: Node is missing its 'UnitData' resource. Cannot initialize.")
		return
	
	current_health = data.max_health
	
	# --- ADDED: Apply Texture and Scaling ---
	_apply_texture_and_scale()
	
	# Pass the timer reference to the FSM
	fsm = UnitFSM.new(self, attack_timer)
	
	# Initialize visual to current state color (IDLE by default)
	sprite.modulate = STATE_COLORS.get(UnitFSM.State.IDLE, Color.WHITE)
	
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)

func _apply_texture_and_scale() -> void:
	"""
	Applies the texture from 'data' and scales both the
	sprite and collision shape to match the 'data.target_pixel_size'.
	"""
	
	# 1. Validate the target size
	if data.target_pixel_size.x <= 0 or data.target_pixel_size.y <= 0:
		push_warning("BaseUnit: '%s' has a target_pixel_size of %s, which is invalid." % [data.display_name, data.target_pixel_size])
		return
		
	var target_size: Vector2 = data.target_pixel_size

	# 2. Apply and Scale the Sprite
	if data.visual_texture:
		sprite.texture = data.visual_texture
		var texture_size: Vector2 = sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			# Non-uniform scaling to fill the target size
			var new_scale: Vector2 = target_size / texture_size
			sprite.scale = new_scale
		else:
			push_warning("BaseUnit: Texture for '%s' has an invalid size of %s. Cannot scale sprite." % [data.display_name, texture_size])
	else:
		push_warning("BaseUnit: '%s' is missing its 'visual_texture'. Sprite will be blank or use placeholder." % data.display_name)
		
	# 3. Scale the Collision Shape
	if collision_shape and collision_shape.shape is RectangleShape2D:
		# Set extents to *half* the target size (from center)
		collision_shape.shape.extents = target_size / 2.0
	else:
		push_warning("BaseUnit: '%s' is missing its CollisionShape2D node or its shape is not a RectangleShape2D. Collision will not match visuals." % data.display_name)
# --- END ADDED ---

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	if fsm and fsm.current_state == UnitFSM.State.MOVING:
		fsm._recalculate_path()

func _physics_process(delta: float) -> void:
	if fsm:
		fsm.update(delta)
	
	if not fsm or fsm.current_state != UnitFSM.State.MOVING:
		velocity = Vector2.ZERO
		move_and_slide()

# --- Visual State Hooks ---
func on_state_changed(state: UnitFSM.State) -> void:
	var to_color: Color = STATE_COLORS.get(state, Color.WHITE)
	_tween_color(to_color, 0.2)

func flash_error_color() -> void:
	# Quick flash to purple, then return to current state color
	var back_color: Color = STATE_COLORS.get(fsm.current_state, Color.WHITE)
	var t := create_tween()
	t.tween_property(sprite, "modulate", ERROR_COLOR, 0.08).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
	t.tween_property(sprite, "modulate", back_color, 0.18).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func _tween_color(to_color: Color, duration: float = 0.2) -> void:
	if _color_tween and _color_tween.is_running():
		_color_tween.kill()
	_color_tween = create_tween()
	_color_tween.tween_property(sprite, "modulate", to_color, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	# print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been killed." % data.display_name)
	destroyed.emit()
	queue_free()

# --- RTS Command Interface ---

func command_move_to(target_pos: Vector2) -> void:
	"""Command this unit to move to a position"""
	if fsm:
		fsm.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	"""Command this unit to attack a target"""
	if fsm:
		fsm.command_attack(target)

# --- Selection System ---

var is_selected: bool = false

func set_selected(selected: bool) -> void:
	"""Set the unit's selection state"""
	is_selected = selected
	
	if is_selected:
		_show_selection_indicator()
		# print("%s selected" % data.display_name) # Too noisy
	else:
		_hide_selection_indicator()
		# print("%s deselected" % data.display_name) # Too noisy

func _show_selection_indicator() -> void:
	"""Show visual selection indicator"""
	queue_redraw()

func _hide_selection_indicator() -> void:
	"""Hide visual selection indicator"""
	queue_redraw()

func _draw() -> void:
	"""Draw unit-specific visuals"""
	if is_selected:
		# Draw selection circle around the unit
		var radius = 25.0
		var color = Color.YELLOW
		color.a = 0.8
		draw_circle(Vector2.ZERO, radius, color, false, 3.0)

--- SCRIPT: res://scripts/units/EnemyVikingRaider.gd ---
# res://scripts/units/VikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Target position is now adjacent to the Hall ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set the node (for attacking)
	fsm.target_unit = target
	
	# --- THIS IS THE FIX ---
	# Set the position (for moving) to be one tile *below*
	# the Hall's center. This is a walkable tile, so
	# pathfinding will succeed.
	fsm.target_position = target.global_position + Vector2(0, 32)
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVING)
	print("Viking Raider initialized and moving to target: %s" % target.data.display_name)

--- SCRIPT: res://scripts/units/PlayerVikingRaider.gd ---
# res://scripts/units/PlayerVikingRaider.gd
#
# Player-controlled Viking Raider unit with full RTS integration.
# Extends BaseUnit to inherit all core unit functionality and adds
# player-specific behaviors for selection, command, and group management.

extends BaseUnit
class_name PlayerVikingRaider

func _ready() -> void:
	# Call parent _ready first to initialize base unit systems
	super._ready()
	
	# Add to player units group for RTS selection and control
	add_to_group("player_units")
	
	# Initialize player-specific behaviors
	_setup_player_behaviors()
	
	print("PlayerVikingRaider '%s' initialized and ready for RTS control" % name)

func _setup_player_behaviors() -> void:
	"""Initialize player-specific unit behaviors and properties"""
	# Ensure the unit can be selected and commanded
	# The BaseUnit already provides the necessary methods:
	# - command_move_to()
	# - command_attack() 
	# - set_selected()
	
	# Set any player-specific properties
	if data:
		print("Player Viking Raider ready: %s (Health: %d)" % [data.display_name, current_health])

# Override command methods to add player-specific feedback and behavior
func command_move_to(target_pos: Vector2) -> void:
	"""Enhanced move command with player feedback"""
	print("Player Viking Raider '%s' moving to position %s" % [name, target_pos])
	super.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	"""Enhanced attack command with player feedback"""
	if not fsm or not is_instance_valid(target):
		push_warning("Player Raider FSM or target is not valid.")
		return

	print("Player Viking Raider '%s' attacking %s" % [name, target.name])

	# --- Logic copied from EnemyVikingRaider ---
	# Set the node (for attacking)
	fsm.target_unit = target
	
	# Set the position (for moving) to be adjacent to the target
	# This ensures pathfinding can succeed. Adjust offset as needed.
	fsm.target_position = target.global_position + Vector2(0, 32) 
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVING)
	# ---------------------------------------------

# Override selection methods to provide enhanced player feedback
func set_selected(selected: bool) -> void:
	"""Enhanced selection with player-specific visual feedback"""
	super.set_selected(selected)
	
	if selected:
		# Could add player-specific selection effects here
		# e.g., special sound effects, enhanced visual indicators
		pass
	else:
		# Handle deselection
		pass

# Player-specific utility methods
func get_unit_status() -> Dictionary:
	"""Get comprehensive unit status for UI display"""
	return {
		"name": name,
		"display_name": data.display_name if data else "Unknown",
		"health": current_health,
		"max_health": data.max_health if data else 100,
		"is_selected": is_selected,
		"current_state": fsm.current_state if fsm else "None",
		"position": global_position
	}

func is_player_controlled() -> bool:
	"""Identify this as a player-controlled unit"""
	return true

# Override die method to handle player unit death
func die() -> void:
	"""Handle player unit death with proper cleanup"""
	# Remove from player units group
	remove_from_group("player_units")
	
	# Notify other systems about unit death
	EventBus.emit_signal("player_unit_died", self)
	
	print("Player Viking Raider '%s' has fallen in battle!" % name)
	
	# Call parent die method
	super.die()

--- SCRIPT: res://scripts/utility/GridManager.gd ---
# res://scripts/utility/GridManager.gd
#
# A reusable scene that creates and manages an AStarGrid2D object.
# This encapsulates grid logic so scenes like SettlementBridge
# and RaidMission don't have to duplicate code.

extends Node

@export_group("Grid Configuration")
@export var grid_width: int = 60
@export var grid_height: int = 40
@export var cell_size: int = 32

## The AStarGrid2D object this manager creates and configures.
var astar_grid: AStarGrid2D

func _ready() -> void:
	# Create and configure the grid object
	astar_grid = AStarGrid2D.new()
		
	var playable_rect := Rect2i(0, 0, grid_width, grid_height)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(cell_size, cell_size)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar_grid.update()
	
	print("GridManager: Local grid initialized: %dx%d cells" % [grid_width, grid_height])

--- SCRIPT: res://tools/EnemyBaseEditor.gd ---
@tool
extends EditorScript

# Simple Enemy Base Layout Editor
# Usage: Tools -> Execute Script to run this

func _run():
	print("=== ENEMY BASE LAYOUT EDITOR ===")
	
	var settlement_path = "res://data/settlements/monastery_base.tres"
	var settlement_data: SettlementData = load(settlement_path)
	
	if not settlement_data:
		print("ERROR: Could not load settlement data!")
		return
	
	print("Current layout for: " + settlement_path)
	print("Grid positions (format: Building @ X,Y):")
	print("-".repeat(40))
	
	for i in range(settlement_data.placed_buildings.size()):
		var building = settlement_data.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("-".repeat(40))
	print("To modify layout:")
	print("1. Edit grid_position values in the .tres file")
	print("2. Or use this script to create new layouts")
	print("3. Grid range: 0-%d (width), 0-%d (height)" % [
		SettlementManager.grid_width-1, 
		SettlementManager.grid_height-1
	])

# Helper function to create new enemy base layouts
static func create_enemy_base_layout(buildings: Array[Dictionary], save_path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 500, "wood": 200, "food": 150, "stone": 100}
	settlement.placed_buildings = buildings
	
	ResourceSaver.save(settlement, save_path)
	print("Created new enemy base: " + save_path)

# Example usage:
# EnemyBaseEditor.create_fortress_layout()
static func create_fortress_layout():
	var buildings = [
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(32, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	create_enemy_base_layout(buildings, "res://data/settlements/fortress_base.tres")

--- SCRIPT: res://tools/Phase1TestRunner.gd ---
# res://tools/Phase1_TestRunner.gd
#
# This is an automated integration test for our Phase 1 SceneManager refactor.
# It runs AS AN AUTOLOAD.
#
# To run:
# 1. Add this SCRIPT to Project > Project Settings > Autoload.
# 2. Set the "Main Scene" to "res://scenes/levels/SettlementBridge.tscn".
# 3. Press F5 to run the project.
# 4. Watch the console output. The game will quit automatically on pass/fail.

extends Node

func _ready() -> void:
	# Wait one frame for the main scene (SettlementBridge) to finish loading
	await get_tree().create_timer(0.2).timeout
	
	# Start the test flow
	call_deferred("run_test_flow")

func run_test_flow() -> void:
	print("--- STARTING PHASE 1 TRANSITION TEST ---")
	
	# ---
	# TEST 1: (Settlement -> Map)
	# ---
	print("\nTEST 1/4: Settlement -> Map")
	
	# --- MODIFICATION ---
	# First, verify we are on the correct starting scene (no await)
	if not check_current_scene("res://scenes/levels/SettlementBridge.tscn", "SettlementBridge"):
		return
	# --- END MODIFICATION ---
	
	if not await simulate_button_press("UI/StartRaidButton"):
		fail_test("Failed to press 'World Map' button from Settlement.")
		return
		
	if not await assert_scene_changed("res://scenes/world_map/MacroMap.tscn", "MacroMap"):
		return
	print("...PASS")

	# ---
	# TEST 2: (Map -> Settlement)
	# ---
	print("\nTEST 2/4: Map -> Settlement")
	if not await simulate_button_press("UI/Actions/VBoxContainer/SettlementButton"):
		fail_test("Failed to press 'Return to Settlement' button from Map.")
		return
		
	if not await assert_scene_changed("res://scenes/levels/SettlementBridge.tscn", "SettlementBridge (from Map)"):
		return
	print("...PASS")
	
	# ---
	# TEST 3: (Map -> Raid)
	# ---
	print("\nTEST 3/4: Map -> Raid")
	# Go back to the map first
	EventBus.scene_change_requested.emit("world_map")
	if not await assert_scene_changed("res://scenes/world_map/MacroMap.tscn", "MacroMap (Re-load)"):
		return
	
	# This is a complex click, we must simulate selecting a region first
	if not await simulate_map_to_raid():
		fail_test("Failed to simulate map-to-raid sequence.")
		return
		
	if not await assert_scene_changed("res://scenes/missions/RaidMission.tscn", "RaidMission"):
		return
	print("...PASS")
	
	# ---
	# TEST 4: (Raid -> Settlement)
	# ---
	print("\nTEST 4/4: Raid -> Settlement")
	if not await simulate_raid_end():
		fail_test("Failed to simulate raid end.")
		return
		
	if not await assert_scene_changed("res://scenes/levels/SettlementBridge.tscn", "SettlementBridge (from Raid)"):
		return
	print("...PASS")
	
	# ---
	# COMPLETE
	# ---
	print("\n--- ALL TESTS PASSED ---")
	print("Remember to remove 'Phase1_TestRunner.gd' from Autoload.")
	get_tree().quit()


# --- TEST HELPER FUNCTIONS ---

func simulate_button_press(button_path: String) -> bool:
	# Wait one frame for scene to be fully ready
	await get_tree().create_timer(0.1).timeout 
	
	var scene = get_tree().current_scene
	if not is_instance_valid(scene):
		print("  ERROR: Current scene is not valid.")
		return false
		
	var button = scene.get_node_or_null(button_path)
	
	if not is_instance_valid(button):
		print("  ERROR: Could not find button at path: %s in scene %s" % [button_path, scene.scene_file_path])
		return false
		
	if button.disabled:
		print("  ERROR: Button '%s' is disabled, cannot press." % button_path)
		return false
	
	button.emit_signal("pressed")
	return true

func simulate_map_to_raid() -> bool:
	await get_tree().create_timer(0.1).timeout
	var scene = get_tree().current_scene
	if not is_instance_valid(scene):
		print("  ERROR: Current scene is not valid for map-to-raid sim.")
		return false
		
	# 1. Get the region (assuming only one, "Region")
	var region = scene.get_node_or_null("Regions/Region")
	if not is_instance_valid(region):
		print("  ERROR: Could not find node 'Regions/Region' in MacroMap.")
		return false
	
	# 2. Simulate selecting it
	region.emit_signal("region_selected", region.data)
	
	# 3. Press the launch button
	return await simulate_button_press("UI/RegionInfo/VBoxContainer/LaunchRaidButton")

func simulate_raid_end() -> bool:
	await get_tree().create_timer(0.1).timeout
	var scene = get_tree().current_scene
	if not is_instance_valid(scene):
		print("  ERROR: Current scene is not valid for raid-end sim.")
		return false
		
	var objective_manager = scene.get_node_or_null("RaidObjectiveManager")
	if not is_instance_valid(objective_manager):
		print("  ERROR: Could not find 'RaidObjectiveManager' in RaidMission.")
		return false
	
	# 4. Force a mission end
	# We call _on_mission_failed as it's the quickest way to trigger the scene change
	objective_manager._on_mission_failed()
	return true

# --- NEW FUNCTION ---
func check_current_scene(expected_path: String, step_name: String) -> bool:
	"""Checks the CURRENTLY loaded scene without awaiting a change."""
	var scene = get_tree().current_scene
	if not is_instance_valid(scene) or not scene.scene_file_path == expected_path:
		print("  ERROR: Failed pre-check for test '%s'" % step_name)
		print("    Expected scene: %s" % expected_path)
		if is_instance_valid(scene):
			print("    Got scene: %s" % scene.scene_file_path)
		else:
			print("    Got: <invalid_scene>")
		get_tree().quit()
		return false
	print("  Pre-check PASSED: Currently on %s" % scene.scene_file_path)
	return true

# --- RENAMED FUNCTION ---
func assert_scene_changed(expected_path: String, step_name: String) -> bool:
	"""Waits for a scene change, THEN asserts the new scene is correct."""
	var scene = get_tree().current_scene
	
	# Wait for the scene change to fully complete
	await get_tree().scene_changed
	
	# Get the new scene reference
	scene = get_tree().current_scene
	
	if not is_instance_valid(scene) or not scene.scene_file_path == expected_path:
		print("  ERROR: Failed test '%s'" % step_name)
		print("    Expected: %s" % expected_path)
		if is_instance_valid(scene):
			print("    Got: %s" % scene.scene_file_path)
		else:
			print("    Got: <invalid_scene>")
		get_tree().quit()
		return false
	return true

func fail_test(reason: String) -> void:
	print("\n--- TEST FAILED ---")
	print(reason)
	print("-------------------")
	get_tree().quit()

--- SCRIPT: res://tools/SettlementLayoutEditor.gd ---
# SettlementLayoutEditor.gd
# Tool to help create custom settlement layouts
@tool
extends EditorScript

# Define available buildings with their paths
const BUILDINGS = {
	"Great Hall": "res://data/buildings/GreatHall.tres",
	"Wall": "res://data/buildings/Bldg_Wall.tres", 
	"Lumber Yard": "res://data/buildings/LumberYard.tres",
	"Chapel": "res://data/buildings/Monastery_Chapel.tres",
	"Granary": "res://data/buildings/Monastery_Granary.tres",
	"Library": "res://data/buildings/Monastery_Library.tres",
	"Scriptorium": "res://data/buildings/Monastery_Scriptorium.tres",
	"Watchtower": "res://data/buildings/Monastery_Watchtower.tres"
}

func _run():
	print("=== SETTLEMENT LAYOUT EDITOR ===")
	print("Available buildings:")
	for name in BUILDINGS.keys():
		print("  - %s: %s" % [name, BUILDINGS[name]])
	
	print("\n=== EXAMPLE LAYOUTS ===")
	
	# Example 1: Small Defensive Settlement
	var small_defensive = create_small_defensive_layout()
	print("\n1. SMALL DEFENSIVE LAYOUT:")
	print_layout(small_defensive)
	save_layout(small_defensive, "res://data/settlements/small_defensive.tres")
	
	# Example 2: Economic Settlement
	var economic = create_economic_layout()
	print("\n2. ECONOMIC LAYOUT:")
	print_layout(economic)
	save_layout(economic, "res://data/settlements/economic_base.tres")
	
	# Example 3: Monastery Layout
	var monastery = create_monastery_layout()
	print("\n3. MONASTERY LAYOUT:")
	print_layout(monastery)
	save_layout(monastery, "res://data/settlements/monastery_base.tres")
	
	print("\n=== LAYOUT FILES CREATED ===")
	print("You can now use these layouts by:")
	print("1. Loading them in the Inspector on SettlementBridge")
	print("2. Or copying the placement arrays manually")

func create_small_defensive_layout() -> Array[Dictionary]:
	return [
		# Great Hall in center
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(8, 6)},
		
		# Defensive walls around perimeter
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(7, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(11, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(13, 4)},
		
		# Watchtowers at corners
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(4, 3)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(14, 3)},
		
		# Basic resource building
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 8)}
	]

func create_economic_layout() -> Array[Dictionary]:
	return [
		# Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 8)},
		
		# Economic buildings clustered together
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(8, 6)},
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(12, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(14, 6)},
		
		# Minimal defenses
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(10, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(10, 3)}
	]

func create_monastery_layout() -> Array[Dictionary]:
	return [
		# Central Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 10)},
		
		# Monastery buildings in organized pattern
		{"resource_path": BUILDINGS["Chapel"], "grid_position": Vector2i(8, 7)},
		{"resource_path": BUILDINGS["Library"], "grid_position": Vector2i(12, 7)},
		{"resource_path": BUILDINGS["Scriptorium"], "grid_position": Vector2i(8, 13)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(12, 13)},
		
		# Outer walls for protection
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(14, 5)},
		
		# Watchtowers
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 15)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 15)}
	]

func print_layout(layout: Array[Dictionary]):
	for i in range(layout.size()):
		var building = layout[i]
		var name = get_building_name(building["resource_path"])
		var pos = building["grid_position"]
		print("  [%d] %s at (%d, %d)" % [i, name, pos.x, pos.y])

func get_building_name(path: String) -> String:
	for name in BUILDINGS.keys():
		if BUILDINGS[name] == path:
			return name
	return "Unknown"

func save_layout(layout: Array[Dictionary], path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 200, "stone": 300}
	settlement.placed_buildings = layout
	settlement.garrisoned_units = {"res://data/units/Unit_PlayerRaider.tres": 3}
	
	var error = ResourceSaver.save(settlement, path)
	if error == OK:
		print(" Saved layout to: %s" % path)
	else:
		print(" Failed to save layout to: %s" % path)

--- SCRIPT: res://tools/test_phase3.gd ---
# Test script for Phase 3 functionality
extends Node

func _ready():
	print("=== PHASE 3 TEST STARTING ===")
	test_garrison_system()
	test_raid_system()

func test_garrison_system():
	print("\n--- Testing Garrison System (Pillar 1) ---")
	if SettlementManager.current_settlement:
		print("Current treasury: %s" % SettlementManager.current_settlement.treasury)
		print("Current garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
		
		# Test unit recruitment
		var player_unit_data = load("res://data/units/Unit_PlayerRaider.tres") as UnitData
		if player_unit_data:
			print("Found player unit data: %s" % player_unit_data.display_name)
			print("Unit spawn cost: %s" % player_unit_data.spawn_cost)
			
			# Try to recruit one unit
			if SettlementManager.attempt_purchase(player_unit_data.spawn_cost):
				SettlementManager.recruit_unit(player_unit_data)
				print("Successfully recruited %s!" % player_unit_data.display_name)
			else:
				print("Cannot afford to recruit %s" % player_unit_data.display_name)
		else:
			print("ERROR: Could not load player unit data")
	else:
		print("ERROR: No settlement loaded")

func test_raid_system():
	print("\n--- Testing Raid System (Pillar 3) ---")
	if SettlementManager.current_settlement:
		var garrison = SettlementManager.current_settlement.garrisoned_units
		if not garrison.is_empty():
			print("Garrison ready for raid with %d unit types" % garrison.size())
			var total_units = 0
			for unit_path in garrison:
				total_units += garrison[unit_path]
			print("Total units available: %d" % total_units)
			print("Phase 3 raid system ready!")
		else:
			print("No units in garrison - cannot start raid")
	else:
		print("ERROR: No settlement loaded")
	
	print("\n=== PHASE 3 TEST COMPLETE ===")

--- SCRIPT: res://ui/SelectionBox.gd ---
# res://ui/SelectionBox.gd
# This Control node covers the entire screen. It listens for
# raw input, draws the selection box, and emits clean,
# intent-based signals to the EventBus. It also uses
# accept_event() to stop input from passing through the UI.
extends Control

var is_dragging := false
var start_pos := Vector2.ZERO

func _ready() -> void:
	# This node handles its own input via _gui_input,
	# so it doesn't need to connect to the EventRouter.
	pass

func _gui_input(event: InputEvent) -> void:
	# We use _gui_input, which is only called if the mouse
	# is over this Control. Since it's fullscreen,
	# this will always be the case.
	
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.is_pressed():
				is_dragging = true
				start_pos = get_local_mouse_position()
				# This is the UI-bug-fix. We consume the
				# event so nothing else can process it.
				accept_event()
			elif is_dragging: # On Left-Click Release
				is_dragging = false
				var end_pos := get_local_mouse_position()
				var rect := Rect2(start_pos, end_pos - start_pos).abs()
				
				# Check if it was a "drag" or just a "click"
				# A 'click' is a box with a very small area.
				var is_box_select = rect.size.length_squared() > 100 # 10x10 px
				
				# Emit the clean command for the RTSController
				EventBus.emit_signal("select_command", rect, is_box_select)
				
				queue_redraw() # Clear the box
				accept_event()
		
		elif event.button_index == MOUSE_BUTTON_RIGHT and event.is_pressed():
			# This is a "smart command"
			_handle_smart_command(get_local_mouse_position())
			accept_event()
	
	elif event is InputEventMouseMotion and is_dragging:
		# Update the draw loop as the mouse moves
		queue_redraw()
		accept_event()

func _handle_smart_command(screen_pos: Vector2) -> void:
	# This function determines if a right-click
	# is a "move" or "attack" command.
	var world_space: PhysicsDirectSpaceState2D = get_world_2d().direct_space_state
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	
	if not main_camera:
		push_error("SelectionBox: No Camera2D found in viewport.")
		return
		
	# Convert screen position to world position
	var world_pos: Vector2 = main_camera.get_global_mouse_position()
	
	var query := PhysicsPointQueryParameters2D.new()
	query.position = world_pos
	query.collide_with_areas = true
	query.collide_with_bodies = true
	# We only want to hit "enemy" things
	# GDD: "right-click is the 'smart' command (move on ground, attack on enemy)"
	# We assume layer 2 is "enemy_units" and layer 3 is "enemy_buildings"
	query.collision_mask = 6 # (Binary 0110 = Layers 2 and 3)
	
	var results: Array = world_space.intersect_point(query)
	
	if not results.is_empty():
		# We hit an enemy! Emit an attack command.
		var target = results[0].collider
		EventBus.emit_signal("attack_command", target)
	else:
		# We hit the ground. Emit a move command.
		EventBus.emit_signal("move_command", world_pos)

func _draw() -> void:
	# This function draws the selection box
	if is_dragging:
		var current_pos := get_local_mouse_position()
		var rect := Rect2(start_pos, current_pos - start_pos).abs()
		
		# Draw a semi-transparent fill
		draw_rect(rect, Color(0.8, 0.8, 1.0, 0.2), true)
		# Draw a solid outline
		draw_rect(rect, Color(0.8, 0.8, 1.0, 1.0), false, 1.0)

--- SCRIPT: res://ui/StorefrontUI.gd ---
# res://ui/StorefrontUI.gd (Fully Refactored)
extends Control

# --- Node References ---
@onready var gold_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/GoldLabel
@onready var wood_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/WoodLabel
@onready var food_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/FoodLabel
@onready var stone_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/StoneLabel

# --- REMOVED ---
# @onready var buy_wall_button: Button = ...
# @onready var buy_lumber_yard_button: Button = ...

# --- ADDED ---
@onready var build_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/BuildTab/BuildButtonsContainer
# --- END ADDED ---

@onready var recruit_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/RecruitButtons
@onready var garrison_list_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/GarrisonList

# --- Exported Data ---
@export var available_buildings: Array[BuildingData] = [] # This can now be deprecated or used for manual overrides
@export var available_units: Array[UnitData] = []
@export var default_treasury_display: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}
@export var auto_load_units_from_directory: bool = true

# --- REMOVED ---
# var wall_data: BuildingData = ...
# var lumber_yard_data: BuildingData = ...

func _ready() -> void:
	EventBus.treasury_updated.connect(_update_treasury_display)
	EventBus.purchase_successful.connect(_on_purchase_successful)
	
	if SettlementManager.current_settlement:
		_update_treasury_display(SettlementManager.current_settlement.treasury)
	else:
		_update_treasury_display(default_treasury_display)

	# --- REMOVED ---
	# buy_wall_button.pressed.connect(...)
	# buy_lumber_yard_button.pressed.connect(...)
	
	# --- ADDED ---
	_load_building_data()
	# --- END ADDED ---

	# Load and setup recruit buttons
	_load_unit_data()
	_setup_recruit_buttons()
	_update_garrison_display()

# --- ADDED NEW FUNCTION ---
func _load_building_data() -> void:
	"""Scan res://data/buildings/ for buildable .tres files and create buttons."""
	var dir = DirAccess.open("res://data/buildings/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var building_path = "res://data/buildings/" + file_name
				var building_data = load(building_path) as BuildingData
				
				# Check if the building is valid AND flagged for the player
				if building_data and building_data.is_player_buildable:
					print("Found player-buildable building: %s" % building_data.display_name)
					_create_building_button(building_data)
					
			file_name = dir.get_next()
# --- END ADDED ---

# --- ADDED NEW FUNCTION ---
func _create_building_button(building_data: BuildingData) -> void:
	"""Creates and connects a single button for the build tab."""
	var button = Button.new()
	button.text = "%s (Cost: %s)" % [building_data.display_name, _format_cost(building_data.build_cost)]
	button.custom_minimum_size = Vector2(200, 36) # Matches GDD spec [cite: 405]
	button.pressed.connect(_on_buy_button_pressed.bind(building_data))
	build_buttons_container.add_child(button)
# --- END ADDED ---

func _load_unit_data() -> void:
	"""Scan res://data/units/ directory for .tres files and load them as UnitData"""
	var dir = DirAccess.open("res://data/units/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var unit_path = "res://data/units/" + file_name
				var unit_data = load(unit_path) as UnitData
				if unit_data:
					# Only load player-appropriate units (exclude enemy-only units)
					# Player units should have "Player" in their display name or specific naming convention
					if _is_player_unit(unit_data):
						available_units.append(unit_data)
						print("Loaded player unit data: %s" % unit_data.display_name)
					else:
						print("Skipped enemy unit data: %s" % unit_data.display_name)
			file_name = dir.get_next()
		print("Total player units loaded: %d" % available_units.size())

func _setup_recruit_buttons() -> void:
	"""Create recruit buttons for each available unit"""
	for unit_data in available_units:
		var button = Button.new()
		button.text = "%s (Cost: %s)" % [unit_data.display_name, _format_cost(unit_data.spawn_cost)]
		button.custom_minimum_size = Vector2(200, 36)
		button.pressed.connect(_on_recruit_button_pressed.bind(unit_data))
		recruit_buttons_container.add_child(button)

func _is_player_unit(unit_data: UnitData) -> bool:
	"""Check if a unit is appropriate for player recruitment"""
	if not unit_data:
		return false
	
	# Check if the unit has "Player" in its display name
	if "Player" in unit_data.display_name:
		return true
	
	# Check if the unit data resource path contains "Player" 
	if "Player" in unit_data.resource_path:
		return true
	
	# Check if the scene points to a PlayerVikingRaider or other player unit
	if unit_data.scene_to_spawn:
		var scene_path = unit_data.scene_to_spawn.resource_path
		if "Player" in scene_path:
			return true
	
	# Fallback: exclude known enemy units by name
	var enemy_unit_names = ["Viking Raider"] # This is the enemy version
	if unit_data.display_name in enemy_unit_names:
		return false
	
	# Default to true for backwards compatibility with existing units
	return true

func _format_cost(cost: Dictionary) -> String:
	"""Format cost dictionary as readable string"""
	var cost_parts: Array[String] = []
	for resource in cost:
		cost_parts.append("%d %s" % [cost[resource], resource])
	return ", ".join(cost_parts)

func _get_safe_placement_position() -> Vector2i:
	"""Find a safe position to place a building, avoiding overlaps"""
	if not SettlementManager.current_settlement:
		return Vector2i(10, 15) # Fallback position
	
	# Get grid bounds from SettlementManager
	var grid_width = SettlementManager.grid_width
	var grid_height = SettlementManager.grid_height
	
	# Create a set of occupied positions for quick lookup
	var occupied_positions: Array[Vector2i] = []
	for building_entry in SettlementManager.current_settlement.placed_buildings:
		occupied_positions.append(building_entry["grid_position"])
	
	# Find the first available position using a spiral search pattern
	var center_x = grid_width / 2.0
	var center_y = grid_height / 2.0
	var max_radius = min(grid_width, grid_height) / 2.0
	
	# Start from center and spiral outward
	for radius in range(1, int(max_radius) + 1):
		for angle_step in range(8 * radius): # More points for larger radii
			var angle = (angle_step * 2.0 * PI) / (8 * radius)
			var test_x = center_x + int(radius * cos(angle))
			var test_y = center_y + int(radius * sin(angle))
			var test_pos = Vector2i(test_x, test_y)
			
			# Check bounds
			if test_pos.x < 0 or test_pos.x >= grid_width or test_pos.y < 0 or test_pos.y >= grid_height:
				continue
			
			# Check if position is free
			if not test_pos in occupied_positions:
				print("Found safe placement position: %s" % test_pos)
				return test_pos
	
	# If no free position found, use a fallback with warning
	push_warning("No free placement position found, using fallback")
	return Vector2i(10, 15)

func _update_treasury_display(new_treasury: Dictionary) -> void:
	gold_label.text = "Gold: %d" % new_treasury.get("gold", 0)
	wood_label.text = "Wood: %d" % new_treasury.get("wood", 0)
	food_label.text = "Food: %d" % new_treasury.get("food", 0)
	stone_label.text = "Stone: %d" % new_treasury.get("stone", 0)

func _on_buy_button_pressed(item_data: BuildingData) -> void:
	if not item_data:
		return
	
	print("UI attempting to purchase '%s'." % item_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(item_data.build_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % item_data.display_name)
		# Emit signal for cursor-based placement instead of auto-placing
		EventBus.building_ready_for_placement.emit(item_data)
	else:
		print("UI received purchase failure for '%s'." % item_data.display_name)

func _on_recruit_button_pressed(unit_data: UnitData) -> void:
	"""Handle recruit button press"""
	if not unit_data:
		return
	
	print("UI attempting to recruit '%s'." % unit_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(unit_data.spawn_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % unit_data.display_name)
		SettlementManager.recruit_unit(unit_data)
	else:
		print("UI received purchase failure for '%s'." % unit_data.display_name)

func _on_purchase_successful(item_name: String) -> void:
	"""Handle purchase success event - refresh garrison display"""
	_update_garrison_display()

func _update_garrison_display() -> void:
	"""Update the garrison list display with current garrisoned units"""
	if not garrison_list_container:
		return
	
	# Clear existing display
	for child in garrison_list_container.get_children():
		child.queue_free()
	
	if not SettlementManager.current_settlement:
		var no_settlement_label = Label.new()
		no_settlement_label.text = "No settlement loaded"
		garrison_list_container.add_child(no_settlement_label)
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	
	if garrison.is_empty():
		var empty_garrison_label = Label.new()
		empty_garrison_label.text = "No units in garrison"
		garrison_list_container.add_child(empty_garrison_label)
		return
	
	# Add header
	var header_label = Label.new()
	header_label.text = "Current Garrison:"
	header_label.add_theme_font_size_override("font_size", 16)
	garrison_list_container.add_child(header_label)
	
	# Display each unit type and count
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if unit_data:
			var unit_label = Label.new()
			unit_label.text = " %s x%d" % [unit_data.display_name, unit_count]
			garrison_list_container.add_child(unit_label)
		else:
			var error_label = Label.new()
			error_label.text = " Unknown unit x%d" % unit_count
			garrison_list_container.add_child(error_label)
	
	# Add total count
	var total_units = 0
	for unit_path in garrison:
		total_units += garrison[unit_path]
	
	var total_label = Label.new()
	total_label.text = "Total units: %d" % total_units
	total_label.add_theme_font_size_override("font_size", 12)
	garrison_list_container.add_child(total_label)

--- SCRIPT: res://ui/WelcomeHomePopup.gd ---
# res://ui/WelcomeHomePopup.gd
extends PanelContainer

signal collect_button_pressed(payout: Dictionary)

@onready var payout_label: Label = $MarginContainer/VBoxContainer/PayoutLabel
@onready var collect_button: Button = $MarginContainer/VBoxContainer/CollectButton

var _current_payout: Dictionary = {}

func _ready() -> void:
	collect_button.pressed.connect(_on_collect_pressed)
	hide()

func display_payout(payout: Dictionary) -> void:
	if payout.is_empty():
		return

	_current_payout = payout
	var payout_text: String = "Welcome home!\n\nResources gathered:\n"
	for resource_type in payout:
		payout_text += "- %s: %d\n" % [resource_type.capitalize(), payout[resource_type]]
	
	payout_label.text = payout_text
	show()

func _on_collect_pressed() -> void:
	collect_button_pressed.emit(_current_payout)
	hide()
--- END OF CODEBASE ---

---
