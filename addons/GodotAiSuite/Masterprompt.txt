### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. Project Context`**: The technical project dump, including:
    *   `2.1. Project Settings`
    *   `2.2. Resource Files`
    *   `2.3. Scene Structures`
    *   `2.4. Codebase`

---
### **2. Project Context**

#### **2.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Viking Dynasty"
run/main_scene="uid://c53k15q2w8c1a"
config/features=PackedStringArray("4.5", "GL Compatibility")

[autoload]

EventBus="*res://autoload/EventBus.gd"
SettlementManager="*res://autoload/SettlementManager.gd"
PauseManager="*res://autoload/PauseManager.tscn"
DynastyManager="*res://autoload/DynastyManager.gd"
SceneManager="*res://autoload/SceneManager.tscn"
EventManager="*res://autoload/EventManager.tscn"
ProjectilePoolManager="*res://autoload/ProjectilePoolManager.gd"

[editor]

naming/scene_name_casing=1
naming/script_name_casing=1

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg")

[input]

debug_time_travel="{\"deadzone\": 0.5, \"events\": [{\"physical_keycode\": 84, \"type\": \"key\"}]}"
ui_pause={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="Environment"
2d_physics/layer_2="Player_Units"
2d_physics/layer_3="Enemy_Units"
2d_physics/layer_4="Enemy_Buildings"

[plugins]

enemy_base_editor/enabled=true
--- END OF PROJECT SETTINGS ---

#### **2.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://assets/placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 100
height = 100
noise = SubResource("FastNoiseLite_cemhj")

--- RESOURCE: res://data/buildings/Bldg_Wall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=4 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Texture2D" uid="uid://csni4uyao275g" path="res://textures/placeholders/wall_stone_texture.png" id="1_n45a8"]
[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
building_texture = ExtResource("1_n45a8")
build_cost = {
"stone": 25
}
dev_color = Color(0.050751396, 0.05072763, 0.06304378, 1)
is_player_buildable = true
extends_territory = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/GreatHall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 100,
"wood": 250
}
grid_size = Vector2i(4, 4)
is_player_buildable = true
is_territory_hub = true
territory_radius = 8

--- RESOURCE: res://data/buildings/LumberYard.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://drx4sih8numo1"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="Texture2D" uid="uid://cvtmpipin3j4" path="res://textures/placeholders/lumber_mill_placeholder.png" id="1_plclm"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
fixed_payout_amount = 50
display_name = "Lumber Yard"
scene_to_spawn = ExtResource("2_fghij")
building_texture = ExtResource("1_plclm")
build_cost = {
"wood": 50
}
max_health = 75
grid_size = Vector2i(2, 2)
is_player_buildable = true
territory_radius = 0

--- RESOURCE: res://data/buildings/Monastery_Chapel.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b7p70u4vm3uem"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 25
storage_cap = 200
display_name = "Monastery Chapel"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 100,
"stone": 80,
"wood": 40
}
max_health = 120
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Granary.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bscr3flprg5ts"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "food"
fixed_payout_amount = 20
storage_cap = 300
display_name = "Monastery Granary"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 60,
"stone": 40,
"wood": 100
}
max_health = 90
grid_size = Vector2i(2, 3)

--- RESOURCE: res://data/buildings/Monastery_Library.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bfb0hbf1m2lgf"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 35
storage_cap = 250
display_name = "Monastery Library"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 150,
"stone": 60,
"wood": 80
}
max_health = 80
grid_size = Vector2i(3, 2)

--- RESOURCE: res://data/buildings/Monastery_Scriptorium.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b6dkpjrewc1q6"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 30
storage_cap = 180
display_name = "Monastery Scriptorium"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 120,
"stone": 30,
"wood": 90
}
max_health = 70
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Watchtower.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=5 format=3 uid="uid://ckedcnw210a8k"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]
[ext_resource type="PackedScene" path="res://scenes/components/AttackAI.tscn" id="3_ai"]
[ext_resource type="PackedScene" path="res://scenes/effects/Projectile.tscn" id="4_proj"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Monastery Watchtower"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 80,
"stone": 120,
"wood": 60
}
max_health = 150
dev_color = Color(0.8, 0.2, 0.2, 1)
is_defensive_structure = true
attack_damage = 15
attack_range = 250.0
attack_speed = 1.5
ai_component_scene = ExtResource("3_ai")
projectile_scene = ExtResource("4_proj")
projectile_speed = 500.0

--- RESOURCE: res://data/buildings/Player_Barracks.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=4 format=3 uid="uid://c0ih7mriv2h1g"]

[ext_resource type="Texture2D" uid="uid://csni4uyao275g" path="res://textures/placeholders/wall_stone_texture.png" id="1_e5dmt"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_n2ory"]
[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="3_yutc8"]

[resource]
script = ExtResource("3_yutc8")
display_name = "Barracks"
scene_to_spawn = ExtResource("2_n2ory")
building_texture = ExtResource("1_e5dmt")
build_cost = {
"stone": 50,
"wood": 100
}
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/Player_Farm.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://y7xhmemltm28"]

[ext_resource type="Texture2D" uid="uid://cvtmpipin3j4" path="res://textures/placeholders/lumber_mill_placeholder.png" id="1_lr1ah"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_mixjq"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="3_svyis"]

[resource]
script = ExtResource("3_svyis")
resource_type = "food"
fixed_payout_amount = 75
display_name = "Farm"
scene_to_spawn = ExtResource("2_mixjq")
building_texture = ExtResource("1_lr1ah")
build_cost = {
"wood": 75
}
max_health = 75
grid_size = Vector2i(2, 2)
dev_color = Color(0.2, 0.8, 0.2, 1)
is_player_buildable = true
territory_radius = 0

--- RESOURCE: res://data/buildings/Test_Large_Building.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bk4qd2jfm3kgp"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Large Test Building"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"wood": 100
}
max_health = 200
grid_size = Vector2i(3, 3)
dev_color = Color(0.8, 0.6, 0.2, 1)
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/characters/heirs/Ragnar.tres ---
[gd_resource type="Resource" format=3 uid="uid://c2ilgcmlp12pb"]

[resource]
metadata/_custom_type_script = "uid://cql5qpafvywy1"

--- RESOURCE: res://data/characters/heirs/TestHeir.tres ---
[gd_resource type="Resource" script_class="JarlHeirData" load_steps=2 format=3 uid="uid://dgxbmto5mqee5"]

[ext_resource type="Script" uid="uid://cql5qpafvywy1" path="res://data/characters/JarlHeirData.gd" id="1_iui4g"]

[resource]
script = ExtResource("1_iui4g")
display_name = "Ragnar (Test)"
metadata/_custom_type_script = "uid://cql5qpafvywy1"

--- RESOURCE: res://data/characters/PlayerJarl.tres ---
[gd_resource type="Resource" script_class="JarlData" load_steps=7 format=3]

[ext_resource type="Script" path="res://data/characters/JarlHeirData.gd" id="1_4gouw"]
[ext_resource type="Script" path="res://data/characters/JarlData.gd" id="1_jarl_data"]
[ext_resource type="Resource" path="res://data/characters/heirs/TestHeir.tres" id="2_0bn2j"]
[ext_resource type="Resource" path="res://data/traits/Trait_Pious.tres" id="2_pious_trait"]
[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="3_0bn2j"]
[ext_resource type="Resource" path="res://data/traits/Trait_Ambitious.tres" id="4_ambitious_trait"]

[resource]
script = ExtResource("1_jarl_data")
display_name = "Bjorn"
age = 30
renown = 25
current_authority = 2
legitimacy = 30
allied_regions = Array[String](["res://data/world_map/Region_Monastery.tres"])
command = 12
stewardship = 11
learning = 9
prowess = 14
traits = Array[ExtResource("3_0bn2j")]([ExtResource("2_pious_trait"), ExtResource("4_ambitious_trait")])
spouse_name = "Lagertha"
heirs = Array[ExtResource("1_4gouw")]([ExtResource("2_0bn2j")])
battles_fought = 2
battles_won = 2
successful_raids = 2
metadata/_custom_type_script = "uid://bm8qe8d38a1il"

--- RESOURCE: res://data/events/ambitious_heir.tres ---
[gd_resource type="Resource" script_class="EventData" load_steps=5 format=3 uid="uid://ddjwe73h3diq5"]

[ext_resource type="Script" uid="uid://c7lxr02yr1fn6" path="res://data/events/EventData.gd" id="1_event_data"]
[ext_resource type="Script" uid="uid://dvc7gumtvwaal" path="res://data/events/EventChoice.gd" id="2_event_choice"]

[sub_resource type="Resource" id="EventChoice_accept"]
script = ExtResource("2_event_choice")
choice_text = "Here is 100 Renown. Bring us glory!"
tooltip_text = "Spend 100 Renown."
effect_key = "accept"

[sub_resource type="Resource" id="EventChoice_decline"]
script = ExtResource("2_event_choice")
choice_text = "We cannot spare it. Be patient."
tooltip_text = "Your heir will be displeased and gain the 'Rival' trait."
effect_key = "decline"

[resource]
script = ExtResource("1_event_data")
title = "An Ambitious Heir"
description = "Your heir, Ragnar, approaches you. \"My Jarl, I am bored! I wish to lead an expedition to prove my worth. Please fund it so I may bring glory to our dynasty!\""
event_id = "ambitious_heir_1"
base_chance = 1.0
must_have_trait = "Ambitious"
min_available_heirs = 1
choices = Array[ExtResource("2_event_choice")]([SubResource("EventChoice_accept"), SubResource("EventChoice_decline")])
metadata/_custom_type_script = "uid://c7lxr02yr1fn6"

--- RESOURCE: res://data/legacy/JellingStone.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_jelling"]

[resource]
script = ExtResource("1_jelling")
display_name = "Erect Jelling Stone"
description = "Commission a great rune stone to proclaim your dynasty's glory. All future heirs will begin their rule with bonus Renown."
renown_cost = 200
authority_cost = 2
effect_key = "UPG_JELLING_STONE"
prerequisite_key = ""

--- RESOURCE: res://data/legacy/TrelleborgFortress.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_trelleborg"]

[resource]
script = ExtResource("1_trelleborg")
display_name = "Upgrade Trelleborg"
description = "Invest in the Trelleborg's defenses, permanently increasing the max garrison size for your home settlement."
renown_cost = 100
authority_cost = 3
effect_key = "UPG_TRELLEBORG"
prerequisite_key = ""

--- RESOURCE: res://data/legacy/Upg_BuildChapel.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3 uid="uid://c4qpn4hvsgkvh"]

[ext_resource type="Script" uid="uid://bot3rirdcml6f" path="res://data/legacy/LegacyUpgradeData.gd" id="1_chapel"]

[resource]
script = ExtResource("1_chapel")
display_name = "Build Chapel"
description = "Erect a small chapel, honoring the gods and securing their favor for your dynasty."
renown_cost = 50
effect_key = "UPG_BUILD_CHAPEL"
metadata/_custom_type_script = "uid://bot3rirdcml6f"

--- RESOURCE: res://data/legacy/VikingLongships.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_longships"]

[resource]
script = ExtResource("1_longships")
display_name = "Viking Longships"
description = "Improve shipbuilding techniques, allowing for faster raids and more loot."
renown_cost = 150
authority_cost = 1
effect_key = "UPG_LONGSHIPS"
prerequisite_key = ""

--- RESOURCE: res://data/settlements/economic_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://chtd3i4qtdv31"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_e06fl"]

[resource]
script = ExtResource("1_e06fl")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 8),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(8, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/fortress_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c2nrib7nroeas"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 150,
"gold": 1200,
"stone": 500,
"wood": 600
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 8
}

--- RESOURCE: res://data/settlements/home_base_fixed.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://dsgbqyqqlvlwn"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 657,
"gold": 600,
"stone": 125,
"wood": 1547
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(33, 18),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(31, 18),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(29, 18),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(31, 16),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2(36, 13),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2(37, 13),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2(38, 13),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(42, 15),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(41, 9),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(52, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(40, 9),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(51, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(50, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(49, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(32, 9),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(48, 16),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
pending_construction_buildings = [{
"grid_position": Vector2i(43, 11),
"progress": 25,
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(36, 26),
"progress": 0,
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}]
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 16
}
worker_assignments = {
"construction": 1,
"food": 0,
"stone": 0,
"wood": 0
}
metadata/_custom_type_script = "uid://hlb8s5g0yp6k"

--- RESOURCE: res://data/settlements/monastery_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://okf2novkg804"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_pnvr3"]

[resource]
script = ExtResource("1_pnvr3")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/monastery_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://6kk36f5nlwns"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 300,
"gold": 800,
"stone": 200,
"wood": 400
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/sample_fortress_gui.tres ---
[gd_resource type="SettlementData" script_class="SettlementData" load_steps=2 format=3 uid="uid://cl3pbg7tiqyng"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1"]

[resource]
resource_local_to_scene = false
resource_name = ""
script = ExtResource("1")
treasury = {
"food": 300,
"gold": 1000,
"stone": 400,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(30, 20),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(29, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(29, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(28, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(28, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(27, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(33, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 4,
"res://data/units/Unit_Raider.tres": 8
}

--- RESOURCE: res://data/settlements/small_defensive.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c5wkbqulshkqe"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_mtb34"]

[resource]
script = ExtResource("1_mtb34")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(11, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(4, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(14, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(6, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/traits/Trait_Ambitious.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://wo43cpcxhf4i"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Ambitious"
description = "This Jarl is driven by a burning desire for power and glory, and inspires the same in their children."
command_modifier = 2
stewardship_modifier = -1
intrigue_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"

--- RESOURCE: res://data/traits/Trait_Cowardly.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bivw1rejl06qi"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Cowardly"
description = "This character has shown cowardice in battle, losing the respect of their people."
is_visible = true
command_modifier = -3
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -2.0
vassal_opinion_modifier = -10
alliance_cost_modifier = 1.2
is_wounded_trait = false
is_dishonorable_trait = true

--- RESOURCE: res://data/traits/Trait_Legendary.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://c6a8qce5fgub0"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Legendary"
description = "This character has achieved legendary status through glorious deeds and successful raids."
is_visible = true
command_modifier = 5
stewardship_modifier = 2
intrigue_modifier = 3
renown_per_year_modifier = 5.0
vassal_opinion_modifier = 20
alliance_cost_modifier = 0.8
is_wounded_trait = false
is_dishonorable_trait = false

--- RESOURCE: res://data/traits/Trait_Maimed.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bbiwlkmmne5md"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Maimed"
description = "This character has suffered a permanent injury that affects their combat ability."
is_visible = true
command_modifier = -2
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -1.0
vassal_opinion_modifier = -5
alliance_cost_modifier = 1.1
is_wounded_trait = true
is_dishonorable_trait = false

--- RESOURCE: res://data/traits/Trait_Pious.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://y1xcw7hwydkx"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Pious"
description = "This Jarl is known for their devotion to the gods, making religious acts cheaper and sacrilege more costly."
stewardship_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"

--- RESOURCE: res://data/traits/Trait_Rival.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Rival"
description = "This character has developed a bitter rivalry with their liege."
is_visible = true
command_modifier = 1
stewardship_modifier = 0
intrigue_modifier = 2
vassal_opinion_modifier = -15

--- RESOURCE: res://data/traits/Trait_Seasoned.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bvgxc8k7j2rqp"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Seasoned"
description = "This character has experience from successful expeditions, granting improved combat and leadership abilities."
command_modifier = 2
stewardship_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"

--- RESOURCE: res://data/units/EnemyVikingRaider_Data.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=6 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://dsv0s4yq8c8m5" path="res://scenes/units/EnemyVikingRaider.tscn" id="2_spawn_scene"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="3_6go6j"]
[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="4_ai"]
[ext_resource type="PackedScene" uid="uid://d10havsaesr6i" path="res://scenes/effects/Projectile.tscn" id="5_proj"]

[resource]
script = ExtResource("1_script")
display_name = "Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
icon = ExtResource("3_6go6j")
spawn_cost = {
"food": 30,
"gold": 15
}
max_health = 45
move_speed = 100.0
attack_damage = 10
attack_range = 200.0
attack_speed = 0.5
ai_component_scene = ExtResource("4_ai")
projectile_scene = ExtResource("5_proj")
projectile_speed = 450.0
visual_texture = ExtResource("3_6go6j")

--- RESOURCE: res://data/units/Unit_PlayerRaider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=5 format=3 uid="uid://ejxn3hg8xcu6"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://cfanwutbtfcp2" path="res://scenes/units/PlayerVikingRaider.tscn" id="2_spawn_scene"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="3_6go6j"]
[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="4_ai"]

[resource]
script = ExtResource("1_script")
display_name = "Player Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
icon = ExtResource("3_6go6j")
spawn_cost = {
"food": 25,
"gold": 10
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 80.0
attack_speed = 0.6000000000058208
ai_component_scene = ExtResource("4_ai")
visual_texture = ExtResource("3_6go6j")
acceleration = 12.0
linear_damping = 6.0

--- RESOURCE: res://data/world_map/Region_Agdir.tres ---
[gd_resource type="Resource" script_class="WorldRegionData" load_steps=2 format=3 uid="uid://rb575376gmgd"]

[ext_resource type="Script" uid="uid://dqlbgeegli821" path="res://data/world_map/WorldRegionData.gd" id="1_8hjpx"]

[resource]
script = ExtResource("1_8hjpx")
metadata/_custom_type_script = "uid://dqlbgeegli821"

--- RESOURCE: res://data/world_map/Region_Monastery.tres ---
[gd_resource type="Resource" script_class="WorldRegionData" load_steps=3 format=3 uid="uid://bk6wv22mknptc"]

[ext_resource type="Resource" uid="uid://okf2novkg804" path="res://data/settlements/monastery_base.tres" id="1_settlement"]
[ext_resource type="Script" uid="uid://dqlbgeegli821" path="res://data/world_map/WorldRegionData.gd" id="2_world_region"]

[resource]
script = ExtResource("2_world_region")
display_name = "Nearby Monastery"
description = "A wealthy but poorly-defended monastery. An easy target for a quick grab."
target_settlement_data = ExtResource("1_settlement")
region_type_tag = "Monastery"
yearly_income = {
"food": 10,
"gold": 25
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

--- RESOURCE: res://resources/rectangleshape2d_879319.tres ---
[gd_resource type="RectangleShape2D" format=3 uid="uid://bvjkr2ny3hnvo"]

[resource]
size = Vector2(25, 3)

--- RESOURCE: res://resources/separation_circle_shape.tres ---
[gd_resource type="CircleShape2D" format=3 uid="uid://bda7xb0judu2h"]

[resource]
radius = 40.0

--- RESOURCE: res://textures/placeholders/building_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://ds2w780g4nf1t"]

[resource]
size = Vector2(128, 128)

--- RESOURCE: res://textures/placeholders/defensive_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://db3pfgf4u4pql"]

[resource]
size = Vector2(96, 96)

--- RESOURCE: res://textures/placeholders/unit_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://bg2e08mncpjg1"]

[resource]
size = Vector2(64, 64)

--- RESOURCE: res://textures/placeholders/unit_texture.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://cybqs3wt5wpg3"]

[resource]
size = Vector2(10, 2)

--- RESOURCE: res://ui/themes/VikingDynastyTheme.tres ---
[gd_resource type="Theme" load_steps=0 format=3 uid="uid://63duv3n1vwhg"]

[resource]
--- END OF RESOURCE FILES ---

#### **2.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://autoload/EventManager.tscn ---
EventManager (Node)
> script: res://autoload/EventManager.gd
> scene: res://autoload/EventManager.tscn
> event_ui_scene = res://ui/Event_UI.tscn
> succession_crisis_scene = res://ui/Succession_Crisis_UI.tscn

--- SCENE: res://autoload/PauseManager.tscn ---
PauseManager (Node)
> script: res://autoload/PauseManager.gd
> scene: res://autoload/PauseManager.tscn
> pause_menu_scene = res://scripts/ui/PauseMenu.tscn

--- SCENE: res://autoload/SceneManager.tscn ---
SceneManager (Node)
> script: res://autoload/SceneManager.gd
> scene: res://autoload/SceneManager.tscn
> settlement_scene = res://scenes/levels/SettlementBridge.tscn
> world_map_scene = res://scenes/world_map/MacroMap.tscn
> raid_mission_scene = res://scenes/missions/RaidMission.tscn

--- SCENE: res://player/RTSController.tscn ---
RTSController (Node)
> script: res://player/RTSController.gd
> scene: res://player/RTSController.tscn

--- SCENE: res://scenes/buildings/Base_Building.tscn ---
Base_Building (StaticBody2D)
> script: res://data/buildings/Base_Building.gd
> scene: res://scenes/buildings/Base_Building.tscn

--- SCENE: res://scenes/components/AttackAI.tscn ---
AttackAI (Node2D)
> script: res://scenes/components/AttackAI.gd
> scene: res://scenes/components/AttackAI.tscn
> ai_mode = 0
> great_hall_los_range = 600.0
> attack_damage = 10
> attack_range = 200.0
> attack_speed = 1.0
> DetectionArea (Area2D)
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://scenes/components/AttackAI.tscn::CircleShape2D_2baay
> AttackTimer (Timer)

--- SCENE: res://scenes/effects/Projectile.tscn ---
Projectile (Area2D)
> script: res://scenes/effects/Projectile.gd
> scene: res://scenes/effects/Projectile.tscn
> scale = (2.0, 2.0)
> collision_layer = 1024
> collision_mask = 0
> monitorable = false
> Sprite2D (Sprite2D)
> > scale = (0.024707, 0.00293)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://resources/rectangleshape2d_879319.tres
> LifetimeTimer (Timer)
> > wait_time = 3.0
> > one_shot = true
> > autostart = true

--- SCENE: res://scenes/levels/DefensiveMicro.tscn ---
DefensiveMicro (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/levels/DefensiveMicro.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> is_defensive_mission = true
> enemy_spawn_position = 
> TileMap (TileMap)
> > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > enable_drag_panning = true
> > min_zoom = 0.5
> > max_zoom = 2.0
> > zoom_speed = 0.1
> > zoom_smoothing = 10.0
> > bounds_enabled = true
> > bounds_rect = [P: (-1000.0, -1000.0), S: (3000.0, 2500.0)]
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
> > grid_width = 60
> > grid_height = 40
> > cell_size = 32
> BuildingContainer (Node2D)
> RaidObjectiveManager (Node)
>   script: res://scenes/missions/RaidObjectiveManager.gd
> > victory_bonus_loot = {"gold":200}
> > settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> > is_defensive_mission = false
> EnemySpawnPosition (Marker2D)
> > position = (700.0, 100.0)

--- SCENE: res://scenes/levels/SettlementBridge.tscn ---
SettlementBridge (Node)
> script: res://scripts/buildings/SettlementBridge.gd
> scene: res://scenes/levels/SettlementBridge.tscn
> home_base_data = res://scenes/levels/SettlementBridge.tscn::Resource_vmd61
> end_of_year_popup_scene = res://ui/EndOfYear_Popup.tscn
> world_map_scene_path = "res://scenes/world_map/MacroMap.tscn"
> UnitContainer (Node2D)
> UI (CanvasLayer)
>   Label (Label)
>   > anchors_preset = 5
>   > anchor_left = 0.5
>   > anchor_right = 0.5
>   > offset_left = -319.0
>   > offset_right = 319.0
>   > offset_bottom = 23.0
>   > grow_horizontal = 2
>   > text = "Purchase buildings from the storefront below, then place them on your settlement"
>   > horizontal_alignment = 1
>   Storefront_UI (Control)
>     script: res://ui/StorefrontUI.gd
>     scene: res://ui/Storefront_UI.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > available_buildings = []
>   > available_units = []
>   > default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
>   > auto_load_units_from_directory = true
>     PanelContainer (PanelContainer)
>     > layout_mode = 1
>     > anchors_preset = -1
>     > anchor_top = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = 20.0
>     > offset_top = -140.0
>     > offset_right = 480.0
>     > offset_bottom = -20.0
>     > grow_vertical = 0
>       MarginContainer (MarginContainer)
>       > layout_mode = 2
>         TabContainer (TabContainer)
>         > layout_mode = 2
>         > current_tab = 0
>           BuildTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             TreasuryDisplay (HBoxContainer)
>             > layout_mode = 2
>               GoldLabel (Label)
>               > layout_mode = 2
>               > text = "Gold: 0"
>               WoodLabel (Label)
>               > layout_mode = 2
>               > text = "Wood: 0"
>               FoodLabel (Label)
>               > layout_mode = 2
>               > text = "Food: 0"
>               StoneLabel (Label)
>               > layout_mode = 2
>               > text = "Stone: 0"
>             BuildButtonsContainer (VBoxContainer)
>             > layout_mode = 2
>           RecruitTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             RecruitButtons (VBoxContainer)
>             > layout_mode = 2
>             GarrisonList (VBoxContainer)
>             > layout_mode = 2
>           LegacyTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             JarlStatsDisplay (HBoxContainer)
>             > layout_mode = 2
>               RenownLabel (Label)
>               > layout_mode = 2
>               > text = "Renown: 0"
>               AuthorityLabel (Label)
>               > layout_mode = 2
>               > text = "Authority: 0/0"
>             Description (Label)
>             > layout_mode = 2
>             > text = "Spend Renown and Authority on permanent dynasty upgrades."
>             > autowrap_mode = 3
>             HSeparator (HSeparator)
>             > layout_mode = 2
>             LegacyButtonsContainer (VBoxContainer)
>             > layout_mode = 2
>     DebugRaidButton (Button)
>     > layout_mode = 1
>     > anchors_preset = -1
>     > anchor_left = 1.0
>     > anchor_right = 1.0
>     > offset_left = -143.0
>     > offset_bottom = 27.0
>     > grow_horizontal = 0
>     > text = "DEBUG: Start Raid"
>   RestartButton (Button)
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -84.0
>   > offset_top = -15.5
>   > offset_right = 84.0
>   > offset_bottom = 15.5
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "Return to Settlement"
>   StartRaidButton (Button)
>   > anchors_preset = 3
>   > anchor_left = 1.0
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -150.0
>   > offset_top = -40.0
>   > grow_horizontal = 0
>   > grow_vertical = 0
>   > text = "World Map"
> BuildingCursor (Node2D)
>   script: res://scripts/ui/BuildingPreviewCursor.gd
> BuildingContainer (Node2D)
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
>   scene: res://scripts/utility/GridManager.tscn
> > grid_width = 60
> > grid_height = 40
> > cell_size = 32
> GridVisualizer (Node2D)
>   script: res://scripts/utility/GridVisualizer.gd
>   scene: res://scripts/utility/GridVisualizer.tscn
> Camera2D (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (1000.0, 400.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > enable_drag_panning = true
> > min_zoom = 0.5
> > max_zoom = 2.0
> > zoom_speed = 0.1
> > zoom_smoothing = 10.0
> > bounds_enabled = true
> > bounds_rect = [P: (-1000.0, -1000.0), S: (3000.0, 2500.0)]

--- SCENE: res://scenes/missions/RaidMission.tscn ---
RaidMission (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/missions/RaidMission.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> is_defensive_mission = false
> enemy_spawn_position = EnemySpawnPosition
> PlayerStartPosition (Marker2D)
> > position = (-161.0, 606.0)
> EnemySpawnPosition (Marker2D)
> > position = (383.0, -21.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> CanvasLayer (CanvasLayer)
>   SelectionBox (Control)
>     script: res://ui/SelectionBox.gd
>     scene: res://ui/SelectionBox.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://ui/themes/VikingDynastyTheme.tres
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > enable_drag_panning = true
> > min_zoom = 0.5
> > max_zoom = 2.0
> > zoom_speed = 0.1
> > zoom_smoothing = 10.0
> > bounds_enabled = true
> > bounds_rect = [P: (-1000.0, -1000.0), S: (3000.0, 2500.0)]
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
>   scene: res://scripts/utility/GridManager.tscn
> > grid_width = 120
> > grid_height = 80
> > cell_size = 32
> GridVisualizer (Node2D)
>   script: res://scripts/utility/GridVisualizer.gd
>   scene: res://scripts/utility/GridVisualizer.tscn
> BuildingContainer (Node2D)
> RaidObjectiveManager (Node)
>   script: res://scenes/missions/RaidObjectiveManager.gd
> > victory_bonus_loot = {"gold":200}
> > settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> > is_defensive_mission = false

--- SCENE: res://scenes/units/Base_Unit.tscn ---
Base_Unit (CharacterBody2D)
> script: res://scripts/units/Base_Unit.gd
> scene: res://scenes/units/Base_Unit.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/units/EnemyVikingRaider.tscn ---
EnemyVikingRaider (CharacterBody2D)
> script: res://scripts/units/EnemyVikingRaider.gd
> scene: res://scenes/units/EnemyVikingRaider.tscn
> collision_layer = 4
> collision_mask = 3
> separation_enabled = true
> separation_force = 30.0
> separation_radius = 40.0
> Sprite2D (Sprite2D)
> > scale = (0.06543, 0.068359)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/units/PlayerVikingRaider.tscn ---
PlayerVikingRaider (CharacterBody2D)
> script: res://scripts/units/PlayerVikingRaider.gd
> scene: res://scenes/units/PlayerVikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > scale = (0.058594, 0.061523)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/units/VikingRaider.tscn ---
VikingRaider (CharacterBody2D)
> script: res://scripts/units/EnemyVikingRaider.gd
> scene: res://scenes/units/VikingRaider.tscn
> collision_layer = 4
> data = res://data/units/EnemyVikingRaider_Data.tres
> separation_enabled = false
> Sprite2D (Sprite2D)
> > modulate = (0.5464, 0.0, 0.0, 1.0)
> > self_modulate = (1.0, 0.0, 0.0, 1.0)
> > scale = (0.059, 0.062)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > position = (-1.0, 0.0)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/world_map/MacroCamera.tscn ---
MacroCamera (Camera2D)
> script: res://scenes/world_map/MacroCamera.gd
> scene: res://scenes/world_map/MacroCamera.tscn
> camera_speed = 500.0
> edge_pan_margin = 20.0
> enable_edge_panning = true
> enable_keyboard_movement = true
> min_zoom = 0.5
> max_zoom = 2.0
> zoom_speed = 0.1
> zoom_smoothing = 10.0
> bounds_enabled = true
> bounds_rect = [P: (0.0, 0.0), S: (1920.0, 1080.0)]

--- SCENE: res://scenes/world_map/MacroMap.tscn ---
MacroMap (Node2D)
> script: res://scenes/world_map/MacroMap.gd
> scene: res://scenes/world_map/MacroMap.tscn
> raid_mission_scene_path = "res://scenes/missions/RaidMission.tscn"
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> end_year_popup_scene = res://ui/EndOfYear_Popup.tscn
> enemy_raid_chance = 0.25
> player_home_marker_path = PlayerHomeMarker
> TextureRect (TextureRect)
> > offset_left = 2.0
> > offset_top = -4.0
> > offset_right = 1022.0
> > offset_bottom = 771.0
> > texture = res://assets/Viking Dynasty Game Map.png
> Regions (Node2D)
>   Region_1 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_seg4e
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(539.0, 493.0), (542.0, 507.0), (548.0, 519.0), (550.0, 534.0), (564.0, 561.0), (571.0, 570.0), (569.0, 574.0), (568.0, 577.0), (566.0, 580.0), (566.0, 587.0), (569.0, 591.0), (574.0, 596.0), (574.0, 603.0), (574.0, 607.0), (578.0, 609.0), (584.0, 609.0), (590.0, 606.0), (596.0, 607.0), (600.0, 604.0), (597.0, 597.0), (598.0, 586.0), (611.0, 581.0), (622.0, 579.0), (625.0, 580.0), (628.0, 580.0), (628.0, 573.0), (632.0, 564.0), (634.0, 560.0), (633.0, 545.0), (635.0, 535.0), (634.0, 524.0), (635.0, 515.0), (635.0, 509.0), (630.0, 505.0), (626.0, 505.0), (606.0, 489.0), (591.0, 478.0), (570.0, 465.0), (564.0, 456.0), (558.0, 453.0), (556.0, 457.0), (555.0, 459.0), (550.0, 461.0), (549.0, 466.0), (546.0, 471.0), (548.0, 477.0), (549.0, 482.0), (546.0, 488.0), (546.0, 492.0), (541.0, 491.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>     > polygon = [(0.0, 0.0)]
>   Region_2 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_seg4e
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(450.0, 509.0), (440.0, 496.0), (453.0, 483.0), (455.0, 475.0), (448.0, 478.0), (441.0, 479.0), (438.0, 471.0), (440.0, 463.0), (446.0, 456.0), (443.3711, 449.4278), (440.0, 441.0), (439.0, 426.0), (440.0, 416.0), (439.4912, 404.8077), (439.0, 394.0), (445.0, 393.0), (444.0, 385.0), (452.0, 383.0), (457.0, 375.0), (467.0, 370.0), (467.0, 363.0), (476.0, 361.0), (482.0, 362.0), (485.0, 352.0), (493.0, 341.0), (508.0, 344.0), (512.0, 340.0), (515.0, 343.0), (546.0, 348.0), (552.0, 368.0), (552.0, 391.0), (555.0, 405.0), (563.0, 410.0), (563.0, 422.0), (554.0, 428.0), (558.0, 436.0), (561.0, 455.0), (551.0, 463.0), (548.0, 472.0), (546.0, 494.0), (537.0, 491.0), (534.0, 483.0), (528.0, 482.0), (520.0, 490.0), (500.0, 507.0), (491.0, 519.0), (479.0, 524.0), (467.0, 522.0), (458.0, 514.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_3 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_seg4e
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(632.0, 505.0), (600.0, 483.0), (581.0, 473.0), (559.0, 452.0), (559.0, 437.0), (553.0, 425.0), (561.0, 423.0), (561.0, 417.0), (561.0, 411.0), (556.0, 404.0), (553.0, 402.0), (551.0, 363.0), (549.0, 352.0), (552.0, 333.0), (558.0, 325.0), (566.0, 325.0), (574.0, 324.0), (577.0, 314.0), (569.0, 306.0), (578.0, 289.0), (579.0, 264.0), (578.0, 256.0), (589.0, 249.0), (589.0, 241.0), (601.0, 220.0), (596.0, 207.0), (601.0, 200.0), (601.0, 190.0), (607.0, 185.0), (612.0, 187.0), (616.0, 187.0), (616.0, 181.0), (616.0, 172.0), (620.0, 169.0), (640.0, 172.0), (642.0, 153.0), (643.0, 148.0), (646.0, 148.0), (655.0, 156.0), (663.0, 162.0), (673.0, 164.0), (679.0, 170.0), (687.0, 177.0), (690.0, 194.0), (694.0, 205.0), (701.0, 218.0), (698.0, 227.0), (709.0, 245.0), (705.0, 249.0), (688.0, 253.0), (679.0, 269.0), (674.0, 288.0), (682.0, 298.0), (673.0, 320.0), (657.0, 335.0), (652.0, 342.0), (648.0, 344.0), (640.0, 358.0), (637.0, 366.0), (633.0, 372.0), (632.0, 381.0), (631.0, 394.0), (630.0, 408.0), (633.0, 423.0), (637.0, 431.0), (647.0, 433.0), (656.0, 443.0), (663.0, 451.0), (665.0, 458.0), (663.0, 467.0), (660.0, 474.0), (654.0, 482.0), (650.0, 488.0), (643.0, 492.0), (636.0, 496.0), (636.0, 501.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_4 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_seg4e
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(515.0, 343.0), (523.0, 347.0), (535.0, 347.0), (545.0, 347.0), (549.0, 346.0), (553.0, 331.0), (559.0, 325.0), (572.0, 325.0), (575.0, 320.0), (576.0, 313.0), (572.0, 308.0), (570.0, 304.0), (574.0, 296.0), (579.0, 283.0), (579.0, 271.0), (578.0, 259.0), (579.0, 255.0), (588.0, 251.0), (590.0, 248.0), (589.0, 243.0), (600.0, 220.0), (592.0, 219.0), (585.0, 219.0), (580.0, 219.0), (573.0, 219.0), (550.0, 275.0), (541.0, 296.0), (536.0, 303.0), (538.0, 307.0), (537.0, 310.0), (535.0, 308.0), (530.0, 307.0), (528.0, 312.0), (522.0, 317.0), (519.0, 322.0), (517.0, 327.0), (515.0, 331.0), (512.0, 336.0), (512.0, 339.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_5 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_seg4e
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(528.0, 533.0), (526.0, 537.0), (527.0, 540.0), (528.0, 545.0), (527.0, 551.0), (525.0, 556.0), (525.0, 560.0), (524.0, 564.0), (524.0, 567.0), (525.0, 569.0), (527.0, 572.0), (529.0, 572.0), (534.0, 572.0), (536.0, 575.0), (535.0, 578.0), (529.0, 588.0), (519.0, 597.0), (518.0, 608.0), (518.0, 620.0), (543.0, 625.0), (552.0, 626.0), (551.0, 618.0), (538.0, 612.0), (538.0, 604.0), (541.0, 596.0), (547.0, 592.0), (559.0, 590.0), (561.0, 596.0), (566.0, 600.0), (571.0, 605.0), (571.0, 610.0), (567.0, 611.0), (563.0, 614.0), (563.0, 619.0), (563.0, 623.0), (560.0, 628.0), (555.0, 635.0), (549.0, 634.0), (546.0, 634.0), (530.0, 633.0), (514.0, 628.0), (511.0, 628.0), (504.0, 627.0), (499.0, 627.0), (494.0, 624.0), (490.0, 621.0), (492.0, 615.0), (493.0, 611.0), (486.0, 606.0), (484.0, 604.0), (483.0, 600.0), (488.0, 592.0), (485.0, 581.0), (483.0, 577.0), (483.0, 571.0), (486.0, 565.0), (488.0, 559.0), (490.0, 556.0), (492.0, 554.0), (496.0, 553.0), (501.0, 553.0), (505.0, 553.0), (509.0, 551.0), (513.0, 546.0), (516.0, 541.0), (520.0, 538.0), (525.0, 537.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_6 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_seg4e
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(648.0, 148.0), (649.0, 139.0), (653.0, 139.0), (658.0, 143.0), (665.0, 150.0), (666.0, 153.0), (672.0, 156.0), (681.0, 154.0), (685.0, 149.0), (691.0, 152.0), (697.0, 153.0), (698.0, 148.0), (700.0, 146.0), (705.0, 143.0), (704.0, 115.0), (705.0, 109.0), (710.0, 103.0), (716.0, 102.0), (720.0, 97.0), (729.0, 101.0), (738.0, 104.0), (742.0, 112.0), (744.0, 121.0), (744.0, 129.0), (741.0, 133.0), (741.0, 138.0), (741.0, 148.0), (745.0, 154.0), (754.0, 159.0), (760.0, 161.0), (767.0, 167.0), (768.0, 176.0), (766.0, 190.0), (764.0, 198.0), (770.0, 204.0), (774.0, 209.0), (779.0, 216.0), (785.0, 224.0), (788.0, 232.0), (787.0, 244.0), (788.0, 252.0), (790.0, 261.0), (798.0, 262.0), (799.0, 270.0), (805.0, 272.0), (810.0, 277.0), (810.0, 286.0), (806.0, 293.0), (811.0, 296.0), (820.0, 301.0), (830.0, 307.0), (836.0, 313.0), (836.0, 325.0), (832.0, 334.0), (827.0, 345.0), (823.0, 355.0), (821.0, 363.0), (817.0, 375.0), (809.0, 386.0), (805.0, 395.0), (800.0, 404.0), (791.0, 409.0), (788.0, 411.0), (781.0, 417.0), (772.0, 422.0), (760.0, 428.0), (749.0, 432.0), (734.0, 438.0), (725.0, 436.0), (719.0, 432.0), (708.0, 426.0), (703.0, 420.0), (695.0, 404.0), (693.0, 384.0), (691.0, 374.0), (685.0, 368.0), (685.0, 354.0), (688.0, 348.0), (688.0, 337.0), (690.0, 335.0), (694.0, 335.0), (701.0, 330.0), (703.0, 321.0), (708.0, 314.0), (714.0, 300.0), (721.0, 280.0), (727.0, 272.0), (712.0, 244.0), (704.0, 237.0), (700.0, 224.0), (698.0, 212.0), (692.0, 200.0), (688.0, 187.0), (682.0, 174.0), (675.0, 164.0), (662.0, 161.0), (653.0, 155.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_7 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_qn6r3
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(814.0, 438.0), (808.0, 438.0), (805.0, 439.0), (801.0, 441.0), (798.0, 441.0), (794.0, 441.0), (792.0, 440.0), (785.0, 440.0), (781.0, 440.0), (779.0, 440.0), (776.0, 442.0), (774.0, 445.0), (772.0, 445.0), (768.0, 447.0), (765.0, 448.0), (761.0, 449.0), (757.0, 449.0), (754.0, 451.0), (753.0, 453.0), (749.0, 456.0), (748.0, 458.0), (744.0, 461.0), (741.0, 463.0), (734.0, 469.0), (728.0, 469.0), (727.0, 471.0), (724.0, 473.0), (722.0, 475.0), (724.0, 477.0), (726.0, 479.0), (727.0, 480.0), (728.0, 482.0), (728.0, 484.0), (724.0, 488.0), (723.0, 489.0), (722.0, 493.0), (722.0, 496.0), (722.0, 498.0), (722.0, 500.0), (724.0, 500.0), (729.0, 500.0), (731.0, 498.0), (733.0, 496.0), (737.0, 494.0), (738.0, 492.0), (740.0, 490.0), (744.0, 488.0), (745.0, 485.0), (748.0, 484.0), (751.0, 487.0), (752.0, 489.0), (756.0, 489.0), (761.0, 489.0), (765.0, 488.0), (765.0, 491.0), (766.0, 495.0), (766.0, 499.0), (766.0, 502.0), (771.0, 497.0), (774.0, 496.0), (778.0, 495.0), (780.0, 494.0), (782.0, 493.0), (785.0, 494.0), (788.0, 495.0), (791.0, 496.0), (792.0, 497.0), (797.0, 499.0), (799.0, 501.0), (801.0, 502.0), (804.0, 504.0), (808.0, 503.0), (809.0, 501.0), (812.0, 500.0), (816.0, 500.0), (818.0, 500.0), (819.0, 498.0), (819.0, 496.0), (820.0, 493.0), (822.0, 491.0), (823.0, 489.0), (822.0, 484.0), (820.0, 482.0), (818.0, 478.0), (815.0, 475.0), (815.0, 472.0), (815.0, 470.0), (812.0, 466.0), (812.0, 460.0), (812.0, 455.0), (814.0, 453.0), (814.0, 449.0), (814.0, 446.0), (817.0, 440.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_8 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_aeufb
>     HighlightPoly (Polygon2D)
>     > visible = false
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(716.0, 563.0), (716.0, 556.0), (716.0, 551.0), (716.0, 546.0), (718.0, 542.0), (719.0, 540.0), (719.0, 534.0), (719.0, 529.0), (720.0, 523.0), (723.0, 519.0), (727.0, 517.0), (731.0, 515.0), (735.0, 512.0), (737.0, 512.0), (737.0, 513.0), (738.0, 515.0), (741.0, 516.0), (745.0, 519.0), (748.0, 522.0), (751.0, 526.0), (752.0, 529.0), (754.0, 532.0), (757.0, 532.0), (759.0, 532.0), (763.0, 532.0), (765.0, 530.0), (766.0, 528.0), (769.0, 526.0), (769.0, 524.0), (769.0, 521.0), (769.0, 519.0), (769.0, 517.0), (768.0, 514.0), (768.0, 511.0), (768.0, 507.0), (767.0, 501.0), (770.0, 498.0), (775.0, 498.0), (776.0, 496.0), (778.0, 495.0), (783.0, 495.0), (790.0, 495.0), (798.0, 499.0), (800.0, 501.0), (803.0, 503.0), (805.0, 504.0), (810.0, 501.0), (813.0, 500.0), (819.0, 500.0), (821.0, 501.0), (825.0, 504.0), (829.0, 506.0), (831.0, 508.0), (832.0, 511.0), (832.0, 517.0), (832.0, 519.0), (835.0, 519.0), (838.0, 523.0), (840.0, 527.0), (841.0, 529.0), (843.0, 533.0), (845.0, 535.0), (846.0, 538.0), (843.0, 544.0), (841.0, 547.0), (840.0, 549.0), (838.0, 552.0), (837.0, 554.0), (833.0, 556.0), (831.0, 556.0), (830.0, 555.0), (828.0, 556.0), (827.0, 559.0), (823.0, 561.0), (821.0, 561.0), (816.0, 561.0), (813.0, 560.0), (808.0, 556.0), (805.0, 555.0), (803.0, 553.0), (800.0, 552.0), (798.0, 552.0), (792.0, 552.0), (791.0, 552.0), (790.0, 551.0), (788.0, 547.0), (787.0, 546.0), (784.0, 546.0), (784.0, 549.0), (782.0, 552.0), (780.0, 554.0), (775.0, 554.0), (770.0, 554.0), (765.0, 554.0), (762.0, 554.0), (758.0, 554.0), (757.0, 554.0), (754.0, 557.0), (752.0, 555.0), (751.0, 553.0), (750.0, 553.0), (749.0, 554.0), (748.0, 556.0), (744.0, 556.0), (740.0, 556.0), (736.0, 556.0), (733.0, 557.0), (729.0, 560.0), (727.0, 562.0), (727.0, 562.0), (725.0, 564.0), (723.0, 564.0), (718.0, 565.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_9 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_3epe4
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(725.0, 564.0), (726.0, 567.0), (726.0, 569.0), (727.0, 571.0), (727.0, 575.0), (727.0, 577.0), (730.0, 578.0), (729.0, 580.0), (726.0, 581.0), (726.0, 585.0), (726.0, 588.0), (726.0, 590.0), (726.0, 592.0), (726.0, 594.0), (728.0, 596.0), (731.0, 596.0), (734.0, 597.0), (737.0, 599.0), (742.0, 600.0), (745.0, 600.0), (750.0, 600.0), (751.0, 599.0), (755.0, 600.0), (756.0, 601.0), (757.0, 603.0), (759.0, 604.0), (759.0, 608.0), (759.0, 610.0), (759.0, 611.0), (759.0, 614.0), (759.0, 616.0), (761.0, 617.0), (764.0, 618.0), (768.0, 620.0), (771.0, 621.0), (774.0, 622.0), (775.0, 623.0), (776.0, 625.0), (777.0, 627.0), (776.0, 630.0), (776.0, 631.0), (778.0, 632.0), (780.0, 631.0), (782.0, 631.0), (786.0, 630.0), (788.0, 629.0), (789.0, 628.0), (793.0, 629.0), (794.0, 629.0), (799.0, 624.0), (800.0, 623.0), (802.0, 620.0), (803.0, 618.0), (804.0, 618.0), (807.0, 616.0), (808.0, 615.0), (812.0, 612.0), (814.0, 609.0), (814.0, 606.0), (814.0, 603.0), (815.0, 602.0), (815.0, 599.0), (814.0, 597.0), (814.0, 595.0), (814.0, 593.0), (814.0, 590.0), (816.0, 588.0), (818.0, 588.0), (820.0, 587.0), (820.0, 584.0), (820.0, 582.0), (820.0, 581.0), (822.0, 580.0), (824.0, 580.0), (826.0, 579.0), (827.0, 576.0), (827.0, 574.0), (825.0, 573.0), (823.0, 572.0), (823.0, 569.0), (823.0, 564.0), (821.0, 563.0), (819.0, 562.0), (816.0, 562.0), (814.0, 560.0), (812.0, 558.0), (809.0, 556.0), (804.0, 554.0), (801.0, 552.0), (797.0, 553.0), (794.0, 552.0), (790.0, 551.0), (787.0, 550.0), (785.0, 547.0), (783.0, 547.0), (780.0, 551.0), (779.0, 552.0), (778.0, 552.0), (773.0, 555.0), (770.0, 553.0), (767.0, 553.0), (764.0, 553.0), (760.0, 553.0), (757.0, 553.0), (756.0, 554.0), (755.0067, 555.4899), (754.0, 557.0), (752.8177, 555.8177), (752.0, 554.0), (750.0, 553.0), (749.0, 555.0), (747.0, 557.0), (744.0, 556.0), (740.0, 556.0), (737.0, 556.0), (734.0, 557.0), (731.0, 559.0), (728.0, 560.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_10 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_37xpq
>     HighlightPoly (Polygon2D)
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(728.0, 595.0), (727.0, 597.0), (727.0, 599.0), (729.0, 602.0), (729.0, 606.0), (729.0, 608.0), (727.0, 608.0), (726.0, 608.0), (724.0, 608.0), (722.0, 608.0), (720.0, 607.0), (718.0, 606.0), (715.0, 607.0), (713.0, 608.0), (712.0, 608.0), (710.0, 608.0), (707.0, 609.0), (707.0, 611.0), (706.0, 612.0), (705.0, 615.0), (706.0, 616.0), (706.0, 617.0), (707.0, 620.0), (707.0, 622.0), (706.0, 624.0), (704.0, 625.0), (701.0, 627.0), (700.0, 628.0), (704.0, 628.0), (706.0, 628.0), (709.0, 628.0), (713.0, 628.0), (718.0, 628.0), (724.0, 628.0), (728.0, 627.0), (730.0, 627.0), (735.0, 626.0), (740.0, 625.0), (744.0, 624.0), (747.0, 623.0), (751.0, 623.0), (754.0, 621.0), (757.0, 619.0), (758.0, 618.0), (758.0, 615.0), (759.0, 612.0), (759.0, 608.0), (759.0, 606.0), (759.0, 603.0), (758.0, 602.0), (757.0, 602.0), (755.0, 600.0), (753.0, 598.0), (751.0, 598.0), (747.0, 598.0), (745.0, 599.0), (742.0, 600.0), (739.0, 599.0), (735.0, 598.0), (734.0, 598.0), (733.0, 597.0), (731.0, 596.0), (729.0, 595.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_11 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_n4r4f
>     HighlightPoly (Polygon2D)
>     > visible = false
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(690.0, 631.0), (694.0, 631.0), (698.0, 629.0), (701.0, 627.0), (705.0, 628.0), (710.0, 628.0), (715.0, 628.0), (721.0, 628.0), (728.0, 626.0), (734.0, 626.0), (743.0, 624.0), (749.0, 623.0), (756.0, 621.0), (759.0, 619.0), (761.0, 617.0), (766.0, 619.0), (770.0, 619.0), (772.0, 621.0), (775.0, 626.0), (777.0, 629.0), (780.0, 634.0), (782.0, 640.0), (785.0, 645.0), (787.0, 649.0), (790.0, 655.0), (793.0, 659.0), (794.0, 670.0), (794.0, 671.0), (791.0, 675.0), (788.0, 677.0), (785.0, 680.0), (784.0, 682.0), (785.0, 684.0), (787.0, 686.0), (792.0, 690.0), (793.0, 694.0), (793.0, 700.0), (793.0, 705.0), (794.0, 709.0), (796.0, 713.0), (800.0, 717.0), (804.0, 721.0), (807.0, 726.0), (809.0, 729.0), (810.0, 735.0), (810.0, 738.0), (809.0, 741.0), (806.0, 745.0), (799.0, 756.0), (796.0, 763.0), (793.0, 769.0), (737.0, 767.0), (739.0, 762.0), (744.0, 759.0), (747.0, 757.0), (755.0, 753.0), (757.0, 750.0), (759.0, 745.0), (762.0, 740.0), (762.0, 736.0), (762.0, 731.0), (760.0, 726.0), (759.0, 721.0), (760.0, 716.0), (753.0, 713.0), (748.0, 708.0), (746.0, 704.0), (744.0, 699.0), (742.0, 696.0), (737.0, 692.0), (734.0, 690.0), (728.0, 690.0), (724.0, 691.0), (716.0, 692.0), (712.0, 691.0), (708.0, 691.0), (703.0, 690.0), (697.0, 687.0), (693.0, 683.0), (685.0, 679.0), (685.0, 677.0), (682.0, 676.0), (677.0, 673.0), (678.0, 669.0), (680.0, 665.0), (682.0, 664.0), (685.0, 661.0), (689.0, 654.0), (689.0, 653.0), (688.0, 646.0), (687.0, 644.0), (687.0, 638.0), (688.0, 633.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_12 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_47i7n
>     HighlightPoly (Polygon2D)
>     > visible = false
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(602.0, 655.0), (600.0, 657.0), (595.0, 657.0), (594.0, 652.0), (592.0, 649.0), (588.0, 649.0), (585.0, 649.0), (583.0, 646.0), (586.0, 643.0), (588.0, 640.0), (588.0, 638.0), (587.0, 634.0), (585.0, 634.0), (581.0, 636.0), (580.0, 638.0), (574.0, 639.0), (571.0, 640.0), (568.0, 640.0), (565.0, 644.0), (562.0, 645.0), (559.0, 647.0), (556.0, 649.0), (550.0, 650.0), (550.0, 652.0), (549.0, 655.0), (547.0, 656.0), (543.0, 655.0), (542.0, 654.0), (538.0, 655.0), (534.0, 654.0), (537.0, 650.0), (539.0, 648.0), (539.0, 646.0), (540.0, 640.0), (537.0, 638.0), (534.0, 642.0), (534.0, 644.0), (531.0, 644.0), (529.0, 642.0), (523.0, 641.0), (523.0, 641.0), (518.0, 635.0), (518.0, 633.0), (514.0, 629.0), (507.0, 629.0), (496.0, 627.0), (494.0, 626.0), (493.0, 628.0), (495.0, 631.0), (495.0, 634.0), (498.0, 636.0), (498.0, 639.0), (496.0, 641.0), (493.0, 642.0), (493.0, 643.0), (493.0, 645.0), (496.0, 645.0), (497.0, 646.0), (497.0, 649.0), (497.0, 652.0), (496.0, 655.0), (495.0, 658.0), (491.0, 660.0), (490.0, 662.0), (488.0, 667.0), (486.0, 669.0), (483.0, 667.0), (479.0, 663.0), (474.0, 663.0), (470.0, 663.0), (466.0, 664.0), (465.0, 664.0), (464.0, 666.0), (463.0, 669.0), (455.0, 672.0), (453.0, 672.0), (448.0, 673.0), (442.0, 675.0), (434.0, 676.0), (431.0, 678.0), (428.0, 685.0), (428.0, 687.0), (425.0, 690.0), (423.0, 692.0), (415.0, 696.0), (414.0, 697.0), (412.0, 702.0), (410.0, 706.0), (408.0, 709.0), (407.0, 713.0), (404.0, 716.0), (402.0, 719.0), (398.0, 722.0), (409.0, 733.0), (411.0, 734.0), (417.0, 738.0), (424.0, 742.0), (430.0, 746.0), (434.0, 747.0), (436.0, 754.0), (437.0, 762.0), (438.0, 766.0), (585.0, 768.0), (588.0, 764.0), (591.0, 761.0), (598.0, 758.0), (605.0, 756.0), (611.0, 756.0), (616.0, 755.0), (621.0, 751.0), (622.0, 743.0), (622.0, 737.0), (616.0, 731.0), (614.0, 724.0), (614.0, 717.0), (614.0, 709.0), (609.0, 702.0), (605.0, 695.0), (603.0, 691.0), (602.0, 688.0), (601.0, 683.0), (602.0, 678.0), (603.0, 673.0), (604.0, 670.0), (604.0, 664.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_13 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_uahyi
>     HighlightPoly (Polygon2D)
>     > visible = false
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(687.0, 633.0), (684.0, 631.0), (683.0, 629.0), (681.0, 626.0), (679.0, 623.0), (676.0, 618.0), (670.0, 620.0), (666.0, 621.0), (659.0, 622.0), (655.0, 625.0), (650.0, 628.0), (647.0, 630.0), (642.0, 633.0), (640.0, 636.0), (638.0, 638.0), (635.0, 639.0), (630.0, 642.0), (627.0, 643.0), (622.0, 645.0), (618.0, 646.0), (612.0, 649.0), (609.0, 651.0), (606.0, 653.0), (603.0, 654.0), (605.0, 657.0), (605.0, 658.0), (606.0, 661.0), (607.0, 665.0), (607.0, 671.0), (606.0, 674.0), (604.0, 678.0), (602.0, 682.0), (602.0, 685.0), (602.0, 687.0), (603.0, 690.0), (604.0, 692.0), (605.0, 693.0), (610.0, 697.0), (613.0, 705.0), (613.0, 709.0), (613.0, 710.0), (621.0, 711.0), (629.0, 713.0), (639.0, 716.0), (641.0, 723.0), (642.0, 730.0), (651.0, 731.0), (654.0, 736.0), (654.0, 739.0), (662.0, 741.0), (668.0, 743.0), (676.0, 748.0), (685.0, 754.0), (687.0, 755.0), (694.0, 763.0), (701.0, 772.0), (734.0, 769.0), (738.0, 762.0), (745.0, 760.0), (750.0, 758.0), (754.0, 755.0), (758.0, 752.0), (760.0, 746.0), (761.0, 733.0), (761.0, 731.0), (761.0, 725.0), (761.0, 721.0), (759.0, 716.0), (752.0, 712.0), (747.0, 707.0), (745.0, 703.0), (742.0, 697.0), (737.0, 693.0), (732.0, 691.0), (723.0, 692.0), (714.0, 692.0), (703.0, 691.0), (701.0, 688.0), (695.0, 683.0), (689.0, 681.0), (686.0, 680.0), (684.0, 677.0), (678.0, 669.0), (678.0, 666.0), (682.0, 663.0), (686.0, 658.0), (689.0, 653.0), (689.0, 650.0), (689.0, 649.0), (689.0, 642.0), (689.0, 636.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
>   Region_14 (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > data = res://scenes/world_map/MacroMap.tscn::Resource_jetqj
>     HighlightPoly (Polygon2D)
>     > visible = false
>     > color = (1.0, 1.0, 1.0, 0.1961)
>     > polygon = [(264.0, 478.0), (270.0, 483.0), (272.0, 484.0), (276.0, 484.0), (281.0, 484.0), (290.0, 484.0), (297.0, 485.0), (296.0, 487.0), (296.0, 490.0), (296.0, 492.0), (293.0, 494.0), (290.0, 496.0), (285.0, 499.0), (280.0, 501.0), (277.0, 503.0), (277.0, 504.0), (278.0, 506.0), (277.0, 509.0), (272.0, 513.0), (271.0, 514.0), (279.0, 514.0), (285.0, 514.0), (292.0, 515.0), (299.0, 516.0), (303.0, 517.0), (308.0, 518.0), (310.0, 522.0), (309.0, 530.0), (304.0, 536.0), (301.0, 542.0), (298.0, 549.0), (292.0, 554.0), (287.0, 558.0), (287.0, 560.0), (288.0, 568.0), (292.0, 572.0), (297.0, 578.0), (303.0, 588.0), (305.0, 594.0), (306.0, 603.0), (305.0, 616.0), (306.0, 617.0), (312.0, 623.0), (316.0, 628.0), (319.0, 634.0), (322.0, 642.0), (323.0, 654.0), (324.0, 660.0), (327.0, 664.0), (331.0, 668.0), (330.0, 672.0), (326.0, 679.0), (326.0, 683.0), (329.0, 684.0), (332.0, 680.0), (335.0, 678.0), (351.0, 682.0), (356.0, 685.0), (359.0, 691.0), (358.0, 697.0), (354.0, 703.0), (343.0, 717.0), (337.0, 722.0), (327.0, 725.0), (333.0, 733.0), (345.0, 734.0), (342.0, 739.0), (333.0, 744.0), (323.0, 746.0), (307.0, 746.0), (291.0, 746.0), (276.0, 745.0), (260.0, 745.0), (252.0, 739.0), (246.0, 739.0), (242.0, 744.0), (237.0, 750.0), (231.0, 752.0), (226.0, 747.0), (220.0, 744.0), (207.0, 747.0), (201.0, 751.0), (195.0, 748.0), (202.0, 742.0), (210.0, 738.0), (216.0, 732.0), (221.0, 727.0), (226.0, 723.0), (231.0, 721.0), (242.0, 721.0), (252.0, 721.0), (264.0, 714.0), (254.0, 714.0), (246.0, 713.0), (236.0, 706.0), (230.0, 702.0), (219.0, 699.0), (214.0, 693.0), (223.0, 688.0), (233.0, 684.0), (242.0, 682.0), (245.0, 673.0), (245.0, 664.0), (240.0, 665.0), (233.0, 665.0), (236.0, 662.0), (240.0, 658.0), (238.0, 653.0), (239.0, 647.0), (244.0, 649.0), (248.0, 651.0), (257.0, 652.0), (267.0, 655.0), (269.0, 657.0), (268.0, 651.0), (268.0, 646.0), (270.0, 641.0), (270.0, 635.0), (275.0, 634.0), (274.0, 628.0), (267.0, 628.0), (266.0, 620.0), (265.0, 615.0), (265.0, 607.0), (270.0, 603.0), (269.0, 601.0), (261.0, 602.0), (255.0, 603.0), (250.0, 600.0), (249.0, 605.0), (248.0, 606.0), (242.0, 602.0), (242.0, 604.0), (239.0, 596.0), (237.0, 590.0), (245.0, 586.0), (247.0, 583.0), (251.0, 576.0), (247.0, 566.0), (243.0, 570.0), (241.0, 578.0), (237.0, 581.0), (229.0, 582.0), (228.0, 579.0), (234.0, 573.0), (235.0, 569.0), (230.0, 564.0), (228.0, 564.0), (226.0, 568.0), (217.0, 568.0), (218.0, 562.0), (222.0, 558.0), (230.0, 556.0), (234.0, 553.0), (237.0, 550.0), (232.0, 549.0), (226.0, 549.0), (228.0, 537.0), (241.0, 531.0), (242.0, 522.0), (236.0, 522.0), (231.0, 518.0), (229.0, 511.0), (217.0, 519.0), (208.0, 517.0), (216.0, 499.0), (221.0, 495.0), (225.0, 484.0), (232.0, 482.0), (240.0, 479.0), (245.0, 479.0), (240.0, 490.0), (236.0, 495.0), (236.0, 504.0), (238.0, 510.0), (241.0, 503.0), (248.0, 499.0), (255.0, 499.0), (255.0, 493.0), (261.0, 493.0), (261.0, 486.0)]
>     CollisionPolygon2D (CollisionPolygon2D)
> MacroCamera (Camera2D)
>   script: res://scenes/world_map/MacroCamera.gd
>   scene: res://scenes/world_map/MacroCamera.tscn
> > zoom = (1.2, 1.2)
> > camera_speed = 500.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_keyboard_movement = true
> > min_zoom = 1.2
> > max_zoom = 2.0
> > zoom_speed = 0.1
> > zoom_smoothing = 10.0
> > bounds_enabled = true
> > bounds_rect = [P: (0.0, 0.0), S: (1020.0, 775.0)]
> UI (CanvasLayer)
> > layer = 10
>   JarlInfo (PanelContainer)
>   > anchors_preset = 5
>   > anchor_left = 0.5
>   > anchor_right = 0.5
>   > offset_left = -20.0
>   > offset_right = 20.0
>   > offset_bottom = 40.0
>   > grow_horizontal = 2
>   > mouse_filter = 1
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       AuthorityLabel (Label)
>       > layout_mode = 2
>       > size_flags_horizontal = 4
>       > text = "Authority: 3/3"
>       > horizontal_alignment = 1
>       RenownLabel (Label)
>       > layout_mode = 2
>       > text = "Renown: 25"
>       > horizontal_alignment = 1
>   Actions (PanelContainer)
>   > anchors_preset = 3
>   > anchor_left = 1.0
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -40.0
>   > offset_top = -40.0
>   > grow_horizontal = 0
>   > grow_vertical = 0
>   > mouse_filter = 2
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       EndYearButton (Button)
>       > layout_mode = 2
>       > text = "End Year"
>       SettlementButton (Button)
>       > layout_mode = 2
>       > text = "Return to Settlement"
>       DynastyButton (Button)
>       > layout_mode = 2
>       > text = "Dynasty"
>   RegionInfo (PanelContainer)
>   > anchors_preset = 7
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -20.0
>   > offset_top = -40.0
>   > offset_right = 20.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > mouse_filter = 1
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       RegionNameLabel (Label)
>       > layout_mode = 2
>       > horizontal_alignment = 1
>       TargetList (VBoxContainer)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       LaunchRaidButton (Button)
>       > layout_mode = 2
>       > disabled = true
>       > text = "Launch Raid"
>       SubjugateButton (Button)
>       > layout_mode = 2
>       > disabled = true
>       > text = "Subjugate"
>       MarryButton (Button)
>       > layout_mode = 2
>       > disabled = true
>       > text = "Marry for Alliance"
>   Tooltip (PanelContainer)
>   > anchors_preset = 7
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -51.5
>   > offset_top = -58.0
>   > offset_right = 98.5
>   > offset_bottom = -28.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > mouse_filter = 2
>     Label (Label)
>     > layout_mode = 2
>     > text = "Region Name"
>     > horizontal_alignment = 1
>   Dynasty_UI (PanelContainer)
>     script: res://ui/DynastyUI.gd
>     scene: res://ui/Dynasty_UI.tscn
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -200.0
>   > offset_top = -150.0
>   > offset_right = 200.0
>   > offset_bottom = 150.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     Margin (MarginContainer)
>     > layout_mode = 2
>       VBox (VBoxContainer)
>       > layout_mode = 2
>         TitleLabel (Label)
>         > layout_mode = 2
>         > text = "Jarl Bjorn\'s Dynasty"
>         > horizontal_alignment = 1
>         HSeparator (HSeparator)
>         > layout_mode = 2
>         HeirsLabel (Label)
>         > layout_mode = 2
>         > text = "Heirs:"
>         HeirsContainer (VBoxContainer)
>         > layout_mode = 2
>         Spacer (Control)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         CloseButton (Button)
>         > layout_mode = 2
>         > text = "Close"
> PlayerHomeMarker (Marker2D)
> > position = (526.0, 485.0)

--- SCENE: res://scenes/world_map/Region.tscn ---
Region (Area2D)
> script: res://scenes/world_map/Region.gd
> scene: res://scenes/world_map/Region.tscn
> HighlightPoly (Polygon2D)
> > visible = false
> CollisionPolygon2D (CollisionPolygon2D)

--- SCENE: res://scenes/world_map/WorldMap_Stub.tscn ---
WorldMapStub (Control)
> script: res://scenes/world_map/WorldMap_Stub.gd
> scene: res://scenes/world_map/WorldMap_Stub.tscn
> raid_mission_scene_path = "res://scenes/missions/RaidMission.tscn"
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> Background (ColorRect)
> > layout_mode = 0
> > color = (0.0, 0.0, 0.0, 1.0)
> TitleLabel (Label)
> > layout_mode = 0
> > offset_top = 50.0
> > offset_right = 141.0
> > offset_bottom = 73.0
> > text = "Select Your Target"
> > horizontal_alignment = 1
> ButtonContainer (VBoxContainer)
> > layout_mode = 0
> > offset_top = 150.0
> > offset_right = 190.0
> > offset_bottom = 216.0
> > alignment = 1
>   RaidMonasteryButton (Button)
>   > layout_mode = 2
>   > text = "Raid: Nearby Monastery"
>   Spacer (HSeparator)
>   > layout_mode = 2
>   BackButton (Button)
>   > layout_mode = 2
>   > text = "Return to Settlement"
> Phase3Test (Node)

--- SCENE: res://scripts/ui/PauseMenu.tscn ---
PauseMenu (CanvasLayer)
> script: res://scripts/ui/PauseMenu.gd
> scene: res://scripts/ui/PauseMenu.tscn
> process_mode = 2
> PanelContainer (PanelContainer)
> > anchors_preset = 8
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -20.0
> > offset_top = -20.0
> > offset_right = 20.0
> > offset_bottom = 20.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     ResumeButton (Button)
>     > layout_mode = 2
>     > text = "Resume"
>     SaveButton (Button)
>     > layout_mode = 2
>     > text = "Save Game"
>     QuitButton (Button)
>     > layout_mode = 2
>     > text = "Quit Game"

--- SCENE: res://scripts/utility/GridManager.tscn ---
GridManager (Node)
> script: res://scripts/utility/GridManager.gd
> scene: res://scripts/utility/GridManager.tscn
> grid_width = 60
> grid_height = 40
> cell_size = 32

--- SCENE: res://scripts/utility/GridVisualizer.tscn ---
GridVisualizer (Node2D)
> script: res://scripts/utility/GridVisualizer.gd
> scene: res://scripts/utility/GridVisualizer.tscn

--- SCENE: res://ui/BuildingPreviewCursor.tscn ---
BuildingPreviewCursor (Node2D)
> script: res://scripts/ui/BuildingPreviewCursor.gd
> scene: res://ui/BuildingPreviewCursor.tscn

--- SCENE: res://ui/Dynasty_UI.tscn ---
Dynasty_UI (PanelContainer)
> script: res://ui/DynastyUI.gd
> scene: res://ui/Dynasty_UI.tscn
> anchor_left = 0.5
> anchor_top = 0.5
> anchor_right = 0.5
> anchor_bottom = 0.5
> offset_left = -200.0
> offset_top = -150.0
> offset_right = 200.0
> offset_bottom = 150.0
> grow_horizontal = 2
> grow_vertical = 2
> Margin (MarginContainer)
> > layout_mode = 2
>   VBox (VBoxContainer)
>   > layout_mode = 2
>     TitleLabel (Label)
>     > layout_mode = 2
>     > text = "Jarl Bjorn\'s Dynasty"
>     > horizontal_alignment = 1
>     HSeparator (HSeparator)
>     > layout_mode = 2
>     HeirsLabel (Label)
>     > layout_mode = 2
>     > text = "Heirs:"
>     HeirsContainer (VBoxContainer)
>     > layout_mode = 2
>     Spacer (Control)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>     CloseButton (Button)
>     > layout_mode = 2
>     > text = "Close"

--- SCENE: res://ui/EndOfYear_Popup.tscn ---
Main (PanelContainer)
> script: res://ui/EndOfYear_Popup.gd
> scene: res://ui/EndOfYear_Popup.tscn
> anchor_left = 0.5
> anchor_top = 0.5
> anchor_right = 0.5
> anchor_bottom = 0.5
> offset_left = -150.0
> offset_top = -75.0
> offset_right = 150.0
> offset_bottom = 75.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 4
> size_flags_vertical = 4
> theme = res://ui/themes/VikingDynastyTheme.tres
> MarginContainer (MarginContainer)
> > layout_mode = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     PayoutLabel (Label)
>     > layout_mode = 2
>     > text = "Welcome home! ..."
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     CollectButton (Button)
>     > custom_minimum_size = (120.0, 40.0)
>     > layout_mode = 2
>     > text = "Collect"

--- SCENE: res://ui/Event_UI.tscn ---
Event_UI (CanvasLayer)
> script: res://ui/Event_UI.gd
> scene: res://ui/Event_UI.tscn
> process_mode = 2
> layer = 20
> PanelContainer (PanelContainer)
> > custom_minimum_size = (500.0, 300.0)
> > anchors_preset = 8
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -78.5
> > offset_top = -105.5
> > offset_right = 78.5
> > offset_bottom = 105.5
> > grow_horizontal = 2
> > grow_vertical = 2
>   Margin (MarginContainer)
>   > layout_mode = 2
>     VBox (VBoxContainer)
>     > layout_mode = 2
>       TitleLabel (Label)
>       > custom_minimum_size = (300.0, 30.0)
>       > layout_mode = 2
>       > size_flags_vertical = 1
>       > text = "Event Title"
>       > horizontal_alignment = 1
>       > autowrap_mode = 3
>       HSeparator (HSeparator)
>       > layout_mode = 2
>       HBox (HBoxContainer)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>         Portrait (TextureRect)
>         > unique_name_in_owner = true
>         > custom_minimum_size = (128.0, 128.0)
>         > layout_mode = 2
>         > texture = res://textures/placeholders/unit_placeholder.png
>         > expand_mode = 1
>         > stretch_mode = 5
>         DescriptionLabel (Label)
>         > custom_minimum_size = (200.0, 100.0)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 1
>         > text = "This is the event description text. It will be multiple lines long and explain the situation to the player, presenting them with a difficult choice."
>         > autowrap_mode = 3
>         > clip_text = true
>       HSeparator2 (HSeparator)
>       > layout_mode = 2
>       ChoiceButtonsContainer (VBoxContainer)
>       > layout_mode = 2
>       > size_flags_vertical = 10
>       > alignment = 2

--- SCENE: res://ui/SelectionBox.tscn ---
SelectionBox (Control)
> script: res://ui/SelectionBox.gd
> scene: res://ui/SelectionBox.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> theme = res://ui/themes/VikingDynastyTheme.tres

--- SCENE: res://ui/Storefront_UI.tscn ---
Main (Control)
> script: res://ui/StorefrontUI.gd
> scene: res://ui/Storefront_UI.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> available_buildings = []
> available_units = []
> default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
> auto_load_units_from_directory = true
> PanelContainer (PanelContainer)
> > layout_mode = 1
> > anchors_preset = -1
> > anchor_top = 1.0
> > anchor_bottom = 1.0
> > offset_left = 20.0
> > offset_top = -140.0
> > offset_right = 480.0
> > offset_bottom = -20.0
> > grow_vertical = 0
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     TabContainer (TabContainer)
>     > layout_mode = 2
>     > current_tab = 0
>       BuildTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         TreasuryDisplay (HBoxContainer)
>         > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           > text = "Gold: 0"
>           WoodLabel (Label)
>           > layout_mode = 2
>           > text = "Wood: 0"
>           FoodLabel (Label)
>           > layout_mode = 2
>           > text = "Food: 0"
>           StoneLabel (Label)
>           > layout_mode = 2
>           > text = "Stone: 0"
>         BuildButtonsContainer (VBoxContainer)
>         > layout_mode = 2
>       RecruitTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         RecruitButtons (VBoxContainer)
>         > layout_mode = 2
>         GarrisonList (VBoxContainer)
>         > layout_mode = 2
>       LegacyTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         JarlStatsDisplay (HBoxContainer)
>         > layout_mode = 2
>           RenownLabel (Label)
>           > layout_mode = 2
>           > text = "Renown: 0"
>           AuthorityLabel (Label)
>           > layout_mode = 2
>           > text = "Authority: 0/0"
>         Description (Label)
>         > layout_mode = 2
>         > text = "Spend Renown and Authority on permanent dynasty upgrades."
>         > autowrap_mode = 3
>         HSeparator (HSeparator)
>         > layout_mode = 2
>         LegacyButtonsContainer (VBoxContainer)
>         > layout_mode = 2

--- SCENE: res://ui/Succession_Crisis_UI.tscn ---
Succession_Crisis_UI (CanvasLayer)
> script: res://ui/Succession_Crisis_UI.gd
> scene: res://ui/Succession_Crisis_UI.tscn
> PanelContainer (PanelContainer)
> > anchors_preset = 8
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -255.5
> > offset_top = -151.0
> > offset_right = 255.5
> > offset_bottom = 249.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       TitleLabel (Label)
>       > layout_mode = 2
>       > text = "Succession Crisis"
>       DescriptionLabel (Label)
>       > layout_mode = 2
>       > text = "The Jarl is dead. Your rule is fragile..."
>       LegitimacyLabel (Label)
>       > layout_mode = 2
>       > text = "New Legitimacy: 20/100"
>       HSeparator (HSeparator)
>       > layout_mode = 2
>       RenownTaxTitle (Label)
>       > layout_mode = 2
>       > text = "Legacy Projects"
>       RenownTaxDescription (Label)
>       > layout_mode = 2
>       > text = "Pay 50 Renown to protect your legacy, or refuse and risk setbacks."
>       RenownTaxButtons (HBoxContainer)
>       > layout_mode = 2
>         PayRenownButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Pay Renown"
>         RefuseRenownButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Refuse"
>       HSeparator2 (HSeparator)
>       > layout_mode = 2
>       GoldTaxTitle (Label)
>       > layout_mode = 2
>       > text = "Garrison Stability"
>       GoldTaxDescription (Label)
>       > layout_mode = 2
>       > text = "Pay 1000 Gold to ensure loyalty, or refuse and risk instability."
>       GoldTaxButtons (HBoxContainer)
>       > layout_mode = 2
>         PayGoldButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Pay Gold"
>         RefuseGoldButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Refuse"
>       HSeparator3 (HSeparator)
>       > layout_mode = 2
>       ConfirmButton (Button)
>       > layout_mode = 2
>       > text = "Confirm"

--- SCENE: res://ui/WorkAssignment_UI.tscn ---
WorkAssignment_UI (CanvasLayer)
> script: res://ui/WorkAssignment_UI.gd
> scene: res://ui/WorkAssignment_UI.tscn
> PanelContainer (PanelContainer)
> > anchors_preset = 8
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -20.0
> > offset_top = -20.0
> > offset_right = 20.0
> > offset_bottom = 20.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > size_flags_horizontal = 4
> > size_flags_vertical = 4
>   MarginContainer (MarginContainer)
>   > custom_minimum_size = (20.0, 20.0)
>   > layout_mode = 2
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       Header (HBoxContainer)
>       > layout_mode = 2
>         TotalPopLabel (Label)
>         > layout_mode = 2
>         AvailablePopLabel (Label)
>         > layout_mode = 2
>       HSeparator (HSeparator)
>       > layout_mode = 2
>       SlidersContainer (VBoxContainer)
>       > layout_mode = 2
>       HSeparator2 (HSeparator)
>       > layout_mode = 2
>       ConfirmButton (Button)
>       > layout_mode = 2
>       > text = "End Year"
--- END OF SCENE STRUCTURES ---

#### **2.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://autoload/DynastyManager.gd ---
# res://autoload/DynastyManager.gd
#
# A global Singleton (Autoload) that acts as a pure data manager
# for the player's Jarl and dynasty state.
# This is the "Core Pacing Engine" as defined in the GDD.
# It is the single source of truth for all Jarl data.
extends Node

## Emitted when Jarl data changes (e.g., spent Authority, ended year)
signal jarl_stats_updated(jarl_data: JarlData)
signal year_ended

var current_jarl: JarlData
var current_raid_target: SettlementData

var is_defensive_raid: bool = false

#Succession System ---
var minimum_inherited_legitimacy: int = 0
var loaded_legacy_upgrades: Array[LegacyUpgradeData] = []

#Raid Context & Results ---
# Stores the difficulty (Tier) of the active raid for reward calculation
var current_raid_difficulty: int = 1 

# Stores the raw outcome from the RTS layer before processing
# Format: { "outcome": "win", "gold_looted": 0, "buildings_destroyed": 0 }
var pending_raid_result: Dictionary = {} 
# -----------------------------------
# Path to the player's persistent Jarl data
const PLAYER_JARL_PATH = "res://data/characters/PlayerJarl.tres"

func _ready() -> void:
	_load_player_jarl()
	_load_legacy_upgrades_from_disk() # <-- THIS IS THE FIX
	EventBus.succession_choices_made.connect(_on_succession_choices_made) # Connect to UI

# --- THIS IS THE NEW FUNCTION ---
func _load_legacy_upgrades_from_disk() -> void:
	"""
	Scans res://data/legacy/ for .tres files and loads them.
	This manager is now the single source of truth for this data.
	"""
	loaded_legacy_upgrades.clear()
	
	var dir = DirAccess.open("res://data/legacy/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var path = "res://data/legacy/" + file_name
				var upgrade_data = load(path) as LegacyUpgradeData
				
				if upgrade_data:
					# We create a local instance/duplicate of the resource.
					# This prevents cost changes from modifying the .tres file.
					var unique_upgrade = upgrade_data.duplicate()
					
					# Check if already purchased
					if has_purchased_upgrade(unique_upgrade.effect_key):
						# This logic needs to be based on progress, not just key
						# We will need to load progress from JarlData in the future.
						# For now, this is fine, but we need to load progress *from* jarl data.
						pass
					
					loaded_legacy_upgrades.append(unique_upgrade)
					
			file_name = dir.get_next()
	print("DynastyManager: Loaded %d legacy upgrades." % loaded_legacy_upgrades.size())
# --- END NEW FUNCTION ---

func _load_player_jarl() -> void:
	if ResourceLoader.exists(PLAYER_JARL_PATH):
		current_jarl = load(PLAYER_JARL_PATH)
		print("DynastyManager: PlayerJarl.tres loaded successfully.")
	else:
		# Use push_error for missing persistent files
		push_error("DynastyManager: Failed to load Jarl data from %s. File not found!" % PLAYER_JARL_PATH)
		# Create a fallback in-memory Jarl to prevent crashes
		current_jarl = JarlData.new()
		current_jarl.display_name = "Fallback Jarl"
		current_jarl.current_authority = 3
		current_jarl.max_authority = 3
		
	# Emit initial stats
	jarl_stats_updated.emit(current_jarl)

func get_current_jarl() -> JarlData:
	if not current_jarl:
		_load_player_jarl()
	return current_jarl

func can_spend_authority(cost: int) -> bool:
	if not current_jarl:
		return false
	return current_jarl.can_take_action(cost)

func spend_authority(cost: int) -> bool:
	if not current_jarl:
		return false
		
	if current_jarl.spend_authority(cost):
		_save_jarl_data()
		jarl_stats_updated.emit(current_jarl)
		# REMOVED: print("DynastyManager: Spent %d authority. %d remaining." % [cost, current_jarl.current_authority])
		return true
	
	# RETAINED: Failure is important
	print("DynastyManager: Failed to spend %d authority. %d remaining." % [cost, current_jarl.current_authority])
	return false

func can_spend_renown(cost: int) -> bool:
	"""Check if the Jarl has enough Renown."""
	if not current_jarl:
		return false
	return current_jarl.renown >= cost

func spend_renown(cost: int) -> bool:
	"""Spend the Jarl's Renown."""
	if not can_spend_renown(cost):
		# RETAINED: Failure is important
		print("DynastyManager: Failed to spend %d renown. %d available." % [cost, current_jarl.renown])
		return false
	
	current_jarl.renown -= cost
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	# REMOVED: print("DynastyManager: Spent %d renown. %d remaining." % [cost, current_jarl.renown])
	return true

func purchase_legacy_upgrade(upgrade_key: String) -> void:
	"""Mark a legacy upgrade as purchased on the Jarl's data."""
	if not current_jarl:
		return
	if not upgrade_key in current_jarl.purchased_legacy_upgrades:
		current_jarl.purchased_legacy_upgrades.append(upgrade_key)
		_save_jarl_data()
		print("DynastyManager: Legacy upgrade '%s' purchased and saved." % upgrade_key)

func has_purchased_upgrade(upgrade_key: String) -> bool:
	"""Check if a legacy upgrade has already been purchased."""
	if not current_jarl:
		return false
	return upgrade_key in current_jarl.purchased_legacy_upgrades

# --- NEW: Unifier Pillar Functions ---
func add_conquered_region(region_path: String) -> void:
	"""Adds a region's path to the Jarl's list of conquered territories."""
	if not current_jarl:
		return
	if not region_path in current_jarl.conquered_regions:
		current_jarl.conquered_regions.append(region_path)
		_save_jarl_data()
		# RETAINED: This is a major game state change
		print("DynastyManager: Region '%s' conquered and saved." % region_path)
		# We don't emit jarl_stats_updated here because spending authority
		# will have already triggered the UI refresh.

func has_conquered_region(region_path: String) -> bool:
	"""Checks if a region has been conquered."""
	if not current_jarl:
		return false
	return region_path in current_jarl.conquered_regions

# --- NEW: Progenitor Pillar Functions ---

func get_available_heir_count() -> int:
	if not current_jarl:
		return 0
	return current_jarl.get_available_heir_count()

func start_heir_expedition(heir: JarlHeirData, expedition_duration: int = 5) -> void:
	"""
	Sends an heir on an expedition.
	This marks them as unavailable and starts a timer.
	"""
	if not current_jarl or not heir in current_jarl.heirs:
		push_error("DynastyManager: Tried to send an invalid heir on expedition.")
		return
	
	heir.status = JarlHeirData.HeirStatus.OnExpedition
	heir.expedition_years_remaining = expedition_duration
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("Heir %s sent on expedition for %d years." % [heir.display_name, expedition_duration])

func process_heir_expeditions() -> Array[String]:
	"""
	Called at the End of Year.
	Processes all heirs on expedition, returning results.
	"""
	if not current_jarl:
		return []

	var results: Array[String] = []
	var heirs_to_remove: Array[JarlHeirData] = []
	
	for heir in current_jarl.heirs:
		if heir.status == JarlHeirData.HeirStatus.OnExpedition:
			heir.expedition_years_remaining -= 1
			
			if heir.expedition_years_remaining <= 0:
				# Expedition is over, run probability check
				var roll = randf()
				if roll <= 0.7: # 70% success 
					var renown_gain = randi_range(100, 300)
					award_renown(renown_gain)
					results.append("Heir %s returned from their expedition with %d Renown!" % [heir.display_name, renown_gain])
					heir.status = JarlHeirData.HeirStatus.Available
					
					# --- NEW: Add Trait to Heir ---
					var seasoned_trait = load("res://data/traits/Trait_Seasoned.tres") # Load the trait we created
					if seasoned_trait:
						heir.traits.append(seasoned_trait)
					# --- END NEW ---
					
					# --- NEW: Add Legitimacy Boost ---
					current_jarl.legitimacy = min(100, current_jarl.legitimacy + 5) # +5 Legitimacy for successful expedition
					# --- END NEW ---
				else: # 30% failure 
					results.append("Tragic news!
Heir %s was lost at sea during their expedition." % heir.display_name)
					heir.status = JarlHeirData.HeirStatus.LostAtSea
					heirs_to_remove.append(heir) # Queue for removal
	
	# Remove lost heirs
	for heir in heirs_to_remove:
		current_jarl.remove_heir(heir)

	if not results.is_empty():
		_save_jarl_data()
		jarl_stats_updated.emit(current_jarl)
		
	return results

# --- NEW: Marry for Alliance ---
func marry_heir_for_alliance(region_path: String) -> bool:
	"""
	Spends the first available heir to form an alliance with a region.
	Returns true on success, false if no heir is available.
	"""
	if not current_jarl:
		return false
		
	var heir_to_marry = current_jarl.get_first_available_heir()
	if not heir_to_marry:
		print("DynastyManager: Marriage failed. No available heir.")
		return false
	
	# "Spend" the heir
	heir_to_marry.status = JarlHeirData.HeirStatus.MarriedOff
	
	# Add the alliance
	if not region_path in current_jarl.allied_regions:
		current_jarl.allied_regions.append(region_path)
	
	# --- NEW: Add Legitimacy Boost ---
	current_jarl.legitimacy = min(100, current_jarl.legitimacy + 10) # +10 Legitimacy
	# --- END NEW ---

	print("Heir %s married off to form alliance with %s" % [heir_to_marry.display_name, region_path])
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	return true

func is_allied_region(region_path: String) -> bool:
	"""Checks if a region is allied."""
	if not current_jarl:
		return false
	return region_path in current_jarl.allied_regions
# --- END NEW ---
func add_trait_to_heir(heir: JarlHeirData, trait_data: JarlTraitData) -> void:
	"""
	Placeholder function to add a trait to an heir.
	Currently, JarlHeirData does not store traits.
	This function will just log for now.
	"""
	# Using push_warning to flag this missing feature for development
	push_warning("EVENT: (TODO) Would add trait '%s' to heir '%s'." % [trait_data.display_name, heir.display_name])


func end_year() -> void:
	if not current_jarl:
		push_error("DynastyManager: Cannot end year, current Jarl is null.")
		return
	
	# --- MODIFIED: Death check happens *before* reset ---
	var jarl_died = _check_for_jarl_death()
	if jarl_died:
		# Succession crisis is triggered, which will emit 'event_system_finished'
		# when it's done. We stop 'end_year' here.
		return
	# --- END MODIFIED ---
	
	# Jarl did not die, proceed as normal
	current_jarl.reset_authority() # This now contains the debuff logic
	
	var expedition_results = process_heir_expeditions()
	if not expedition_results.is_empty():
		print("Expedition Results: %s" % expedition_results)
		# TODO: We will need a way to show these results to the player,
		# likely by modifying the EndOfYear_Popup.
	
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("DynastyManager: Year ended. Authority reset to %d." % current_jarl.max_authority)
	
	# Emit the signal so the EventManager can hear it.
	year_ended.emit()
	
func set_current_raid_target(data: SettlementData) -> void:
	current_raid_target = data
	# REMOVED: print("DynastyManager: Raid target set to %s" % data.resource_path)

func get_current_raid_target() -> SettlementData:
	var target = current_raid_target
	current_raid_target = null # Clear the target after getting it
	return target

func _save_jarl_data() -> void:
	if not current_jarl:
		push_error("DynastyManager: Cannot save, current_jarl is null.")
		return
		
	if current_jarl.resource_path.is_empty():
		current_jarl.resource_path = PLAYER_JARL_PATH
		
	var error = ResourceSaver.save(current_jarl, current_jarl.resource_path)
	if error != OK:
		# Using push_error to alert to critical save file failures
		push_error("DynastyManager: Failed to save Jarl data to %s. Error: %s" % [current_jarl.resource_path, error])
	# No success print needed for every save, keeps log clean

func award_renown(amount: int) -> void:
	if not current_jarl:
		push_error("DynastyManager: Cannot award renown, current Jarl is null.")
		return
	
	current_jarl.award_renown(amount)
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("DynastyManager: Awarded %d renown.
Total: %d" % [amount, current_jarl.renown])

# --- NEW: Succession System Functions ---
func debug_kill_jarl() -> void:
	"""
	Public-facing debug function to immediately trigger succession.
	Bypasses all age and 'end_year' checks.
	"""
	print("DEBUG: debug_kill_jarl() called. Forcing succession...")
	_trigger_succession()


func _check_for_jarl_death() -> bool:
	"""Rolls for Jarl's death.
Returns true if Jarl died."""
	var jarl = get_current_jarl()
	var death_chance = 0.0
	
	if jarl.age > 80:
		death_chance = 0.5
	elif jarl.age > 65:
		death_chance = 0.25
	elif jarl.age > 50:
		death_chance = 0.1
	
	if randf() < death_chance:
		print("The Jarl has died at age %d!" % jarl.age)
		_trigger_succession()
		return true
	
	return false

func _trigger_succession() -> void:
	"""Manages the promotion of an heir and triggers the crisis event."""
	var old_jarl = current_jarl
	var heir = current_jarl.get_first_available_heir()
	
	if not heir:
		print("GAME OVER: The Jarl died with no available heir!")
		# TODO: Add game over logic
		get_tree().quit() # Placeholder
		return
	
	# Promote heir to Jarl
	var new_jarl = _promote_heir_to_jarl(heir, old_jarl)
	current_jarl.heirs.erase(heir) # Remove heir from list
	current_jarl = new_jarl
	
	# Trigger the event
	var succession_event_data = EventData.new() # Create a dummy event
	succession_event_data.event_id = "succession_crisis"
	EventManager._trigger_event(succession_event_data)

func _promote_heir_to_jarl(heir: JarlHeirData, predecessor: JarlData) -> JarlData:
	"""Creates a new JarlData resource from an heir."""
	var new_jarl = JarlData.new()
	new_jarl.display_name = heir.display_name
	new_jarl.age = heir.age
	new_jarl.command = heir.command
	new_jarl.stewardship = heir.stewardship
	new_jarl.learning = heir.learning
	new_jarl.prowess = heir.prowess
	new_jarl.traits = heir.traits
	
	# Calculate Legitimacy
	var new_legit = int(predecessor.legitimacy * 0.8) # Inherit 80%
	
	# Apply trait/skill penalties
	var penalty = (10 - new_jarl.get_effective_skill("stewardship")) * 2 # Example
	penalty += (10 - new_jarl.get_effective_skill("prowess")) # Example
	
	new_legit = max(0, new_legit - penalty)
	
	# Apply floor from Jelling Stone 
	new_legit = max(new_legit, minimum_inherited_legitimacy) 
	
	new_jarl.legitimacy = new_legit
	new_jarl.succession_debuff_years_remaining = 3 # Start the 3-year debuff
	
	return new_jarl

func _on_succession_choices_made(renown_choice: String, gold_choice: String) -> void:
	"""Applies the consequences of the succession crisis choices."""
	if renown_choice == "refuse":
		# Apply Renown Tax Consequence
		var setback_applied = false
		
		# --- THIS IS THE FIX ---
		# We iterate over our own 'loaded_legacy_upgrades' array,
		# not one from another scene.
		for upgrade in loaded_legacy_upgrades:
		# --- END FIX ---
			if not upgrade.is_purchased and upgrade.current_progress > 0:
				upgrade.current_progress = max(0, upgrade.current_progress - 2) # -2 Progress
				setback_applied = true
				break
		if setback_applied:
			print("A legacy project has lost progress!")
	
	if gold_choice == "refuse":
		# Apply Gold Tax Consequence 
		if SettlementManager.current_settlement:
			SettlementManager.current_settlement.has_stability_debuff = true
			print("Settlement instability debuff applied!")
	
	# This is the "all-clear" signal
	EventBus.event_system_finished.emit()

# --- END NEW ---

--- SCRIPT: res://autoload/EventBus.gd ---
# res://autoload/EventBus.gd
#
# A global Singleton (Autoload) that acts as a central "switchboard"
# for decoupled signal communication between major systems.

extends Node

# --- Build System Signals ---
# TODO: Connect this signal when implementing advanced building system
signal building_right_clicked(building: Node2D) # Emitted when a placed building is right-clicked
signal building_state_changed(building: BaseBuilding, new_state: int) # Emitted when building state changes
# @warning_ignore("unused_signal")
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)
# Emitted when a building is purchased and ready for cursor placement
signal building_ready_for_placement(building_data: BuildingData)
# Emitted when building placement is cancelled (should refund cost)
signal building_placement_cancelled(building_data: BuildingData)

# --- Pathfinding Signals ---
signal pathfinding_grid_updated(grid_position: Vector2i)

# --- Treasury & Economy Signals (Phase 2) ---
signal treasury_updated(new_treasury: Dictionary)
signal purchase_successful(item_name: String)
signal purchase_failed(reason: String)

# --- Navigation Signals (Phase 3) ---
# MODIFIED: Now emits a string KEY name, not a full path.
signal scene_change_requested(scene_key: String)
signal world_map_opened()
signal raid_mission_started(target_type: String)

# --- Settlement Management Signals ---
signal settlement_loaded(settlement_data: SettlementData)

# --- Unit Management Signals ---
signal player_unit_died(unit: Node2D)

# --- NEW: RTS Command Signals (GDD Section 10) ---
# Emitted by SelectionBox.gd, consumed by RTSController.gd

# Emitted on left-click or drag-release
signal select_command(select_rect: Rect2, is_box_select: bool)

# Emitted on right-click on the ground
signal move_command(target_position: Vector2)

# Emitted on right-click on an enemy
signal attack_command(target_node: Node2D)

# --- NEW: Emitted on right-click-and-drag ---
signal formation_move_command(target_position: Vector2, direction_vector: Vector2)

# --- NEW: Building Cursor System Signals ---


# --- NEW: Event System Flow Control ---
signal event_system_finished()

# --- NEW: Succession Crisis System ---
signal succession_choices_made(renown_choice: String, gold_choice: String)

--- SCRIPT: res://autoload/EventManager.gd ---
# res://autoload/EventManager.gd
#
# Global singleton (Autoload) to manage the "Full Event System" (Phase 3b).
# This manager loads all events, checks their triggers,
# and displays them to the player.
extends Node

# Assign res://ui/Event_UI.tscn in the Autoload settings in Godot
@export var event_ui_scene: PackedScene
@export var succession_crisis_scene: PackedScene # Add this in the Inspector

var event_ui: EventUI
var available_events: Array[EventData] = []
var fired_unique_events: Array[String] = []

# Preload resources needed for consequences
const TRAIT_RIVAL = preload("res://data/traits/Trait_Rival.tres")

func _ready() -> void:
	# Defer initialization to ensure all Autoloads are ready
	call_deferred("initialize_event_system")

func initialize_event_system() -> void:
	"""Handles all initialization after the engine is stable."""
	if not event_ui_scene:
		push_error("EventManager: 'event_ui_scene' is not set in Autoload Inspector! Event system is disabled.")
		return
	
	# 1. Instance and add the UI
	event_ui = event_ui_scene.instantiate()
	add_child(event_ui)
	event_ui.choice_made.connect(_on_choice_made)
	
	# 2. Load all events
	_load_events_from_disk()
	
	# 3. Connect to the main game trigger
	if DynastyManager:
		DynastyManager.year_ended.connect(_on_year_ended)
	else:
		push_error("EventManager: DynastyManager Autoload is not found! Cannot connect year_ended signal.")

func _load_events_from_disk() -> void:
	"""Scans the res://data/events/ directory for EventData resources."""
	available_events.clear()
	var dir = DirAccess.open("res://data/events/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var path = "res://data/events/" + file_name
				var event_data = load(path) as EventData 
				if event_data:
					available_events.append(event_data)
				else:
					push_warning("EventManager: Failed to load event resource from %s." % path)
			file_name = dir.get_next()
	print("EventManager: Loaded %d events from disk." % available_events.size())

func _on_year_ended() -> void:
	"""Triggered by DynastyManager, this checks all events."""
	print("EventManager: Checking event triggers for end of year...")
	
	var event_was_triggered: bool = _check_event_triggers()
	
	# Status print remains for end-of-year summary
	if event_was_triggered:
		print("EventManager: An event was recognized and triggered.")
	else:
		print("EventManager: No events were recognized or triggered this year.")
	
	if not event_was_triggered:
		# No events were found, so we signal the "all-clear" immediately.
		EventBus.event_system_finished.emit()

func _check_event_triggers() -> bool:
	"""
	Checks all events. Returns true if an event was triggered, false otherwise.
	"""
	var jarl = DynastyManager.get_current_jarl()
	if not jarl:
		push_error("EventManager: Cannot check events, Jarl data is null.")
		return false

	for event in available_events:
		if _check_conditions(event, jarl):
			_trigger_event(event)
			return true # An event was triggered
	
	return false # No events were triggered

func _check_conditions(event: EventData, jarl: JarlData) -> bool:
	"""Checks if a single event's trigger conditions are met."""
	
	# Check if unique and already fired
	if event.is_unique and event.event_id in fired_unique_events:
		return false
		
	# Check prerequisites
	for pre_id in event.prerequisites:
		if not pre_id in fired_unique_events:
			return false 
			
	# Check Jarl stats
	if event.min_renown > -1 and jarl.renown < event.min_renown:
		return false
	if event.min_stewardship > -1 and jarl.get_effective_skill("stewardship") < event.min_stewardship:
		return false
	
	# Check Jarl traits
	if not event.must_have_trait.is_empty() and not jarl.has_trait(event.must_have_trait):
		return false
	if not event.must_not_have_trait.is_empty() and jarl.has_trait(event.must_not_have_trait):
		return false
	
	# Check Dynasty state
	if event.min_available_heirs > -1 and jarl.get_available_heir_count() < event.min_available_heirs:
		return false
	
	# Check World state
	if event.min_conquered_regions > -1 and jarl.conquered_regions.size() < event.min_conquered_regions:
		return false
		
	# Check base chance
	if randf() > event.base_chance:
		return false
	
	# All conditions passed
	print("EventManager: Conditions MET for event '%s'" % event.event_id)
	return true

func _trigger_event(event: EventData) -> void:
	"""Pauses the game and displays the event UI."""
	
	# --- NEW: Special Case for Succession ---
	if event.event_id == "succession_crisis":
		if not succession_crisis_scene:
			push_error("EventManager: succession_crisis_scene is not set!")
			return
		
		var crisis_ui = succession_crisis_scene.instantiate()
		add_child(crisis_ui)
		
		var jarl = DynastyManager.get_current_jarl()
		var settlement = SettlementManager.current_settlement
		crisis_ui.display_crisis(jarl, settlement)
		
		# The crisis UI will emit 'succession_choices_made' on its own
		# and then call EventBus.event_system_finished when it closes.
	else:
	# --- END NEW ---
		print("EventManager: Triggering event '%s'" % event.event_id)
		
		get_tree().paused = true
		event_ui.display_event(event)
	
	if event.is_unique:
		fired_unique_events.append(event.event_id)

func _on_choice_made(event: EventData, choice: EventChoice) -> void:
	"""
	Called by the EventUI.
	Applies consequences, unpauses, and signals the "all-clear".
	"""
	
	if choice:
		print("EventManager: Player chose '%s' (%s) for event '%s'" % [choice.choice_text, choice.effect_key, event.event_id])
		_apply_event_consequences(event, choice)
	else:
		print("EventManager: Event '%s' closed with no choice." % event.event_id)
		
	get_tree().paused = false
	
	# This is the "all-clear" signal.
	EventBus.event_system_finished.emit()

func _apply_event_consequences(event: EventData, choice: EventChoice) -> void:
	"""
	This is the "logic" part of the event system.
	It matches the event_id and choice.effect_key to apply results.
	"""
	
	if event.event_id == "ambitious_heir_1":
		
		if choice.effect_key == "accept":
			var success = DynastyManager.spend_renown(100)
			if not success:
				push_warning("EventManager: Tried to spend 100 Renown for event, but failed.")
			
		elif choice.effect_key == "decline":
			var heir = DynastyManager.get_current_jarl().get_first_available_heir()
			if heir and TRAIT_RIVAL:
				DynastyManager.add_trait_to_heir(heir, TRAIT_RIVAL)
			else:
				push_warning("EventManager: Could not apply 'Rival' trait. No heir or trait not loaded.")

--- SCRIPT: res://autoload/PauseManager.gd ---
# res://autoload/PauseManager.gd
#
# This is a global autoload script that listens for the 'ui_pause'
# input to pause the game.
# It is only responsible for *pausing* and instancing the menu.
# The menu itself is responsible for unpausing.

extends Node

# We will assign this scene in the Project Settings Autoload menu
@export var pause_menu_scene: PackedScene


func _unhandled_input(event: InputEvent) -> void:
	# We only listen for the pause input
	# We only pause if the game is NOT already paused
	if event.is_action_pressed("ui_pause") and not get_tree().paused:
		
		if not pause_menu_scene:
			push_error("PauseManager: 'pause_menu_scene' is not set in Project Settings!")
			return
		
		# Consume the event so nothing else (like the menu) can use it
		get_viewport().set_input_as_handled()
		
		# Pause the game
		get_tree().paused = true
		
		# Create the menu
		var menu = pause_menu_scene.instantiate()
		get_tree().root.add_child(menu)

--- SCRIPT: res://autoload/ProjectilePoolManager.gd ---
# res://autoload/ProjectilePoolManager.gd
#
# Manages an object pool of projectiles to avoid the performance
# cost of instantiating and freeing them during gameplay.

extends Node

# Set this to the scene your game uses for projectiles.
@export var projectile_scene: PackedScene = preload("res://scenes/effects/Projectile.tscn")
@export var initial_pool_size: int = 50

# This array holds the projectiles that are "on the shelf" and ready to be used.
var available_projectiles: Array[Projectile] = []

# This node just holds all projectiles so they exist in the scene tree.
var projectile_container: Node

func _ready() -> void:
	projectile_container = Node.new()
	projectile_container.name = "ProjectileContainer"
	add_child(projectile_container)
	
	# Pre-load the pool with an initial batch of projectiles
	for i in range(initial_pool_size):
		var p = projectile_scene.instantiate() as Projectile
		projectile_container.add_child(p)
		p.return_to_pool() # Deactivate it and move it off-screen
		available_projectiles.append(p)
	
	print("ProjectilePoolManager: Initialized with %d projectiles." % initial_pool_size)

func get_projectile() -> Projectile:
	"""
	Retrieves an available projectile from the pool.
	If the pool is empty, it creates a new one.
	"""
	if not available_projectiles.is_empty():
		# Get a projectile from the "shelf"
		return available_projectiles.pop_front()
	else:
		# The "shelf" is empty. This isn't ideal, but we can
		# create a new one on-the-fly to prevent errors.
		push_warning("ProjectilePoolManager: Pool depleted! Creating a new projectile.")
		var p = projectile_scene.instantiate() as Projectile
		projectile_container.add_child(p)
		return p

func return_projectile(projectile: Projectile) -> void:
	"""
	Returns a projectile to the pool, making it available again.
	"""
	projectile.return_to_pool()
	available_projectiles.append(projectile)

--- SCRIPT: res://autoload/SceneManager.gd ---
# res://autoload/SceneManager.gd
#
# A global Singleton (Autoload) that handles all scene transitions.
# It listens for a signal on the EventBus and performs the change.
# This decouples all scenes from each other, preventing circular dependencies.
extends Node

# --- Phase 1 Refactor: PackedScene Exports ---
# Assign these in the Godot Editor (Project > Project Settings > Autoload > SceneManager)
@export var settlement_scene: PackedScene
@export var world_map_scene: PackedScene
@export var raid_mission_scene: PackedScene
# ---------------------------------------------

func _ready() -> void:
	# Connect to the EventBus signal that all other scenes will use 
	EventBus.scene_change_requested.connect(_on_scene_change_requested)

func _on_scene_change_requested(scene_key: String) -> void:
	if scene_key.is_empty():
		push_error("SceneManager: scene_change_requested received an empty key.")
		return

	var target_scene: PackedScene = null
	
	# Match the string key to the exported PackedScene
	match scene_key.to_lower():
		"settlement":
			target_scene = settlement_scene
		"world_map":
			target_scene = world_map_scene
		"raid_mission":
			target_scene = raid_mission_scene
		_:
			push_error("SceneManager: Unknown scene key '%s'. No scene transition will occur." % scene_key)
			return

	if not target_scene:
		push_error("SceneManager: Scene key '%s' is valid, but its PackedScene is not assigned in the Inspector!" % scene_key)
		return

	print("SceneManager: Changing to scene: %s (Key: %s)" % [target_scene.resource_path, scene_key])
	var error = get_tree().change_scene_to_packed(target_scene)
	
	if error != OK:
		push_error("SceneManager: Failed to change to scene '%s'. Error code: %s" % [target_scene.resource_path, error])

--- SCRIPT: res://autoload/SettlementManager.gd ---
# res://autoload/SettlementManager.gd
#
# A global Singleton (Autoload) that acts as a pure data manager
# for the player's current settlement.
# --- MODIFIED: Fixed Type Error in _remove_from_list ---

extends Node

# --- Configuration Constants ---
const BUILDER_EFFICIENCY: int = 25 # Construction progress per worker per year
const GATHERER_EFFICIENCY: int = 10 # Resources produced per worker per year
const BASE_GATHERING_CAPACITY: int = 2

#Define a Save Path
const USER_SAVE_PATH = "user://savegame.tres"

var current_settlement: SettlementData

# --- Scene Registry ---
var active_astar_grid: AStarGrid2D = null
var active_building_container: Node2D = null
var grid_manager_node: Node = null 

# --- Scene Management ---

func register_active_scene_nodes(grid: AStarGrid2D, container: Node2D, manager_node: Node = null) -> void:
	if not is_instance_valid(grid) or not is_instance_valid(container):
		push_error("SettlementManager: Failed to register invalid scene nodes.")
		return
	active_astar_grid = grid
	active_building_container = container
	grid_manager_node = manager_node 
	print("SettlementManager: Active scene nodes registered.")
	
	_trigger_territory_update()

func unregister_active_scene_nodes() -> void:
	active_astar_grid = null
	active_building_container = null
	grid_manager_node = null 
	print("SettlementManager: Active scene nodes unregistered.")

func _trigger_territory_update() -> void:
	if current_settlement and is_instance_valid(grid_manager_node) and grid_manager_node.has_method("recalculate_territory"):
		var all_buildings = current_settlement.placed_buildings + current_settlement.pending_construction_buildings
		grid_manager_node.recalculate_territory(all_buildings)

# --- Settlement Data ---

func load_settlement(data: SettlementData) -> void:
	# 1. Try to load from User Save first (Persistence)
	if ResourceLoader.exists(USER_SAVE_PATH):
		var saved_data = load(USER_SAVE_PATH)
		if saved_data is SettlementData:
			current_settlement = saved_data
			print("SettlementManager: Loaded user save from %s" % USER_SAVE_PATH)
		else:
			_load_fallback_data(data)
	else:
		_load_fallback_data(data)
	
	EventBus.settlement_loaded.emit(current_settlement)
	_trigger_territory_update()

func _load_fallback_data(data: SettlementData) -> void:
	if data:
		# Duplicate data so we don't overwrite the .tres template in memory
		current_settlement = data.duplicate(true)
		print("SettlementManager: Loaded default template.")
	else:
		push_error("SettlementManager: No data provided and no save file found.")

func save_settlement() -> void:
	if not current_settlement: return
	
	# --- FIX: Save to user:// instead of res:// ---
	var error = ResourceSaver.save(current_settlement, USER_SAVE_PATH)
	
	if error == OK:
		var count = current_settlement.pending_construction_buildings.size()
		print("SettlementManager: Saved to %s (Pending: %d)" % [USER_SAVE_PATH, count])
	else:
		push_error("Failed to save to %s. Error code: %s" % [USER_SAVE_PATH, error])

func has_current_settlement() -> bool:
	return current_settlement != null

# --- Treasury & Economy ---
func get_labor_capacities() -> Dictionary:
	"""
	Returns the maximum workers allowed for each category.
	Based on Active Buildings (Gathering) and Blueprints (Construction).
	"""
	var capacities = {
		"construction": 0,
		"food": BASE_GATHERING_CAPACITY,
		"wood": BASE_GATHERING_CAPACITY,
		"stone": BASE_GATHERING_CAPACITY
		# Gold is removed (Raiding only)
	}
	
	if not current_settlement:
		return capacities

	# 1. Gathering Capacity (From Active Buildings)
	for entry in current_settlement.placed_buildings:
		var b_data = load(entry["resource_path"])
		if b_data is EconomicBuildingData:
			var type = b_data.resource_type
			if capacities.has(type):
				capacities[type] += b_data.max_workers
	
	# 2. Construction Capacity (From Blueprints)
	# Limits how many people can crowd around a construction site
	for entry in current_settlement.pending_construction_buildings:
		var b_data = load(entry["resource_path"]) as BuildingData
		if b_data:
			capacities["construction"] += b_data.base_labor_capacity
			
	return capacities

func deposit_resources(loot: Dictionary) -> void:
	if not current_settlement: return
	
	for resource_type in loot:
		var amount = loot[resource_type]
		
		# --- NEW: Handle Population (Thralls) ---
		if resource_type == "population":
			# Ensure the variable exists in data (it was added in Phase 2 but let's be safe)
			if not "population_total" in current_settlement:
				current_settlement.population_total = 10
				
			current_settlement.population_total += amount
			print("SettlementManager: Acquired %d new thralls. Total Pop: %d" % [amount, current_settlement.population_total])
		# ----------------------------------------
		
		# Handle Standard Resources
		elif current_settlement.treasury.has(resource_type):
			current_settlement.treasury[resource_type] += amount
		else:
			# Create key if missing (e.g. specialized loot)
			current_settlement.treasury[resource_type] = amount
			
	EventBus.treasury_updated.emit(current_settlement.treasury)
	save_settlement()

func attempt_purchase(item_cost: Dictionary) -> bool:
	if not current_settlement: return false
	
	for resource_type in item_cost:
		if not current_settlement.treasury.has(resource_type) or \
		current_settlement.treasury[resource_type] < item_cost[resource_type]:
			var reason = "Insufficient %s" % resource_type
			print("Purchase failed. %s." % reason)
			EventBus.purchase_failed.emit(reason)
			return false
			
	for resource_type in item_cost:
		current_settlement.treasury[resource_type] -= item_cost[resource_type]
	
	EventBus.treasury_updated.emit(current_settlement.treasury)
	EventBus.purchase_successful.emit("Unnamed Item")
	return true

func calculate_payout() -> Dictionary:
	if not current_settlement: return {}

	_process_construction_labor()

	var total_payout: Dictionary = {}
	var stewardship_bonus = 1.0
	var jarl = DynastyManager.get_current_jarl()
	if jarl:
		var skill = jarl.get_effective_skill("stewardship")
		stewardship_bonus = 1.0 + (skill - 10) * 0.05
		stewardship_bonus = max(0.5, stewardship_bonus)

	# 1. Labor Output (Gold Removed)
	if current_settlement.worker_assignments:
		for resource_type in ["food", "wood", "stone"]: # Gold removed
			var assigned = current_settlement.worker_assignments.get(resource_type, 0)
			if assigned > 0:
				if not total_payout.has(resource_type): total_payout[resource_type] = 0
				var labor_yield = int(assigned * GATHERER_EFFICIENCY * stewardship_bonus)
				total_payout[resource_type] += labor_yield
				print("Labor added %d %s" % [labor_yield, resource_type])

	# 2. Passive Building Output (Gold allowed here, e.g. Markets/Mints)
	for entry in current_settlement.placed_buildings:
		var b_data = load(entry["resource_path"])
		if b_data is EconomicBuildingData:
			var type = b_data.resource_type
			if not total_payout.has(type): total_payout[type] = 0
			total_payout[type] += int(b_data.fixed_payout_amount * stewardship_bonus)

	# 3. Region Income
	if jarl:
		for region_path in jarl.conquered_regions:
			var r_data = load(region_path)
			if r_data:
				for res in r_data.yearly_income:
					if not total_payout.has(res): total_payout[res] = 0
					total_payout[res] += int(r_data.yearly_income[res] * stewardship_bonus)

	# 4. Debuffs
	if jarl and current_settlement.has_stability_debuff:
		if total_payout.has("gold"):
			total_payout["gold"] = int(total_payout["gold"] * 0.75)
		current_settlement.has_stability_debuff = false
		save_settlement()

	return total_payout

func recruit_unit(unit_data: UnitData) -> void:
	if not current_settlement or not unit_data: return
	var unit_path: String = unit_data.resource_path
	if unit_path.is_empty(): return
	
	if current_settlement.garrisoned_units.has(unit_path):
		current_settlement.garrisoned_units[unit_path] += 1
	else:
		current_settlement.garrisoned_units[unit_path] = 1
	
	print("Recruited %s." % unit_data.display_name)
	save_settlement()
	EventBus.purchase_successful.emit(unit_data.display_name)

# --- Building Construction Logic ---

func _process_construction_labor() -> void:
	if not current_settlement: return
	
	var assigned_builders = current_settlement.worker_assignments.get("construction", 0)
	if assigned_builders <= 0:
		print("End Year: No builders assigned. Construction stalled.")
		return
		
	var total_labor_points = assigned_builders * BUILDER_EFFICIENCY
	print("End Year: Processing Construction. Available Labor: %d" % total_labor_points)
	
	var completed_indices: Array[int] = []
	
	for i in range(current_settlement.pending_construction_buildings.size()):
		if total_labor_points <= 0:
			break
			
		var entry = current_settlement.pending_construction_buildings[i]
		var building_data = load(entry["resource_path"]) as BuildingData
		
		if not building_data: continue
		
		var current_progress = entry.get("progress", 0)
		var effort_needed = building_data.construction_effort_required
		var effort_remaining = effort_needed - current_progress
		
		var points_to_apply = min(total_labor_points, effort_remaining)
		
		# 1. Update Data
		entry["progress"] = current_progress + points_to_apply
		total_labor_points -= points_to_apply
		
		print("  > Applied %d points to %s (Progress: %d/%d)" % [points_to_apply, building_data.display_name, entry["progress"], effort_needed])
		
		# 2. Update Visuals (LIVE SCENE UPDATE)
		# We must convert the stored position to Vector2i for the lookup
		var grid_pos = Vector2i(entry["grid_position"]) 
		var active_instance = _find_building_instance_at(grid_pos)
		
		if is_instance_valid(active_instance):
			# This triggers the visual state change (Blueprint -> Construction)
			# and updates the health bar/label immediately
			active_instance.add_construction_progress(points_to_apply)
		else:
			print("Warning: Could not find visual instance for building at %s" % grid_pos)
		
		# 3. Check Completion
		if entry["progress"] >= effort_needed:
			print("  >>> Construction COMPLETE: %s" % building_data.display_name)
			completed_indices.append(i)
			
			var new_placed_entry = {
				"resource_path": entry["resource_path"],
				"grid_position": entry["grid_position"]
			}
			current_settlement.placed_buildings.append(new_placed_entry)
	
	completed_indices.sort()
	completed_indices.reverse()
	for i in completed_indices:
		current_settlement.pending_construction_buildings.remove_at(i)
		
	save_settlement()
	
	# If anything completed, we might need to reload/refresh territory
	if not completed_indices.is_empty():
		_trigger_territory_update()

# --- NEW HELPER ---
func _find_building_instance_at(grid_pos: Vector2i) -> BaseBuilding:
	"""Finds the actual node in the scene for a given grid position."""
	if not is_instance_valid(active_building_container):
		return null
		
	# Convert grid pos to world pos logic to match building positions?
	# Actually, simpler: Iterate children and check their data.
	# Since we don't have a dictionary map of instances, we loop.
	# Optimization: Maintain a lookup dict in the future if building count > 100.
	
	var cell_size = get_active_grid_cell_size()
	
	for child in active_building_container.get_children():
		if child is BaseBuilding:
			# Reverse engineer the grid pos from global pos
			var size_offset = Vector2(child.data.grid_size) * cell_size / 2.0
			var top_left = child.global_position - size_offset
			var child_grid_pos = Vector2i(round(top_left.x / cell_size.x), round(top_left.y / cell_size.y))
			
			if child_grid_pos == grid_pos:
				return child
	return null
# --- Building & Pathfinding ---

func remove_building(building_instance: BaseBuilding) -> void:
	if not current_settlement or not is_instance_valid(building_instance): return

	var cell_size = get_active_grid_cell_size()
	var building_pos = building_instance.global_position
	var size_pixels = Vector2(building_instance.data.grid_size) * cell_size
	var top_left_pixels = building_pos - (size_pixels / 2.0)
	var grid_pos = Vector2i(top_left_pixels / cell_size)
	
	if is_instance_valid(active_astar_grid):
		for x in range(building_instance.data.grid_size.x):
			for y in range(building_instance.data.grid_size.y):
				var cell = grid_pos + Vector2i(x, y)
				if _is_cell_within_bounds(cell):
					active_astar_grid.set_point_solid(cell, false)
		active_astar_grid.update()
		EventBus.pathfinding_grid_updated.emit(grid_pos)

	var removed = _remove_from_list(current_settlement.placed_buildings, grid_pos)
	if not removed:
		removed = _remove_from_list(current_settlement.pending_construction_buildings, grid_pos)
	
	if removed:
		save_settlement()
		print("SettlementManager: Removed %s from data at %s." % [building_instance.data.display_name, grid_pos])
		_trigger_territory_update()
	else:
		push_warning("SettlementManager: Could not find data entry for building at %s" % grid_pos)

	building_instance.queue_free()

func _remove_from_list(list: Array, grid_pos: Vector2i) -> bool:
	for i in range(list.size()):
		var entry = list[i]
		var entry_pos = entry["grid_position"]
		
		# Explicitly cast entry to Vector2i for safe comparison
		var current_pos_i: Vector2i
		
		if entry_pos is Vector2:
			current_pos_i = Vector2i(entry_pos)
		elif entry_pos is Vector2i:
			current_pos_i = entry_pos
		else:
			continue 
			
		if current_pos_i == grid_pos:
			list.remove_at(i)
			return true
	return false

func get_active_grid_cell_size() -> Vector2:
	if is_instance_valid(active_astar_grid): return active_astar_grid.cell_size
	return Vector2(32, 32)

func place_building(building_data: BuildingData, grid_position: Vector2i, is_new_construction: bool = false) -> BaseBuilding:
	if not is_instance_valid(active_astar_grid) or not is_instance_valid(active_building_container):
		push_error("Place building failed: Active scene nodes are not registered.")
		return null

	if not building_data or not building_data.scene_to_spawn:
		push_error("Build request failed: BuildingData or scene_to_spawn is null.")
		return null
	
	if not is_placement_valid(grid_position, building_data.grid_size):
		push_error("Cannot place building at %s: Invalid position." % grid_position)
		return null
	
	var new_building: BaseBuilding = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	
	var world_pos_top_left: Vector2 = Vector2(grid_position) * active_astar_grid.cell_size
	var building_footprint_size: Vector2 = Vector2(building_data.grid_size) * active_astar_grid.cell_size
	var building_center_offset: Vector2 = building_footprint_size / 2.0
	new_building.global_position = world_pos_top_left + building_center_offset
	
	active_building_container.add_child(new_building)
	
	if building_data.blocks_pathfinding:
		for x in range(building_data.grid_size.x):
			for y in range(building_data.grid_size.y):
				var cell_pos = grid_position + Vector2i(x, y)
				if _is_cell_within_bounds(cell_pos):
					active_astar_grid.set_point_solid(cell_pos, true)
		
		active_astar_grid.update()
		EventBus.pathfinding_grid_updated.emit(grid_position)

	if is_new_construction:
		new_building.set_state(BaseBuilding.BuildingState.BLUEPRINT)
		
		var entry = {
			"resource_path": building_data.resource_path,
			"grid_position": grid_position,
			"progress": 0
		}
		if current_settlement.pending_construction_buildings == null:
			current_settlement.pending_construction_buildings = []
			
		current_settlement.pending_construction_buildings.append(entry)
		save_settlement() 
		print("SettlementManager: New blueprint placed and saved at %s." % grid_position)
	else:
		new_building.set_state(BaseBuilding.BuildingState.ACTIVE)
	
	_trigger_territory_update()
		
	return new_building

func is_placement_valid(grid_position: Vector2i, building_size: Vector2i) -> bool:
	if not is_instance_valid(active_astar_grid): return false
	
	for x in range(building_size.x):
		for y in range(building_size.y):
			var cell_pos = grid_position + Vector2i(x, y)
			if not _is_cell_within_bounds(cell_pos): return false
			if active_astar_grid.is_point_solid(cell_pos): return false
	return true

func _is_cell_within_bounds(grid_position: Vector2i) -> bool:
	if not is_instance_valid(active_astar_grid): return false
	var bounds = active_astar_grid.region
	return grid_position.x >= bounds.position.x and grid_position.x < bounds.end.x and \
		   grid_position.y >= bounds.position.y and grid_position.y < bounds.end.y

func get_astar_path(start_pos: Vector2, end_pos: Vector2, allow_partial_path: bool = false) -> PackedVector2Array:
	if not is_instance_valid(active_astar_grid): return PackedVector2Array()
	var start_id: Vector2i = Vector2i(start_pos / active_astar_grid.cell_size)
	var end_id: Vector2i = Vector2i(end_pos / active_astar_grid.cell_size)
	if not _is_cell_within_bounds(start_id): return PackedVector2Array()
	return active_astar_grid.get_point_path(start_id, end_id, allow_partial_path)

func set_astar_point_solid(grid_position: Vector2i, solid: bool) -> void:
	if is_instance_valid(active_astar_grid) and _is_cell_within_bounds(grid_position):
		active_astar_grid.set_point_solid(grid_position, solid)
# --- Phase 4.1: The Prediction Engine ---

func simulate_turn(simulated_assignments: Dictionary) -> Dictionary:
	if not current_settlement: return {}

	var result = {
		"resources_gained": { "food": 0, "wood": 0, "stone": 0, "gold": 0 },
		"buildings_completing": []
	}

	# 1. Simulate Construction
	var assigned_builders = simulated_assignments.get("construction", 0)
	var total_points = assigned_builders * BUILDER_EFFICIENCY
	
	for entry in current_settlement.pending_construction_buildings:
		if total_points <= 0: break
		var b_data = load(entry["resource_path"]) as BuildingData
		if not b_data: continue
		
		var needed = b_data.construction_effort_required - entry.get("progress", 0)
		var applied = min(total_points, needed)
		total_points -= applied
		
		if (entry.get("progress", 0) + applied) >= b_data.construction_effort_required:
			result["buildings_completing"].append(b_data.display_name)

	# 2. Simulate Economy
	var stewardship_bonus = 1.0
	var jarl = DynastyManager.get_current_jarl()
	if jarl:
		var skill = jarl.get_effective_skill("stewardship")
		stewardship_bonus = 1.0 + (skill - 10) * 0.05

	# Labor (Gold Removed)
	for res in ["food", "wood", "stone"]:
		var count = simulated_assignments.get(res, 0)
		if count > 0:
			result["resources_gained"][res] += int(count * GATHERER_EFFICIENCY * stewardship_bonus)

	# Passive Buildings & Regions (Keep Gold)
	for entry in current_settlement.placed_buildings:
		var b_data = load(entry["resource_path"])
		if b_data is EconomicBuildingData:
			result["resources_gained"][b_data.resource_type] += int(b_data.fixed_payout_amount * stewardship_bonus)
			
	if jarl:
		for path in jarl.conquered_regions:
			var r_data = load(path)
			if r_data:
				for res in r_data.yearly_income:
					result["resources_gained"][res] += int(r_data.yearly_income[res] * stewardship_bonus)

	return result

--- SCRIPT: res://data/buildings/Base_Building.gd ---
class_name BaseBuilding
extends StaticBody2D

signal building_destroyed(building: BaseBuilding)
signal construction_completed(building: BaseBuilding)

enum BuildingState { 
	BLUEPRINT, 
	UNDER_CONSTRUCTION, 
	ACTIVE 
}

@export var data: BuildingData
var current_health: int = 100
var current_state: BuildingState = BuildingState.ACTIVE 
var construction_progress: int = 0

# Node refs
var background: ColorRect
var label: Label
var collision_shape: CollisionShape2D
var hitbox_area: Area2D
var health_bar: ProgressBar
var border_rect: ColorRect
var attack_ai: Node = null 

# StyleBox references for dynamic coloring
var style_fill: StyleBoxFlat
var style_bg: StyleBoxFlat

func _ready() -> void:
	if not data: return
	
	current_health = data.max_health
	
	# --- Create core nodes ---
	collision_shape = CollisionShape2D.new()
	collision_shape.shape = RectangleShape2D.new()
	add_child(collision_shape)
	
	background = ColorRect.new()
	label = Label.new()
	background.add_child(label)
	add_child(background)
	# -------------------------
	
	input_pickable = true
	_create_hitbox()
	_apply_data_and_scale()
	_create_dev_visuals() 
	_setup_defensive_ai()
	
	# Apply the initial state visual
	_update_visual_state()

func _input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_RIGHT:
			EventBus.building_right_clicked.emit(self)

func set_state(new_state: BuildingState) -> void:
	var old_state = current_state
	current_state = new_state
	_update_visual_state()
	_update_logic_state()
	
	if current_state == BuildingState.ACTIVE and old_state != BuildingState.ACTIVE:
		construction_completed.emit(self)
		if SettlementManager and SettlementManager.has_method("complete_building_construction"):
			SettlementManager.complete_building_construction(self)

func _update_visual_state() -> void:
	if not background: return

	match current_state:
		BuildingState.BLUEPRINT:
			# Ghostly Blue
			self.modulate = Color(0.4, 0.6, 1.0, 0.5)
			background.color = Color.WHITE
			background.color.a = 0.5 
			if label: label.text = "%s\n(Blueprint)" % data.display_name
			if health_bar: health_bar.hide()
			
		BuildingState.UNDER_CONSTRUCTION:
			# Dark Foundation, Opaque
			self.modulate = Color.WHITE 
			background.color = Color(0.2, 0.2, 0.2, 0.9) 
			
			# --- CONSTRUCTION BAR CONFIG ---
			if health_bar: 
				health_bar.show()
				# Set correct range
				var max_effort = max(1, data.construction_effort_required)
				health_bar.max_value = max_effort
				health_bar.value = construction_progress
				
				# Set Colors Directly on StyleBox (Blue)
				if style_fill: style_fill.bg_color = Color(0.2, 0.6, 1.0) # Bright Blue
				
				# Reset modulation (don't tint the black background)
				health_bar.modulate = Color.WHITE 
			
			_update_percentage_label()
			
		BuildingState.ACTIVE:
			# Standard Colors
			self.modulate = Color.WHITE
			_apply_color_coding() 
			background.color.a = 1.0
			if label: label.text = data.display_name
			
			# --- HEALTH BAR CONFIG ---
			if health_bar:
				health_bar.max_value = data.max_health
				health_bar.value = current_health
				
				# Set Colors Directly on StyleBox (Green)
				if style_fill: style_fill.bg_color = Color(0.2, 0.8, 0.2) # Green
				
				health_bar.modulate = Color.WHITE
				health_bar.show()

func _update_logic_state() -> void:
	match current_state:
		BuildingState.BLUEPRINT, BuildingState.UNDER_CONSTRUCTION:
			if collision_shape: collision_shape.disabled = true
			if hitbox_area: hitbox_area.monitorable = false
			if attack_ai:
				attack_ai.process_mode = Node.PROCESS_MODE_DISABLED
				if attack_ai.has_method("stop_attacking"):
					attack_ai.stop_attacking()
			EventBus.building_state_changed.emit(self, current_state)
			
		BuildingState.ACTIVE:
			if collision_shape: collision_shape.disabled = false
			if hitbox_area: hitbox_area.monitorable = true
			if attack_ai: attack_ai.process_mode = Node.PROCESS_MODE_INHERIT
			EventBus.building_state_changed.emit(self, current_state)

func add_construction_progress(amount: int) -> void:
	if current_state == BuildingState.ACTIVE: return
	
	# Auto-transition state on first progress
	if current_state == BuildingState.BLUEPRINT:
		set_state(BuildingState.UNDER_CONSTRUCTION)
		
	construction_progress += amount
	print("Building %s progress: %d / %d" % [name, construction_progress, data.construction_effort_required])
	
	# Update the bar immediately
	if health_bar:
		health_bar.value = construction_progress
		
	_update_percentage_label()
	
	# Auto-complete
	if construction_progress >= data.construction_effort_required:
		# Handled by Manager, but ensures local state is correct
		pass 

func _update_percentage_label() -> void:
	if label and data.construction_effort_required > 0:
		var percent = int((float(construction_progress) / data.construction_effort_required) * 100)
		label.text = "%s\n(%d%%)" % [data.display_name, percent]

func _create_hitbox() -> void:
	hitbox_area = Area2D.new()
	hitbox_area.name = "Hitbox"
	if self.collision_layer & 1: hitbox_area.collision_layer = 1
	elif self.collision_layer & 8: hitbox_area.collision_layer = 8
	else: hitbox_area.collision_layer = 1
	hitbox_area.collision_mask = 0
	hitbox_area.monitorable = true
	var s = CollisionShape2D.new()
	s.shape = RectangleShape2D.new()
	hitbox_area.add_child(s)
	add_child(hitbox_area)

func _apply_data_and_scale() -> void:
	if not SettlementManager: return
	var cell = SettlementManager.get_active_grid_cell_size()
	var size = Vector2(data.grid_size) * cell
	background.custom_minimum_size = size
	background.position = -size / 2.0
	
	label.text = data.display_name
	label.custom_minimum_size = size
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	
	_apply_color_coding()
	
	if collision_shape: collision_shape.shape.size = size
	if hitbox_area: hitbox_area.get_child(0).shape.size = size

func _apply_color_coding() -> void:
	var c = Color.GRAY
	if data.dev_color != Color.TRANSPARENT and data.dev_color != Color.GRAY: c = data.dev_color
	elif data.is_defensive_structure: c = Color.CRIMSON * 0.8
	elif data.is_player_buildable: c = Color.ROYAL_BLUE * 0.8
	background.color = c

func _create_dev_visuals() -> void:
	var cell = SettlementManager.get_active_grid_cell_size()
	var size = Vector2(data.grid_size) * cell
	if data.is_defensive_structure:
		border_rect = ColorRect.new()
		border_rect.color = Color.DARK_RED
		border_rect.custom_minimum_size = size + Vector2(4,4)
		border_rect.position = -border_rect.custom_minimum_size/2.0
		add_child(border_rect)
		move_child(border_rect, 0)
	
	# --- UPDATED BAR CREATION ---
	health_bar = ProgressBar.new()
	health_bar.custom_minimum_size = Vector2(size.x * 0.9, 10) # 90% width, 10px height
	health_bar.position = Vector2(-size.x * 0.45, -size.y/2 - 15) # Centered above
	health_bar.max_value = data.max_health
	health_bar.value = current_health
	health_bar.show_percentage = false
	
	# Create StyleBox Resources
	style_bg = StyleBoxFlat.new()
	style_bg.bg_color = Color(0, 0, 0, 1) # Black Background
	health_bar.add_theme_stylebox_override("background", style_bg)
	
	style_fill = StyleBoxFlat.new()
	style_fill.bg_color = Color(1, 1, 1, 1) # White (Default, changed in update)
	health_bar.add_theme_stylebox_override("fill", style_fill)
	
	add_child(health_bar)

func _setup_defensive_ai() -> void:
	if not data or not data.is_defensive_structure or not data.ai_component_scene: return
	attack_ai = data.ai_component_scene.instantiate()
	add_child(attack_ai)
	if attack_ai.has_method("configure_from_data"): attack_ai.configure_from_data(data)
	if attack_ai.has_method("set_target_mask"): attack_ai.set_target_mask(1 << 1)

func take_damage(amount: int, _attacker: Node2D = null) -> void:
	if current_state != BuildingState.ACTIVE: return
	current_health = max(0, current_health - amount)
	
	if health_bar: health_bar.value = current_health
	
	if current_health == 0: die()

func die() -> void:
	building_destroyed.emit(self)
	queue_free()

--- SCRIPT: res://data/buildings/BuildingData.gd ---
# res://data/buildings/BuildingData.gd
# Defines the core data for any building in the game.
class_name BuildingData
extends Resource

## The name displayed in the UI.
@export var display_name: String = "New Building"
@export var scene_to_spawn: PackedScene
@export var icon: Texture2D
@export var building_texture: Texture2D
@export var build_cost: Dictionary
@export var max_health: int = 100
@export var blocks_pathfinding: bool = true
@export var grid_size: Vector2i = Vector2i.ONE
@export var dev_color: Color = Color.GRAY
@export var is_player_buildable: bool = false

@export_group("Construction")
@export var construction_effort_required: int = 100
@export var base_labor_capacity: int = 3

@export_group("Territory & Expansion")
## If true, this building generates territory even if not connected to anything (e.g., Great Hall).
@export var is_territory_hub: bool = false

## If true, this building extends territory if connected to a Hub (e.g., Walls, Roads).
@export var extends_territory: bool = false

## The radius of buildable land this building provides around itself.
@export var territory_radius: int = 4
# -----------------------------------------

@export_group("Defensive Stats")
@export var is_defensive_structure: bool = false
@export var attack_damage: int = 5
@export var attack_range: float = 200.0
@export var attack_speed: float = 1.0
@export var ai_component_scene: PackedScene
@export var projectile_scene: PackedScene
@export var projectile_speed: float = 400.0

--- SCRIPT: res://data/buildings/EconomicBuildingData.gd ---
# res://data/buildings/EconomicBuildingData.gd
extends BuildingData
class_name EconomicBuildingData

@export_group("Economic Stats")
## The type of resource this building generates (e.g., "wood", "food", "stone").
@export var resource_type: String = "wood"

## The fixed amount of resources generated passively per turn.
@export var fixed_payout_amount: int = 10

## The maximum amount of the resource that can be stored before collection.
@export var storage_cap: int = 100

## The max number of workers that can be assigned to gather this resource here.
@export var max_workers: int = 3

--- SCRIPT: res://data/characters/JarlData.gd ---
# res://data/characters/JarlData.gd
#
# Defines the persistent data for a Jarl character in Viking Dynasty.
# This resource stores all the attributes that persist across the dynasty layer.
# GDD Ref: Section 2.A (Macro Layer), Appendix A.2 (Renown & Succession Loop)

class_name JarlData
extends Resource

## The Jarl's name displayed in the UI
@export var display_name: String = "New Jarl"

## The Jarl's portrait/icon for the UI
@export var portrait: Texture2D

## The Jarl's age in years
@export var age: int = 25

## The Jarl's gender (affects marriage and succession options)
@export var gender: String = "Male"  # "Male", "Female"


@export_group("Dynasty & Authority")
## Total Renown accumulated by this Jarl (persistent XP/Legacy score)
@export var renown: int = 0

## Current Renown Tier (determines Authority cap per year)
## Tiers: 0="Petty Jarl", 1="High Jarl", 2="Kingmaker", etc.
@export var renown_tier: int = 0

## Authority remaining for this year (action points for Macro layer)
@export var current_authority: int = 3

## Maximum Authority this Jarl can generate per year (based on Renown Tier)
@export var max_authority: int = 3

## Years since last offensive action (for Renown Decay calculations)
@export var years_since_action: int = 0

## Legitimacy score affecting succession and stability (0-100 scale)
@export var legitimacy: int = 20

## Years remaining in succession debuff (reduced Authority generation)
@export var succession_debuff_years_remaining: int = 0

# --- Builder Pillar Upgrade Properties ---
## Bonus starting renown for all future heirs (from "Erect Jelling Stone")
@export var heir_starting_renown_bonus: int = 0

## An array of unique effect_keys for one-time legacy upgrades
## (e.g., ["UPG_TRELLEBORG", "UPG_JELLING_STONE"])
@export var purchased_legacy_upgrades: Array[String] = []

# --- Unifier Pillar Property ---
## An array of resource paths to WorldRegionData files that have been subjugated.
@export var conquered_regions: Array[String] = []

# --- Progenitor Pillar Property ---
## An array of resource paths to WorldRegionData files that are allied.
@export var allied_regions: Array[String] = []


@export_group("Naval Logistics")
## The distance (in pixels) a fleet can travel with 0% attrition.
@export var safe_naval_range: float = 600.0

## Attrition penalty per 100 pixels beyond safe range (e.g., 0.10 = 10% risk).
@export var attrition_per_100px: float = 0.10


@export_group("Base Skills")
## Combat leadership and personal prowess
@export var command: int = 10
@export var diplomacy: int = 10
@export var stewardship: int = 10
@export var learning: int = 10
@export var prowess: int = 10
@export var charisma: int = 10


@export_group("Traits")
## Array of JarlTraitData resources that modify the Jarl's abilities and story
@export var traits: Array[JarlTraitData] = []
## Legacy trait names for backward compatibility (can be removed later)
@export var legacy_trait_names: Array[String] = []
## Whether this Jarl is currently wounded (affects stats temporarily)
@export var is_wounded: bool = false
## Number of turns remaining for wound recovery
@export var wound_recovery_turns: int = 0

# --- HELPER FUNCTIONS ---

func get_safe_range() -> float:
	# Placeholder for future trait modifiers (e.g. "Seafarer" trait)
	return safe_naval_range

## Get the number of *available* heirs (not on expedition, etc.)
func get_available_heir_count() -> int:
	var count = 0
	for heir in heirs:
		if heir and heir.status == JarlHeirData.HeirStatus.Available:
			count += 1
	return count

## Get the first available heir resource
func get_first_available_heir() -> JarlHeirData:
	for heir in heirs:
		if heir and heir.status == JarlHeirData.HeirStatus.Available:
			return heir
	return null

## Remove an heir from the dynasty (e.g., married off or lost)
## Returns false if the heir could not be found.
func remove_heir(heir_to_remove: JarlHeirData) -> bool:
	if heir_to_remove in heirs:
		heirs.erase(heir_to_remove)
		return true
	return false

## Check if the Jarl has at least one valid, available heir
func check_has_valid_heir() -> bool:
	return get_first_available_heir() != null


@export_group("Family & Succession")
## The Jarl's spouse (if any)
@export var spouse_name: String = ""
## Array of JarlHeirData resources in order of succession priority
@export var heirs: Array[JarlHeirData] = []

## DEPRECATED Properties (kept for compatibility if needed)
var has_valid_heir: bool:
	get: return check_has_valid_heir()
var children_count: int:
	get: return get_available_heir_count()


@export_group("Political Status")
@export var title: String = "Jarl"
@export var vassal_count: int = 0
@export var reputation: int = 0
@export var is_in_exile: bool = false


@export_group("Combat & Mission State")
@export var is_on_mission: bool = false
@export var battles_fought: int = 0
@export var battles_won: int = 0
@export var successful_raids: int = 0


## Get the effective skill value including trait modifiers
func get_effective_skill(skill_name: String) -> int:
	var base_value: int = 0
	match skill_name.to_lower():
		"command": base_value = command
		"diplomacy": base_value = diplomacy
		"stewardship": base_value = stewardship
		"learning": base_value = learning
		"prowess": base_value = prowess
		"charisma": base_value = charisma
		_: return 0
	
	var trait_modifier: int = 0
	for jarl_trait in traits:
		if jarl_trait == null: continue
		match skill_name.to_lower():
			"command": trait_modifier += jarl_trait.command_modifier
			"stewardship": trait_modifier += jarl_trait.stewardship_modifier
			"intrigue": trait_modifier += jarl_trait.intrigue_modifier
	
	return base_value + trait_modifier


## Add a trait to the Jarl (if not already present)
func add_trait(trait_data: JarlTraitData) -> void:
	if trait_data == null: return
	for existing_trait in traits:
		if existing_trait != null and existing_trait.display_name == trait_data.display_name:
			return
	traits.append(trait_data)

## Check if Jarl has a specific trait by display name
func has_trait(trait_name: String) -> bool:
	for jarl_trait in traits:
		if jarl_trait != null and jarl_trait.display_name == trait_name:
			return true
	return false

## Get the Jarl's Authority cap based on Renown Tier
func get_authority_cap() -> int:
	match renown_tier:
		0: return 3
		1: return 5
		2: return 7
		_: return 3 + renown_tier

func can_take_action(authority_cost: int = 1) -> bool:
	return current_authority >= authority_cost

func spend_authority(cost: int = 1) -> bool:
	if can_take_action(cost):
		current_authority -= cost
		return true
	return false

func award_renown(amount: int) -> void:
	renown += amount
	years_since_action = 0
	_update_renown_tier()

func _update_renown_tier() -> void:
	if renown >= 1000: renown_tier = 3
	elif renown >= 500: renown_tier = 2
	elif renown >= 200: renown_tier = 1
	else: renown_tier = 0

func reset_authority() -> void:
	max_authority = get_authority_cap()
	if succession_debuff_years_remaining > 0:
		var legit_multiplier = legitimacy / 100.0
		var authority_gained = int(round(max_authority * legit_multiplier))
		current_authority = max(1, authority_gained)
		succession_debuff_years_remaining -= 1
	else:
		current_authority = max_authority

func age_jarl(years: int = 1) -> void:
	age += years
	years_since_action += years
	if age > 60:
		prowess = max(1, prowess - 1)
		learning = min(20, learning + 1)

func remove_trait(trait_name: String) -> bool:
	for i in range(traits.size()):
		if traits[i] != null and traits[i].display_name == trait_name:
			traits.remove_at(i)
			return true
	return false

--- SCRIPT: res://data/characters/JarlHeirData.gd ---
# res://data/characters/JarlHeirData.gd
#
# Defines the data for a single heir in the dynasty.
# This allows heirs to be "spent" or go on missions.
class_name JarlHeirData
extends Resource

enum HeirStatus {
	Available,
	OnExpedition,
	MarriedOff,
	LostAtSea,
	Deceased
}

## The heir's name.
@export var display_name: String = "New Heir"

## The heir's age.
@export var age: int = 16

## The heir's current status.
@export var status: HeirStatus = HeirStatus.Available

## If on expedition, how many "years" remain.
@export var expedition_years_remaining: int = 0

# --- NEW: Heir Skills & Traits ---
@export_group("Skills & Traits")
@export var command: int = 8
@export var stewardship: int = 8
@export var learning: int = 8
@export var prowess: int = 8
@export var traits: Array[JarlTraitData] = []
# --- END NEW ---

--- SCRIPT: res://data/events/EventChoice.gd ---
# res://data/events/EventChoice.gd
#
# Defines a single choice for a story event.
# This resource is designed to be embedded within an EventData resource.
class_name EventChoice
extends Resource

## The text displayed on the button for this choice.
@export var choice_text: String = "Choice Text"

## A tooltip to show what the likely (or guaranteed) outcome is.
@export var tooltip_text: String = "Tooltip"

## A unique key (e.g., "CHOICE_ACCEPT", "CHOICE_DECLINE")
## The EventManager will use this key to apply the correct consequence.
@export var effect_key: String = ""

--- SCRIPT: res://data/events/EventData.gd ---
# res://data/events/EventData.gd
#
# Defines a single, self-contained story event.
# This resource is the core of the "Full Event System" (Phase 3b).
# It is designed to be created and edited by designers in the Inspector.
class_name EventData
extends Resource

# --- The nested "class EventChoice" definition has been REMOVED ---

@export_group("Event Display")
## The title of the event window.
@export var title: String = "An Event Occurs"
## The main story text for the event.
@export_multiline var description: String = "Event description..."
## An optional icon or portrait for the event.
@export var portrait: Texture2D

@export_group("Event Triggering")
## The unique ID for this event.
@export var event_id: String = "unique_event_id"
## If true, this event can only fire once per campaign.
@export var is_unique: bool = true
## The base chance (0.0 to 1.0) for this event to fire when its
## conditions are met.
@export var base_chance: float = 0.5
## An array of prerequisite event_ids that must have fired
## *before* this event can be considered.
@export var prerequisites: Array[String] = []

@export_group("Event Conditions")
## Conditions related to the Jarl's stats.
@export var min_stewardship: int = -1
@export var min_command: int = -1
@export var min_prowess: int = -1
@export var min_renown: int = -1
## Conditions related to the Jarl's traits.
@export var must_have_trait: String = ""
@export var must_not_have_trait: String = ""
## Conditions related to the dynasty.
@export var min_available_heirs: int = -1
## Conditions related to the game world.
@export var min_conquered_regions: int = -1

@export_group("Event Choices")
## The array of choices to present to the player.
## This now correctly references the external EventChoice resource.
@export var choices: Array[EventChoice] = []

--- SCRIPT: res://data/legacy/LegacyUpgradeData.gd ---
# res://data/legacy/LegacyUpgradeData.gd
#
# Defines a permanent, one-time dynasty upgrade.
# These are purchased in the "Legacy" tab of the Storefront
# and cost Renown and Authority.
class_name LegacyUpgradeData
extends Resource

## The name displayed in the Storefront UI.
@export var display_name: String = "New Legacy Upgrade"

## The icon shown next to the upgrade name in the UI.
@export var icon: Texture2D

## The description shown in a tooltip or in the UI.
@export_multiline var description: String = "A permanent dynasty upgrade."

## The cost in Jarl's Renown.
@export var renown_cost: int = 100

## The cost in Jarl's Authority.
@export var authority_cost: int = 1

# --- NEW: Progress System ---
@export_group("Progress")
@export var required_progress: int = 1
@export var current_progress: int = 0
# --- END NEW ---

## A unique key to identify this upgrade's effect in code.
## e.g., "UPG_TRELLEBORG", "UPG_JELLING_STONE"
@export var effect_key: String = ""

## A key to check if a prerequisite upgrade has been purchased.
@export var prerequisite_key: String = ""

## 'is_purchased' is now a calculated variable, not stored.
var is_purchased: bool:
	get:
		return current_progress >= required_progress

--- SCRIPT: res://data/missions/RaidLootData.gd ---
# res://data/missions/RaidLootData.gd
# Resource for tracking loot collected during raids
# GDD Ref: Phase 3 Task 7 - Resource-Driven Payout

extends Resource
class_name RaidLootData

@export var collected_loot: Dictionary = {}

func _init() -> void:
	# Initialize with default resource types
	collected_loot = {
		"gold": 0,
		"wood": 0,
		"food": 0,
		"stone": 0
	}

func add_loot(resource_type: String, amount: int) -> void:
	"""Add loot to the collection"""
	if collected_loot.has(resource_type):
		collected_loot[resource_type] += amount
	else:
		collected_loot[resource_type] = amount
	
	print("Loot added: %d %s (Total: %d)" % [amount, resource_type, collected_loot[resource_type]])

func add_loot_from_building(building_data: BuildingData) -> void:
	"""Extract loot from a destroyed building"""
	if not building_data:
		return
	
	# For EconomicBuildingData, give loot based on the resource type
	if building_data is EconomicBuildingData:
		var eco_data: EconomicBuildingData = building_data
		var loot_amount = eco_data.fixed_payout_amount * 3  # 3x the daily payout as loot
		add_loot(eco_data.resource_type, loot_amount)
	else:
		# Default loot for other buildings
		add_loot("gold", 50)

func get_total_loot() -> Dictionary:
	"""Get a copy of the collected loot"""
	return collected_loot.duplicate()

func clear_loot() -> void:
	"""Reset all loot to zero"""
	for resource_type in collected_loot:
		collected_loot[resource_type] = 0

func get_loot_summary() -> String:
	"""Get a formatted string of collected loot"""
	var summary_parts: Array[String] = []
	for resource_type in collected_loot:
		if collected_loot[resource_type] > 0:
			summary_parts.append("%d %s" % [collected_loot[resource_type], resource_type])
	
	if summary_parts.is_empty():
		return "No loot collected"
	else:
		return "Loot: " + ", ".join(summary_parts)

--- SCRIPT: res://data/settlements/SettlementData.gd ---
extends Resource
class_name SettlementData

@export var treasury: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}

# Active Buildings
@export var placed_buildings: Array[Dictionary] = []

# Pending Blueprints
@export var pending_construction_buildings: Array = []

# Garrison
@export var garrisoned_units: Dictionary = {}
@export var max_garrison_bonus: int = 0

# --- NEW: Phase 2 Population Data ---
@export_group("Population & Labor")
## Total population available for work assignments.
@export var population_total: int = 10

## Current worker assignments for the year.
## Keys: "construction", "food", "wood", "stone", "gold"
@export var worker_assignments: Dictionary = {
	"construction": 0,
	"food": 0,
	"wood": 0,
	"stone": 0,
	"gold": 0
}
# ------------------------------------

@export var has_stability_debuff: bool = false

--- SCRIPT: res://data/traits/JarlTraitData.gd ---
# res://data/traits/JarlTraitData.gd
#
# This resource defines the statistical and diplomatic impact of a single trait.
# Renamed to JarlTraitData to avoid keyword conflict with Godot's internal 'Trait'.
class_name JarlTraitData
extends Resource

## General Information
@export var display_name: String = ""
@export var description: String = ""
@export var is_visible: bool = true # Should the player/AI know about this trait?

## Character Skill Modifiers (Permanent)
# Used to adjust the Jarl's base skills (Command, Stewardship, Intrigue)
@export_group("Skill Modifiers")
@export var command_modifier: int = 0
@export var stewardship_modifier: int = 0
@export var intrigue_modifier: int = 0

## Macro Layer Modifiers (Diplomacy/Renown)
@export_group("Macro Modifiers")
@export var renown_per_year_modifier: float = 0.0 # Used for passive Renown gain/loss
@export var vassal_opinion_modifier: int = 0  # Global change to vassal opinion of Jarl
@export var alliance_cost_modifier: float = 1.0 # Multiplier for alliance Authority cost

## Behavioral Flags (For AI and Event Triggers)
@export_group("Behavior Flags")
@export var is_wounded_trait: bool = false # e.g., Maimed, Crippled
@export var is_dishonorable_trait: bool = false # e.g., Betrayer, Cowardly

--- SCRIPT: res://data/units/UnitData.gd ---
# res://data/units/UnitData.gd
#
# Defines the core data for any unit in the game.
# This resource is used by Base_Unit.tscn to configure instances.
# GDD Ref: 7.C.1.b

class_name UnitData
extends Resource

## The name displayed in the UI (e.g., "Viking Raider").
@export var display_name: String = "New Unit"

## The scene that will be instanced when this unit is spawned.
@export var scene_to_spawn: PackedScene

## The icon shown in the training menu.
@export var icon: Texture2D

## The cost in 'Resources' to train this unit.
@export var spawn_cost: Dictionary = {"food": 25}


@export_group("Combat Stats")
## The unit's maximum hit points.
@export var max_health: int = 50

## Movement speed in pixels per second.
@export var move_speed: float = 75.0

## Damage dealt per attack.
@export var attack_damage: int = 8

## Range in pixels. (e.g., 10 for melee, 300 for archer).
@export var attack_range: float = 10.0

## Attacks per second.
@export var attack_speed: float = 1.2

## An optional AI scene to instance (e.g., for ranged units)
@export var ai_component_scene: PackedScene

## The projectile scene to spawn when this unit attacks (for ranged units).
@export var projectile_scene: PackedScene

## The speed of the projectile, in pixels per second.
@export var projectile_speed: float = 400.0


@export_group("Visuals")
## The texture to use for the unit's sprite.
@export var visual_texture: Texture2D

## The target gameplay size in pixels (e.g., 32x32).
@export var target_pixel_size: Vector2 = Vector2(32, 32)


@export_group("Movement Feel")
# --- NEW: Added properties from Base_Unit ---
## How quickly the unit reaches max speed (e.g., 10.0)
@export var acceleration: float = 10.0
## How much "friction" the unit has (e.g., 5.0)
@export var linear_damping: float = 5.0
# ---------------------------------------------

--- SCRIPT: res://data/world_map/MapState.gd ---
# res://data/world_map/MapState.gd
class_name MapState
extends Resource

# Dictionary mapping Region Node Names to their Data
# Format: { "Region1": WorldRegionData, "Region2": WorldRegionData }
@export var region_data_map: Dictionary = {}

# We can track global map flags here too
@export var turns_elapsed: int = 0

--- SCRIPT: res://data/world_map/RaidTargetData.gd ---
# res://data/world_map/RaidTargetData.gd
class_name RaidTargetData
extends Resource

@export var display_name: String = "Monastery"
@export var description: String = "A small, undefended religious site."
@export var settlement_data: SettlementData
@export var raid_cost_authority: int = 1
@export var difficulty_rating: int = 1 # 1-5 Stars

--- SCRIPT: res://data/world_map/WorldRegionData.gd ---
# res://data/world_map/WorldRegionData.gd
class_name WorldRegionData
extends Resource

@export var display_name: String = "New Region"
@export_multiline var description: String = "A description of this region."

# --- MODIFIED: Now a list of targets ---
@export var raid_targets: Array[RaidTargetData] = []
# --------------------------------------

@export var region_type_tag: String = "Province"
@export var yearly_income: Dictionary = {"gold": 10}

# Deprecated (Keep for temporary compatibility if needed, or delete)
# @export var target_settlement_data: SettlementData 
@export var base_authority_cost: int = 1

--- SCRIPT: res://player/RTSCamera.gd ---
# res://player/RTSCamera.gd
# Basic RTS-style camera controller for Phase 3
# Provides WASD movement, mouse edge panning, drag panning, and zooming.
# Keeps camera controls simple and focused on tactical gameplay.

extends Camera2D
class_name RTSCamera

# --- Movement Settings ---
@export_group("Movement")
@export var camera_speed: float = 400.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_wasd_movement: bool = true
@export var enable_drag_panning: bool = true

# --- Zoom Settings ---
@export_group("Zoom")
@export var min_zoom: float = 0.5  # Far away
@export var max_zoom: float = 2.0  # Close up
@export var zoom_speed: float = 0.1
@export var zoom_smoothing: float = 10.0

# --- Bounds Settings ---
@export_group("Bounds")
@export var bounds_enabled: bool = true
@export var bounds_rect: Rect2 = Rect2(-1000, -1000, 3000, 2500)

# Internal State
var target_zoom: Vector2 = Vector2.ONE
var is_dragging: bool = false
var drag_start_mouse_pos: Vector2 = Vector2.ZERO
var drag_start_camera_pos: Vector2 = Vector2.ZERO

func _ready() -> void:
	print("RTS Camera Initialized") # Check your Output tab for this!
	# Initialize target zoom to current zoom
	target_zoom = zoom
	make_current()

func _unhandled_input(event: InputEvent) -> void:
	# --- Zoom Control (Mouse Wheel) ---
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			_zoom_in()
			get_viewport().set_input_as_handled()
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			_zoom_out()
			get_viewport().set_input_as_handled()
			
		# --- Drag Panning (Middle Mouse) ---
		elif event.button_index == MOUSE_BUTTON_MIDDLE and enable_drag_panning:
			if event.is_pressed():
				is_dragging = true
				drag_start_mouse_pos = get_viewport().get_mouse_position()
				drag_start_camera_pos = global_position
				get_viewport().set_input_as_handled()
			else:
				is_dragging = false
				get_viewport().set_input_as_handled()

	# --- Handle Drag Motion ---
	if event is InputEventMouseMotion and is_dragging:
		var current_mouse_pos = get_viewport().get_mouse_position()
		var mouse_delta = drag_start_mouse_pos - current_mouse_pos
		
		# Scale delta by zoom so dragging feels consistent at all zoom levels
		global_position = drag_start_camera_pos + (mouse_delta / zoom.x)
		
		_clamp_position()
		get_viewport().set_input_as_handled()

func _process(delta: float) -> void:
	# 1. Apply Smooth Zoom
	zoom = zoom.lerp(target_zoom, zoom_smoothing * delta)
	
	# 2. Handle Keyboard/Edge Movement (Only if not dragging)
	if not is_dragging:
		_handle_keyboard_movement(delta)

	# 3. Clamp Bounds
	_clamp_position()

func _handle_keyboard_movement(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	var viewport_size = get_viewport().get_visible_rect().size
	var mouse_pos = get_viewport().get_mouse_position()
	
	# WASD Movement
	if enable_wasd_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Edge Panning
	if enable_edge_panning:
		# Check X axis
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
			
		# Check Y axis
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply Movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		# Adjust speed based on zoom level (faster when zoomed out)
		var zoom_multiplier = 1.0 / zoom.x
		global_position += movement_vector * camera_speed * zoom_multiplier * delta

func _zoom_in() -> void:
	target_zoom += Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _zoom_out() -> void:
	target_zoom -= Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _clamp_zoom() -> void:
	target_zoom.x = clamp(target_zoom.x, min_zoom, max_zoom)
	target_zoom.y = clamp(target_zoom.y, min_zoom, max_zoom)

func _clamp_position() -> void:
	if bounds_enabled:
		global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.end.x)
		global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.end.y)

--- SCRIPT: res://player/RTSController.gd ---
# res://player/RTSController.gd
#
# --- REFACTORED ---
# This script is now decoupled from input.
# It listens for clean signals from the EventBus
# (which are fired by SelectionBox.gd).
# It also correctly cleans up dead units.
#
# --- ADDED: Control Group & Formation Drag Support ---

extends Node
class_name RTSController

var selected_units: Array[BaseUnit] = []
var controllable_units: Array[BaseUnit] = []
var current_formation: SquadFormation.FormationType = SquadFormation.FormationType.LINE

# --- NEW: Control Group Storage ---
# We store the unit instance IDs, not the nodes themselves,
# to more safely handle units dying.
var control_groups: Dictionary = {
	1: [], 2: [], 3: [], 4: [], 5: [],
	6: [], 7: [], 8: [], 9: [], 0: [],
}
# ---------------------------------


func _ready() -> void:
	# Connect to the clean signals from our new EventBus/SelectionBox
	EventBus.select_command.connect(_on_select_command)
	EventBus.move_command.connect(_on_move_command)
	EventBus.attack_command.connect(_on_attack_command)
	# --- THIS LINE IS REQUIRED FOR DRAG-FORMATIONS ---
	EventBus.formation_move_command.connect(_on_formation_move_command)

func _input(event: InputEvent) -> void:
	# --- MODIFIED: Handle Control Group logic ---
	if event is InputEventKey and event.is_pressed():
		var key = event.keycode
		
		# --- THIS IS THE FIX (Line 41) ---
		# We use the 'ctrl_pressed' *property*
		var is_ctrl_pressed: bool = event.ctrl_pressed
		# ---------------------------------

		# Handle number keys 0-9
		if key >= KEY_0 and key <= KEY_9:
			var num = key - KEY_0 # Get the integer 0-9
			
			if is_ctrl_pressed:
				# Ctrl + Number: SET group
				_set_control_group(num)
				get_viewport().set_input_as_handled()
			else:
				# Number: SELECT group
				_select_control_group(num)
				get_viewport().set_input_as_handled()
		# -------------------------------------------
		else:
			# Handle non-number-key inputs (like formations)
			match event.keycode:
				# --- MOVED to F-Keys to avoid conflict ---
				KEY_F1:
					current_formation = SquadFormation.FormationType.LINE
					print("Formation: LINE")
				KEY_F2:
					current_formation = SquadFormation.FormationType.COLUMN
					print("Formation: COLUMN")
				KEY_F3:
					current_formation = SquadFormation.FormationType.WEDGE
					print("Formation: WEDGE")
				KEY_F4:
					current_formation = SquadFormation.FormationType.BOX
					print("Formation: BOX")
				# -----------------------------------------

# --- PUBLIC API ---

func add_unit_to_group(unit: Node2D) -> void:
	# Verify the unit is a BaseUnit (which has 'destroyed' signal)
	if not unit is BaseUnit:
		push_error("RTSController: Tried to add unit '%s' that doesn't extend BaseUnit." % unit.name)
		return
		
	if unit in controllable_units:
		return

	controllable_units.append(unit)
	
	# --- THIS IS THE DEAD UNIT CRASH FIX ---
	# Connect to this unit's 'destroyed' signal.
	# When it's destroyed, we'll clean it up.
	# We use CONNECT_DEFERRED to avoid race conditions.
	if unit.has_signal("destroyed"):
		unit.destroyed.connect(remove_unit.bind(unit), CONNECT_DEFERRED)
	else:
		# This check is vital. Our old debug units will fail this.
		push_warning("Unit %s does not have 'destroyed' signal!" % unit.name)

func remove_unit(unit: BaseUnit) -> void:
	"""Removes a unit from tracking. Called by the unit's 'destroyed' signal."""
	print("RTSController: Unit %s was destroyed/removed." % unit.name)
	
	if unit in selected_units:
		selected_units.erase(unit)
		if is_instance_valid(unit):
			# set_selected is a function on BaseUnit
			unit.set_selected(false)
			
	if unit in controllable_units:
		controllable_units.erase(unit)
		
	# --- NEW: Clean up control groups ---
	var unit_id = unit.get_instance_id()
	for group_num in control_groups:
		if control_groups[group_num].has(unit_id):
			control_groups[group_num].erase(unit_id)
	# ------------------------------------
		
	# Check if this was the last unit
	if controllable_units.is_empty():
		print("RTSController: All units are gone.")

# --- EVENTBUS HANDLERS ---

func _on_select_command(select_rect: Rect2, is_box_select: bool) -> void:
	_clear_selection()
	
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	if not main_camera:
		push_error("RTSController: No Camera2D found to perform selection.")
		return
	
	if is_box_select:
		# Box select - convert screen rect to world coordinates instead
		# This is more reliable than converting world to screen for each unit
		var camera_pos = main_camera.get_screen_center_position()
		var camera_zoom = main_camera.zoom
		var viewport_size = get_viewport().get_visible_rect().size
		
		# Convert screen rectangle to world coordinates
		var world_rect_min = camera_pos - (viewport_size / (2.0 * camera_zoom)) + (select_rect.position / camera_zoom)
		var world_rect_max = world_rect_min + (select_rect.size / camera_zoom)
		var world_rect = Rect2(world_rect_min, world_rect_max - world_rect_min)
		
		for unit in controllable_units:
			if world_rect.has_point(unit.global_position):
				selected_units.append(unit)
				unit.set_selected(true)
	else:
		# Single select (find closest unit to the click)
		# We must get the world position from the camera
		var click_world_pos := main_camera.get_global_mouse_position()
		var closest_unit: BaseUnit = null
		var min_dist_sq = INF
		
		for unit in controllable_units:
			var dist_sq = unit.global_position.distance_squared_to(click_world_pos)
			# 40px click radius
			if dist_sq < min_dist_sq and dist_sq < (40 * 40): 
				min_dist_sq = dist_sq
				closest_unit = unit
				
		if closest_unit:
			selected_units.append(closest_unit)
			closest_unit.set_selected(true)

func _on_move_command(target_position: Vector2) -> void:
	if selected_units.is_empty():
		return
	
	if selected_units.size() == 1:
		# Single unit - direct movement
		selected_units[0].command_move_to(target_position)
	else:
		# Multiple units - use formation
		var units_as_node2d: Array[Node2D] = []
		for unit in selected_units:
			units_as_node2d.append(unit)
		
		var formation = SquadFormation.new(units_as_node2d)
		formation.formation_type = current_formation
		formation.unit_spacing = 45.0
		
		# --- MODIFIED: Calculate direction ---
		# For a simple right-click, we just face the destination
		var group_center = formation.formation_center
		var direction = (target_position - group_center).normalized()
		if direction.is_zero_approx():
			direction = Vector2.DOWN # Default fallback
		formation.move_to_position(target_position, direction)
		# -------------------------------------

# --- THIS IS THE NEW FUNCTION FOR DRAG-FORMATIONS ---
func _on_formation_move_command(target_position: Vector2, direction_vector: Vector2):
	# --- DEBUG ---
	print("==================================================")
	print("RTSController: Received formation_move_command.")
	print("  -> Target Center: %s, Direction: %s" % [target_position, direction_vector])
	# --- END DEBUG ---
	
	if selected_units.is_empty():
		return

	if selected_units.size() == 1:
		# Single unit - just move, ignore direction
		selected_units[0].command_move_to(target_position)
	else:
		# Multiple units - use formation
		var units_as_node2d: Array[Node2D] = []
		for unit in selected_units:
			units_as_node2d.append(unit)
		
		var formation = SquadFormation.new(units_as_node2d)
		formation.formation_type = current_formation
		formation.unit_spacing = 45.0
		# Pass the specific direction from the drag
		formation.move_to_position(target_position, direction_vector)
# ---------------------------------------------

func _on_attack_command(target_node: Node2D) -> void:
	if selected_units.is_empty():
		return
		
	for unit in selected_units:
		unit.command_attack(target_node)

func _clear_selection() -> void:
	for unit in selected_units:
		# Check if it's valid, it might have been destroyed
		if is_instance_valid(unit):
			unit.set_selected(false)
	selected_units.clear()

# --- Control Group Functions ---

func _set_control_group(num: int) -> void:
	print("Setting control group %d" % num)
	# Clear the old group
	control_groups[num].clear()
	# Add all currently selected units by their ID
	for unit in selected_units:
		control_groups[num].append(unit.get_instance_id())

func _select_control_group(num: int) -> void:
	print("Selecting control group %d" % num)
	_clear_selection()
	
	var new_group_ids = control_groups[num]
	var still_valid_ids = []
	
	for unit_id in new_group_ids:
		var unit = instance_from_id(unit_id) as BaseUnit
		
		# Check if unit is still alive and controllable
		if is_instance_valid(unit) and unit in controllable_units:
			selected_units.append(unit)
			unit.set_selected(true)
			still_valid_ids.append(unit_id)
		
	# Prune any dead units from the control group
	control_groups[num] = still_valid_ids

	# --- Optional: Camera Pan ---
	# If we selected units, pan camera to them
	if not selected_units.is_empty():
		var center_pos = Vector2.ZERO
		for unit in selected_units:
			center_pos += unit.global_position
		center_pos /= selected_units.size()
		
		# Pan camera (assuming camera is RTSCamera)
		var camera = get_viewport().get_camera_2d()
		if camera and camera is RTSCamera:
			# Simple jump, as RTSCamera has no tween_pan_to method
			camera.global_position = center_pos
		elif camera:
			camera.global_position = center_pos

--- SCRIPT: res://scenes/components/AttackAI.gd ---
# res://scenes/components/AttackAI.gd
#
# A modular AI component that provides attack behavior for any unit or building.
# Simply instance this as a child of units or buildings that need to attack.
class_name AttackAI
extends Node2D

## Emitted when this AI starts attacking a target
signal attack_started(target: Node2D)
## Emitted when this AI stops attacking (no targets)
signal attack_stopped()
## Emitted just before firing a projectile or dealing damage
signal about_to_attack(target: Node2D, damage: int)

# --- NEW: AI Behavior Modes ---
enum AI_Mode {
	DEFAULT,         # Default behavior: Prioritize closest enemy units, then buildings.
	DEFENSIVE_SIEGE  # Enemy AI behavior: Prioritize Great Hall, then closest building.
}
@export var ai_mode: AI_Mode = AI_Mode.DEFAULT
@export var great_hall_los_range: float = 600.0 # Arbitrary LOS value
# --- END NEW ---

# Configuration - set these from the parent
@export var attack_damage: int = 10
@export var attack_range: float = 200.0
@export var attack_speed: float = 1.0  # attacks per second
@export var projectile_scene: PackedScene

var target_collision_mask: int = 0
var projectile_speed: float = 400.0

# Node references
@onready var detection_area: Area2D = $DetectionArea
@onready var attack_timer: Timer = $AttackTimer

# AI state
var parent_node: Node2D
var current_target: Node2D = null
var targets_in_range: Array[Node2D] = []
var is_attacking: bool = false

func _ready() -> void:
	parent_node = get_parent() as Node2D
	if not parent_node:
		push_error("AttackAI: Parent must be a Node2D")
		return
	
	_setup_ai()

func _setup_ai() -> void:
	"""Initialize the AI components"""
	if detection_area:
		detection_area.collision_layer = 0
		detection_area.collision_mask = target_collision_mask
		
		if detection_area.get_child(0) is CollisionShape2D:
			var detection_shape = detection_area.get_child(0) as CollisionShape2D
			if detection_shape.shape is CircleShape2D:
				(detection_shape.shape as CircleShape2D).radius = attack_range
		
		detection_area.body_entered.connect(_on_target_entered)
		detection_area.area_entered.connect(_on_target_entered)
		detection_area.body_exited.connect(_on_target_exited)
		detection_area.area_exited.connect(_on_target_exited)
	
	if attack_timer:
		if attack_speed > 0:
			attack_timer.wait_time = 1.0 / attack_speed
		else:
			attack_timer.wait_time = 999.0
	
		attack_timer.timeout.connect(_on_attack_timer_timeout)

func configure_from_data(data_resource) -> void:
	if not data_resource:
		return
	
	if "attack_damage" in data_resource:
		attack_damage = data_resource.attack_damage
	if "attack_range" in data_resource:
		attack_range = data_resource.attack_range
	if "attack_speed" in data_resource:
		attack_speed = data_resource.attack_speed
	if "projectile_scene" in data_resource:
		projectile_scene = data_resource.projectile_scene
	if "projectile_speed" in data_resource:
		projectile_speed = data_resource.projectile_speed
	
	if attack_timer:
		if attack_speed > 0:
			attack_timer.wait_time = 1.0 / attack_speed
		else:
			attack_timer.wait_time = 999.0
	
	if detection_area and detection_area.get_child(0) is CollisionShape2D:
		var detection_shape = detection_area.get_child(0) as CollisionShape2D
		if detection_shape.shape is CircleShape2D:
			(detection_shape.shape as CircleShape2D).radius = attack_range

func set_target_mask(mask: int) -> void:
	target_collision_mask = mask
	if detection_area:
		detection_area.collision_mask = mask

func force_target(target: Node2D) -> void:
	if not is_instance_valid(target):
		return
	
	if target is BaseBuilding and target.has_node("Hitbox"):
		current_target = target.get_node("Hitbox")
	else:
		current_target = target
	
	if current_target not in targets_in_range:
		targets_in_range.append(current_target)
	
	_start_attacking()

func stop_attacking() -> void:
	current_target = null
	_stop_attacking()

func _on_target_entered(body: Node2D) -> void:
	if body not in targets_in_range:
		targets_in_range.append(body)
	
	if not current_target and targets_in_range.size() > 0:
		_select_target()

func _on_target_exited(body: Node2D) -> void:
	targets_in_range.erase(body)
	
	if current_target == body:
		current_target = null
		_select_target()

func _select_target() -> void:
	"""Selects a target based on the current AI_Mode."""
	match ai_mode:
		AI_Mode.DEFAULT:
			_select_target_default()
		AI_Mode.DEFENSIVE_SIEGE:
			_select_target_defensive_siege()

func _select_target_default() -> void:
	"""Select the closest valid target, prioritizing units over buildings."""
	if targets_in_range.is_empty():
		current_target = null
		_stop_attacking()
		return
	
	var unit_targets: Array[Node2D] = []
	var building_targets: Array[Node2D] = []

	for target in targets_in_range:
		if not is_instance_valid(target):
			targets_in_range.erase(target)
			continue
		
		# --- FIX: Enforce Collision Mask ---
		# This prevents Friendly Fire. We check if the target matches our allowed mask.
		if not (target.collision_layer & target_collision_mask):
			continue
		# -----------------------------------

		# Determine type based on layer
		# Units: Layer 2 (Player) or Layer 3 (Enemy) -> Binary 0110 -> 6
		if target.collision_layer & 6: 
			unit_targets.append(target)
		# Buildings: Layer 1 (Player) or Layer 4 (Enemy) -> Binary 1001 -> 9
		elif target.collision_layer & 9: 
			building_targets.append(target)

	var closest_target: Node2D = null
	var closest_distance: float = INF
	
	# Prioritize Units over Buildings
	if not unit_targets.is_empty():
		for target in unit_targets:
			var distance = parent_node.global_position.distance_to(target.global_position)
			if distance < closest_distance:
				closest_distance = distance
				closest_target = target
	elif not building_targets.is_empty():
		for target in building_targets:
			var distance = parent_node.global_position.distance_to(target.global_position)
			if distance < closest_distance:
				closest_distance = distance
				closest_target = target
	
	current_target = closest_target
	
	if current_target:
		_start_attacking()
	else:
		_stop_attacking()

# --- NEW SIEGE AI LOGIC ---
func _select_target_defensive_siege() -> void:
	"""
	Enemy AI logic:
	1. Prioritize the Great Hall if it's in LOS.
	2. Otherwise, attack the closest building.
	"""
	# Only access FSM if parent is a BaseUnit
	var unit_parent = parent_node as BaseUnit
	if not is_instance_valid(unit_parent) or not unit_parent.fsm:
		_stop_attacking()
		return

	# 1. Check for Great Hall (Priority 1)
	var great_hall = unit_parent.fsm.objective_target
	if is_instance_valid(great_hall):
		var hall_pos = great_hall.global_position
		var distance_to_hall = parent_node.global_position.distance_to(hall_pos)
		
		if distance_to_hall <= great_hall_los_range:
			# If Hall is in LOS, override all other targets
			current_target = great_hall
			_start_attacking()
			return # Found our priority target

	# 2. Find Closest Building (Priority 2)
	var closest_building: Node2D = null
	var closest_distance: float = INF
	
	for target in targets_in_range:
		if not is_instance_valid(target):
			targets_in_range.erase(target)
			continue
			
		# --- FIX: Enforce Collision Mask ---
		if not (target.collision_layer & target_collision_mask):
			continue
		# -----------------------------------
		
		# Target Layer 1 (Player Buildings) or Layer 4 (Enemy Buildings)
		if target.collision_layer & 9: 
			var distance = parent_node.global_position.distance_to(target.global_position)
			if distance < closest_distance:
				closest_distance = distance
				closest_building = target
	
	current_target = closest_building
	
	if current_target:
		_start_attacking()
	else:
		# No buildings in range, stop attacking
		_stop_attacking()
# --- END NEW ---

func _start_attacking() -> void:
	if not is_attacking:
		is_attacking = true
		attack_started.emit(current_target)
	
	# Fire the first attack immediately instead of waiting for the timer.
	_on_attack_timer_timeout()
	
	if attack_timer and attack_timer.is_stopped():
		attack_timer.start()

func _stop_attacking() -> void:
	if is_attacking:
		is_attacking = false
		attack_stopped.emit()
	
	if attack_timer:
		attack_timer.stop()

func _on_attack_timer_timeout() -> void:
	"""Called when the attack timer fires"""
	if not current_target:
		# If our target is null, we should stop attacking
		_stop_attacking()
		return
	
	# Verify target is still valid and in range
	if not is_instance_valid(current_target):
		_select_target()
		return
	
	var distance_to_target = parent_node.global_position.distance_to(current_target.global_position)
	
	# Added a +10 buffer to prevent units from stopping if target is *just* at the edge
	if distance_to_target > attack_range + 10.0:
		_stop_attacking() 
		return
	
	# Emit signal before attacking
	about_to_attack.emit(current_target, attack_damage)
	
	# Attack the target
	if projectile_scene:
		# RANGED: Spawn projectile
		_spawn_projectile(current_target.global_position)
	else:
		# MELEE: Direct damage
		var target_to_damage = current_target
		
		if target_to_damage.name == "Hitbox":
			target_to_damage = target_to_damage.get_parent()
		
		if target_to_damage.has_method("take_damage"):
			# Pass parent_node as the attacker for retaliation logic
			target_to_damage.take_damage(attack_damage, parent_node)

func _spawn_projectile(target_position_world: Vector2) -> void:
	"""Spawn a projectile towards the target position"""
	if not projectile_scene:
		push_warning("AttackAI: No projectile scene assigned. Cannot fire.")
		return
	
	# 1. Get a projectile from the pool
	var projectile: Projectile = ProjectilePoolManager.get_projectile()
	if not projectile:
		push_error("AttackAI: ProjectilePoolManager failed to provide a projectile.")
		return
	
	# We set our new 'firer' variable instead of the 'owner' property
	projectile.firer = parent_node
	
	projectile.setup(
		parent_node.global_position,  # start position
		target_position_world,        # target position
		attack_damage,                # damage
		projectile_speed,             # Use configured speed
		target_collision_mask         # what to hit
	)

--- SCRIPT: res://scenes/effects/Projectile.gd ---
# res://scenes/effects/Projectile.gd
#
# A simple, straight-line projectile that applies damage on impact.
# Now integrated with ProjectilePoolManager.

class_name Projectile
extends Area2D

# Projectile properties
var damage: int = 0
var speed: float = 400.0
var direction: Vector2 = Vector2.RIGHT
var firer: Node2D = null

@onready var lifetime_timer: Timer = $LifetimeTimer

func _ready() -> void:
	area_entered.connect(_on_area_entered)
	body_entered.connect(_on_body_entered)
	
	# We must defer setting physics properties
	set_deferred("monitoring", true)
	
	self.monitorable = false
	lifetime_timer.timeout.connect(_on_lifetime_timeout)

func _physics_process(delta: float) -> void:
	global_position += direction * speed * delta

func setup(start_position: Vector2, target_position: Vector2, projectile_damage: int, projectile_speed: float = 400.0, collision_mask: int = 0) -> void:
	# This function now "wakes up" the projectile
	global_position = start_position
	direction = (target_position - start_position).normalized()
	damage = projectile_damage
	speed = projectile_speed
	self.collision_mask = collision_mask
	
	if direction != Vector2.ZERO:
		rotation = direction.angle()
	
	# Activate the projectile
	show()
	set_physics_process(true)
	set_deferred("monitoring", true)
	lifetime_timer.start()

func return_to_pool() -> void:
	"""
	Deactivates the projectile and hides it, returning it to the pool.
	"""
	hide()
	set_physics_process(false)
	set_deferred("monitoring", false)
	lifetime_timer.stop()
	global_position = Vector2(-1000, -1000) # Move it off-screen

func _on_area_entered(area: Area2D) -> void:
	"""Called when this Area2D detects a 'monitorable' Area2D (like our Hitbox)."""
	
	if area.collision_layer & self.collision_mask:
		var parent_body = area.get_parent()
		if parent_body and parent_body.has_method("take_damage"):
			
			if is_instance_valid(firer):
				parent_body.take_damage(damage, firer)
			else:
				parent_body.take_damage(damage, null)
			
			ProjectilePoolManager.return_projectile(self)
		else:
			push_warning("Projectile hit non-damagable Area: '%s'." % area.name)

func _on_body_entered(body: Node2D) -> void:
	"""Called when this Area2D detects a 'monitorable' PhysicsBody (like a unit)."""
	
	if not body is CollisionObject2D:
		return
	
	if body.collision_layer & self.collision_mask:
		if body.has_method("take_damage"):
			if is_instance_valid(firer):
				body.take_damage(damage, firer)
			else:
				body.take_damage(damage, null)
		
		ProjectilePoolManager.return_projectile(self)

func _on_lifetime_timeout() -> void:
	ProjectilePoolManager.return_projectile(self)

--- SCRIPT: res://scenes/missions/RaidMission.gd ---
# res://scenes/missions/RaidMission.gd
# Raid Mission Controller for Phase 3
#
# --- REFACTORED ---
# Fixed initialization order: 'data' is now assigned BEFORE add_child().
# This ensures BaseUnit._ready() has the data needed to create the FSM.
# Fixed race condition in enemy spawning by using fsm_ready signal.
# ------------------
extends Node2D

# --- Exported Mission Configuration ---
@export var enemy_base_data: SettlementData
@export var default_enemy_base_path: String = "res://data/settlements/monastery_base.tres"
@export_group("Enemy Base Presets")
@export var available_enemy_bases: Array[String] = [
	"res://data/settlements/monastery_base.tres",
	"res://data/settlements/fortress_base.tres"
]
@export var player_spawn_formation: Dictionary = {"units_per_row": 5, "spacing": 40}
@export var mission_difficulty: float = 1.0
@export var allow_retreat: bool = true

# --- NEW: Defensive Mission ---
@export var is_defensive_mission: bool = false
@export var enemy_spawn_position: NodePath
# -----------------------------

# --- Node References ---
@onready var player_spawn_pos: Marker2D = $PlayerStartPosition
@onready var rts_controller: RTSController = $RTSController
@onready var grid_manager: Node = $GridManager
@onready var building_container: Node2D = $BuildingContainer
@onready var objective_manager: RaidObjectiveManager = $RaidObjectiveManager

# --- State Variables ---
var objective_building: BaseBuilding = null
var enemy_units: Array[BaseUnit] = []


func _ready() -> void:
	if DynastyManager.is_defensive_raid:
		self.is_defensive_mission = true
		objective_manager.is_defensive_mission = true
		DynastyManager.is_defensive_raid = false
	
	EventBus.settlement_loaded.connect(_on_settlement_ready_for_mission)
	
	if not SettlementManager.has_current_settlement():
		print("RaidMission: No current settlement - loading test settlement")
		_load_test_settlement()
		call_deferred("initialize_mission")
	else:
		print("RaidMission: Settlement already loaded - initializing mission")
		call_deferred("initialize_mission")

func _exit_tree() -> void:
	SettlementManager.unregister_active_scene_nodes()
	
	if EventBus.is_connected("settlement_loaded", _on_settlement_ready_for_mission):
		EventBus.settlement_loaded.disconnect(_on_settlement_ready_for_mission)


func _load_test_settlement() -> void:
	var test_settlement_path = "res://data/settlements/home_base_fixed.tres"
	var test_settlement = load(test_settlement_path) as SettlementData
	
	if test_settlement:
		print("RaidMission: Loading test settlement: %s" % test_settlement_path)
		SettlementManager.load_settlement(test_settlement)
	else:
		push_error("RaidMission: Failed to load test settlement from %s" % test_settlement_path)

func _on_settlement_ready_for_mission(_settlement_data: SettlementData) -> void:
	if not is_instance_valid(objective_manager.rts_controller): 
		print("RaidMission: Settlement loaded - initializing mission")
		initialize_mission()


func initialize_mission() -> void:
	print("RaidMission starting...")
	
	if rts_controller == null or objective_manager == null:
		push_error("RaidMission: Critical error! Nodes missing.")
		get_tree().quit()
		return
	
	if not is_instance_valid(grid_manager) or not "astar_grid" in grid_manager:
		push_error("RaidMission: GridManager node is missing or invalid!")
		return
	var local_astar_grid = grid_manager.astar_grid
	SettlementManager.register_active_scene_nodes(local_astar_grid, building_container)
	
	if is_defensive_mission:
		_load_player_base_for_defense()
		_spawn_player_garrison()
		_spawn_enemy_wave()
	else:
		if not enemy_base_data:
			enemy_base_data = load(default_enemy_base_path)
			if not enemy_base_data:
				push_error("Could not load enemy base data.")
				return
		_load_enemy_base()
		_spawn_player_garrison()
	
	if is_instance_valid(objective_building):
		objective_manager.initialize(rts_controller, objective_building, building_container, enemy_units)
	else:
		push_error("RaidMission: Could not find Objective Building (Great Hall)!")


# --- MODIFIED: Updated to load PENDING buildings too ---
func _load_player_base_for_defense() -> void:
	print("Loading PLAYER base for defense...")
	var settlement = SettlementManager.current_settlement
	if not settlement:
		push_error("Defensive Mission: Cannot load player base.")
		return
	
	# 1. Load Completed Buildings
	_spawn_building_list(settlement.placed_buildings, false)
	
	# 2. Load Blueprints (New Fix)
	_spawn_building_list(settlement.pending_construction_buildings, true)
	
	_update_astar_grid_for_base(settlement.placed_buildings)
func _spawn_building_list(list: Array, is_blueprint: bool) -> void:
	for building_entry in list:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if not building_data or not building_data.scene_to_spawn:
			continue
		
		var building_instance: BaseBuilding = building_data.scene_to_spawn.instantiate()
		building_instance.name = building_data.display_name + "_Player"
		building_instance.data = building_data
		
		var world_pos_top_left: Vector2 = Vector2(grid_pos) * grid_manager.cell_size
		var building_footprint_size: Vector2 = Vector2(building_data.grid_size) * grid_manager.cell_size
		var building_center_offset: Vector2 = building_footprint_size / 2.0
		building_instance.global_position = world_pos_top_left + building_center_offset
		
		building_instance.set_collision_layer(1)
		building_instance.set_collision_mask(0) 
		
		if building_data.display_name.to_lower().contains("hall"):
			objective_building = building_instance
			
		building_container.add_child(building_instance)
		
		# Apply Blueprint State if needed
		if is_blueprint:
			building_instance.set_state(BaseBuilding.BuildingState.BLUEPRINT)

func _load_enemy_base() -> void:
	print("Loading ENEMY base for offense...")
	if not enemy_base_data:
		return
	
	for building_entry in enemy_base_data.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if not building_data or not building_data.scene_to_spawn:
			continue
		
		var building_instance: BaseBuilding = building_data.scene_to_spawn.instantiate()
		building_instance.name = building_data.display_name + "_Enemy"
		
		if "data" in building_instance:
			building_instance.data = building_data
		
		var world_pos_top_left: Vector2 = Vector2(grid_pos) * grid_manager.cell_size
		var building_footprint_size: Vector2 = Vector2(building_data.grid_size) * grid_manager.cell_size
		var building_center_offset: Vector2 = building_footprint_size / 2.0
		building_instance.global_position = world_pos_top_left + building_center_offset
		
		building_instance.add_to_group("enemy_buildings")
		building_instance.set_collision_layer(1 << 3) # Layer 4
		building_instance.set_collision_mask(0)
		
		if building_data.display_name.to_lower().contains("hall"):
			objective_building = building_instance
		
		if building_instance.has_signal("building_destroyed"):
			building_instance.building_destroyed.connect(_on_enemy_building_destroyed_grid_clear)
		
		building_container.add_child(building_instance)
	
	_update_astar_grid_for_base(enemy_base_data.placed_buildings)

func _update_astar_grid_for_base(placed_buildings: Array) -> void:
	for building_entry in placed_buildings:
		var building_data: BuildingData = load(building_entry["resource_path"])
		if not building_data: continue
		
		if building_data.blocks_pathfinding:
			var grid_size: Vector2i = building_data.grid_size
			var grid_pos: Vector2i = building_entry["grid_position"]
			
			for x in range(grid_size.x):
				for y in range(grid_size.y):
					var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
					SettlementManager.set_astar_point_solid(cell_pos, true)
	
	if is_instance_valid(grid_manager) and is_instance_valid(grid_manager.astar_grid):
		grid_manager.astar_grid.update()


func _spawn_player_garrison() -> void:
	if not SettlementManager.current_settlement:
		_spawn_test_units() 
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	if garrison.is_empty():
		if not is_defensive_mission:
			objective_manager.call_deferred("_check_loss_condition")
		return
	
	var units_per_row: int = player_spawn_formation.get("units_per_row", 5)
	var spacing: float = player_spawn_formation.get("spacing", 40.0)
	var current_row: int = 0
	var current_col: int = 0
	
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if not unit_data or not unit_data.scene_to_spawn:
			continue
		
		for i in range(unit_count):
			var unit_instance: Node2D = unit_data.scene_to_spawn.instantiate()
			
			if not unit_instance is BaseUnit:
				continue
				
			unit_instance.name = unit_data.display_name + "_" + str(i)
			if "data" in unit_instance:
				unit_instance.data = unit_data
			
			var spawn_pos: Vector2 = player_spawn_pos.global_position
			
			if is_defensive_mission and is_instance_valid(objective_building):
				spawn_pos = objective_building.global_position + Vector2(100, 100)
			
			spawn_pos.x += current_col * spacing
			spawn_pos.y += current_row * spacing
			unit_instance.global_position = spawn_pos
			
			unit_instance.add_to_group("player_units")
			rts_controller.add_unit_to_group(unit_instance)
			add_child(unit_instance)
			
			current_col += 1
			if current_col >= units_per_row:
				current_col = 0
				current_row += 1


func _spawn_enemy_wave() -> void:
	print("=== SPAWNING ENEMY WAVE ===")
	var enemy_spawner = get_node_or_null(enemy_spawn_position)
	if not is_instance_valid(enemy_spawner):
		push_error("Defensive Mission: Invalid or missing 'Enemy Spawn Position' node!")
		return
		
	var enemy_data_path = "res://data/units/EnemyVikingRaider_Data.tres"
	var enemy_data: UnitData = load(enemy_data_path)
	if not enemy_data or not enemy_data.scene_to_spawn:
		push_error("Failed to load enemy unit data: %s" % enemy_data_path)
		return

	var enemy_count = 5
	for i in range(enemy_count):
		
		# 1. Instantiate
		var enemy_node = enemy_data.scene_to_spawn.instantiate()
		
		# 2. Cast to BaseUnit and Set Data BEFORE add_child
		var enemy_unit = enemy_node as BaseUnit
		if not enemy_unit:
			push_error("Spawned enemy node is not a BaseUnit!")
			enemy_node.queue_free()
			continue
		
		# Assign data before adding to tree
		enemy_unit.data = enemy_data
		enemy_unit.name = enemy_data.display_name + "_Enemy_" + str(i)
		# Use bit-shift for clarity (Layer 3 = 1 << 2, value 4)
		enemy_unit.collision_layer = 1 << 2 
		
		# 3. Add to Tree (Triggers _ready(), which now finds 'data')
		add_child(enemy_node) 
		
		var spawn_pos = enemy_spawner.global_position + Vector2(i * 40, 0)
		enemy_unit.global_position = spawn_pos
		
		enemy_unit.add_to_group("enemy_units")
		enemy_units.append(enemy_unit)
		
		# 4. Connect to the FSM ready signal
		# We DO NOT access FSM or AttackAI here. We wait for the signal.
		if is_instance_valid(objective_building):
			enemy_unit.fsm_ready.connect(_on_enemy_fsm_ready.bind(objective_building))
	
	print("Spawned %d enemy raiders." % enemy_count)

# --- UPDATED SIGNAL HANDLER: Handles ALL post-spawn configuration ---
func _on_enemy_fsm_ready(enemy_unit: BaseUnit, target: BaseBuilding) -> void:
	"""
	Called by the enemy unit when its FSM is fully set up via _deferred_setup.
	This ensures we only issue the command when the unit is ready to receive it.
	"""
	if not is_instance_valid(target) or not is_instance_valid(enemy_unit):
		return

	# 1. Configure the AttackAI mode (NOW SAFE)
	if enemy_unit.attack_ai:
		enemy_unit.attack_ai.ai_mode = AttackAI.AI_Mode.DEFENSIVE_SIEGE
		
	# 2. Command Attack (NOW SAFE)
	if enemy_unit.fsm:
		enemy_unit.fsm.command_attack(target)
	else:
		push_error("Enemy unit %s FSM is still null after signal! FSM setup failed." % enemy_unit.name)

func _spawn_test_units() -> void:
	# (Test unit spawning code omitted for brevity - unchanged)
	pass

func _on_enemy_building_destroyed_grid_clear(building: BaseBuilding) -> void:
	_clear_building_from_pathfinding_grid(building)

func _clear_building_from_pathfinding_grid(building: BaseBuilding) -> void:
	if not building.data or not is_instance_valid(grid_manager):
		return
		
	var cell_size = grid_manager.cell_size
	var size_in_pixels = Vector2(building.data.grid_size) * cell_size
	var top_left_pos = building.global_position - (size_in_pixels / 2.0)
	var grid_pos = Vector2i(top_left_pos / cell_size)
	var grid_size = building.data.grid_size
	
	for x in range(grid_size.x):
		for y in range(grid_size.y):
			var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
			SettlementManager.set_astar_point_solid(cell_pos, false)
	
	if is_instance_valid(grid_manager.astar_grid):
		grid_manager.astar_grid.update()

--- SCRIPT: res://scenes/missions/RaidObjectiveManager.gd ---
# res://scenes/missions/RaidObjectiveManager.gd
#
# Manages all mission-specific logic for a raid, including
# loot, win conditions, and loss conditions.
# Decoupled from RaidMission.gd (which is now just a level loader).
extends Node
class_name RaidObjectiveManager
# --- Mission Configuration ---
# These will be set in the Inspector on this node.
@export var victory_bonus_loot: Dictionary = {"gold": 200}
# MODIFIED: This is no longer used, but we leave it to avoid breaking the .tscn file
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
@export var is_defensive_mission: bool = false

# --- Internal State ---
var raid_loot: RaidLootData
var rts_controller: RTSController
var objective_building: BaseBuilding
var building_container: Node2D
var enemy_units: Array[BaseUnit] = [] # For defensive win condition
var is_initialized: bool = false
var mission_over: bool = false

# --- NEW: Preload the theme ---
const UI_THEME = preload("res://ui/themes/VikingDynastyTheme.tres")

func _ready() -> void:
	raid_loot = RaidLootData.new()

func initialize(
	p_rts_controller: RTSController, 
	p_objective_building: BaseBuilding, 
	p_building_container: Node2D,
	p_enemy_units: Array[BaseUnit] = []
) -> void:
	"""
	Called by RaidMission.gd after the level is loaded
	to pass in all necessary scene references.
	"""
	# Prevent multiple initialization
	if is_initialized:
		print("RaidObjectiveManager: Already initialized, skipping.")
		return
		
	self.rts_controller = p_rts_controller
	self.objective_building = p_objective_building
	self.building_container = p_building_container
	self.enemy_units = p_enemy_units
	
	if not is_instance_valid(rts_controller) or \
	   not is_instance_valid(objective_building) or \
	   not is_instance_valid(building_container):
		push_error("RaidObjectiveManager: Failed to initialize. Received invalid node references.")
		return
	
	print("RaidObjectiveManager: Initialized and tracking objectives.")
	
	# Connect to all necessary signals
	if not is_defensive_mission:
		_connect_to_building_signals()
		
	_setup_win_loss_conditions()
	
	# Mark as initialized
	is_initialized = true


func _connect_to_building_signals() -> void:
	# Connect to the Great Hall for the win condition
	if objective_building.has_signal("building_destroyed"):
		if not objective_building.building_destroyed.is_connected(_on_enemy_hall_destroyed):
			objective_building.building_destroyed.connect(_on_enemy_hall_destroyed)
	
	# Connect to *all* buildings for loot collection
	for building in building_container.get_children():
		if building is BaseBuilding and building.has_signal("building_destroyed"):
			if not building.building_destroyed.is_connected(_on_enemy_building_destroyed_for_loot):
				building.building_destroyed.connect(_on_enemy_building_destroyed_for_loot)

# --- Objective Logic ---

func _on_enemy_building_destroyed_for_loot(building: BaseBuilding) -> void:
	"""Called when any enemy building is destroyed - collect loot."""
	if mission_over: return
	
	var building_data = building.data as BuildingData
	
	if raid_loot and building_data:
		raid_loot.add_loot_from_building(building_data)
		print("RaidObjectiveManager: Building destroyed: %s | %s" % [building_data.display_name, raid_loot.get_loot_summary()])
	
	# Count remaining buildings for mission tracking
	var remaining_buildings = building_container.get_children().size() - 1 # -1 for the one just destroyed

func _setup_win_loss_conditions() -> void:
	"""Setup win/loss condition monitoring"""
	if is_defensive_mission:
		# --- DEFENSIVE MISSION ---
		# Lose if Hall is destroyed
		if objective_building.has_signal("building_destroyed"):
			objective_building.building_destroyed.connect(_on_player_hall_destroyed)
		# Win if all enemies are defeated
		_check_defensive_win_condition()
	else:
		# --- OFFENSIVE MISSION ---
		# Lose if all player units are destroyed
		_check_loss_condition()
		# Win if Enemy Hall is destroyed (handled by _connect_to_building_signals)


func _check_loss_condition() -> void:
	"""Check if all player units are destroyed (OFFENSIVE loss condition)"""
	if mission_over: return
	await get_tree().create_timer(1.0).timeout
	
	var remaining_units = 0
	if is_instance_valid(rts_controller):
		remaining_units = rts_controller.controllable_units.size()
	
	if remaining_units == 0:
		_on_mission_failed("All units destroyed")
		return # Stop the loop
	
	# Continue checking if mission is still active
	_check_loss_condition()

# --- NEW: Defensive Win/Loss ---
func _check_defensive_win_condition() -> void:
	"""Check if all enemy units are destroyed (DEFENSIVE win condition)"""
	if mission_over: return
	await get_tree().create_timer(1.0).timeout

	# Prune dead/invalid units
	enemy_units = enemy_units.filter(func(unit): return is_instance_valid(unit))
	var remaining_enemies = enemy_units.size()
	
	if remaining_enemies == 0:
		_on_defensive_mission_won()
		return # Stop the loop

	# Continue checking
	_check_defensive_win_condition()

func _on_player_hall_destroyed(_building: BaseBuilding) -> void:
	"""LOSE CONDITION for defensive mission"""
	if mission_over: return
	_on_mission_failed("Your Great Hall was destroyed!")

func _on_defensive_mission_won() -> void:
	"""WIN CONDITION for defensive mission"""
	if mission_over: return
	mission_over = true
	print("Mission Success! All attackers defeated.")
	
	# --- NEW: Show Victory Popup ---
	_show_victory_message("VICTORY!", "All attackers have been defeated.")
	
	# No loot for defense, just return home
	await get_tree().create_timer(3.0).timeout
	EventBus.scene_change_requested.emit("settlement")
# --- END NEW ---

func _on_mission_failed(reason: String) -> void:
	"""Called when player fails the mission"""
	if mission_over: return
	mission_over = true
	
	print("Mission Failed! %s" % reason)
	
	_show_failure_message(reason)
	
	await get_tree().create_timer(3.0).timeout
	
	EventBus.scene_change_requested.emit("settlement")


func _show_failure_message(reason: String) -> void:
	"""Display the mission failure message to the player"""
	var failure_popup = Control.new()
	failure_popup.name = "FailurePopup"
	failure_popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	# --- FIX: Apply theme ---
	failure_popup.theme = UI_THEME
	
	var bg_panel = Panel.new()
	bg_panel.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg_panel.modulate = Color(0, 0, 0, 0.7)
	failure_popup.add_child(bg_panel)
	
	var message_container = VBoxContainer.new()
	message_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	
	var failure_label = Label.new()
	failure_label.text = "DEFENSE FAILED!"
	failure_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	# --- FIX: Add theme overrides for visibility ---
	failure_label.add_theme_font_size_override("font_size", 32)
	failure_label.add_theme_color_override("font_color", Color.CRIMSON)
	message_container.add_child(failure_label)
	
	var subtitle_label = Label.new()
	subtitle_label.text = reason
	subtitle_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(subtitle_label)
	
	var return_label = Label.new()
	return_label.text = "Returning to settlement..."
	return_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(return_label)
	
	failure_popup.add_child(message_container)
	
	# --- FIX: Add to CanvasLayer, not scene root ---
	var canvas = get_parent().get_node_or_null("CanvasLayer")
	if canvas:
		canvas.add_child(failure_popup)
	else:
		push_error("RaidObjectiveManager: Could not find 'CanvasLayer' to show failure message!")
		get_tree().current_scene.add_child(failure_popup) # Fallback

# --- NEW: VICTORY POPUP FUNCTION ---
func _show_victory_message(title: String, subtitle: String) -> void:
	"""Displays a generic victory message popup."""
	var victory_popup = Control.new()
	victory_popup.name = "VictoryPopup"
	victory_popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	# --- FIX: Apply theme ---
	victory_popup.theme = UI_THEME
	
	var bg_panel = Panel.new()
	bg_panel.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg_panel.modulate = Color(0.1, 0.1, 0.1, 0.7) # Darker background
	victory_popup.add_child(bg_panel)
	
	var message_container = VBoxContainer.new()
	message_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	
	var title_label = Label.new()
	title_label.text = title
	# --- FIX: Add theme overrides for visibility ---
	title_label.add_theme_font_size_override("font_size", 32)
	title_label.add_theme_color_override("font_color", Color.GOLD)
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(title_label)
	
	var subtitle_label = Label.new()
	subtitle_label.text = subtitle
	subtitle_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(subtitle_label)
	
	var return_label = Label.new()
	return_label.text = "Returning to settlement..."
	return_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(return_label)
	
	victory_popup.add_child(message_container)
	
	# --- FIX: Add to CanvasLayer, not scene root ---
	var canvas = get_parent().get_node_or_null("CanvasLayer")
	if canvas:
		canvas.add_child(victory_popup)
	else:
		push_error("RaidObjectiveManager: Could not find 'CanvasLayer' to show victory message!")
		get_tree().current_scene.add_child(victory_popup) # Fallback
# --- END NEW ---

# res://scenes/missions/RaidObjectiveManager.gd

func _on_enemy_hall_destroyed(_building: BaseBuilding = null) -> void:
	"""Called when the enemy's Great Hall is destroyed (OFFENSIVE win condition)"""
	if mission_over: return
	mission_over = true
	
	print("RaidObjectiveManager: Enemy Hall destroyed! Preparing report...")
	
	# 1. Gather Raw Stats
	# We only track what physically happened (gold picked up, win state)
	var raw_gold = raid_loot.collected_loot.get("gold", 0)
	
	# 2. Package the Result
	var result = {
		"outcome": "victory",
		"gold_looted": raw_gold,
		# We can add more stats here later (e.g. "units_lost")
	}
	
	# 3. Send to Courier
	DynastyManager.pending_raid_result = result
	
	# 4. Show simple feedback and leave
	# (We purposely do NOT show the full loot popup here anymore)
	_show_victory_message("VICTORY!", "The settlement lies in ruins.\nReturning to ships...")
	
	await get_tree().create_timer(3.0).timeout
	EventBus.scene_change_requested.emit("settlement")

--- SCRIPT: res://scenes/world_map/MacroCamera.gd ---
# res://scenes/world_map/MacroCamera.gd
# Upgraded with Zoom and Edge Panning
extends Camera2D 
class_name MacroCamera

# --- Movement Settings ---
@export_group("Movement")
@export var camera_speed: float = 500.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_keyboard_movement: bool = true

# --- Zoom Settings ---
@export_group("Zoom")
@export var min_zoom: float = 0.5  # Far away
@export var max_zoom: float = 2.0  # Close up
@export var zoom_speed: float = 0.1
@export var zoom_smoothing: float = 10.0

# --- Bounds Settings ---
@export_group("Bounds")
@export var bounds_enabled: bool = true 
@export var bounds_rect: Rect2 = Rect2(0, 0, 1920, 1080)

# Internal State
var target_zoom: Vector2 = Vector2.ONE
var is_dragging: bool = false
var drag_start_pos: Vector2

func _ready() -> void:
	target_zoom = zoom
	make_current()

func snap_to_target(target_position: Vector2) -> void:
	global_position = target_position
	_clamp_camera_to_bounds()

func _process(delta: float) -> void:
	# 1. Apply Smooth Zoom
	zoom = zoom.lerp(target_zoom, zoom_smoothing * delta)
	
	# 2. Handle Movement
	if not is_dragging:
		_handle_movement(delta)
		
	# 3. Clamp Bounds
	_clamp_camera_to_bounds()

func _handle_movement(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	var viewport_size = get_viewport().get_visible_rect().size
	var mouse_pos = get_viewport().get_mouse_position()
	
	# Keyboard Movement
	if enable_keyboard_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Edge Panning
	if enable_edge_panning:
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply Movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		# Adjust speed based on zoom (move faster when zoomed out)
		var zoom_multiplier = 1.0 / zoom.x
		global_position += movement_vector * camera_speed * zoom_multiplier * delta

func _unhandled_input(event: InputEvent) -> void:
	# Zoom Controls
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			_zoom_in()
			get_viewport().set_input_as_handled()
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			_zoom_out()
			get_viewport().set_input_as_handled()
			
		# Middle-Mouse Drag
		elif event.button_index == MOUSE_BUTTON_MIDDLE:
			if event.is_pressed():
				is_dragging = true
				drag_start_pos = get_global_mouse_position() - global_position
				get_viewport().set_input_as_handled()
			else:
				is_dragging = false
				get_viewport().set_input_as_handled()
				
	elif event is InputEventMouseMotion and is_dragging:
		global_position = get_global_mouse_position() - drag_start_pos
		_clamp_camera_to_bounds()
		get_viewport().set_input_as_handled()

func _zoom_in() -> void:
	target_zoom += Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _zoom_out() -> void:
	target_zoom -= Vector2(zoom_speed, zoom_speed)
	_clamp_zoom()

func _clamp_zoom() -> void:
	target_zoom.x = clamp(target_zoom.x, min_zoom, max_zoom)
	target_zoom.y = clamp(target_zoom.y, min_zoom, max_zoom)

func _clamp_camera_to_bounds() -> void:
	if bounds_enabled:
		# Adjust bounds based on zoom to prevent seeing outside the map
		var view_size = get_viewport_rect().size / zoom
		var min_x = bounds_rect.position.x + view_size.x / 2
		var max_x = bounds_rect.end.x - view_size.x / 2
		var min_y = bounds_rect.position.y + view_size.y / 2
		var max_y = bounds_rect.end.y - view_size.y / 2
		
		# Only clamp if the map is larger than the view
		if min_x < max_x: global_position.x = clamp(global_position.x, min_x, max_x)
		if min_y < max_y: global_position.y = clamp(global_position.y, min_y, max_y)

--- SCRIPT: res://scenes/world_map/MacroMap.gd ---
# res://scenes/world_map/MacroMap.gd
extends Node2D

# --- Scene Configuration ---
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
@export var end_year_popup_scene: PackedScene
@export var enemy_raid_chance: float = 0.25

# --- Phase 5.1: Geography Anchor ---
@export var player_home_marker_path: NodePath = "PlayerHomeMarker"
@onready var player_home_marker: Marker2D = get_node_or_null(player_home_marker_path)
@onready var macro_camera: MacroCamera = $MacroCamera

# --- UI References ---
@onready var authority_label: Label = $UI/JarlInfo/VBoxContainer/AuthorityLabel
@onready var renown_label: Label = $UI/JarlInfo/VBoxContainer/RenownLabel
@onready var end_year_button: Button = $UI/Actions/VBoxContainer/EndYearButton
@onready var region_info_panel: PanelContainer = $UI/RegionInfo
@onready var region_name_label: Label = $UI/RegionInfo/VBoxContainer/RegionNameLabel
# Old button is deprecated/hidden, we use the container now:
@onready var launch_raid_button: Button = $UI/RegionInfo/VBoxContainer/LaunchRaidButton 
@onready var target_list_container: VBoxContainer = $UI/RegionInfo/VBoxContainer/TargetList

@onready var settlement_button: Button = $UI/Actions/VBoxContainer/SettlementButton
@onready var subjugate_button: Button = $UI/RegionInfo/VBoxContainer/SubjugateButton
@onready var dynasty_button: Button = $UI/Actions/VBoxContainer/DynastyButton
@onready var dynasty_ui: DynastyUI = $UI/Dynasty_UI
@onready var marry_button: Button = $UI/RegionInfo/VBoxContainer/MarryButton
@onready var tooltip: PanelContainer = $UI/Tooltip
@onready var tooltip_label: Label = $UI/Tooltip/Label
@onready var regions_container: Node2D = $Regions

# --- Systems & State ---
const WORK_ASSIGNMENT_SCENE_PATH = "res://ui/WorkAssignment_UI.tscn"
var work_assignment_ui: CanvasLayer
var idle_warning_dialog: ConfirmationDialog
var end_year_popup: PanelContainer

# Persistence
const SAVE_PATH = "user://campaign_map.tres"
var map_state: MapState

# Selection State
var selected_region_data: WorldRegionData
var selected_region_node: Region = null
var calculated_subjugate_cost: int = 5 
var current_attrition_risk: float = 0.0

# Visual Constants
const SAFE_COLOR := Color(0.2, 0.8, 0.2, 0.1)   # Green
const RISK_COLOR := Color(1.0, 0.6, 0.0, 0.1)   # Orange
const HIGH_RISK_COLOR := Color(1.0, 0.0, 0.0, 0.1) # Red

func _ready() -> void:
	# 1. Anchor & Camera Setup
	if not player_home_marker:
		push_error("MacroMap: 'PlayerHomeMarker' missing! Distance calculations will fail.")
	else:
		print("MacroMap: Geography Anchor set at %s" % player_home_marker.global_position)
		if macro_camera:
			print("MacroMap: Snapping camera to home.")
			macro_camera.snap_to_target(player_home_marker.global_position)

	# 2. Data Initialization
	_initialize_world_data()
	
	# 3. UI & Signal Connections
	if launch_raid_button: launch_raid_button.hide() # Hide old button
	
	DynastyManager.jarl_stats_updated.connect(_update_jarl_ui)
	# Redraw map circles when stats (range) change
	DynastyManager.jarl_stats_updated.connect(func(_j): queue_redraw())
	
	for region in regions_container.get_children():
		if region is Region:
			region.region_hovered.connect(_on_region_hovered)
			region.region_exited.connect(_on_region_exited)
			region.region_selected.connect(_on_region_selected)
			
	settlement_button.pressed.connect(_on_settlement_pressed)
	subjugate_button.pressed.connect(_on_subjugate_pressed)
	end_year_button.pressed.connect(_on_end_year_pressed)
	dynasty_button.pressed.connect(_on_dynasty_pressed)
	marry_button.pressed.connect(_on_marry_pressed)
	
	# 4. Popups Setup
	if end_year_popup_scene:
		end_year_popup = end_year_popup_scene.instantiate()
		add_child(end_year_popup) 
		if end_year_popup.has_signal("collect_button_pressed"):
			end_year_popup.collect_button_pressed.connect(_on_end_year_payout_collected)
		end_year_popup.hide()
	
	if ResourceLoader.exists(WORK_ASSIGNMENT_SCENE_PATH):
		var scene = load(WORK_ASSIGNMENT_SCENE_PATH)
		if scene:
			work_assignment_ui = scene.instantiate()
			add_child(work_assignment_ui)
			if work_assignment_ui.has_signal("assignments_confirmed"):
				work_assignment_ui.assignments_confirmed.connect(_on_worker_assignments_confirmed)
	
	idle_warning_dialog = ConfirmationDialog.new()
	idle_warning_dialog.title = "Idle Villagers"
	idle_warning_dialog.ok_button_text = "End Year Anyway"
	idle_warning_dialog.cancel_button_text = "Manage Workers"
	idle_warning_dialog.confirmed.connect(_start_end_year_sequence)
	idle_warning_dialog.canceled.connect(_on_open_worker_ui) 
	add_child(idle_warning_dialog)
	
	EventBus.event_system_finished.connect(_on_event_system_finished)
	
	# 5. Final Cleanup
	_update_jarl_ui(DynastyManager.get_current_jarl())
	region_info_panel.hide()
	tooltip.hide()
	queue_redraw()

# --- Phase 5.3: Visualizing Range ---
func _draw() -> void:
	if not player_home_marker: return
	var jarl = DynastyManager.get_current_jarl()
	if not jarl: return
	
	var safe_r = jarl.get_safe_range()
	
	# Draw Safe Zone
	draw_circle(player_home_marker.position, safe_r, SAFE_COLOR)
	draw_arc(player_home_marker.position, safe_r, 0, TAU, 64, Color.GREEN, 2.0)
	
	# Draw Visual "Risk" Gradient
	draw_arc(player_home_marker.position, safe_r + 500, 0, TAU, 64, Color.RED, 1.0)

# --- Phase 5.2: Data Generation & Persistence ---
func _initialize_world_data() -> void:
	if ResourceLoader.exists(SAVE_PATH):
		print("MacroMap: Loading existing campaign state...")
		map_state = load(SAVE_PATH)
		_apply_state_to_regions()
	else:
		print("MacroMap: New Campaign detected. Generating world...")
		map_state = MapState.new()
		_generate_new_world()
		_save_map_state()

func _generate_new_world() -> void:
	if not player_home_marker: return
	var jarl = DynastyManager.get_current_jarl()
	if not jarl: return
	
	var safe_range = jarl.get_safe_range()
	
	for region in regions_container.get_children():
		if not region is Region: continue
		
		# FIX: Use polygon center for accurate distance
		var dist = player_home_marker.global_position.distance_to(region.get_global_center())
		var tier = 1
		
		if dist <= safe_range:
			tier = 1
		elif dist <= safe_range * 1.5:
			tier = 2
		else:
			tier = 3
			
		var data = MapDataGenerator.generate_region_data(tier)
		region.data = data
		map_state.region_data_map[region.name] = data
		
		print("Generated %s (Tier %d) at dist %.0f" % [data.display_name, tier, dist])

func _apply_state_to_regions() -> void:
	for region in regions_container.get_children():
		if not region is Region: continue
		if map_state.region_data_map.has(region.name):
			region.data = map_state.region_data_map[region.name]

func _save_map_state() -> void:
	var error = ResourceSaver.save(map_state, SAVE_PATH)
	if error != OK:
		push_error("MacroMap: Failed to save map state!")

# --- Phase 5.4: Selection & UI Logic ---
func _on_region_selected(data: WorldRegionData) -> void:
	# --- REFACTOR: Use the helper to clear previous selection first ---
	# But we must NOT clear the data yet, or we lose the reference we just clicked.
	# So we only clear the visual node state here.
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	# ------------------------------------------------------------------
	
	# Find new node
	for region in regions_container.get_children():
		if region is Region and region.data == data:
			selected_region_node = region
			selected_region_node.is_selected = true
			selected_region_node.set_visual_state(false)
			break
			
	selected_region_data = data

func _populate_raid_targets(data: WorldRegionData, is_conquered: bool, is_allied: bool) -> void:
	# Clear list
	for child in target_list_container.get_children():
		child.queue_free()
		
	if is_conquered:
		var label = Label.new()
		label.text = "Region Conquered"
		label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		target_list_container.add_child(label)
		return

	if data.raid_targets.is_empty():
		var label = Label.new()
		label.text = "No Valid Targets"
		target_list_container.add_child(label)
		return

	# Generate Buttons
	for target in data.raid_targets:
		var btn = Button.new()
		btn.alignment = HORIZONTAL_ALIGNMENT_LEFT
		
		var risk_text = ""
		var btn_color = Color.WHITE
		
		if current_attrition_risk > 0.0:
			risk_text = " (%d%% Risk)" % int(current_attrition_risk * 100)
			if current_attrition_risk > 0.3:
				btn_color = Color(1.0, 0.4, 0.4) # Reddish
			else:
				btn_color = Color(1.0, 0.9, 0.4) # Yellowish
		
		if is_allied:
			btn.text = "%s (Allied)" % target.display_name
			btn.disabled = true
		else:
			btn.text = "%s - Cost: %d Auth%s" % [target.display_name, target.raid_cost_authority, risk_text]
			btn.modulate = btn_color
			
			var can_afford = DynastyManager.can_spend_authority(target.raid_cost_authority)
			if not can_afford:
				btn.disabled = true
				btn.text += " (Low Auth)"
			else:
				btn.pressed.connect(_initiate_raid.bind(target))
		
		target_list_container.add_child(btn)

func _initiate_raid(target: RaidTargetData) -> void:
	# 1. Apply Attrition Gamble
	if current_attrition_risk > 0.0:
		_apply_attrition(current_attrition_risk)
	
	# 2. Set Data
	DynastyManager.set_current_raid_target(target.settlement_data)
	
	# 3. Set Difficulty Context (Phase 5.5)
	DynastyManager.current_raid_difficulty = target.difficulty_rating
	
	# 4. Spend Cost & Launch
	DynastyManager.spend_authority(target.raid_cost_authority)
	print("Launching raid on: %s (Diff: %d)" % [target.display_name, target.difficulty_rating])
	EventBus.scene_change_requested.emit("raid_mission")

func _apply_attrition(risk_chance: float) -> void:
	if not SettlementManager.has_current_settlement(): return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	var units_lost = 0
	var units_to_remove: Array[String] = []
	
	print("Applying Attrition Risk: %.2f" % risk_chance)
	
	for unit_path in garrison.keys():
		var count = garrison[unit_path]
		var surviving_count = 0
		for i in range(count):
			if randf() > risk_chance:
				surviving_count += 1
			else:
				units_lost += 1
		
		if surviving_count > 0:
			garrison[unit_path] = surviving_count
		else:
			units_to_remove.append(unit_path)
			
	for path in units_to_remove:
		garrison.erase(path)
		
	SettlementManager.save_settlement()
	if units_lost > 0:
		print("ATTRITION: Lost %d units to the sea!" % units_lost)

func _update_diplomacy_buttons(data: WorldRegionData, is_conquered: bool, is_allied: bool) -> void:
	if is_conquered:
		subjugate_button.disabled = true
		subjugate_button.text = "Subjugate (Conquered)"
		marry_button.disabled = true
		marry_button.text = "Marry (Conquered)"
		return

	# Subjugate
	var base_cost = 5
	var ally_mod = 0
	if is_allied: ally_mod = 2
	calculated_subjugate_cost = max(1, base_cost - ally_mod)
	
	subjugate_button.text = "Subjugate (Cost: %d)" % calculated_subjugate_cost
	subjugate_button.disabled = not DynastyManager.can_spend_authority(calculated_subjugate_cost)
	
	# Marry
	marry_button.text = "Marry (Cost: 1 Heir)"
	var has_heir = DynastyManager.get_available_heir_count() > 0
	marry_button.disabled = is_allied or not has_heir
	if is_allied: marry_button.text = "Marry (Allied)"

# --- Standard Action Handlers ---
func _on_subjugate_pressed() -> void:
	if not selected_region_data: return
	var success = DynastyManager.spend_authority(calculated_subjugate_cost)
	if success:
		DynastyManager.add_conquered_region(selected_region_data.resource_path)
		var jarl = DynastyManager.get_current_jarl()
		jarl.legitimacy = min(100, jarl.legitimacy + 5) 
		DynastyManager.jarl_stats_updated.emit(jarl) 
		print("Region %s successfully subjugated." % selected_region_data.display_name)
		_on_region_selected(selected_region_data)

func _on_marry_pressed() -> void:
	if not selected_region_data: return
	var success = DynastyManager.marry_heir_for_alliance(selected_region_data.resource_path)
	if success: 
		print("Alliance with %s successful." % selected_region_data.display_name)
		_on_region_selected(selected_region_data)

func _on_settlement_pressed() -> void: EventBus.scene_change_requested.emit("settlement")
func _on_dynasty_pressed() -> void: if dynasty_ui: dynasty_ui.show()

# --- End Year Logic ---
func _on_end_year_pressed() -> void:
	if not SettlementManager.has_current_settlement(): return
	var settlement = SettlementManager.current_settlement
	var total_pop = settlement.population_total
	var assigned_pop = 0
	for key in settlement.worker_assignments:
		assigned_pop += settlement.worker_assignments[key]
	
	if (total_pop - assigned_pop) > 0:
		idle_warning_dialog.dialog_text = "You have %d idle villagers.\nEnd year anyway?" % (total_pop - assigned_pop)
		idle_warning_dialog.popup_centered()
	else:
		_start_end_year_sequence()

func _start_end_year_sequence() -> void:
	if not is_instance_valid(end_year_popup):
		_process_end_year_logic({})
		return
	var payout = SettlementManager.calculate_payout()
	end_year_popup.display_payout(payout, "End of Year Report")

func _on_end_year_payout_collected(payout: Dictionary) -> void:
	_process_end_year_logic(payout)

func _process_end_year_logic(payout: Dictionary) -> void:
	if not payout.is_empty(): SettlementManager.deposit_resources(payout)
	DynastyManager.end_year()
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	selected_region_data = null
	selected_region_node = null
	region_info_panel.hide()

func _on_event_system_finished() -> void:
	if randf() < enemy_raid_chance:
		print("--- ENEMY RAID TRIGGERED ---")
		DynastyManager.is_defensive_raid = true
		EventBus.scene_change_requested.emit("raid_mission")
	else:
		print("No enemy raid this year.")
		EventBus.scene_change_requested.emit("settlement")

func _update_jarl_ui(jarl: JarlData) -> void:
	if not jarl: return
	authority_label.text = "Authority: %d / %d" % [jarl.current_authority, jarl.max_authority]
	renown_label.text = "Renown: %d" % jarl.renown
	if selected_region_data: _on_region_selected(selected_region_data)

func _on_region_hovered(data: WorldRegionData, _screen_position: Vector2) -> void:
	tooltip_label.text = data.display_name
	var mouse_pos = get_viewport().get_mouse_position()
	tooltip.position = mouse_pos + Vector2(15, 15)
	tooltip.show()

func _on_region_exited() -> void: tooltip.hide()
func _on_open_worker_ui() -> void:
	if work_assignment_ui and SettlementManager.current_settlement:
		work_assignment_ui.setup(SettlementManager.current_settlement)
func _on_worker_assignments_confirmed(assignments: Dictionary) -> void:
	if SettlementManager.current_settlement:
		SettlementManager.current_settlement.worker_assignments = assignments
		SettlementManager.save_settlement()
func _unhandled_input(event: InputEvent) -> void:
	# Detect clicks on the "Ocean" (Background)
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			_deselect_current_region()

func _deselect_current_region() -> void:
	# 1. Reset Visuals on the old node
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	
	# 2. Clear Selection Data
	selected_region_node = null
	selected_region_data = null
	
	# 3. Hide the Side Panel
	if region_info_panel:
		region_info_panel.hide()

--- SCRIPT: res://scenes/world_map/Region.gd ---
# res://scenes/world_map/Region.gd
class_name Region
extends Area2D

# Signals to notify the MacroMap controller
signal region_hovered(data: WorldRegionData, screen_position: Vector2)
signal region_exited()
signal region_selected(data: WorldRegionData)

# The data resource representing this province
@export var data: WorldRegionData

# Reference to the visual polygon (Source of Truth)
@onready var highlight_poly: Polygon2D = get_node_or_null("HighlightPoly")
# Reference to the collision polygon (Target)
@onready var collision_poly: CollisionPolygon2D = get_node_or_null("CollisionPolygon2D")

# Visual Settings
var default_color: Color = Color(0, 0, 0, 0)       # Invisible
var hover_color: Color = Color(1.0, 1.0, 1.0, 0.2) # Faint White
var selected_color: Color = Color(1.0, 0.9, 0.2, 0.4) # Yellowish

var is_selected: bool = false

func _ready() -> void:
	# 1. Data Validation
	if not data:
		push_error("Region node '%s' has no WorldRegionData assigned!" % name)
		return
	
	# 2. Node Validation & Sync
	if not highlight_poly:
		push_error("Region '%s' is missing 'HighlightPoly' (Polygon2D)." % name)
		return
		
	if not collision_poly:
		# Optional: Create it if it doesn't exist
		collision_poly = CollisionPolygon2D.new()
		collision_poly.name = "CollisionPolygon2D"
		add_child(collision_poly)
		print("Region '%s': Created missing CollisionPolygon2D." % name)
	
	# --- THE MAGIC FIX ---
	_sync_collision_shape()
	# ---------------------
	
	# 3. Input Connection
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	input_event.connect(_on_input_event)
	
	# 4. Initial State
	set_visual_state(false)

func _sync_collision_shape() -> void:
	"""Copies points from the Visual Polygon to the Collision Polygon."""
	if not highlight_poly: return
	
	if highlight_poly.polygon.is_empty():
		push_warning("Region '%s': HighlightPoly has no points!" % name)
		return
	
	# --- DEBUG PRINT ---
	print("Region: Syncing shape for '%s' (%d points)..." % [name, highlight_poly.polygon.size()])
	# -------------------

	# Copy the points over
	collision_poly.polygon = highlight_poly.polygon
	
	# Ensure positions match
	collision_poly.position = highlight_poly.position
	collision_poly.scale = highlight_poly.scale

func set_visual_state(is_hovered: bool) -> void:
	if not highlight_poly: return
		
	var target_color: Color
	
	if is_selected:
		target_color = selected_color
		highlight_poly.visible = true
	elif is_hovered:
		target_color = hover_color
		highlight_poly.visible = true
	else:
		target_color = default_color
		highlight_poly.visible = false 
		
	var tween = create_tween()
	tween.tween_property(highlight_poly, "color", target_color, 0.1)

# --- Signal Handlers ---

func _on_mouse_entered() -> void:
	if not is_selected:
		set_visual_state(true)
	emit_signal("region_hovered", data, get_global_mouse_position())

func _on_mouse_exited() -> void:
	if not is_selected:
		set_visual_state(false)
	emit_signal("region_exited")

func _on_input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		is_selected = true
		set_visual_state(true)
		emit_signal("region_selected", data)
		get_viewport().set_input_as_handled()
func get_global_center() -> Vector2:
	# If no poly, fallback to node position
	if not collision_poly or collision_poly.polygon.is_empty():
		return global_position
		
	var sum_points = Vector2.ZERO
	for point in collision_poly.polygon:
		sum_points += point
		
	var local_center = sum_points / collision_poly.polygon.size()
	
	# Apply the node's transform (position/scale/rotation) to get world coords
	return to_global(local_center)
	

--- SCRIPT: res://scenes/world_map/WorldMap_Stub.gd ---
# res://scenes/world_map/WorldMap_Stub.gd
# World map interface for selecting raid targets
# GDD Ref: Phase 3 Task 6

extends Control

# --- MODIFIED: Use String paths, not PackedScene ---
## The main raid mission scene to load (e.g., RaidMission.tscn)
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"

## The scene to return to (e.g., SettlementBridge.tscn)
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
# --- END MODIFICATION ---

@onready var raid_monastery_button: Button = $ButtonContainer/RaidMonasteryButton
@onready var back_button: Button = $ButtonContainer/BackButton

func _ready() -> void:
	raid_monastery_button.pressed.connect(_on_raid_monastery_pressed)
	back_button.pressed.connect(_on_back_pressed)
	
	# Validate that we can actually raid (have settlement & units)
	_validate_raid_capability()

func _validate_raid_capability() -> void:
	"""Ensure the player can actually start a raid"""
	if not SettlementManager.current_settlement:
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Settlement Loaded"
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Units Available"
		return
	
	raid_monastery_button.disabled = false

func _on_raid_monastery_pressed() -> void:
	"""Launch the raid mission"""
	print("Starting raid on nearby monastery...")
	
	# Additional validation before starting raid
	if not SettlementManager.current_settlement:
		push_error("Cannot start raid: No settlement loaded")
		return
	
	# --- MODIFIED: Emit signal ---
	if not raid_mission_scene_path.is_empty():
		EventBus.scene_change_requested.emit(raid_mission_scene_path)
	else:
		push_error("WorldMap_Stub: raid_mission_scene_path is not set! Cannot start raid.")
	# --- END MODIFICATION ---

func _on_back_pressed() -> void:
	"""Return to the settlement"""
	print("Returning to settlement...")
	
	# --- MODIFIED: Emit signal ---
	if not settlement_bridge_scene_path.is_empty():
		EventBus.scene_change_requested.emit(settlement_bridge_scene_path)
	else:
		push_error("WorldMap_Stub: settlement_bridge_scene_path is not set! Cannot return.")
	# --- END MODIFICATION ---

--- SCRIPT: res://scripts/ai/SentryAI.gd ---
# res://scripts/ai/SentryAI.gd
# Simple Sentry AI for enemy defenders in Phase 3
# GDD Ref: Phase 3 - Enemy MVP (Simple Sentry AI)

extends Node2D
class_name SentryAI

@export var detection_radius: float = 80.0
@export var attack_damage: int = 25
@export var attack_cooldown: float = 1.5

var detection_area: Area2D
var attack_timer: float = 0.0
var current_target: Node2D = null

signal enemy_detected(target: Node2D)
signal attack_executed(target: Node2D, damage: int)

func _ready() -> void:
	_setup_detection_area()
	set_process(true)

func _setup_detection_area() -> void:
	"""Create detection area for sentry"""
	detection_area = Area2D.new()
	detection_area.name = "DetectionArea"
	
	var collision_shape = CollisionShape2D.new()
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = detection_radius
	collision_shape.shape = circle_shape
	
	detection_area.add_child(collision_shape)
	add_child(detection_area)
	
	# Connect signals
	detection_area.body_entered.connect(_on_body_entered)
	detection_area.body_exited.connect(_on_body_exited)
	
	# Set collision mask to detect player units (layer 1)
	detection_area.collision_mask = 1

func _process(delta: float) -> void:
	# Update attack timer
	if attack_timer > 0:
		attack_timer -= delta
	
	# Check for and attack valid targets
	if current_target and is_instance_valid(current_target):
		if attack_timer <= 0:
			_attack_target(current_target)
			attack_timer = attack_cooldown
	else:
		current_target = null

func _on_body_entered(body: Node2D) -> void:
	"""Handle detection of player units"""
	if body.is_in_group("player_units") and not current_target:
		current_target = body
		enemy_detected.emit(body)
		# Removed print: print("%s detected enemy: %s" % [get_parent().name, body.name])

func _on_body_exited(body: Node2D) -> void:
	"""Handle player units leaving detection range"""
	if body == current_target:
		current_target = null
		# Removed print: print("%s lost target: %s" % [get_parent().name, body.name])

func _attack_target(target: Node2D) -> void:
	"""Execute attack on target"""
	if not target or not is_instance_valid(target):
		return
	
	# Check if target is still in range
	var distance = global_position.distance_to(target.global_position)
	if distance > detection_radius:
		current_target = null
		return
	
	# Removed print: print("%s attacking %s for %d damage" % [get_parent().name, target.name, attack_damage])
	
	# Apply damage if target has take_damage method
	if target.has_method("take_damage"):
		target.take_damage(attack_damage)
	elif target.has_method("receive_damage"):
		target.receive_damage(attack_damage)
	else:
		# Fallback: just remove the target for demo purposes
		push_warning("SentryAI: Target %s has no damage method; removing for demo purposes." % target.name)
		target.queue_free()
	
	attack_executed.emit(target, attack_damage)

func get_detection_radius() -> float:
	"""Get current detection radius"""
	return detection_radius

func set_detection_radius(new_radius: float) -> void:
	"""Update detection radius"""
	detection_radius = new_radius
	if detection_area:
		var collision_shape = detection_area.get_child(0) as CollisionShape2D
		if collision_shape and collision_shape.shape is CircleShape2D:
			collision_shape.shape.radius = detection_radius

func is_actively_defending() -> bool:
	"""Check if sentry is currently engaged with a target"""
	return current_target != null and is_instance_valid(current_target)

--- SCRIPT: res://scripts/ai/UnitAIConstants.gd ---
# res://scripts/ai/UnitAIConstants.gd
#
# Holds shared enums for the Unit AI system to break
# circular dependencies between BaseUnit and UnitFSM.
class_name UnitAIConstants

enum State { IDLE, MOVING, FORMATION_MOVING, ATTACKING }
enum Stance { DEFENSIVE, HOLD_POSITION }

--- SCRIPT: res://scripts/ai/UnitFSM.gd ---
# res://scripts/ai/UnitFSM.gd
# Refactored UnitFSM for Phase 3 RTS commands
# Now uses modular AttackAI component for attacking behavior
#
# --- REFACTORED ---
# Fixed Friendly Fire bug in _find_closest_blocking_building.
# Units now respect their collision mask when looking for obstructions.
# ------------------

class_name UnitFSM

# Enums are now defined in UnitAIConstants.gd to break circular dependency

# Unit References
var unit # Type hint removed to break circular dependency
var attack_ai: AttackAI  # Reference to the AttackAI component

# State Data
var current_state: UnitAIConstants.State = UnitAIConstants.State.IDLE
var stance: UnitAIConstants.Stance = UnitAIConstants.Stance.DEFENSIVE
var path: Array = []
var stuck_timer: float = 0.0

var los_range: float = 450.0 # Player unit "Line of Sight"

# Target Data
var target_position: Vector2 = Vector2.ZERO
var move_command_position: Vector2 = Vector2.ZERO

var objective_target: Node2D = null # The long-term goal (e.g., Great Hall)
var current_target: Node2D = null # The immediate threat (e.g., nearby unit)

func _init(p_unit, p_attack_ai: AttackAI) -> void:
	unit = p_unit
	attack_ai = p_attack_ai
	
	if attack_ai:
		attack_ai.attack_started.connect(_on_ai_attack_started)
		attack_ai.attack_stopped.connect(_on_ai_attack_stopped)

func change_state(new_state: UnitAIConstants.State) -> void:
	if current_state == new_state:
		return
	
	_exit_state(current_state)
	current_state = new_state
	
	if is_instance_valid(unit):
		unit.call("on_state_changed", current_state)
	
	_enter_state(current_state)

func _enter_state(state: UnitAIConstants.State) -> void:
	match state:
		UnitAIConstants.State.IDLE:
			unit.velocity = Vector2.ZERO
			
		UnitAIConstants.State.MOVING:
			_recalculate_path() 
		
		UnitAIConstants.State.FORMATION_MOVING:
			pass
		
		UnitAIConstants.State.ATTACKING:
			unit.velocity = Vector2.ZERO
			if attack_ai and is_instance_valid(current_target):
				attack_ai.force_target(current_target)

func _exit_state(state: UnitAIConstants.State) -> void:
	match state:
		UnitAIConstants.State.MOVING:
			path.clear()
			stuck_timer = 0.0
		UnitAIConstants.State.FORMATION_MOVING:
			path.clear()
		
		UnitAIConstants.State.ATTACKING:
			if attack_ai:
				attack_ai.stop_attacking()
			# Clear the *current* target, but not the objective
			current_target = null

func _recalculate_path() -> void:
	var target_node = current_target if is_instance_valid(current_target) else objective_target
	
	if not is_instance_valid(target_node):
		change_state(UnitAIConstants.State.IDLE)
		return
		
	target_position = target_node.global_position
	var allow_partial = is_instance_valid(target_node)
	
	path = SettlementManager.get_astar_path(unit.global_position, target_position, allow_partial)
	
	if path.is_empty():
		push_warning("Unit at %s failed to find a path to %s." % [unit.global_position, target_position])
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()

# --- Find Obstruction (FIXED) ---
func _find_closest_blocking_building() -> Node2D:
	var mission_node = unit.get_parent()
	if not is_instance_valid(mission_node) or not mission_node.has_node("BuildingContainer"):
		return null

	var building_container = mission_node.get_node("BuildingContainer")
	var buildings = building_container.get_children()
	
	var closest_building: Node2D = null
	var min_dist_sq = INF
	
	# Use the mask from AttackAI to determine what we are allowed to attack
	var valid_mask = 0
	if attack_ai:
		valid_mask = attack_ai.target_collision_mask
	
	var unit_pos = unit.global_position

	for building in buildings:
		if not building is BaseBuilding:
			continue
		
		# --- FIX: Check if this is a valid target ---
		# If the building's layer is not in our target mask, ignore it.
		# This prevents Player Units (Target Mask L3+L4) from attacking Player Buildings (L1)
		if not (building.collision_layer & valid_mask):
			continue
		# -------------------------------------------
			
		var dist_sq = unit_pos.distance_squared_to(building.global_position)
		if dist_sq < min_dist_sq:
			min_dist_sq = dist_sq
			closest_building = building
				
	return closest_building
# --- END FIX ---


# --- RTS Command Functions ---

func command_defensive_attack(attacker: Node2D) -> void:
	if not is_instance_valid(attacker):
		return
	
	if current_state == UnitAIConstants.State.ATTACKING and current_target == attacker:
		return
	
	current_target = attacker 
	change_state(UnitAIConstants.State.ATTACKING)

func command_attack_obstruction(target: Node2D) -> void:
	if not is_instance_valid(target):
		return
		
	current_target = target
	target_position = target.global_position
	
	var distance: float = unit.global_position.distance_to(target.global_position)
	
	if distance <= unit.data.attack_range:
		change_state(UnitAIConstants.State.ATTACKING)
	else:
		change_state(UnitAIConstants.State.MOVING)

func command_move_to_formation_pos(target_pos: Vector2) -> void:
	target_position = target_pos
	move_command_position = target_pos
	
	current_target = null 
	objective_target = null
	
	if attack_ai:
		attack_ai.stop_attacking()
	
	path.clear()
	path.append(target_pos)
	
	change_state(UnitAIConstants.State.FORMATION_MOVING)

func command_move_to(target_pos: Vector2) -> void:
	target_position = target_pos
	move_command_position = target_pos

	current_target = null
	objective_target = null
	
	if attack_ai:
		attack_ai.stop_attacking()
	
	change_state(UnitAIConstants.State.MOVING)

func command_attack(target: Node2D) -> void:
	if not is_instance_valid(target):
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		return
	
	objective_target = target
	current_target = target
	target_position = target.global_position
	
	var distance: float = unit.global_position.distance_to(target.global_position)
	
	if distance <= unit.data.attack_range:
		change_state(UnitAIConstants.State.ATTACKING)
	else:
		change_state(UnitAIConstants.State.MOVING)

# --- State Machine Update ---

func update(delta: float) -> void:
	match current_state:
		UnitAIConstants.State.IDLE:
			_idle_state(delta)
		UnitAIConstants.State.MOVING:
			_move_state(delta)
		UnitAIConstants.State.FORMATION_MOVING:
			_formation_move_state(delta)
		UnitAIConstants.State.ATTACKING:
			_attack_state(delta)

# --- State Logic Functions ---

func _idle_state(_delta: float) -> void:
	unit.velocity = Vector2.ZERO

func _formation_move_state(delta: float) -> void:
	if path.is_empty():
		change_state(UnitAIConstants.State.IDLE)
		return

	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	unit.move_and_slide()
	
	var arrival_radius: float = 8.0 
	if unit.global_position.distance_to(next_waypoint) < arrival_radius:
		path.pop_front()
		
		if path.is_empty():
			change_state(UnitAIConstants.State.IDLE)

func _move_state(delta: float) -> void:
	var target_node = current_target if is_instance_valid(current_target) else objective_target

	if not is_instance_valid(target_node):
		change_state(UnitAIConstants.State.IDLE)
		return
	
	var distance_to_target: float = unit.global_position.distance_to(target_node.global_position)
	if distance_to_target <= unit.data.attack_range:
		change_state(UnitAIConstants.State.ATTACKING)
		return
	
	if not path.is_empty():
		var next_waypoint: Vector2 = path[0]
		var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
		var velocity: Vector2 = direction * unit.data.move_speed
		
		unit.velocity = velocity
		unit.move_and_slide()
		
		var arrival_radius: float = 8.0 
		if unit.global_position.distance_to(next_waypoint) < arrival_radius:
			path.pop_front()
		
		# Stuck Timer Logic
		if unit.velocity.length_squared() < 1.0:
			stuck_timer += delta
			if stuck_timer > 1.5: # Stuck for 1.5 seconds
				var blocking_building = _find_closest_blocking_building()
				if is_instance_valid(blocking_building):
					# Found a VALID obstruction (Enemy)
					# push_warning("Unit is stuck. Attacking obstruction: %s" % blocking_building.name)
					command_attack_obstruction(blocking_building)
				else:
					# No valid obstruction (or it's friendly), so just give up
					change_state(UnitAIConstants.State.IDLE) 
				stuck_timer = 0.0 
		else:
			stuck_timer = 0.0 
			
		return
	
	# Path is empty logic
	if target_node == objective_target and is_instance_valid(objective_target):
		var blocking_building = _find_closest_blocking_building()
		if is_instance_valid(blocking_building):
			command_attack_obstruction(blocking_building)
		else:
			change_state(UnitAIConstants.State.IDLE)
	else:
		var direction: Vector2 = (target_node.global_position - unit.global_position).normalized()
		var velocity: Vector2 = direction * unit.data.move_speed
		unit.velocity = velocity
		unit.move_and_slide()
		
		if unit.velocity.length_squared() < 1.0:
			stuck_timer += delta
			if stuck_timer > 0.5:
				change_state(UnitAIConstants.State.IDLE)
				stuck_timer = 0.0
		else:
			stuck_timer = 0.0

func _attack_state(_delta: float) -> void:
	if not is_instance_valid(current_target):
		_resume_objective()
		return
	
	var distance_to_target: float = unit.global_position.distance_to(current_target.global_position)
	if distance_to_target > unit.data.attack_range + 10:
		_resume_objective()
		return
	
	unit.velocity = Vector2.ZERO

func _resume_objective() -> void:
	current_target = null
		
	if is_instance_valid(objective_target):
		current_target = objective_target
		change_state(UnitAIConstants.State.MOVING)
	else:
		if attack_ai and attack_ai.ai_mode == AttackAI.AI_Mode.DEFAULT:
			var new_target = _find_closest_enemy_in_los()
			if is_instance_valid(new_target):
				command_attack(new_target)
			else:
				change_state(UnitAIConstants.State.IDLE)
		else:
			change_state(UnitAIConstants.State.IDLE)

func _find_closest_enemy_in_los() -> Node2D:
	var mission_node = unit.get_parent()
	if not is_instance_valid(mission_node):
		return null

	var closest_target: Node2D = null
	var min_dist_sq = los_range * los_range
	var unit_pos = unit.global_position

	# 1. Check Enemy Buildings
	var building_container = mission_node.get_node_or_null("BuildingContainer")
	if is_instance_valid(building_container):
		for building in building_container.get_children():
			if not building is BaseBuilding or not (building.collision_layer & (1 << 3)):
				continue
				
			var dist_sq = unit_pos.distance_squared_to(building.global_position)
			if dist_sq < min_dist_sq:
				min_dist_sq = dist_sq
				closest_target = building

	# 2. Check Enemy Units
	var enemy_units = unit.get_tree().get_nodes_in_group("enemy_units")
	for enemy_unit in enemy_units:
		if not is_instance_valid(enemy_unit) or not enemy_unit is Node2D:
			continue

		var dist_sq = unit_pos.distance_squared_to(enemy_unit.global_position)
		if dist_sq < min_dist_sq:
			min_dist_sq = dist_sq
			closest_target = enemy_unit
			
	return closest_target

func _on_ai_attack_started(target: Node2D) -> void:
	if current_state != UnitAIConstants.State.IDLE:
		return
		
	if current_state == UnitAIConstants.State.ATTACKING and target == current_target:
		return
		
	if attack_ai.ai_mode == AttackAI.AI_Mode.DEFENSIVE_SIEGE:
		return
		
	current_target = target
	change_state(UnitAIConstants.State.ATTACKING)

func _on_ai_attack_stopped() -> void:
	if current_state == UnitAIConstants.State.ATTACKING:
		_resume_objective()

--- SCRIPT: res://scripts/buildings/SettlementBridge.gd ---
# res://scripts/buildings/SettlementBridge.gd
# --- MODIFIED: Added Work Assignment UI & Button ---

extends Node

# --- Exported Resources ---
@export var home_base_data: SettlementData
@export var test_building_data: BuildingData
@export var raider_scene: PackedScene
@export var end_of_year_popup_scene: PackedScene
@export var world_map_scene_path: String = "res://scenes/world_map/WorldMap_Stub.tscn"

# --- Default Assets (fallback) ---
var default_test_building: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
var default_raider_scene: PackedScene 
var default_end_of_year_popup: PackedScene = preload("res://ui/EndOfYear_Popup.tscn")

# --- Scene Node References ---
@onready var unit_container: Node2D = $UnitContainer
@onready var ui_layer: CanvasLayer = $UI
@onready var restart_button: Button = $UI/RestartButton
@onready var start_raid_button: Button = $UI/StartRaidButton
@onready var storefront_ui: Control = $UI/Storefront_UI
@onready var building_cursor: Node2D = $BuildingCursor
var end_of_year_popup: PanelContainer

# --- Debug Button ---
@onready var debug_raid_button: Button = $UI/Storefront_UI/DebugRaidButton

# --- Local Node References ---
@onready var building_container: Node2D = $BuildingContainer
@onready var grid_manager: Node = $GridManager

# --- NEW: Worker Management UI ---
const WORK_ASSIGNMENT_SCENE_PATH = "res://ui/WorkAssignment_UI.tscn"
var work_assignment_ui: CanvasLayer
var manage_workers_button: Button
# -------------------------------

# --- State Variables ---
var great_hall_instance: BaseBuilding = null
var game_is_over: bool = false
var awaiting_placement: BuildingData = null


func _ready() -> void:
	_setup_default_resources()
	_initialize_settlement() 
	_setup_ui()
	_connect_signals()
	
	# --- NEW: Setup Worker UI ---
	_setup_worker_ui()
	# ----------------------------
	if not DynastyManager.pending_raid_result.is_empty():
		_process_raid_return()
		
	storefront_ui.show()
	if end_of_year_popup:
		end_of_year_popup.hide()

func _exit_tree() -> void:
	SettlementManager.unregister_active_scene_nodes()

# --- NEW: Worker UI Setup Function ---
func _setup_worker_ui() -> void:
	# 1. Load the UI Scene
	if ResourceLoader.exists(WORK_ASSIGNMENT_SCENE_PATH):
		var scene = load(WORK_ASSIGNMENT_SCENE_PATH)
		if scene:
			work_assignment_ui = scene.instantiate()
			add_child(work_assignment_ui)
			if work_assignment_ui.has_signal("assignments_confirmed"):
				work_assignment_ui.assignments_confirmed.connect(_on_worker_assignments_confirmed)
	else:
		push_error("SettlementBridge: WorkAssignment_UI scene missing.")

	# 2. Create the Button
	manage_workers_button = Button.new()
	manage_workers_button.text = "Manage Workers"
	manage_workers_button.pressed.connect(_on_manage_workers_pressed)
	
	# Position it Top-Right (below the Start Raid button logic usually, or Top-Left)
	# Let's put it Top-Left for visibility in the settlement view
	ui_layer.add_child(manage_workers_button)
	manage_workers_button.set_anchors_and_offsets_preset(Control.PRESET_TOP_LEFT, Control.PRESET_MODE_MINSIZE, 20)
	manage_workers_button.position.y += 60 # Offset down a bit if needed

func _on_manage_workers_pressed() -> void:
	if not SettlementManager.has_current_settlement():
		return
	
	if work_assignment_ui:
		work_assignment_ui.setup(SettlementManager.current_settlement)

func _on_worker_assignments_confirmed(assignments: Dictionary) -> void:
	print("SettlementBridge: Work assignments saved.")
	if SettlementManager.current_settlement:
		SettlementManager.current_settlement.worker_assignments = assignments
		SettlementManager.save_settlement()
# ----------------------------------------

func _setup_default_resources() -> void:
	if not test_building_data:
		test_building_data = default_test_building
	if not raider_scene:
		raider_scene = load("res://scenes/units/EnemyVikingRaider.tscn")
	if not end_of_year_popup_scene: 
		end_of_year_popup_scene = default_end_of_year_popup

func _initialize_settlement() -> void:
	"""Initialize data, then grid, then spawn buildings."""
	if not home_base_data:
		home_base_data = _create_default_settlement()
		print("SettlementBridge: Created default settlement data")
	else:
		if not home_base_data is SettlementData:
			push_warning("SettlementBridge: Inspector data is not SettlementData, creating default")
			home_base_data = _create_default_settlement()
	
	if home_base_data and (not home_base_data.resource_path or home_base_data.resource_path.is_empty()):
		home_base_data.resource_path = "res://data/settlements/home_base_fixed.tres"
	
	SettlementManager.load_settlement(home_base_data)
	
	if not is_instance_valid(grid_manager) or not "astar_grid" in grid_manager:
		push_error("SettlementBridge: GridManager node is missing or invalid!")
		return
	var local_astar_grid = grid_manager.astar_grid
	
	# Pass GridManager for Phase 3
	SettlementManager.register_active_scene_nodes(local_astar_grid, building_container, grid_manager)
	
	_spawn_placed_buildings()
	
	EventBus.settlement_loaded.emit(home_base_data)


func _spawn_placed_buildings() -> void:
	if not SettlementManager.current_settlement:
		return
	
	for child in building_container.get_children():
		child.queue_free()

	# 1. Spawn Active Buildings
	for building_entry in SettlementManager.current_settlement.placed_buildings:
		_spawn_single_building(building_entry, false) 

	# 2. Spawn Pending Blueprints (Phase 4 Update)
	for building_entry in SettlementManager.current_settlement.pending_construction_buildings:
		var b = _spawn_single_building(building_entry, false)
		if b:
			var progress = building_entry.get("progress", 0)
			if progress > 0:
				b.construction_progress = progress
				b.set_state(BaseBuilding.BuildingState.UNDER_CONSTRUCTION)
				# Force visual update for health bar
				if b.has_method("add_construction_progress"):
					b.add_construction_progress(0) 
			else:
				b.set_state(BaseBuilding.BuildingState.BLUEPRINT)
	
	if is_instance_valid(SettlementManager.active_astar_grid):
		SettlementManager.active_astar_grid.update()
	
	print("SettlementBridge: Settlement restored.")

func _spawn_single_building(entry: Dictionary, is_new: bool) -> BaseBuilding:
	var building_res_path: String = entry["resource_path"]
	var grid_pos: Vector2i = entry["grid_position"]
	
	var building_data: BuildingData = load(building_res_path)
	if building_data:
		var new_building = SettlementManager.place_building(building_data, grid_pos, is_new)
		if new_building and new_building.data.display_name == "Great Hall":
			_setup_great_hall(new_building)
		return new_building
	else:
		push_error("Failed to load building resource from path: %s" % building_res_path)
		return null


func _create_default_settlement() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 100, "stone": 200}
	settlement.placed_buildings = []
	settlement.pending_construction_buildings = [] 
	settlement.garrisoned_units = {}
	settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
	return settlement

func _setup_ui() -> void:
	end_of_year_popup = end_of_year_popup_scene.instantiate()
	ui_layer.add_child(end_of_year_popup)
	end_of_year_popup.collect_button_pressed.connect(_on_payout_collected)
	storefront_ui.hide()

func _connect_signals() -> void:
	restart_button.pressed.connect(_on_restart_pressed)
	start_raid_button.pressed.connect(_on_start_raid_pressed)
	
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	EventBus.building_ready_for_placement.connect(_on_building_ready_for_placement)
	EventBus.building_placement_cancelled.connect(_on_building_placement_cancelled)
	EventBus.building_right_clicked.connect(_on_building_right_clicked)
	
	if building_cursor:
		building_cursor.placement_completed.connect(_on_building_placement_completed)
		building_cursor.placement_cancelled.connect(_on_building_placement_cancelled_by_cursor)

	if is_instance_valid(debug_raid_button):
		debug_raid_button.pressed.connect(_on_debug_raid_pressed)

func _on_settlement_loaded(_settlement_data: SettlementData) -> void:
	pass

func _on_debug_raid_pressed() -> void:
	print("DEBUG: Forcing defensive raid mission!")
	DynastyManager.is_defensive_raid = true
	EventBus.scene_change_requested.emit("raid_mission")

func _on_payout_collected(payout: Dictionary) -> void:
	SettlementManager.deposit_resources(payout)
	storefront_ui.show()

func _setup_great_hall(hall_instance: BaseBuilding) -> void:
	if not is_instance_valid(hall_instance):
		return
	great_hall_instance = hall_instance
	great_hall_instance.building_destroyed.connect(_on_great_hall_destroyed)

func _on_great_hall_destroyed(_building: BaseBuilding) -> void:
	print("GAME OVER: The Great Hall has been destroyed!")
	game_is_over = true
	var label : Label = $UI/Label
	label.text = "YOU HAVE BEEN SACKED."
	restart_button.show()
	_destroy_all_enemies()

func _destroy_all_enemies() -> void:
	for enemy in unit_container.get_children():
		enemy.queue_free()

func _on_restart_pressed() -> void:
	get_tree().reload_current_scene()

func _on_start_raid_pressed() -> void:
	if not SettlementManager.current_settlement:
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		var test_unit_path = "res://data/units/EnemyVikingRaider_Data.tres"
		SettlementManager.current_settlement.garrisoned_units[test_unit_path] = 2
		SettlementManager.save_settlement()
	
	if not world_map_scene_path.is_empty():
		EventBus.scene_change_requested.emit("world_map")

# --- Building Cursor System Functions ---

func _on_building_ready_for_placement(building_data: BuildingData) -> void:
	awaiting_placement = building_data
	building_cursor.cell_size = grid_manager.cell_size
	building_cursor.set_building_preview(building_data)

func _on_building_placement_cancelled(building_data: BuildingData) -> void:
	print("Building placement cancelled: %s" % building_data.display_name)

func _on_building_placement_completed() -> void:
	if awaiting_placement and SettlementManager.current_settlement:
		var snapped_grid_pos = Vector2i(building_cursor.global_position / grid_manager.cell_size)
		
		print("SettlementBridge: Placing NEW blueprint for %s at %s" % [awaiting_placement.display_name, snapped_grid_pos])
		SettlementManager.place_building(awaiting_placement, snapped_grid_pos, true)
	
	awaiting_placement = null

func _on_building_placement_cancelled_by_cursor() -> void:
	if awaiting_placement:
		SettlementManager.deposit_resources(awaiting_placement.build_cost)
		awaiting_placement = null

func _on_building_right_clicked(building: BaseBuilding) -> void:
	# Move/Sell logic
	if building_cursor.is_active:
		return
	
	# --- REVERTED: Lock Removed ---
	# We now allow deleting the Hub because the Cursor logic 
	# permits placing it back down on empty land.
	# ------------------------------
		
	print("SettlementBridge: Move requested for %s" % building.data.display_name)
	
	var data = building.data
	var cost = data.build_cost
	
	# Refund
	SettlementManager.deposit_resources(cost)
	
	# Remove (Manager handles data removal)
	SettlementManager.remove_building(building)
	
	# Re-buy
	if SettlementManager.attempt_purchase(cost):
		EventBus.building_ready_for_placement.emit(data)

func _process_raid_return() -> void:
	print("SettlementBridge: Processing return from raid...")
	var result = DynastyManager.pending_raid_result
	var difficulty = DynastyManager.current_raid_difficulty
	var loot_summary = {}
	
	if result.get("outcome") == "victory":
		# 1. Retrieve Looted Gold
		var gold = result.get("gold_looted", 0)
		
		# 2. Calculate Bonus Gold (Victory Bonus)
		# Base 200 + (50 per difficulty star)
		var bonus_gold = 200 + (difficulty * 50)
		var total_gold = gold + bonus_gold
		
		loot_summary["gold"] = total_gold
		
		# 3. Calculate Thralls (The Scarcity Engine)
		# Formula: Random(2 to 4) * Difficulty
		var base_thralls = randi_range(2, 4)
		var total_thralls = base_thralls * difficulty
		
		loot_summary["population"] = total_thralls
		
		# 4. Deposit
		SettlementManager.deposit_resources(loot_summary)
		
		# 5. Show the Report
		if is_instance_valid(end_of_year_popup):
			# We reuse the EndOfYear popup but with a custom title
			end_of_year_popup.display_payout(loot_summary, "Raid Successful!")
			
	# Clear the result so it doesn't trigger again on reload
	DynastyManager.pending_raid_result.clear()

--- SCRIPT: res://scripts/formations/SquadFormation.gd ---
# res://scripts/formations/SquadFormation.gd
# Squad Formation Manager - Company of Heroes style formations
# Handles formation positioning and movement for multiple units

class_name SquadFormation

enum FormationType {
	LINE,      # Horizontal line formation  
	COLUMN,    # Vertical column formation
	WEDGE,     # V-shaped formation
	BOX,       # Rectangular formation
	CIRCLE     # Circular formation
}

# Formation settings
var formation_type: FormationType = FormationType.LINE
var unit_spacing: float = 40.0
var max_units_per_row: int = 4

# Squad data
var units: Array[Node2D] = []
var leader_position: Vector2 = Vector2.ZERO
var target_position: Vector2 = Vector2.ZERO
var formation_center: Vector2 = Vector2.ZERO

# Movement state
var is_moving: bool = false
var move_speed: float = 100.0

func _init(squad_units: Array[Node2D] = []) -> void:
	units = squad_units
	if not units.is_empty():
		formation_center = _calculate_center_position()

func add_unit(unit: Node2D) -> void:
	"""Add a unit to the squad"""
	if unit not in units:
		units.append(unit)
		_update_formation_positions()

func remove_unit(unit: Node2D) -> void:
	"""Remove a unit from the squad"""
	units.erase(unit)
	_update_formation_positions()

func set_formation_type(new_type: FormationType) -> void:
	"""Change the formation type"""
	formation_type = new_type
	_update_formation_positions()

# --- MODIFIED: Added direction vector parameter ---
func move_to_position(target_pos: Vector2, direction: Vector2 = Vector2.DOWN) -> void:
	"""Command the entire squad to move to a target position"""
	target_position = target_pos
	is_moving = true
	
	# Calculate formation positions around the target, using the direction
	var formation_positions = _calculate_formation_positions(target_pos, direction)
	
	# Assign each unit a position in the formation
	for i in range(min(units.size(), formation_positions.size())):
		var unit = units[i]
		if not is_instance_valid(unit):
			continue
		var target_formation_pos = formation_positions[i]
		
		# Move the unit to its formation position
		_move_unit_to_position(unit, target_formation_pos)
	
	print("Squad moving to %s in %s formation with %d units" % [target_pos, FormationType.keys()[formation_type], units.size()])

# --- MODIFIED: Added direction and rotation logic ---
func _calculate_formation_positions(center_pos: Vector2, direction: Vector2) -> Array[Vector2]:
	"""Calculate formation positions based on formation type"""
	var positions: Array[Vector2] = []
	var unit_count = units.size()
	
	# --- AI FIX: Invert the direction vector ---
	# The user is dragging *from* the center *to* the facing direction.
	# Our previous logic was calculating the opposite rotation.
	# Inverting the vector here corrects the rotation 180 degrees.
	var rotation_angle = Vector2.DOWN.angle_to(direction * -1.0)
	# ------------------------------------------
	
	match formation_type:
		FormationType.LINE:
			positions = _calculate_line_formation(center_pos, unit_count)
		FormationType.COLUMN:
			positions = _calculate_column_formation(center_pos, unit_count)
		FormationType.WEDGE:
			positions = _calculate_wedge_formation(center_pos, unit_count)
		FormationType.BOX:
			positions = _calculate_box_formation(center_pos, unit_count)
		FormationType.CIRCLE:
			positions = _calculate_circle_formation(center_pos, unit_count)
	
	# --- NEW: Rotate all points ---
	var rotated_positions: Array[Vector2] = []
	for pos in positions:
		# 1. Translate position to be relative to center_pos
		var relative_pos = pos - center_pos
		# 2. Rotate it
		var rotated_relative_pos = relative_pos.rotated(rotation_angle)
		# 3. Translate it back to world space
		rotated_positions.append(center_pos + rotated_relative_pos)
	
	return rotated_positions
	# ---------------------------------
	
func _calculate_line_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate horizontal line formation positions"""
	var positions: Array[Vector2] = []
	var start_x = center_pos.x - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(start_x + i * unit_spacing, center_pos.y)
		positions.append(pos)
	
	return positions

func _calculate_column_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate vertical column formation positions"""
	var positions: Array[Vector2] = []
	var start_y = center_pos.y - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(center_pos.x, start_y + i * unit_spacing)
		positions.append(pos)
	
	return positions

func _calculate_wedge_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate V-shaped wedge formation positions"""
	var positions: Array[Vector2] = []
	
	# Leader at the front (relative to center_pos.y)
	positions.append(center_pos)
	
	# Place remaining units in V formation behind the leader
	var side_offset = unit_spacing * 0.7  # 70% spacing for tighter formation
	var rear_offset = unit_spacing
	
	for i in range(1, unit_count):
		var row = (i + 1) / 2  # Which row behind the leader
		var side = 1 if i % 2 == 1 else -1  # Left or right side
		
		# --- AI FIX: Changed from - to + to face DOWN by default ---
		var pos = Vector2(
			center_pos.x + side * side_offset * row,
			center_pos.y + rear_offset * row
		)
		# -----------------------------------------------------------
		positions.append(pos)
	
	return positions

func _calculate_box_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate rectangular box formation positions"""
	var positions: Array[Vector2] = []
	
	var rows = int(ceil(float(unit_count) / max_units_per_row))
	var cols = min(unit_count, max_units_per_row)
	
	var start_x = center_pos.x - (cols - 1) * unit_spacing * 0.5
	var start_y = center_pos.y - (rows - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var row = i / max_units_per_row
		var col = i % max_units_per_row
		
		# Center the last row if it has fewer units
		var row_unit_count = min(max_units_per_row, unit_count - row * max_units_per_row)
		var row_start_x = center_pos.x - (row_unit_count - 1) * unit_spacing * 0.5
		
		var pos = Vector2(
			row_start_x + col * unit_spacing,
			start_y + row * unit_spacing
		)
		positions.append(pos)
	
	return positions

func _calculate_circle_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate circular formation positions"""
	var positions: Array[Vector2] = []
	var radius = max(unit_spacing, unit_count * unit_spacing / (2 * PI))
	
	for i in range(unit_count):
		var angle = (2 * PI * i) / unit_count
		var pos = Vector2(
			center_pos.x + cos(angle) * radius,
			center_pos.y + sin(angle) * radius
		)
		positions.append(pos)
	
	return positions

# --- MODIFIED: To call the new FSM function ---
func _move_unit_to_position(unit: Node2D, target_pos: Vector2) -> void:
	"""Move a specific unit to a target position"""
	if not is_instance_valid(unit):
		return
	
	# Check if unit has FSM (proper unit system)
	if "fsm" in unit and unit.fsm != null:
		# Call the new formation-specific move function
		unit.fsm.command_move_to_formation_pos(target_pos)
	# Check if unit has direct movement method
	elif unit.has_method("command_move_to"):
		# Fallback for non-FSM units (like old test units)
		unit.command_move_to(target_pos)
	# Fallback: simple movement for test units
	else:
		_simple_unit_movement(unit, target_pos)
# --- END MODIFICATION ---

func _simple_unit_movement(unit: Node2D, target_pos: Vector2) -> void:
	"""Simple movement system for test units without FSM"""
	if not unit.has_method("set_target_position"):
		# Add simple movement script to unit if it doesn't have one
		var movement_script = """
var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0
var is_moving: bool = false

func set_target_position(pos: Vector2) -> void:
	target_position = pos
	is_moving = true

func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var direction = (target_position - global_position).normalized()
		var distance = global_position.distance_to(target_position)
		
		if distance < 5.0:
			is_moving = false
			velocity = Vector2.ZERO
		else:
			velocity = direction * move_speed
		
		move_and_slide()
"""
		# Create and attach movement behavior
		var script = GDScript.new()
		var existing_script = unit.get_script()
		if existing_script:
			script.source_code = existing_script.source_code + "\n" + movement_script
		else:
			push_error("Unit has no script, cannot add simple movement.")
			return
		script.reload()
		unit.set_script(script)
	
	# Set the target position
	unit.set_target_position(target_pos)

func _update_formation_positions() -> void:
	"""Update formation positions for current units"""
	if not units.is_empty():
		formation_center = _calculate_center_position()

func _calculate_center_position() -> Vector2:
	"""Calculate the center position of all units"""
	if units.is_empty():
		return Vector2.ZERO
	
	var total_pos = Vector2.ZERO
	for unit in units:
		if is_instance_valid(unit):
			total_pos += unit.global_position
	
	return total_pos / units.size()

func get_unit_count() -> int:
	"""Get the number of units in the squad"""
	return units.size()

func is_squad_moving() -> bool:
	"""Check if the squad is currently moving"""
	return is_moving

func get_formation_info() -> Dictionary:
	"""Get information about the current formation"""
	return {
		"type": FormationType.keys()[formation_type],
		"unit_count": units.size(),
		"spacing": unit_spacing,
		"center": formation_center,
		"is_moving": is_moving
	}

--- SCRIPT: res://scripts/generators/MapDataGenerator.gd ---
# res://scripts/generators/MapDataGenerator.gd
class_name MapDataGenerator
extends RefCounted

# --- Name Generation ---
const REGION_PREFIXES = ["North", "South", "West", "East", "High", "Low", "Old", "New", "Great", "Little"]
const REGION_NAMES = ["Vinland", "Frankia", "Saxony", "Wessex", "Mercia", "Northumbria", "Alba", "Ireland", "Rus", "Novgorod", "Agdir", "Rogaland"]
const REGION_SUFFIXES = ["Hold", "Reach", "Lands", "Coast", "Valley", "Fjord", "Isle", "Haven", "March"]

# --- Templates ---
const LAYOUT_MONASTERY = "res://data/settlements/monastery_base.tres"
const LAYOUT_VILLAGE = "res://data/settlements/economic_base.tres" # Placeholder
const LAYOUT_FORTRESS = "res://data/settlements/fortress_layout.tres"

# --- Generation Logic ---

static func generate_region_data(tier: int) -> WorldRegionData:
	var data = WorldRegionData.new()
	
	# 1. Identity
	data.display_name = _generate_name()
	data.region_type_tag = "Province"
	
	# 2. Difficulty Scaling
	var base_diff = 1.0 + (float(tier - 1) * 0.8)
	var variance = randf_range(0.0, 0.5)
	var final_difficulty = base_diff + variance
	
	# 3. Generate Targets
	var target_count = randi_range(1, 3)
	
	# --- FIX: Declare this BEFORE the loop ---
	var min_cost = 999 
	# ---------------------------------------
	
	for i in range(target_count):
		var target = _generate_target_for_tier(data.display_name, tier, final_difficulty)
		if target:
			data.raid_targets.append(target)
			# Check if this target is cheaper than the current minimum
			if target.raid_cost_authority < min_cost:
				min_cost = target.raid_cost_authority
	
	# 4. Set the region base cost (Safe check if loop failed)
	data.base_authority_cost = min_cost if min_cost != 999 else 1
	
	# 5. Income & Description
	data.yearly_income = {"gold": int(10 * final_difficulty), "food": int(20 * final_difficulty)}
	data.description = "A Tier %d region. Difficulty Rating: %.1f" % [tier, final_difficulty]
	
	return data

static func _generate_target_for_tier(region_name: String, tier: int, difficulty: float) -> RaidTargetData:
	var target = RaidTargetData.new()
	var layout_path = ""
	var type_name = ""
	
	# Biased RNG based on Tier
	var roll = randf()
	
	if tier == 1:
		# Mostly Monasteries/Villages
		if roll < 0.4: 
			type_name = "Monastery"
			layout_path = LAYOUT_MONASTERY
		else:
			type_name = "Village"
			layout_path = LAYOUT_VILLAGE
			
	elif tier == 2:
		# Mix
		if roll < 0.3:
			type_name = "Monastery"
			layout_path = LAYOUT_MONASTERY
		elif roll < 0.7:
			type_name = "Trading Post"
			layout_path = LAYOUT_VILLAGE
		else:
			type_name = "Fortress"
			layout_path = LAYOUT_FORTRESS
			
	elif tier == 3:
		# Mostly Hard Targets
		if roll < 0.2:
			type_name = "Rich Monastery"
			layout_path = LAYOUT_MONASTERY
		else:
			type_name = "Fortress"
			layout_path = LAYOUT_FORTRESS
	
	target.display_name = "%s %s" % [region_name, type_name]
	target.difficulty_rating = int(round(difficulty))
	target.raid_cost_authority = max(1, int(round(difficulty * 0.5)))
	
	# Load Layout Template
	if ResourceLoader.exists(layout_path):
		target.settlement_data = load(layout_path).duplicate(true)
		
		# Scale Garrison Size by Difficulty
		_scale_garrison(target.settlement_data, difficulty)
	
	return target

static func _scale_garrison(settlement: SettlementData, multiplier: float) -> void:
	if not settlement or not settlement.garrisoned_units: return
	
	for unit_path in settlement.garrisoned_units:
		var count = settlement.garrisoned_units[unit_path]
		settlement.garrisoned_units[unit_path] = int(count * multiplier)

static func _generate_name() -> String:
	return "%s %s" % [REGION_PREFIXES.pick_random(), REGION_NAMES.pick_random()]

--- SCRIPT: res://scripts/ui/BuildingPreviewCursor.gd ---
# BuildingPreviewCursor.gd - RTS-style building placement system
extends Node2D
class_name BuildingPreviewCursor

# Building preview components
var current_building_data: BuildingData
var preview_sprite: Sprite2D
var is_active: bool = false

# Grid and placement
var cell_size: int = 32 
var grid_overlay: Node2D
var can_place: bool = false

# Visual feedback
var valid_color: Color = Color(0.0, 1.0, 0.0, 0.7)    # Green
var invalid_color: Color = Color(1.0, 0.0, 0.0, 0.7)  # Red

signal placement_completed
signal placement_cancelled

# --- NEW: Reference to GridManager for Phase 3 checks ---
var grid_manager: Node = null

func _ready() -> void:
	z_index = 100
	
	grid_overlay = Node2D.new()
	grid_overlay.name = "GridOverlay"
	add_child(grid_overlay)
	
	# Find GridManager sibling
	grid_manager = get_parent().get_node_or_null("GridManager")
	
	print("BuildingPreviewCursor ready.")

func set_building_preview(building_data: BuildingData) -> void:
	if not building_data: return
	if cell_size <= 0: return
	
	print("Setting building preview for: %s" % building_data.display_name)
	current_building_data = building_data
	
	_cleanup_preview()
	
	preview_sprite = Sprite2D.new()
	preview_sprite.name = "PreviewSprite"
	
	if building_data.building_texture:
		preview_sprite.texture = building_data.building_texture
	else:
		var texture = _create_building_texture(building_data)
		preview_sprite.texture = texture
	
	# Scale
	var target_size: Vector2 = Vector2(building_data.grid_size) * cell_size
	if preview_sprite.texture:
		var texture_size: Vector2 = preview_sprite.texture.get_size()
		if texture_size.x > 0 and texture_size.y > 0:
			preview_sprite.scale = target_size / texture_size
	
	preview_sprite.modulate = valid_color
	add_child(preview_sprite)
	
	_create_grid_outline(building_data.grid_size)
	
	is_active = true
	visible = true

func _create_building_texture(building_data: BuildingData) -> ImageTexture:
	var size = Vector2i(building_data.grid_size.x * cell_size, building_data.grid_size.y * cell_size)
	var image = Image.create(size.x, size.y, false, Image.FORMAT_RGBA8)
	image.fill(Color(0.6, 0.6, 0.6, 1.0))
	var texture = ImageTexture.new()
	texture.set_image(image)
	return texture

func _create_grid_outline(grid_size: Vector2i) -> void:
	_clear_grid_overlay()
	var outline_color = Color.WHITE
	var line_width = 2.0
	var rect_size = Vector2(grid_size.x * cell_size, grid_size.y * cell_size)
	
	var points = [
		Vector2(0, 0), Vector2(rect_size.x, 0), 
		Vector2(rect_size.x, rect_size.y), Vector2(0, rect_size.y), 
		Vector2(0, 0)
	]
	
	var line = Line2D.new()
	line.points = points
	line.width = line_width
	line.default_color = outline_color
	grid_overlay.add_child(line)

func _clear_grid_overlay() -> void:
	for child in grid_overlay.get_children():
		child.queue_free()

func _process(_delta: float) -> void:
	if not is_active or not current_building_data: return
	
	var mouse_pos = get_global_mouse_position()
	var grid_pos = _world_to_grid(mouse_pos)
	global_position = _grid_to_world(grid_pos)
	
	can_place = _can_place_at_position(grid_pos)
	_update_visual_feedback()

func _world_to_grid(world_pos: Vector2) -> Vector2i:
	if cell_size <= 0: return Vector2i.ZERO
	return Vector2i(int(world_pos.x / cell_size), int(world_pos.y / cell_size))

func _grid_to_world(grid_pos: Vector2i) -> Vector2:
	return Vector2(grid_pos.x * cell_size, grid_pos.y * cell_size)

# --- MODIFIED: Enforce Phase 3 Territory Constraints ---
func _can_place_at_position(grid_pos: Vector2i) -> bool:
	if not SettlementManager or not current_building_data:
		return false
	
	# 1. Check Collision (Is the ground solid/occupied?)
	# This applies to EVERYTHING. You can't build inside a rock.
	if not SettlementManager.is_placement_valid(grid_pos, current_building_data.grid_size):
		return false
		
	# 2. Check Territory (Is it in the Green Zone?)
	# EXCEPTION: If this building IS a Hub (Great Hall), it generates the zone.
	# Therefore, it does not need to be *inside* an existing zone.
	if current_building_data.is_territory_hub:
		return true
	
	# Standard check for non-hubs (Walls, Farms, etc.)
	if grid_manager and grid_manager.has_method("is_cell_buildable"):
		# We check every tile in the building's footprint
		for x in range(current_building_data.grid_size.x):
			for y in range(current_building_data.grid_size.y):
				var check_pos = grid_pos + Vector2i(x, y)
				
				# If ANY part of the building is outside territory, deny placement
				if not grid_manager.is_cell_buildable(check_pos):
					return false
	
	return true

func _update_visual_feedback() -> void:
	if not preview_sprite: return
	if can_place:
		preview_sprite.modulate = valid_color
		_set_grid_overlay_color(Color.GREEN)
	else:
		preview_sprite.modulate = invalid_color
		_set_grid_overlay_color(Color.RED)

func _set_grid_overlay_color(color: Color) -> void:
	for child in grid_overlay.get_children():
		if child is Line2D:
			child.default_color = color

func place_building() -> bool:
	if not is_active or not current_building_data or not can_place:
		return false
	
	var grid_pos = _world_to_grid(global_position)
	var new_building = SettlementManager.place_building(current_building_data, grid_pos, true)
	
	if new_building:
		placement_completed.emit()
		cancel_preview()
		return true
	return false

func cancel_preview() -> void:
	is_active = false
	visible = false
	current_building_data = null
	can_place = false
	_cleanup_preview()
	placement_cancelled.emit()

func _cleanup_preview() -> void:
	if preview_sprite:
		preview_sprite.queue_free()
		preview_sprite = null
	_clear_grid_overlay()

func _input(event: InputEvent) -> void:
	if not is_active: return
	
	if event is InputEventMouseButton and event.is_pressed():
		if event.button_index == MOUSE_BUTTON_LEFT:
			place_building()
			get_viewport().set_input_as_handled()
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			cancel_preview()
			get_viewport().set_input_as_handled()

--- SCRIPT: res://scripts/ui/PauseMenu.gd ---
# res://ui/PauseMenu.gd
#
# This script controls the pause menu itself.
# It runs while the game is paused (Process Mode = "When Paused").
# It is responsible for unpausing the game.

extends CanvasLayer

@onready var resume_button: Button = $PanelContainer/VBoxContainer/ResumeButton
@onready var save_button: Button = $PanelContainer/VBoxContainer/SaveButton
@onready var quit_button: Button = $PanelContainer/VBoxContainer/QuitButton


func _ready() -> void:
	# Connect signals in code
	resume_button.pressed.connect(_on_resume_pressed)
	save_button.pressed.connect(_on_save_pressed)
	quit_button.pressed.connect(_on_quit_pressed)


func _unhandled_input(event: InputEvent) -> void:
	# Also allow 'Escape' to close the pause menu
	if event.is_action_pressed("ui_pause"):
		get_viewport().set_input_as_handled() # Consume the event
		_on_resume_pressed()


func _on_resume_pressed() -> void:
	"""Unpauses the game and removes the menu."""
	get_tree().paused = false
	queue_free() # Destroy the menu


func _on_save_pressed() -> void:
	"""Saves the game state via the SettlementManager."""
	if SettlementManager.has_current_settlement():
		SettlementManager.save_settlement()
		print("Game saved from pause menu.")
	else:
		print("Pause Menu: No settlement loaded, cannot save.")


func _on_quit_pressed() -> void:
	"""Quits the game."""
	get_tree().quit()

--- SCRIPT: res://scripts/units/Base_Unit.gd ---
# res://scripts/units/Base_Unit.gd
# Base unit class for all units in the Viking Dynasty RTS

class_name BaseUnit
extends CharacterBody2D

signal destroyed
signal fsm_ready(unit)

@export var data: UnitData
# Removed the : UnitFSM type hint to break the circular dependency.
var fsm
var current_health: int = 50
var attack_ai: AttackAI = null

# Node refs
@onready var attack_timer: Timer = $AttackTimer
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
@onready var separation_area: Area2D = $SeparationArea

@export_group("AI")
@export var separation_enabled: bool = true
@export var separation_force: float = 30.0
@export var separation_radius: float = 40.0

# Visual state system
var _color_tween: Tween
# --- THIS IS THE FIX ---
# Changed all references from UnitFSM.State to UnitAIConstants.State
const STATE_COLORS := {
	UnitAIConstants.State.IDLE: Color(0.3, 0.6, 1.0),     # Blue
	UnitAIConstants.State.MOVING: Color(0.4, 1.0, 0.4),   # Green
	UnitAIConstants.State.FORMATION_MOVING: Color(0.4, 1.0, 0.4), # Green
	UnitAIConstants.State.ATTACKING: Color(1.0, 0.3, 0.3) # Red
}
# --- END FIX ---
const ERROR_COLOR := Color(0.7, 0.3, 1.0)

func _ready() -> void:
	if not data:
		push_warning("BaseUnit: Node '%s' is missing its 'UnitData' resource.
Cannot initialize." % name)
		return
	
	current_health = data.max_health
	_apply_texture_and_scale()
	
	# --- MODIFIED: DEFER ALL AI/FSM SETUP ---
	call_deferred("_deferred_setup")
	# ----------------------------------------
	
	sprite.modulate = STATE_COLORS.get(UnitAIConstants.State.IDLE, Color.WHITE)
	
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)
	
	separation_area.collision_mask = 2
	
	var area_shape = separation_area.get_node_or_null("CollisionShape2D")
	if area_shape and area_shape.shape is CircleShape2D:
		area_shape.shape.radius = separation_radius
	else:
		push_warning("'%s' has no 'SeparationArea/CollisionShape2D' with a CircleShape!" % name)
		
func _deferred_setup() -> void:
	"""Initializes AttackAI and FSM after all children are guaranteed to be in the tree."""
	
	if data.ai_component_scene:
		attack_ai = data.ai_component_scene.instantiate() as AttackAI
		if attack_ai:
			add_child(attack_ai)
			attack_ai.configure_from_data(data)
			
			var target_mask = 0
			if self.collision_layer & 2: # Player unit (Layer 2)
				target_mask = (1 << 2) | (1 << 3) # Target Enemy Units (L3) & Enemy Buildings (L4)
			elif self.collision_layer & 4: # Enemy unit (Layer 3)
				target_mask = (1 << 0) | (1 << 1) # Target Player Buildings (L1) & Player Units (L2)
			
			if target_mask == 0:
				push_warning("BaseUnit: '%s' is on an unhandled collision layer (%s). AI will not target anything." % [name, self.collision_layer])
			
			attack_ai.set_target_mask(target_mask)
		else:
			push_error("BaseUnit: Failed to instantiate ai_component_scene for %s" % data.display_name)
	
	# FSM relies on attack_ai being valid, so we run this last.
	fsm = UnitFSM.new(self, attack_ai)
	fsm_ready.emit(self)
	
func _apply_texture_and_scale() -> void:
	if data.target_pixel_size.x <= 0 or data.target_pixel_size.y <= 0:
		push_warning("BaseUnit: '%s' has a target_pixel_size of %s, which is invalid." % [data.display_name, data.target_pixel_size])
		return
		
	var target_size: Vector2 = data.target_pixel_size

	if data.visual_texture:
		sprite.texture = data.visual_texture
		var texture_size: Vector2 = sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			var new_scale: Vector2 = target_size / texture_size
			sprite.scale = new_scale
		else:
			push_warning("BaseUnit: Texture for '%s' has an invalid size of %s. Cannot scale sprite." % [data.display_name, texture_size])
	else:
		push_warning("BaseUnit: '%s' is missing its 'visual_texture'. Sprite will be blank or use placeholder." % data.display_name)
		
	if collision_shape and collision_shape.shape is RectangleShape2D:
		collision_shape.shape.size = target_size
	else:
		push_warning("BaseUnit: '%s' is missing its CollisionShape2D node or its shape is not a RectangleShape2D. Collision will not match visuals." % data.display_name)

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	# --- THIS IS THE FIX ---
	if fsm and fsm.current_state == UnitAIConstants.State.MOVING:
	# --- END FIX ---
		fsm._recalculate_path()

func _physics_process(delta: float) -> void:
	if not data:
		return

	var fsm_velocity = Vector2.ZERO
	if fsm:
		fsm.update(delta)
		fsm_velocity = velocity
		velocity = Vector2.ZERO 
	
	var target_fsm_velocity = Vector2.ZERO
	
	# --- THIS IS THE FIX ---
	if fsm and (fsm.current_state == UnitAIConstants.State.MOVING or fsm.current_state == UnitAIConstants.State.FORMATION_MOVING):
	# --- END FIX ---
		target_fsm_velocity = fsm_velocity
	
	if target_fsm_velocity.length() > 0.1:
		velocity = velocity.lerp(target_fsm_velocity, data.acceleration * delta)
	else:
		velocity = velocity.lerp(Vector2.ZERO, data.linear_damping * delta)
	
	if separation_enabled:
		var separation_push = _calculate_separation_push(delta)
		velocity += separation_push

	move_and_slide()

func _calculate_separation_push(delta: float) -> Vector2:
	var push_vector = Vector2.ZERO
	var neighbors = separation_area.get_overlapping_bodies()
	if neighbors.is_empty():
		return Vector2.ZERO
		
	for neighbor in neighbors:
		if neighbor == self or not neighbor is CharacterBody2D:
			continue
			
		var away_vector = global_position - neighbor.global_position
		var distance_sq = away_vector.length_squared()
		
		if distance_sq > 0.01 and distance_sq < separation_radius * separation_radius:
			var push_strength = 1.0 - (sqrt(distance_sq) / separation_radius)
			push_vector += away_vector.normalized() * push_strength
			
	return push_vector * separation_force * delta

# --- THIS IS THE FIX ---
func on_state_changed(state: UnitAIConstants.State) -> void:
# --- END FIX ---
	var to_color: Color = STATE_COLORS.get(state, Color.WHITE)
	_tween_color(to_color, 0.2)

func flash_error_color() -> void:
	var back_color: Color = STATE_COLORS.get(fsm.current_state, Color.WHITE)
	var t := create_tween()
	t.tween_property(sprite, "modulate", ERROR_COLOR, 0.08).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
	t.tween_property(sprite, "modulate", back_color, 0.18).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func _tween_color(to_color: Color, duration: float = 0.2) -> void:
	if _color_tween and _color_tween.is_running():
		_color_tween.kill()
	_color_tween = create_tween()
	_color_tween.tween_property(sprite, "modulate", to_color, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

# --- MODIFIED: Added attacker parameter ---
func take_damage(amount: int, attacker: Node2D = null) -> void:
	current_health = max(0, current_health - amount)
	
	# --- NEW: Retaliation Logic ---
	if fsm and is_instance_valid(attacker):
		# Tell the FSM we are being attacked
		fsm.command_defensive_attack(attacker)
	# --- END NEW ---
	
	if current_health == 0:
		die()

func die() -> void:
	destroyed.emit()
	queue_free()

func command_move_to(target_pos: Vector2) -> void:
	if fsm:
		fsm.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	if fsm:
		fsm.command_attack(target)

var is_selected: bool = false

func set_selected(selected: bool) -> void:
	is_selected = selected
	
	if is_selected:
		_show_selection_indicator()
	else:
		_hide_selection_indicator()

func _show_selection_indicator() -> void:
	queue_redraw()

func _hide_selection_indicator() -> void:
	queue_redraw()

func _draw() -> void:
	if is_selected:
		var radius = 25.0
		var color = Color.YELLOW
		color.a = 0.8
		draw_circle(Vector2.ZERO, radius, color, false, 3.0)

--- SCRIPT: res://scripts/units/EnemyVikingRaider.gd ---
# res://scripts/units/EnemyVikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Target position is now set correctly ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set the node (for attacking)
	fsm.target_unit = target
	
	# --- THIS IS THE FIX ---
	# Target the building's actual center.
	# The FSM will find the closest walkable spot.
	fsm.target_position = target.global_position
	# --- END FIX ---
	
	# Start the FSM
	# --- THIS IS THE FINAL FIX ---
	# Updated to use the new constants script
	fsm.change_state(UnitAIConstants.State.MOVING)
	# --- END FIX ---
	print("Viking Raider initialized and moving to target: %s" % target.data.display_name)

--- SCRIPT: res://scripts/units/PlayerVikingRaider.gd ---
# res://scripts/units/PlayerVikingRaider.gd
#
# Player-controlled Viking Raider unit.
# This script is now much simpler. It just inherits all the
# complex logic from BaseUnit and the FSM.

extends BaseUnit
class_name PlayerVikingRaider

func _ready() -> void:
	# Call parent _ready first to initialize base unit systems
	super._ready()
	
	# Add to player units group for RTS selection and control
	add_to_group("player_units")
	
	print("PlayerVikingRaider '%s' initialized and ready for RTS control" % name)

# --- THIS IS THE FIX ---
# We override the command_attack function just to add a print statement,
# then we call super.command_attack(target) to let the Base_Unit and FSM
# handle the *actual* logic correctly.
func command_attack(target: Node2D) -> void:
	if not fsm or not is_instance_valid(target):
		push_warning("Player Raider FSM or target is not valid.")
		return

	print("Player Viking Raider '%s' attacking %s" % [name, target.name])

	# Pass the command to the base class, which will pass it to the FSM
	super.command_attack(target)
# --- END FIX ---

# Override die method to handle player unit death
func die() -> void:
	"""Handle player unit death with proper cleanup"""
	# Remove from player units group
	remove_from_group("player_units")
	
	# Notify other systems about unit death
	EventBus.emit_signal("player_unit_died", self)
	
	print("Player Viking Raider '%s' has fallen in battle!" % name)
	
	# Call parent die method
	super.die()

--- SCRIPT: res://scripts/utility/GridManager.gd ---
# res://scripts/utility/GridManager.gd
#
# Manages the AStarGrid2D and the Territory System (Flood Fill).
# --- MODIFIED: Phase 3.1 Territory Logic ---

extends Node

@export_group("Grid Configuration")
@export var grid_width: int = 60
@export var grid_height: int = 40
@export var cell_size: int = 32

var astar_grid: AStarGrid2D

# Phase 3: Territory Tracking
# Dictionary { Vector2i: true } containing all cells where players can build.
var buildable_cells: Dictionary = {}

func _ready() -> void:
	astar_grid = AStarGrid2D.new()
	var playable_rect := Rect2i(0, 0, grid_width, grid_height)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(cell_size, cell_size)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar_grid.update()
	
	print("GridManager: Local grid initialized: %dx%d cells" % [grid_width, grid_height])


func recalculate_territory(placed_buildings: Array) -> void:
	"""
	Recalculates territory using a 'Wireless' propagation model.
	1. Hubs generate territory naturally.
	2. Connectors (Walls) extend territory if they are INSIDE an existing territory.
	3. This allows daisy-chaining without physical contact.
	"""
	buildable_cells.clear()
	
	# 1. Sort buildings into Hubs (Sources) and Connectors (Extenders)
	var active_sources: Array[Dictionary] = []
	var candidate_connectors: Array[Dictionary] = []
	
	for entry in placed_buildings:
		var pos = entry["grid_position"]
		# Normalize to Vector2
		var grid_pos = Vector2(pos.x, pos.y) if pos is Vector2i else pos
		
		var data = load(entry["resource_path"]) as BuildingData
		if not data: continue
		
		# Calculate center point for distance checks
		var center_pos = grid_pos + (Vector2(data.grid_size) / 2.0)
		
		var info = {
			"grid_pos": Vector2i(grid_pos),
			"center": center_pos,
			"data": data,
			"radius": data.territory_radius
		}
		
		if data.is_territory_hub:
			active_sources.append(info)
		elif data.extends_territory:
			candidate_connectors.append(info)

	# 2. Iterative Propagation (Daisy-Chaining)
	# We loop until we stop finding new powered connectors.
	var new_connection_found = true
	
	while new_connection_found:
		new_connection_found = false
		var next_candidates: Array[Dictionary] = []
		
		for connector in candidate_connectors:
			var is_powered = false
			
			# Check if this connector is inside the range of ANY active source
			for source in active_sources:
				var distance = source["center"].distance_to(connector["center"])
				# Use a forgiving check: if distance <= source radius + small buffer
				# We check if the connector is essentially "covered" by the source
				if distance <= source["radius"]:
					is_powered = true
					break
			
			if is_powered:
				active_sources.append(connector)
				new_connection_found = true
			else:
				next_candidates.append(connector)
		
		# Shrink the list of candidates to only those who haven't powered on yet
		candidate_connectors = next_candidates

	# 3. Rasterize (Draw) the Territory
	# Now that we know which buildings are active, apply their radius to the grid.
	for source in active_sources:
		_apply_territory_to_grid(source)

	print("GridManager: Territory recalculated (Wireless). %d valid build tiles." % buildable_cells.size())
	
	# Force visualizer update
	queue_redraw_visualizer()

func _apply_territory_to_grid(source_info: Dictionary) -> void:
	var center = Vector2i(source_info["grid_pos"]) + (source_info["data"].grid_size / 2)
	var r = source_info["radius"]
	
	# Draw a square radius (matches standard RTS logic best)
	for x in range(-r, r + 1):
		for y in range(-r, r + 1):
			var cell = center + Vector2i(x, y)
			
			# Check bounds
			if cell.x >= 0 and cell.x < grid_width and \
			   cell.y >= 0 and cell.y < grid_height:
				buildable_cells[cell] = true


func queue_redraw_visualizer() -> void:
	var visualizer = get_parent().get_node_or_null("GridVisualizer")
	if visualizer:
		visualizer.queue_redraw()

func is_cell_buildable(grid_pos: Vector2i) -> bool:
	return buildable_cells.has(grid_pos)

--- SCRIPT: res://scripts/utility/GridVisualizer.gd ---
# res://scripts/utility/GridVisualizer.gd
# --- MODIFIED: Phase 3.2 Visualizing the Zone ---
class_name GridVisualizer
extends Node2D

const GRID_LINE_COLOR := Color(1.0, 1.0, 1.0, 0.05)
const SOLID_CELL_COLOR := Color(1.0, 0.0, 0.0, 0.3) # Red for blocked
const TERRITORY_COLOR := Color(0.0, 1.0, 0.0, 0.1) # Light Green for territory

# Configuration populated in _ready()
var grid_width: int = 0
var grid_height: int = 0
var cell_size: int = 0
var astar_grid: AStarGrid2D = null
var grid_manager: Node = null

func _ready() -> void:
	grid_manager = get_parent().get_node_or_null("GridManager")
	if not grid_manager:
		queue_free()
		return

	grid_width = grid_manager.grid_width
	grid_height = grid_manager.grid_height
	cell_size = grid_manager.cell_size
	
	if "astar_grid" in grid_manager:
		astar_grid = grid_manager.astar_grid

	EventBus.pathfinding_grid_updated.connect(_on_pathfinding_grid_updated)
	
	set_process_mode(Node.PROCESS_MODE_ALWAYS) # Draw even when paused
	queue_redraw()

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_pathfinding_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_pathfinding_grid_updated)

func _draw() -> void:
	if cell_size <= 0: return

	# --- 1. Draw Territory (Green) ---
	if grid_manager and "buildable_cells" in grid_manager:
		var buildable = grid_manager.buildable_cells
		for cell in buildable:
			var rect = Rect2(cell.x * cell_size, cell.y * cell_size, cell_size, cell_size)
			draw_rect(rect, TERRITORY_COLOR)

	# --- 2. Draw Grid Lines ---
	var map_width = grid_width * cell_size
	var map_height = grid_height * cell_size

	for i in range(grid_height + 1):
		var y = float(i) * cell_size
		draw_line(Vector2(0, y), Vector2(map_width, y), GRID_LINE_COLOR, 1.0)

	for j in range(grid_width + 1):
		var x = float(j) * cell_size
		draw_line(Vector2(x, 0), Vector2(x, map_height), GRID_LINE_COLOR, 1.0)

	# --- 3. Draw Blocked Cells (Red) ---
	if is_instance_valid(astar_grid):
		var cell_draw_size = cell_size * 0.6
		var cell_offset = cell_size * 0.2
		
		for i in range(grid_width):
			for j in range(grid_height):
				if astar_grid.is_point_solid(Vector2i(i, j)):
					var rect_top_left = Vector2(float(i * cell_size) + cell_offset, float(j * cell_size) + cell_offset)
					draw_rect(Rect2(rect_top_left, Vector2(cell_draw_size, cell_draw_size)), SOLID_CELL_COLOR)

func _on_pathfinding_grid_updated(_grid_position: Vector2i) -> void:
	queue_redraw()

--- SCRIPT: res://test/test_blueprint_saving.gd ---
# Test script to verify blueprint saving functionality

extends EditorScript
# Test function to place a blueprint and verify it's saved
func test_blueprint_saving():
	print("=== Testing Blueprint Saving ===")
	
	if not SettlementManager.has_current_settlement():
		print("ERROR: No settlement loaded for testing")
		return false
	
	# Test building placement
	var building_data: BuildingData = load("res://data/buildings/Bldg_Wall.tres")
	if not building_data:
		print("ERROR: Could not load test building data")
		return false
	
	print("1. Initial pending buildings: %d" % SettlementManager.get_pending_construction_buildings().size())
	
	# Place a new blueprint
	var grid_pos = Vector2i(5, 5)  # Choose a safe position
	var new_building = SettlementManager.place_building(building_data, grid_pos, true)
	
	if new_building:
		print("2. Building placed successfully at %s" % grid_pos)
		print("   - Building state: %s" % new_building.current_state)
		print("   - Is active: %s" % new_building.is_active())
		
		# Check if it's in pending buildings
		var pending = SettlementManager.get_pending_construction_buildings()
		print("3. Pending buildings after placement: %d" % pending.size())
		for entry in pending:
			print("   - Entry: %s" % entry)
		
		# Wait a frame for save to complete
		await get_tree().process_frame
		
		# Reload the settlement and check if blueprint was saved
		if SettlementManager.current_settlement and SettlementManager.current_settlement.resource_path:
			var reloaded_settlement = load(SettlementManager.current_settlement.resource_path)
			if reloaded_settlement:
				print("4. Reloaded settlement - Pending buildings: %d" % reloaded_settlement.pending_construction_buildings.size())
				for i in range(reloaded_settlement.pending_construction_buildings.size()):
					var entry = reloaded_settlement.pending_construction_buildings[i]
					print("   - Saved Entry [%d]: %s" % [i, entry])
				
				if reloaded_settlement.pending_construction_buildings.size() > 0:
					print(" SUCCESS: Blueprint saved successfully!")
					return true
				else:
					print(" FAILED: Blueprint was not saved to file")
					return false
		else:
			print("ERROR: Could not reload settlement for verification")
			return false
	else:
		print("ERROR: Failed to place building")
		return false

func _ready():
	# Auto-run test if this script is attached to a node
	call_deferred("run_test")

func run_test():
	await get_tree().process_frame  # Wait for scene to be ready
	var result = await test_blueprint_saving()
	if result:
		print(" Blueprint saving test PASSED!")
	else:
		print(" Blueprint saving test FAILED!")

--- SCRIPT: res://tools/EnemyBaseEditor.gd ---
@tool
extends EditorScript

# Simple Enemy Base Layout Editor
# Usage: Tools -> Execute Script to run this

func _run():
	print("=== ENEMY BASE LAYOUT EDITOR ===")
	
	var settlement_path = "res://data/settlements/monastery_base.tres"
	var settlement_data: SettlementData = load(settlement_path)
	
	if not settlement_data:
		print("ERROR: Could not load settlement data!")
		return
	
	print("Current layout for: " + settlement_path)
	print("Grid positions (format: Building @ X,Y):")
	print("-".repeat(40))
	
	for i in range(settlement_data.placed_buildings.size()):
		var building = settlement_data.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("-".repeat(40))
	print("To modify layout:")
	print("1. Edit grid_position values in the .tres file")
	print("2. Or use this script to create new layouts")
	print("3. Grid range: 0-%d (width), 0-%d (height)" % [
		SettlementManager.grid_width-1, 
		SettlementManager.grid_height-1
	])

# Helper function to create new enemy base layouts
static func create_enemy_base_layout(buildings: Array[Dictionary], save_path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 500, "wood": 200, "food": 150, "stone": 100}
	settlement.placed_buildings = buildings
	
	ResourceSaver.save(settlement, save_path)
	print("Created new enemy base: " + save_path)

# Example usage:
# EnemyBaseEditor.create_fortress_layout()
static func create_fortress_layout():
	var buildings = [
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(32, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	create_enemy_base_layout(buildings, "res://data/settlements/fortress_base.tres")

--- SCRIPT: res://tools/SettlementLayoutEditor.gd ---
# SettlementLayoutEditor.gd
# Tool to help create custom settlement layouts
@tool
extends EditorScript

# Define available buildings with their paths
const BUILDINGS = {
	"Great Hall": "res://data/buildings/GreatHall.tres",
	"Wall": "res://data/buildings/Bldg_Wall.tres", 
	"Lumber Yard": "res://data/buildings/LumberYard.tres",
	"Chapel": "res://data/buildings/Monastery_Chapel.tres",
	"Granary": "res://data/buildings/Monastery_Granary.tres",
	"Library": "res://data/buildings/Monastery_Library.tres",
	"Scriptorium": "res://data/buildings/Monastery_Scriptorium.tres",
	"Watchtower": "res://data/buildings/Monastery_Watchtower.tres"
}

func _run():
	print("=== SETTLEMENT LAYOUT EDITOR ===")
	print("Available buildings:")
	for name in BUILDINGS.keys():
		print("  - %s: %s" % [name, BUILDINGS[name]])
	
	print("\n=== EXAMPLE LAYOUTS ===")
	
	# Example 1: Small Defensive Settlement
	var small_defensive = create_small_defensive_layout()
	print("\n1. SMALL DEFENSIVE LAYOUT:")
	print_layout(small_defensive)
	save_layout(small_defensive, "res://data/settlements/small_defensive.tres")
	
	# Example 2: Economic Settlement
	var economic = create_economic_layout()
	print("\n2. ECONOMIC LAYOUT:")
	print_layout(economic)
	save_layout(economic, "res://data/settlements/economic_base.tres")
	
	# Example 3: Monastery Layout
	var monastery = create_monastery_layout()
	print("\n3. MONASTERY LAYOUT:")
	print_layout(monastery)
	save_layout(monastery, "res://data/settlements/monastery_base.tres")
	
	print("\n=== LAYOUT FILES CREATED ===")
	print("You can now use these layouts by:")
	print("1. Loading them in the Inspector on SettlementBridge")
	print("2. Or copying the placement arrays manually")

func create_small_defensive_layout() -> Array[Dictionary]:
	return [
		# Great Hall in center
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(8, 6)},
		
		# Defensive walls around perimeter
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(7, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(11, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(13, 4)},
		
		# Watchtowers at corners
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(4, 3)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(14, 3)},
		
		# Basic resource building
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 8)}
	]

func create_economic_layout() -> Array[Dictionary]:
	return [
		# Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 8)},
		
		# Economic buildings clustered together
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(8, 6)},
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(12, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(14, 6)},
		
		# Minimal defenses
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(10, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(10, 3)}
	]

func create_monastery_layout() -> Array[Dictionary]:
	return [
		# Central Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 10)},
		
		# Monastery buildings in organized pattern
		{"resource_path": BUILDINGS["Chapel"], "grid_position": Vector2i(8, 7)},
		{"resource_path": BUILDINGS["Library"], "grid_position": Vector2i(12, 7)},
		{"resource_path": BUILDINGS["Scriptorium"], "grid_position": Vector2i(8, 13)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(12, 13)},
		
		# Outer walls for protection
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(14, 5)},
		
		# Watchtowers
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 15)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 15)}
	]

func print_layout(layout: Array[Dictionary]):
	for i in range(layout.size()):
		var building = layout[i]
		var name = get_building_name(building["resource_path"])
		var pos = building["grid_position"]
		print("  [%d] %s at (%d, %d)" % [i, name, pos.x, pos.y])

func get_building_name(path: String) -> String:
	for name in BUILDINGS.keys():
		if BUILDINGS[name] == path:
			return name
	return "Unknown"

func save_layout(layout: Array[Dictionary], path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 200, "stone": 300}
	settlement.placed_buildings = layout
	settlement.garrisoned_units = {"res://data/units/Unit_PlayerRaider.tres": 3}
	
	var error = ResourceSaver.save(settlement, path)
	if error == OK:
		print(" Saved layout to: %s" % path)
	else:
		print(" Failed to save layout to: %s" % path)

--- SCRIPT: res://ui/DynastyUI.gd ---
# res://ui/DynastyUI.gd
#
# Manages the "Dynasty" UI panel, which allows the player
# to spend heirs as a resource for the "Progenitor" pillar.
class_name DynastyUI
extends PanelContainer

@onready var title_label: Label = $Margin/VBox/TitleLabel
@onready var heirs_container: VBoxContainer = $Margin/VBox/HeirsContainer
@onready var close_button: Button = $Margin/VBox/CloseButton

# Expedition cost from proposal 
const EXPEDITION_GOLD_COST = 500

func _ready() -> void:
	close_button.pressed.connect(hide)
	
	# Connect to the DynastyManager to refresh when Jarl data changes
	DynastyManager.jarl_stats_updated.connect(_on_jarl_stats_updated)
	
	# Initial population
	if DynastyManager.current_jarl:
		_on_jarl_stats_updated(DynastyManager.get_current_jarl())
	
	hide() # Start hidden by default

func _on_jarl_stats_updated(jarl: JarlData) -> void:
	"""Refreshes all UI elements with the latest Jarl data."""
	if not jarl:
		return
		
	title_label.text = "%s's Dynasty" % jarl.display_name
	
	# Clear existing heirs
	for child in heirs_container.get_children():
		child.queue_free()
		
	# Populate heirs list
	if jarl.heirs.is_empty():
		var label = Label.new()
		label.text = "No valid heirs."
		heirs_container.add_child(label)
		return

	# Check current gold for button disabling
	var current_gold = 0
	if SettlementManager.current_settlement:
		current_gold = SettlementManager.current_settlement.treasury.get("gold", 0)

	for heir in jarl.heirs:
		if not heir: continue
		
		var heir_row = HBoxContainer.new()
		heir_row.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		
		var name_label = Label.new()
		name_label.text = " %s (%d)" % [heir.display_name, heir.age]
		name_label.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		heir_row.add_child(name_label)

		match heir.status:
			JarlHeirData.HeirStatus.Available:
				var expedition_button = Button.new()
				expedition_button.text = "Send on Expedition"
				expedition_button.tooltip_text = "Cost: 1 Heir, %d Gold" % EXPEDITION_GOLD_COST
				
				if current_gold < EXPEDITION_GOLD_COST:
					expedition_button.disabled = true
					expedition_button.tooltip_text += "\n(Not enough Gold)"
				
				expedition_button.pressed.connect(_on_expedition_pressed.bind(heir))
				heir_row.add_child(expedition_button)
				
				# TODO: Add "Marry for Alliance" button here
			
			JarlHeirData.HeirStatus.OnExpedition:
				var status_label = Label.new()
				status_label.text = "On Expedition (%d years)" % heir.expedition_years_remaining
				status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
				heir_row.add_child(status_label)
				
			JarlHeirData.HeirStatus.MarriedOff:
				var status_label = Label.new()
				status_label.text = "Married Away"
				status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
				heir_row.add_child(status_label)
			
			_:
				var status_label = Label.new()
				status_label.text = "Unavailable"
				status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
				heir_row.add_child(status_label)

		heirs_container.add_child(heir_row)


func _on_expedition_pressed(heir: JarlHeirData) -> void:
	"""Called when an 'Send on Expedition' button is pressed."""
	
	var cost = {"gold": EXPEDITION_GOLD_COST}
	
	# 1. Attempt to spend the gold
	if SettlementManager.attempt_purchase(cost):
		# 2. If gold spend is successful, spend the heir
		print("DynastyUI: Spent %d gold. Sending heir %s on expedition." % [EXPEDITION_GOLD_COST, heir.display_name])
		DynastyManager.start_heir_expedition(heir)
		
		# UI will refresh automatically via the jarl_stats_updated signal
	else:
		# This shouldn't happen if the button is disabled, but as a fallback.
		print("DynastyUI: Expedition failed. Not enough gold.")
		EventBus.purchase_failed.emit("Not enough Gold")

--- SCRIPT: res://ui/EndOfYear_Popup.gd ---
# res://ui/EndOfYear_Popup.gd
extends PanelContainer

signal collect_button_pressed(payout: Dictionary)

@onready var payout_label: Label = $MarginContainer/VBoxContainer/PayoutLabel
@onready var collect_button: Button = $MarginContainer/VBoxContainer/CollectButton

var _current_payout: Dictionary = {}

func _ready() -> void:
	collect_button.pressed.connect(_on_collect_pressed)
	
	# --- MODIFICATION ---
	# Update the button text as requested
	collect_button.text = "Collect and return to settlement"
	# --- END MODIFICATION ---
	
	hide()

func display_payout(payout: Dictionary, title: String = "Welcome home!") -> void:
	if payout.is_empty():
		# If there's no payout, just emit the signal and don't show
		collect_button_pressed.emit({})
		return

	_current_payout = payout
	
	# Use the new title parameter
	var payout_text: String = "%s\n\nResources gathered:\n" % title
	for resource_type in payout:
		payout_text += "- %s: %d\n" % [resource_type.capitalize(), payout[resource_type]]
	
	payout_label.text = payout_text
	show()

func _on_collect_pressed() -> void:
	collect_button_pressed.emit(_current_payout)
	hide()

--- SCRIPT: res://ui/Event_UI.gd ---
# res://ui/Event_UI.gd
#
# Controller script for the modal event window (Event_UI.tscn).
# This scene is responsible for displaying an EventData resource
# and returning the player's choice.
class_name EventUI
extends CanvasLayer

## Emitted when the player clicks a choice button.
## Passes the EventData and the chosen EventChoice.
signal choice_made(event: EventData, choice: EventChoice)

# Node References
@onready var title_label: Label = $PanelContainer/Margin/VBox/TitleLabel
@onready var description_label: Label = $PanelContainer/Margin/VBox/HBox/DescriptionLabel
@onready var portrait: TextureRect = %Portrait
@onready var choice_buttons_container: VBoxContainer = $PanelContainer/Margin/VBox/ChoiceButtonsContainer

var current_event: EventData

func _ready() -> void:
	# Start hidden. The EventManager will show this UI.
	hide()
	
	# Set process mode to "When Paused" so it works even if
	# the EventManager pauses the game to show the event.
	process_mode = Node.PROCESS_MODE_WHEN_PAUSED

func display_event(event_data: EventData) -> void:
	"""
	Configures and displays the event window based on an EventData resource.
	"""
	if not event_data:
		push_error("EventUI: Cannot display a null EventData resource.")
		return
		
	current_event = event_data
	
	# 1. Populate Text
	title_label.text = event_data.title
	description_label.text = event_data.description
	
	# 2. Populate Portrait
	if event_data.portrait:
		portrait.texture = event_data.portrait
		portrait.show()
	else:
		portrait.texture = null
		portrait.hide()
		
	# 3. Clear and Create Choice Buttons
	for child in choice_buttons_container.get_children():
		child.queue_free()
		
	if event_data.choices.is_empty():
		# Create a default "OK" button if no choices are provided
		var ok_button = Button.new()
		ok_button.text = "OK"
		ok_button.pressed.connect(_on_choice_button_pressed.bind(null))
		choice_buttons_container.add_child(ok_button)
	else:
		# Create a button for each choice
		for choice in event_data.choices:
			var choice_button = Button.new()
			choice_button.text = choice.choice_text
			choice_button.tooltip_text = choice.tooltip_text
			choice_button.pressed.connect(_on_choice_button_pressed.bind(choice))
			choice_buttons_container.add_child(choice_button)
			
	# 4. Show the UI
	show()
	
	# Grab focus so gamepad/keyboard input works
	# A CanvasLayer can't grab focus, so we focus the first button
	var first_button = choice_buttons_container.get_child(0) as Button
	if first_button:
		first_button.grab_focus()

func _on_choice_button_pressed(choice: EventChoice) -> void:
	"""
	Called when any choice button is pressed.
	Emits the signal and hides the window.
	"""
	hide()
	choice_made.emit(current_event, choice)
	current_event = null

--- SCRIPT: res://ui/SelectionBox.gd ---
# res://ui/SelectionBox.gd
# This Control node covers the entire screen.
# It listens for
# raw input, draws the selection box, and emits clean,
# intent-based signals to the EventBus.
# It also uses
# accept_event() to stop input from passing through the UI.
extends Control

var is_dragging := false
var start_pos := Vector2.ZERO
var is_command_dragging := false
var command_start_pos := Vector2.ZERO
# ---------------------------

func _ready() -> void:
	#Allow unused mouse events (like Zoom) to pass to the Camera
	mouse_filter = Control.MOUSE_FILTER_PASS

func _gui_input(event: InputEvent) -> void:
	# We use _gui_input, which is only called if the mouse
	# is over this Control. Since it's fullscreen,
	# this will always be the case.
	
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.is_pressed():
				is_dragging = true
				start_pos = get_local_mouse_position()
				# This is the UI-bug-fix. We consume the
				# event so nothing else can process it.
				accept_event()
			elif is_dragging: # On Left-Click Release
				is_dragging = false
				var end_pos := get_local_mouse_position()
				var rect := Rect2(start_pos, end_pos - start_pos).abs()
				
				# Check if it was a "drag" or just a "click"
				# A 'click' is a box with a very small area.
				var is_box_select = rect.size.length_squared() > 100 # 10x10 px
				
				# Emit the clean command for the RTSController
				EventBus.emit_signal("select_command", rect, is_box_select)
				
				queue_redraw() # Clear the box
				accept_event()
		
		# --- MODIFIED: Handle Right Click Drag ---
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			if event.is_pressed():
				is_command_dragging = true
				command_start_pos = get_local_mouse_position()
				accept_event()
			else: # On Right-Click Release
				if not is_command_dragging:
					# This can happen if the click started outside the window
					# and was released inside. Ignore it.
					return
					
				is_command_dragging = false
				var end_pos = get_local_mouse_position()
				var drag_vector = end_pos - command_start_pos
				
				var main_camera: Camera2D = get_viewport().get_camera_2d()
				if not main_camera: 
					push_error("SelectionBox: No Camera2D found.")
					return

				# Convert screen positions to world
				# We use get_global_mouse_position() for the *end*
				# and calculate the start based on the drag vector
				var world_end_pos = main_camera.get_global_mouse_position()
				var world_start_pos = world_end_pos - (drag_vector / main_camera.zoom)
				
				# Check if it was a drag or just a click
				if drag_vector.length_squared() > 225: # 15px drag threshold
					# It was a drag. Emit formation move.
					# The direction is from start to end
					var world_drag_vector = (world_end_pos - world_start_pos).normalized()
					EventBus.formation_move_command.emit(world_start_pos, world_drag_vector)
				else:
					# It was a click. Do smart command.
					_handle_smart_command(end_pos)
					
				queue_redraw() # Clear drag line
				accept_event()
		# -----------------------------------------
	
	elif event is InputEventMouseMotion:
		if is_dragging or is_command_dragging:
			# Update the draw loop as the mouse moves
			queue_redraw()
			accept_event()

func _handle_smart_command(_screen_pos: Vector2) -> void:
	# This function determines if a right-click
	# is a "move" or "attack" command.
	var world_space: PhysicsDirectSpaceState2D = get_world_2d().direct_space_state
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	
	if not main_camera:
		push_error("SelectionBox: No Camera2D found in viewport.")
		return
		
	# Convert screen position to world position
	var world_pos: Vector2 = main_camera.get_global_mouse_position()
	
	var query := PhysicsPointQueryParameters2D.new()
	query.position = world_pos
	query.collide_with_areas = true
	query.collide_with_bodies = true
	
	# --- MODIFIED: Collision Mask ---
	# We now attack Layer 3 (Enemy Units) and Layer 4 (Enemy Buildings)
	# Binary 1100 = 12
	query.collision_mask = 12 
	# --------------------------------
	
	var results: Array = world_space.intersect_point(query)
	
	if not results.is_empty():
		# We hit an enemy! Emit an attack command.
		var target = results[0].collider
		EventBus.emit_signal("attack_command", target)
	else:
		# We hit the ground. Emit a move command.
		EventBus.emit_signal("move_command", world_pos)

func _draw() -> void:
	# This function draws the selection box
	if is_dragging:
		var current_pos := get_local_mouse_position()
		var rect := Rect2(start_pos, current_pos - start_pos).abs()
		
		# Draw a semi-transparent fill
		draw_rect(rect, Color(0.8, 0.8, 1.0, 0.2), true)
		# Draw a solid outline
		draw_rect(rect, Color(0.8, 0.8, 1.0, 1.0), false, 1.0)
	
	# --- NEW: Draw command drag line ---
	if is_command_dragging:
		var current_pos := get_local_mouse_position()
		draw_line(command_start_pos, current_pos, Color.GREEN, 2.0)
		draw_circle(command_start_pos, 5.0, Color.GREEN)
		draw_circle(current_pos, 3.0, Color.GREEN)
	# ----------------------------------

--- SCRIPT: res://ui/StorefrontUI.gd ---
# res://ui/StorefrontUI.gd (Fully Refactored)
extends Control

const LegacyUpgradeData = preload("res://data/legacy/LegacyUpgradeData.gd")
# --- Node References ---
@onready var gold_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/GoldLabel
@onready var wood_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/WoodLabel
@onready var food_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/FoodLabel
@onready var stone_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/StoneLabel

@onready var build_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/BuildTab/BuildButtonsContainer

@onready var recruit_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/RecruitButtons
@onready var garrison_list_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/GarrisonList

# --- Legacy Tab References ---
@onready var renown_label: Label = $PanelContainer/MarginContainer/TabContainer/LegacyTab/JarlStatsDisplay/RenownLabel
@onready var authority_label: Label = $PanelContainer/MarginContainer/TabContainer/LegacyTab/JarlStatsDisplay/AuthorityLabel
@onready var legacy_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/LegacyTab/LegacyButtonsContainer

# --- Exported Data ---
@export var available_buildings: Array[BuildingData] = []
@export var available_units: Array[UnitData] = []
@export var default_treasury_display: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}
@export var auto_load_units_from_directory: bool = true

# --- Internal state ---
var minimum_inherited_legitimacy: int = 0 

func _ready() -> void:
	# --- FIX: Allow unused mouse events to pass to the Camera ---
	mouse_filter = Control.MOUSE_FILTER_PASS
	# ------------------------------------------------------------

	# Connect to SettlementManager for treasury
	EventBus.treasury_updated.connect(_update_treasury_display)
	EventBus.purchase_successful.connect(_on_purchase_successful)
	
	# Connect to settlement loading signal to update treasury when settlement loads
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	
	# Initial treasury display - defer to ensure settlement is loaded
	call_deferred("_update_initial_treasury")

	# Connect to DynastyManager for Jarl stats
	DynastyManager.jarl_stats_updated.connect(_update_jarl_stats_display)
	
	# Initial load
	_load_building_data()
	_load_unit_data()
	
	# Setup UI
	if DynastyManager.current_jarl:
		_update_jarl_stats_display(DynastyManager.get_current_jarl())
	
	_setup_recruit_buttons()
	_update_garrison_display()
	_populate_legacy_buttons() 

# --- Utility Functions ---
func _format_cost(cost: Dictionary) -> String:
	var cost_parts: Array[String] = []
	for resource in cost:
		cost_parts.append("%d %s" % [cost[resource], resource])
	return ", ".join(cost_parts)

func _update_treasury_display(new_treasury: Dictionary) -> void:
	gold_label.text = "Gold: %d" % new_treasury.get("gold", 0)
	wood_label.text = "Wood: %d" % new_treasury.get("wood", 0)
	food_label.text = "Food: %d" % new_treasury.get("food", 0)
	stone_label.text = "Stone: %d" % new_treasury.get("stone", 0)

func _on_purchase_successful(item_name: String) -> void:
	if item_name.contains("Raider") or item_name.contains("Unit"):
		_update_garrison_display()

func _on_settlement_loaded(settlement_data: SettlementData) -> void:
	"""Called when settlement is loaded to update treasury display"""
	if settlement_data and settlement_data.treasury:
		_update_treasury_display(settlement_data.treasury)
	else:
		_update_treasury_display(default_treasury_display)

func _update_initial_treasury() -> void:
	"""Deferred treasury update to ensure settlement is loaded"""
	if SettlementManager.current_settlement and SettlementManager.current_settlement.treasury:
		_update_treasury_display(SettlementManager.current_settlement.treasury)
	else:
		_update_treasury_display(default_treasury_display)

func _update_garrison_display() -> void:
	if not garrison_list_container: return
	
	for child in garrison_list_container.get_children():
		child.queue_free()
	
	if not SettlementManager.current_settlement: return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	if garrison.is_empty():
		var empty_garrison_label = Label.new()
		empty_garrison_label.text = "No units in garrison"
		garrison_list_container.add_child(empty_garrison_label)
		return
	
	var header_label = Label.new()
	header_label.text = "Current Garrison:"
	header_label.add_theme_font_size_override("font_size", 16)
	garrison_list_container.add_child(header_label)
	
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		if unit_data:
			var unit_label = Label.new()
			unit_label.text = " %s x%d" % [unit_data.display_name, unit_count]
			garrison_list_container.add_child(unit_label)
	
	var total_units = 0
	for unit_path in garrison:
		total_units += garrison[unit_path]
	
	var total_label = Label.new()
	total_label.text = "Total units: %d" % total_units
	total_label.add_theme_font_size_override("font_size", 12)
	garrison_list_container.add_child(total_label)

# --- Jarl Stats UI ---
func _update_jarl_stats_display(jarl_data: JarlData) -> void:
	if not jarl_data: return
	renown_label.text = "Renown: %d" % jarl_data.renown
	authority_label.text = "Authority: %d / %d" % [jarl_data.current_authority, jarl_data.max_authority]
	_populate_legacy_buttons()

func _populate_legacy_buttons() -> void:
	for child in legacy_buttons_container.get_children():
		child.queue_free()
	
	if DynastyManager.loaded_legacy_upgrades.is_empty():
		var placeholder_label = Label.new()
		placeholder_label.text = "No legacy upgrades found."
		legacy_buttons_container.add_child(placeholder_label)
		return
	
	var jarl = DynastyManager.get_current_jarl()
	if not jarl: return

	var is_pious = jarl.has_trait("Pious")

	for upgrade_data in DynastyManager.loaded_legacy_upgrades:
		var current_renown_cost = upgrade_data.renown_cost
		var trait_modifier_text = ""
		
		if is_pious and upgrade_data.effect_key == "UPG_BUILD_CHAPEL":
			current_renown_cost = max(0, upgrade_data.renown_cost - 25)
			trait_modifier_text = " (-25 Pious)"

		var button = Button.new()
		var cost_text = "Cost: %d Renown%s, %d Auth" % [current_renown_cost, trait_modifier_text, upgrade_data.authority_cost]
		
		var title_text = upgrade_data.display_name
		if upgrade_data.required_progress > 1:
			title_text += " (%d/%d)" % [upgrade_data.current_progress, upgrade_data.required_progress]
		
		button.text = "%s\n%s" % [title_text, cost_text]
		button.tooltip_text = upgrade_data.description
		
		# --- FIX: Constrain Legacy Button Icons too ---
		if upgrade_data.icon:
			button.icon = upgrade_data.icon
			button.expand_icon = true
			button.custom_minimum_size = Vector2(0, 64)
			button.alignment = HORIZONTAL_ALIGNMENT_LEFT
			button.icon_alignment = HORIZONTAL_ALIGNMENT_LEFT
		# ---------------------------------------------
		
		var can_buy_renown = jarl.renown >= current_renown_cost
		var can_buy_auth = jarl.current_authority >= upgrade_data.authority_cost
		
		if upgrade_data.is_purchased:
			button.disabled = true
			button.text = "%s (Completed)" % upgrade_data.display_name
		elif not can_buy_renown:
			button.disabled = true
			button.text += "\n(Not enough Renown)"
		elif not can_buy_auth:
			button.disabled = true
			button.text += "\n(Not enough Authority)"
		
		button.pressed.connect(_on_legacy_upgrade_pressed.bind(upgrade_data, current_renown_cost))
		legacy_buttons_container.add_child(button)

func _on_legacy_upgrade_pressed(upgrade_data: LegacyUpgradeData, final_renown_cost: int) -> void:
	if not DynastyManager.can_spend_renown(final_renown_cost):
		EventBus.purchase_failed.emit("Not enough Renown")
		return
	if not DynastyManager.can_spend_authority(upgrade_data.authority_cost):
		EventBus.purchase_failed.emit("Not enough Authority")
		return
	
	var spent_renown = DynastyManager.spend_renown(final_renown_cost)
	var spent_auth = DynastyManager.spend_authority(upgrade_data.authority_cost)
	
	if spent_renown and spent_auth:
		upgrade_data.current_progress += 1
		if upgrade_data.is_purchased:
			DynastyManager.purchase_legacy_upgrade(upgrade_data.effect_key)
			_apply_legacy_upgrade_effect(upgrade_data.effect_key)
		_populate_legacy_buttons()
		EventBus.purchase_successful.emit(upgrade_data.display_name)

func _apply_legacy_upgrade_effect(effect_key: String) -> void:
	match effect_key:
		"UPG_TRELLEBORG":
			if SettlementManager.current_settlement:
				SettlementManager.current_settlement.max_garrison_bonus += 10
				SettlementManager.save_settlement()
		"UPG_JELLING_STONE":
			var jarl = DynastyManager.get_current_jarl()
			if jarl:
				jarl.heir_starting_renown_bonus += 50
				DynastyManager.minimum_inherited_legitimacy = 25
		"UPG_BUILD_CHAPEL":
			print("Applied UPG_BUILD_CHAPEL: Dynasty's piety increased.")

# --- Building Tab Functions ---
func _load_building_data() -> void:
	var dir = DirAccess.open("res://data/buildings/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var building_path = "res://data/buildings/" + file_name
				var building_data = load(building_path) as BuildingData
				if building_data and building_data.is_player_buildable:
					_create_building_button(building_data)
			file_name = dir.get_next()

func _create_building_button(building_data: BuildingData) -> void:
	var button = Button.new()
	button.text = "%s (Cost: %s)" % [building_data.display_name, _format_cost(building_data.build_cost)]
	
	# --- FIX: Constrain Building Icons ---
	if building_data.icon:
		button.icon = building_data.icon
		button.expand_icon = true # Force icon to scale
		button.custom_minimum_size = Vector2(0, 64) # Force button height
		button.alignment = HORIZONTAL_ALIGNMENT_LEFT
		button.icon_alignment = HORIZONTAL_ALIGNMENT_LEFT
	# -------------------------------------
	
	button.pressed.connect(_on_buy_button_pressed.bind(building_data))
	build_buttons_container.add_child(button)

func _on_buy_button_pressed(item_data: BuildingData) -> void:
	if not item_data: return
	if SettlementManager.attempt_purchase(item_data.build_cost):
		EventBus.building_ready_for_placement.emit(item_data)
	else:
		print("UI received purchase failure for '%s'." % item_data.display_name)

# --- Recruit Tab Functions ---
func _load_unit_data() -> void:
	var dir = DirAccess.open("res://data/units/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var unit_path = "res://data/units/" + file_name
				var unit_data = load(unit_path) as UnitData
				if unit_data and _is_player_unit(unit_data):
					available_units.append(unit_data)
			file_name = dir.get_next()

func _setup_recruit_buttons() -> void:
	for unit_data in available_units:
		var button = Button.new()
		button.text = "%s (Cost: %s)" % [unit_data.display_name, _format_cost(unit_data.spawn_cost)]
		
		# --- FIX: Constrain Recruit Icons ---
		if unit_data.icon:
			button.icon = unit_data.icon
			button.expand_icon = true # Force icon to scale
			button.custom_minimum_size = Vector2(0, 64) # Force button height
			button.alignment = HORIZONTAL_ALIGNMENT_LEFT
			button.icon_alignment = HORIZONTAL_ALIGNMENT_LEFT
		# ------------------------------------

		button.pressed.connect(_on_recruit_button_pressed.bind(unit_data))
		recruit_buttons_container.add_child(button)

func _is_player_unit(unit_data: UnitData) -> bool:
	if not unit_data: return false
	if "Player" in unit_data.display_name: return true
	if "Player" in unit_data.resource_path: return true
	if unit_data.scene_to_spawn and "Player" in unit_data.scene_to_spawn.resource_path: return true
	if unit_data.display_name in ["Viking Raider"]: return false
	return true

func _on_recruit_button_pressed(unit_data: UnitData) -> void:
	if not unit_data: return
	if SettlementManager.attempt_purchase(unit_data.spawn_cost):
		SettlementManager.recruit_unit(unit_data)

--- SCRIPT: res://ui/Succession_Crisis_UI.gd ---
# res://ui/Succession_Crisis_UI.gd
extends CanvasLayer

# --- Node Refs ---
@onready var desc_label = $PanelContainer/MarginContainer/VBoxContainer/DescriptionLabel
@onready var legit_label = $PanelContainer/MarginContainer/VBoxContainer/LegitimacyLabel
@onready var renown_desc = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxDescription
@onready var gold_desc = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxDescription
@onready var pay_renown_btn = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons/PayRenownButton
@onready var refuse_renown_btn = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons/RefuseRenownButton
@onready var pay_gold_btn = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons/PayGoldButton
@onready var refuse_gold_btn = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons/RefuseGoldButton
@onready var confirm_btn = $PanelContainer/MarginContainer/VBoxContainer/ConfirmButton

# --- State ---
var renown_tax: int = 0
var gold_tax: int = 0
var renown_choice: String = "pay"
var gold_choice: String = "pay"

func _ready() -> void:
	# Create ButtonGroups
	var renown_group = ButtonGroup.new()
	pay_renown_btn.button_group = renown_group
	refuse_renown_btn.button_group = renown_group
	
	var gold_group = ButtonGroup.new()
	pay_gold_btn.button_group = gold_group
	refuse_gold_btn.button_group = gold_group
	
	pay_renown_btn.pressed.connect(_on_renown_choice.bind("pay"))
	refuse_renown_btn.pressed.connect(_on_renown_choice.bind("refuse"))
	pay_gold_btn.pressed.connect(_on_gold_choice.bind("pay"))
	refuse_gold_btn.pressed.connect(_on_gold_choice.bind("refuse"))
	confirm_btn.pressed.connect(_on_confirm)

func display_crisis(jarl: JarlData, settlement: SettlementData) -> void:
	var legitimacy = jarl.legitimacy
	legit_label.text = "New Legitimacy: %d/100" % legitimacy
	
	# --- Calculate Taxes (Higher legitimacy = lower taxes) ---
	var tax_multiplier = 1.0 - (legitimacy / 100.0) # 100 legit = 0x, 20 legit = 0.8x
	
	# Renown Tax
	renown_tax = int(max(50, DynastyManager.get_current_jarl().renown * 0.2) * tax_multiplier)
	pay_renown_btn.text = "Pay %d Renown" % renown_tax
	refuse_renown_btn.text = "Refuse (Risk Project Setbacks)"
	
	# --- FIX: Update Description Text Dynamically ---
	renown_desc.text = "Pay %d Renown to protect your legacy, or refuse and risk setbacks." % renown_tax
	# -----------------------------------------------
	
	# Gold Tax
	gold_tax = int(max(200, settlement.treasury.get("gold", 0) * 0.3) * tax_multiplier)
	pay_gold_btn.text = "Pay %d Gold" % gold_tax
	refuse_gold_btn.text = "Refuse (Risk Instability)"
	
	# --- FIX: Update Description Text Dynamically ---
	gold_desc.text = "Pay %d Gold to ensure loyalty, or refuse and risk instability." % gold_tax
	# -----------------------------------------------
	
	# Check affordability
	if jarl.renown < renown_tax:
		pay_renown_btn.disabled = true
		refuse_renown_btn.button_pressed = true
		renown_choice = "refuse"
	else:
		pay_renown_btn.button_pressed = true
		renown_choice = "pay"
	
	if settlement.treasury.get("gold", 0) < gold_tax:
		pay_gold_btn.disabled = true
		refuse_gold_btn.button_pressed = true
		gold_choice = "refuse"
	else:
		pay_gold_btn.button_pressed = true
		gold_choice = "pay"
	
	show()

func _on_renown_choice(choice: String) -> void:
	renown_choice = choice

func _on_gold_choice(choice: String) -> void:
	gold_choice = choice

func _on_confirm() -> void:
	# 1. Apply costs
	if renown_choice == "pay":
		DynastyManager.spend_renown(renown_tax)
	if gold_choice == "pay":
		SettlementManager.attempt_purchase({"gold": gold_tax})
	
	# 2. Emit choices to EventManager/DynastyManager for consequences
	EventBus.succession_choices_made.emit(renown_choice, gold_choice)
	
	# 3. Close the window
	queue_free()

--- SCRIPT: res://ui/WorkAssignment_UI.gd ---
# res://ui/WorkAssignment_UI.gd
extends CanvasLayer

signal assignments_confirmed(assignments: Dictionary)

@onready var total_pop_label: Label = $PanelContainer/MarginContainer/VBoxContainer/Header/TotalPopLabel
@onready var available_pop_label: Label = $PanelContainer/MarginContainer/VBoxContainer/Header/AvailablePopLabel
@onready var sliders_container: VBoxContainer = $PanelContainer/MarginContainer/VBoxContainer/SlidersContainer
@onready var confirm_button: Button = $PanelContainer/MarginContainer/VBoxContainer/ConfirmButton

var prediction_label: RichTextLabel

var current_settlement: SettlementData
var temp_assignments: Dictionary = {}
var total_population: int = 0
var available_population: int = 0

# --- NEW: Capacity Tracking ---
var labor_capacities: Dictionary = {} 
# ------------------------------

var sliders: Dictionary = {} 
var labels: Dictionary = {}  

func _ready() -> void:
	confirm_button.pressed.connect(_on_confirm_pressed)
	confirm_button.text = "Confirm Assignments"
	
	prediction_label = RichTextLabel.new()
	prediction_label.name = "PredictionLabel"
	prediction_label.fit_content = true
	prediction_label.bbcode_enabled = true
	prediction_label.custom_minimum_size = Vector2(0, 60)
	
	var container = $PanelContainer/MarginContainer/VBoxContainer
	container.add_child(prediction_label)
	container.move_child(prediction_label, container.get_child_count() - 2)
	
	hide()

func setup(settlement: SettlementData) -> void:
	current_settlement = settlement
	total_population = settlement.population_total
	
	# --- NEW: Fetch Capacities ---
	if SettlementManager.has_method("get_labor_capacities"):
		labor_capacities = SettlementManager.get_labor_capacities()
	else:
		labor_capacities = {"construction": 100, "food": 100, "wood": 100, "stone": 100}
	# -----------------------------
	
	# Initialize temp assignments (Gold Removed)
	temp_assignments = {
		"construction": 0,
		"food": 0,
		"wood": 0,
		"stone": 0
	}
	
	# Restore saved values if valid
	for key in temp_assignments:
		if current_settlement.worker_assignments.has(key):
			# Clamp to current capacity in case buildings were lost
			temp_assignments[key] = min(current_settlement.worker_assignments[key], labor_capacities.get(key, 0))
	
	_rebuild_ui()
	_update_calculations()
	show()

func _rebuild_ui() -> void:
	for child in sliders_container.get_children():
		child.queue_free()
	sliders.clear()
	labels.clear()
	
	# --- MODIFIED: Gold Removed ---
	var categories = ["construction", "food", "wood", "stone"]
	
	for category in categories:
		_create_slider_row(category)

func _create_slider_row(category: String) -> void:
	var row = HBoxContainer.new()
	
	var name_label = Label.new()
	name_label.text = category.capitalize()
	name_label.custom_minimum_size = Vector2(100, 0)
	row.add_child(name_label)
	
	# --- NEW: Capacity Logic ---
	var capacity = labor_capacities.get(category, 0)
	# The absolute max is capped by BOTH total population AND building capacity
	var max_assignable = min(total_population, capacity)
	
	var slider = HSlider.new()
	slider.min_value = 0
	slider.max_value = max_assignable
	slider.value = temp_assignments.get(category, 0)
	slider.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	# Disable slider if no capacity (e.g., no blueprints for construction)
	if max_assignable == 0:
		slider.editable = false
		slider.modulate = Color(0.5, 0.5, 0.5)
	
	slider.value_changed.connect(_on_slider_changed.bind(category))
	row.add_child(slider)
	sliders[category] = slider
	
	var value_label = Label.new()
	# Display as "Assigned / Capacity"
	value_label.text = "%d / %d" % [slider.value, capacity]
	value_label.custom_minimum_size = Vector2(60, 0)
	value_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	row.add_child(value_label)
	labels[category] = value_label
	
	sliders_container.add_child(row)

func _on_slider_changed(value: float, category: String) -> void:
	var new_val = int(value)
	var current_usage = 0
	for key in temp_assignments:
		if key != category:
			current_usage += temp_assignments[key]
	
	# Check Global Pop Limit
	if current_usage + new_val > total_population:
		new_val = total_population - current_usage
		sliders[category].set_value_no_signal(new_val)
	
	temp_assignments[category] = new_val
	_update_calculations()

func _update_calculations() -> void:
	var assigned_count = 0
	for key in temp_assignments:
		assigned_count += temp_assignments[key]
		if labels.has(key):
			var capacity = labor_capacities.get(key, 0)
			labels[key].text = "%d / %d" % [temp_assignments[key], capacity]
	
	available_population = total_population - assigned_count
	
	total_pop_label.text = "Total Population: %d" % total_population
	available_pop_label.text = "Idle: %d" % available_population
	
	if available_population < 0:
		available_pop_label.modulate = Color.RED
		confirm_button.disabled = true
	else:
		available_pop_label.modulate = Color.GREEN
		confirm_button.disabled = false

	if SettlementManager.has_method("simulate_turn"):
		var prediction = SettlementManager.simulate_turn(temp_assignments)
		_update_prediction_display(prediction)

func _update_prediction_display(data: Dictionary) -> void:
	if not prediction_label: return
	
	var text = "[b]Estimated Outcome:[/b]\n"
	var res = data.get("resources_gained", {})
	var res_str = ""
	
	for r in res:
		if res[r] > 0:
			var color_tag = "[color=white]"
			if r == "food": color_tag = "[color=salmon]"
			elif r == "wood": color_tag = "[color=burlywood]"
			
			res_str += "%s+%d %s[/color]  " % [color_tag, res[r], r.capitalize()]
	
	if res_str != "":
		text += res_str + "\n"
	else:
		text += "[color=gray]No resource gain[/color]\n"
		
	var completed = data.get("buildings_completing", [])
	if not completed.is_empty():
		text += "[color=green]Completing: " + ", ".join(completed) + "[/color]"
	
	prediction_label.text = text

func _on_confirm_pressed() -> void:
	hide()
	assignments_confirmed.emit(temp_assignments)
--- END OF CODEBASE ---

---
