### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. GDD`**: The Game Design Document.
*   **`3. DevLog`**: A log of implemented features and changes.
*   **`4. Project Context`**: The technical project dump, including:
	*   `4.1. Project Settings`
	*   `4.2. Resource Files`
	*   `4.3. Scene Structures`
	*   `4.4. Codebase`

---
### **2. GDD**

 Viking Dynasty GDD v1.72
1. High-Level Concept & Vision
(Unchanged from v1.62)
Viking Dynasty is a strategy game that blends the dynastic ambition and grand strategy of Crusader Kings with the tactical, real-time battles of Age of Empires II.
Players will manage a Viking dynasty, not just a single character. They will forge alliances, declare wars, and manage their growing family on a strategic world map (the Macro layer). When battles occur or raids are launched, the game will transition into a real-time strategy mission (the Micro layer). The bridge between these two layers is the player's persistent, grid-based Settlement, which they will build, upgrade, and defend.
The core tension is balancing the long-term needs of your dynasty (geopolitics, heirs) with the immediate, visceral needs of combat (resources, unit control), all while protecting your home from rival Jarls.
Target Audience: Players who enjoy deep strategic systems (e.g., Paradox titles) but also crave tactical, skill-based RTS combat (e.g., Age of Empires, Company of Heroes).
Genre: Grand Strategy / Real-Time Strategy (RTS) Hybrid.
Theme: Viking Age, focusing on the grit, ambition, and legacy of a Norse dynasty.
2. Core Gameplay Loop: The Three Layers
(Unchanged from v1.62)
The gameplay is built on three interconnected layers: the Macro (Dynasty), the Micro (RTS), and the Bridge (Settlement).
2.A. The Macro (Dynasty Layer)
This is the "Crusader Kings" layer. It is the top-level grand strategy map of Scandinavia and beyond.
Gameplay: Turn-based or pausable real-time.
Player Actions: Managing family and heirs, diplomacy with AI Jarls, managing traits and succession, triggering events, and directing armies on a geopolitical map.
Consequence: Declaring war on a rival Jarl (Macro) triggers an offensive "Micro" mission. A rival attacking the player triggers a defensive "Micro" mission.
2.B. The Micro (RTS Layer)
This is the "Age of Empires" layer. It is the real-time, grid-based combat mission.
Gameplay: Real-time strategy.
Player Actions: Commanding units, using special abilities, and achieving mission objectives (e.g., "Destroy the enemy's Great Hall," "Survive for 10 minutes").
Consequence: Winning a battle (Micro) results in loot and prestige (Macro). Losing a defensive battle (Micro) results in your Settlement being "Sacked" (Bridge).
2.C. The Bridge (Settlement Layer)
This is the player's persistent home base, which connects the two layers.
Gameplay: Grid-based city-builder (e.g., RimWorld, Stronghold).
Player Actions: Placing buildings, upgrading structures, assigning workers, and managing resources.
Consequence: The layout of your Settlement becomes the map for all defensive "Micro" missions. A well-designed base provides a massive tactical advantage.
3. Key Features
(Unchanged from v1.62) (This section will be expanded as we implement Phases 2-4)
4. Technical Stack & Philosophy
(Unchanged from v1.62)
Engine: Godot 4.4
Scripting: GDScript
Architecture:
Data-Driven: All game stats (unit HP, building cost, etc.) must be custom Resource files (.tres) to empower design and balancing without code changes.
Singleton (Autoload) Managers: Global systems (SettlementManager, EventBus) are implemented as Autoloads for easy access and clear separation of concerns.
Event Bus: All communication between major, decoupled systems (e.g., UI, AI, Game Loop) must go through the EventBus singleton. No direct references.
Finite State Machines (FSMs): All entities with 3+ states (like AI units) must use an FSM.
5. Art Style & Mood
(Unchanged from v1.62) (Placeholder section for future development)
6. Core Entities & Data Structures
6.A. Overview
(Unchanged from v1.62)
All game entities are defined by a Resource script (.gd) and then implemented as one or more .tres files.
6.B. BuildingData.gd (AMENDED)
Defines the stats for all static structures in the game.
Path: res://data/buildings/BuildingData.gd
Extends: Resource
class_name BuildingData
Key Properties:
@export var display_name: String  (e.g., "Stone Wall")
@export var scene_to_spawn: PackedScene  (The .tscn file to instance)
@export var icon: Texture2D  (For the build menu)
@export var build_cost: int
@export var max_health: int
@export var blocks_pathfinding: bool  (If true, updates the A* grid)
@export var grid_size: Vector2i  (Size in grid cells)
@export_group("Defensive Stats")
@export var is_defensive_structure: bool
@export var attack_damage: int
@export var attack_range: float
@export var attack_speed: float


6.C. UnitData.gd (AMENDED)
Defines the stats for all mobile units in the game.
Path: res://data/units/UnitData.gd
Extends: Resource
class_name UnitData
Key Properties:
@export var display_name: String  (e.g., "Viking Raider")
@export var scene_to_spawn: PackedScene
@export var icon: Texture2D  (For the training menu)
@export var spawn_cost: int
@export_group("Combat Stats")
@export var max_health: int
@export var move_speed: float
@export var attack_damage: int
@export var attack_range: float
@export var attack_speed: float


7. The "Defense-First" MVP
7.A. MVP Goals
(Unchanged from v1.62)
The only goal of this MVP is to prove the "Sacked" loop. This is a technical, defense-first prototype.
MVP Success Criteria: "A pre-spawned enemy unit must successfully navigate a player-built settlement, pathfind around the player's 'Wall', destroy the 'Great Hall', and trigger a 'Sacked' game-over state."
7.B. Feature Set
(Unchanged from v1.62) (This is the minimal feature set required to achieve the MVP goal)
Systems: SettlementManager, AStarGrid2D Pathfinding, EventBus, FSM.
Buildings (Data): "Great Hall" (Objective), "Stone Wall" (Obstacle).
Units (Data): "Viking Raider" (Enemy).
Scenes: SettlementBridge.tscn (The "Conductor" scene), DefensiveMicro.tscn (The "World" scene), Base_Building.tscn, Base_Unit.tscn.
Core Loop:
Game starts in SettlementBridge.tscn.
SettlementBridge.gd spawns the Great Hall and the Raider.
Player can click to place "Stone Wall" obstacles.
Raider AI paths around walls to the Great Hall.
Raider attacks and destroys the Hall.
Hall's destruction triggers a "SACKED" message on the UI.
7.C. Core Architecture (Phase 2 Specification)
This section defines the target architecture for the Phase 2 economic systems. This design refactors the Phase 1 SettlementManager to support scalability and the new data requirements.
The monolithic SettlementManager will be split into two distinct parts:
Persistent Data Resource (SettlementData.gd): This new Resource script will hold all persistent settlement data, including:
treasury (Dictionary)
placed_buildings (Array)
last_visited_timestamp (int) A .tres file (e.g., home_base.tres) will represent a unique, persistent settlement.
Singleton Manager (SettlementManager.gd): The Autoload will be refactored into a runtime manager. Its new responsibilities are to:
Load a SettlementData resource on demand.
Manage the AStarGrid2D and pathfinding.
Process runtime requests (e.g., attempt_purchase, calculate_chunk_payout).
It will no longer hold any persistent data itself.
Data-Driven: BuildingData.gd and UnitData.gd will be expanded by EconomicBuildingData.gd.
AI: UnitFSM.gd and EventBus signals remain the core of unit AI.
8. Post-MVP Roadmap
Phase 2: The "Reinvestment" Economy (The 'Bridge')
Overview
This phase implements the core economic engine of the "Bridge" (Settlement) layer. This is not a traditional passive-income RTS economy (like Age of Empires).
The design is a hybrid "Raid-and-Spend" model. This keeps the player's focus on the active, core fantasy of Viking raiding, while supplementing it with strategic, long-term investments in their home base.
Pillar 1: The 'Treasury' & 'Storefront'
This pillar involves tracking player resources (Gold, Wood, Stone, etc.) in a persistent Treasury and creating a 'Storefront' UI where those resources can be spent on new buildings and units.
Build Cost Data Structure To support the multi-resource "Raid-and-Spend" economy, all buildable items, units, and upgrades will have their costs defined as a Dictionary data structure. This allows any item to cost one or more resource types.
Example (Defensive):
Stone Wall Cost: {"stone": 25}
Example (Economic):
Lumber Yard Cost: {"wood": 50, "gold": 10}
Example (Unit):
Viking Raider Cost: {"food": 50, "gold": 20}


Pillar 2: The 'Active' Loop (Raiding for Loot)
This is the primary source of all income in the game.
Concept: This system is the "generator" for the entire economy. It directly connects to the Phase 3 (Offensive Raids) RTS loop.
Function: Upon successfully completing an "Offensive Raid" mission, the player will be awarded a lump sum of Loot based on their performance. When the player returns to the "Bridge" scene, this loot is deposited directly into the "Treasury."
Pillar 3: The 'Reinvestment' Loop (Investing for Growth)
This is the secondary economic loop, providing strategic depth and a long-term progression path.
Concept: Players can spend loot from the Treasury to build or upgrade "Economic Buildings" (e.g., Farm Upgrade, Trading Post, Lumber Yard). This represents a long-term investment in the settlement's infrastructure.
Function (The "Chunk" Payout): These buildings do not generate resources passively in real-time. Instead, they accumulate a "chunk" of their given resource while the player is away (e.g., on a raid or offline).
Payout Mechanism: Upon returning to the "Bridge" scene, a function will calculate the total accumulated resources from all economic buildings (up to a defined 'storage cap' for each) and present it to the player as a "Welcome Home" reward. This simulates the "harvest" or "trade profits" that occurred during their absence. The player must click the "Collect" button on the modal. This action will deposit the resources into the Treasury and update the UI, providing a tangible, player-driven feedback loop for their investment.
Strategic Layer: This creates the central economic choice for the player:
Spend Loot: On immediate military power (e.t., better troops for the next raid).
Invest Loot: On economic buildings for long-term, compounding resource growth.
Pillar 4: Core Architectural Refactor (To Support Colonization)
To support the long-term vision of founding new colonies (as discussed in Section 7.C), the SettlementManager Singleton must be refactored before this phase is implemented.
Task: The SettlementManager AutoLoad will be replaced by a Resource-based system.
New Structure:
Create a new custom Resource named SettlementData.gd.
This script will hold all data for a single settlement: its settlement_grid, building_status, treasury, and economic_building_levels.
Benefit: The "Home Base" (home_base.tres) and any future "Colonies" (colony_1.tres) will simply be different resource files loaded by the same SettlementBridge.tscn scene. This makes expansion infinitely scalable.
Phase 3: The "Offensive Raid" Mission Type
Goal: To implement the player-driven "Micro" RTS loop.
Key Features:
Player Unit Spawning: Logic to spend resources to spawn player-controlled units.
Basic Unit Control: A simple "RTS-style" control script (select units, right-click to move/attack).
"Offensive Raid" Mission Loader: A system to load an "enemy" settlement map and spawn pre-defined enemy units.
Why second? This re-uses all the combat and A* tech from the MVP but gives the player agency. It directly connects the economy (Phase 2) to combat (Phase 3).
Phase 4: Integrate the "Macro" (The Dynasty Layer)
Goal: To build the "Crusader Kings" DNA that connects all the loops into a single, compelling narrative.
Key Features:
Dynasty & Trait System: Implement the family tree, character inheritance, and traits.
Geopolitical Map: Build the high-level map where the player interacts with other AI Jarls.
Event Triggers: A rival Jarl declaring war (Macro) will trigger the "Sacked" defensive loop (Micro). The player deciding to attack (Macro) will trigger the "Offensive Raid" loop (Micro).
Why last? This system provides the ultimate context, but it relies on the other two pillars (Economy and Combat) to have meaningful consequences.

---
### **3. DevLog**

Devlog: "Defense-First" MVP is Complete!
We've successfully completed our "Defense-First" MVP. The goal was to prove our core "Micro-to-Bridge" loop by building a playable, grid-based defensive battle. We can confirm that all 5 implementation tasks are now functional and integrated.

Here's a breakdown of our progress:

✅ Task 1: Data Foundations Built

We successfully defined our core data structures, BuildingData.gd and UnitData.gd.

This allows us to create new units and buildings (like the "Stone Wall" and "Great Hall") entirely as .tres resource files, with no new code required.

✅ Task 2: Core Grid & Manager Implemented

The SettlementManager singleton is live. It now successfully creates, configures, and manages the AStarGrid2D pathfinding object.

It handles all building placement logic, correctly marking tiles as "solid" on the grid.

✅ Task 3: Test Scene Operational

Our main SettlementBridge.tscn is fully functional as the MVP's "conductor."

It successfully spawns the level, instances the UI, and captures player input to test our building logic.

✅ Task 4: Reactive AI & Pathfinding Complete

We have a working BaseUnit with a Finite State Machine (FSM) that correctly manages IDLE, MOVE, and ATTACK states.

The AI successfully requests paths from the SettlementManager.

Crucially, the AI is now reactive. Thanks to our EventBus integration, units listening for the pathfinding_grid_updated signal will automatically re-calculate their path when the player builds a new wall.

✅ Task 5: Full "Sacked" Loop Complete!

This is the final win that connects everything. The SettlementBridge now:

Spawns the Great Hall.

Spawns a Raider and tells it to attack the Hall.

The Raider paths to a walkable tile above the Hall (solving our "stuck" bug).

It successfully enters the ATTACK state and deals damage until the Hall is destroyed.

The Hall's building_destroyed signal is caught, triggering the "YOU HAVE BEEN SACKED" UI state and ending the combat.

⚠️ Key Challenges & Amendments
A core part of this MVP was "retiring risk," and we solved several major technical hurdles:

GDD Amendment (StaticBody2D): We proved the GDD's Area2D spec for buildings was incorrect for our goals. We've amended the GDD to use StaticBody2D, which correctly provides the physical collision needed for pathfinding.

AI Range & "Jank": We fixed a bug where the AI's "attack range" was too short, causing it to "re-engage" and get stuck. By increasing the range in the Unit_Raider.tres file, we've confirmed the AI can now complete its attack cycle.

Singleton vs. class_name: We debugged and resolved the core engine conflict between Autoload singletons (like EventBus and SettlementManager) and custom resource scripts (like BuildingData).

In short: The foundation is built and it is solid.

This officially concludes our work on the MVP implementation plan. We are now ready to move on to the post-MVP roadmap.

---
### **4. Project Context**

#### **4.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Viking Dynasty"
run/main_scene="uid://cpkd7lvdwsydo"
config/features=PackedStringArray("4.5", "GL Compatibility")

[autoload]

EventBus="*res://autoload/EventBus.gd"
SettlementManager="*res://autoload/SettlementManager.tscn"

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg")
--- END OF PROJECT SETTINGS ---

#### **4.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://.ai-checkpoints/placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 32
height = 32
noise = SubResource("FastNoiseLite_cemhj")

--- RESOURCE: res://data/buildings/Bldg_GreatHall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = 500
max_health = 50
grid_size = Vector2i(3, 2)
metadata/_custom_type_script = "uid://js4bbqgeyd6c"

--- RESOURCE: res://data/buildings/Bldg_Wall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0
metadata/_custom_type_script = "uid://js4bbqgeyd6c"

--- RESOURCE: res://data/units/Unit_Raider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=2 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_tcvvg"]

[resource]
script = ExtResource("1_tcvvg")
display_name = "Viking Raider"
attack_range = 50.0
metadata/_custom_type_script = "uid://cq155t20ujb2j"

--- RESOURCE: res://placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 32
height = 32
noise = SubResource("FastNoiseLite_cemhj")
--- END OF RESOURCE FILES ---

#### **4.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://.ai-checkpoints/main_test.tscn ---
Main Test (Node2D)
> scene: res://.ai-checkpoints/main_test.tscn

--- SCENE: res://autoload/SettlementManager.tscn ---
SettlementManager (Node)
> script: res://autoload/SettlementManager.gd
> scene: res://autoload/SettlementManager.tscn
> BuildingContainer (Node2D)

--- SCENE: res://main_test.tscn ---
Main Test (Node2D)
> scene: res://main_test.tscn

--- SCENE: res://scenes/buildings/Base_Building.tscn ---
Base_Building (StaticBody2D)
> script: res://data/buildings/Base_Building.gd
> scene: res://scenes/buildings/Base_Building.tscn
> Sprite2D (Sprite2D)
> > texture = res://placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/buildings/Base_Building.tscn::RectangleShape2D_b5w0v

--- SCENE: res://scenes/levels/DefensiveMicro.tscn ---
DefensiveMicro (Node2D)
> scene: res://scenes/levels/DefensiveMicro.tscn
> TileMap (TileMap)
> > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc

--- SCENE: res://scenes/levels/SettlementBridge.tscn ---
SettlementBridge (Node)
> script: res://scripts/buildings/SettlementBridge.gd
> scene: res://scenes/levels/SettlementBridge.tscn
> DefensiveMicro (Node2D)
>   scene: res://scenes/levels/DefensiveMicro.tscn
>   TileMap (TileMap)
>   > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
> UnitContainer (Node2D)
> UI (CanvasLayer)
>   Label (Label)
>   > anchors_preset = -1
>   > offset_left = 19.0
>   > offset_top = 16.0
>   > offset_right = 328.0
>   > offset_bottom = 39.0
>   > text = "Click to build a Wall. Defend the Great Hall!"

--- SCENE: res://scenes/units/Base_Unit.tscn ---
Base_Unit (CharacterBody2D)
> script: res://scripts/units/Base_Unit.gd
> scene: res://scenes/units/Base_Unit.tscn
> Sprite2D (Sprite2D)
> > texture = res://placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/VikingRaider.tscn ---
VikingRaider (CharacterBody2D)
> script: res://scripts/units/VikingRaider.gd
> scene: res://scenes/units/VikingRaider.tscn
> data = res://data/units/Unit_Raider.tres
> Sprite2D (Sprite2D)
> > texture = res://placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
--- END OF SCENE STRUCTURES ---

#### **4.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://autoload/EventBus.gd ---
# res://autoload/EventBus.gd
#
# A global Singleton (Autoload) that acts as a central "switchboard"
# for decoupled signal communication between major systems.


extends Node

# Emitted by the UI, listened for by the SettlementManager.
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)

# --- ADDED ---
# Emitted by the SettlementManager when a wall is placed.
# Listened for by any unit's FSM to trigger a re-path.
signal pathfinding_grid_updated(grid_position: Vector2i)

--- SCRIPT: res://autoload/SettlementManager.gd ---
# res://autoload/SettlementManager.gd
#
# --- MODIFIED: Added GDD-required function 'update_building_status' ---


extends Node

var astar_grid: AStarGrid2D
@onready var building_container: Node2D = $BuildingContainer

const TILE_SIZE: int = 32
const GRID_WIDTH: int = 50
const GRID_HEIGHT: int = 30

func _ready() -> void:
	astar_grid = AStarGrid2D.new()
	EventBus.build_request_made.connect(place_building, CONNECT_DEFERRED)
	_initialize_grid()

func _exit_tree() -> void:
	if EventBus.is_connected("build_request_made", place_building):
		EventBus.build_request_made.disconnect(place_building)

func _initialize_grid() -> void:
	print("Initializing Settlement Grid...")
	var playable_rect := Rect2i(0, 0, GRID_WIDTH, GRID_HEIGHT)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(TILE_SIZE, TILE_SIZE)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar_grid.update()
	print("Settlement Grid Initialized: %d x %d" % [GRID_WIDTH, GRID_HEIGHT])

func place_building(building_data: BuildingData, grid_position: Vector2i) -> void:
	if not building_data or not building_data.scene_to_spawn:
		push_error("Build request failed: BuildingData or scene_to_spawn is null.")
		return
	
	print("Placing '%s' at grid position %s" % [building_data.display_name, grid_position])
	
	var new_building: BaseBuilding = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	
	var world_pos_top_left: Vector2 = Vector2(grid_position) * astar_grid.cell_size
	var half_cell_offset: Vector2 = astar_grid.cell_size / 2.0
	new_building.global_position = world_pos_top_left + half_cell_offset
	
	building_container.add_child(new_building)
	
	if building_data.blocks_pathfinding:
		# TODO: This should loop over the building's grid_size
		astar_grid.set_point_solid(grid_position, true)
		astar_grid.update()
		print("Updated A* grid. Point %s is now solid." % grid_position)
		EventBus.pathfinding_grid_updated.emit(grid_position)

# --- ADDED ---
# As required by GDD
func update_building_status(grid_position: Vector2i, new_status: String) -> void:
	"""
	Updates the status of a building in the settlement grid.
	This is the hook for the 'Macro' layer's save data.
	"""
	# For now, we just print. In the future, this would
	# update a dictionary or save file.
	print("SETTLEMENT_MANAGER: Building at %s status set to '%s'" % [grid_position, new_status])


func get_astar_path(start_pos: Vector2, end_pos: Vector2) -> PackedVector2Array:
	var start_id: Vector2i = Vector2i(start_pos / astar_grid.cell_size)
	var end_id: Vector2i = Vector2i(end_pos / astar_grid.cell_size)
	
	var world_path: PackedVector2Array = astar_grid.get_point_path(start_id, end_id)
	return world_path

--- SCRIPT: res://data/buildings/Base_Building.gd ---
# res://scenes/buildings/Base_Building.gd
#
# --- MODIFIED: Added 'building_destroyed' signal ---

class_name BaseBuilding
extends StaticBody2D

## This signal is emitted when health reaches zero.
## GDD Ref:
signal building_destroyed(building: BaseBuilding)

@export var data: BuildingData
var current_health: int = 100

func _ready() -> void:
	if not data:
		push_warning("BaseBuilding scene is missing its BuildingData resource.")
		return
	
	current_health = data.max_health

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been destroyed." % data.display_name)
	
	# --- ADDED ---
	# Emit the signal *before* queue_free() so listeners
	# can react before the node is deleted.
	building_destroyed.emit(self)
	
	queue_free()

--- SCRIPT: res://data/buildings/BuildingData.gd ---
# res://data/buildings/BuildingData.gd
#
# Defines the core data for any building in the game.
#
# --- MODIFIED: Added 'class_name BuildingData' ---

class_name BuildingData
extends Resource

## The name displayed in the UI (e.g., "Stone Wall", "Watchtower").
@export var display_name: String = "New Building"

## The scene that will be instanced when this building is placed.
@export var scene_to_spawn: PackedScene

## The icon shown in the build menu.
@export var icon: Texture2D

## The cost in 'Resources' (e.g., wood, gold) to build this.
@export var build_cost: int = 10

## The building's maximum hit points.
@export var max_health: int = 100

## If true, this building blocks enemy pathfinding.
@export var blocks_pathfinding: bool = true

## The size of the building on the AStarGrid2D.
@export var grid_size: Vector2i = Vector2i.ONE


@export_group("Defensive Stats")
## If true, this building can attack enemies (e.g., Watchtower).
@export var is_defensive_structure: bool = false

## Damage dealt per attack (if defensive).
@export var attack_damage: int = 5

## Range in pixels (if defensive).
@export var attack_range: float = 200.0

## Attacks per second (if defensive).
@export var attack_speed: float = 1.0

--- SCRIPT: res://data/units/UnitData.gd ---
# res://data/units/UnitData.gd
#
# Defines the core data for any unit in the game.
# This resource is used by Base_Unit.tscn to configure instances.
# GDD Ref: 7.C.1.b

class_name UnitData
extends Resource

## The name displayed in the UI (e.g., "Viking Raider").
@export var display_name: String = "New Unit"

## The scene that will be instanced when this unit is spawned.
@export var scene_to_spawn: PackedScene

## The icon shown in the training menu.
@export var icon: Texture2D

## The cost in 'Resources' to train this unit.
@export var spawn_cost: int = 25


@export_group("Combat Stats")
## The unit's maximum hit points.
@export var max_health: int = 50

## Movement speed in pixels per second.
@export var move_speed: float = 75.0

## Damage dealt per attack.
@export var attack_damage: int = 8

## Range in pixels. (e.g., 10 for melee, 300 for archer).
@export var attack_range: float = 10.0

## Attacks per second.
@export var attack_speed: float = 1.2

--- SCRIPT: res://scripts/ai/UnitFSM.gd ---
# res://scripts/ai/UnitFSM.gd
#
# --- MODIFIED: _move_state now checks for attack range ---

class_name UnitFSM

enum State { IDLE, MOVE, ATTACK }

# Unit References
var unit: BaseUnit
var attack_timer: Timer

# State Data
var current_state: State = State.IDLE
var path: Array = []

# Target Data
var target_position: Vector2 = Vector2.ZERO
var target_node: BaseBuilding = null # The building we want to attack

func _init(p_unit: BaseUnit, p_timer: Timer) -> void:
	unit = p_unit
	attack_timer = p_timer
	
	# Connect the timer's timeout signal to our attack function
	attack_timer.timeout.connect(_on_attack_timer_timeout)

func change_state(new_state: State) -> void:
	if current_state == new_state:
		return
	
	_exit_state(current_state)
	current_state = new_state
	_enter_state(current_state)

func _enter_state(state: State) -> void:
	match state:
		State.MOVE:
			recalculate_path()
		
		State.ATTACK:
			print("%s entering ATTACK state." % unit.data.display_name)
			# Set timer wait time based on unit's attack speed
			attack_timer.wait_time = 1.0 / unit.data.attack_speed
			attack_timer.start()
			# Attack immediately on entering state
			_on_attack_timer_timeout()

func _exit_state(state: State) -> void:
	match state:
		State.MOVE:
			path.clear()
		State.ATTACK:
			attack_timer.stop()

func recalculate_path() -> void:
	path = SettlementManager.get_astar_path(unit.global_position, target_position)
	if path.is_empty():
		print("Raider at %s failed to find a path to %s." % [unit.global_position, target_position])
		# If we can't find a path, check if we're already at the target
		if unit.global_position.distance_to(target_position) < (unit.data.attack_range + 16):
			change_state(State.ATTACK)
		else:
			change_state(State.IDLE)
	else:
		print("Raider found new path. Waypoints: %d" % path.size())

func update(delta: float) -> void:
	match current_state:
		State.IDLE:
			_idle_state(delta)
		State.MOVE:
			_move_state(delta)
		State.ATTACK:
			_attack_state(delta)

# --- State Logic Functions ---

func _idle_state(_delta: float) -> void:
	pass

func _move_state(delta: float) -> void:
	# --- THIS IS THE FIX ---
	# First, check if we are in attack range of our target.
	# This is more important than finishing the path.
	if is_instance_valid(target_node) and \
	unit.global_position.distance_to(target_node.global_position) < unit.data.attack_range:
		print("Raider in range, switching to ATTACK.")
		change_state(State.ATTACK)
		return
	# --- END FIX ---
	
	# If we're not in range, check if our path is empty
	if path.is_empty():
		# Path is done, but we're still not in range?
		print("Raider path ended, but not in range. Idling.")
		change_state(State.IDLE)
		return
	
	# Path is not empty and we're not in range, so keep moving
	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	unit.move_and_slide()
	
	var arrival_radius: float = 8.0 
	if unit.global_position.distance_to(next_waypoint) < arrival_radius:
		path.pop_front()
		
		# If that was the last waypoint, check for target
		if path.is_empty():
			if is_instance_valid(target_node) and \
			unit.global_position.distance_to(target_node.global_position) < unit.data.attack_range:
				change_state(State.ATTACK)
			else:
				change_state(State.IDLE)
		
func _attack_state(_delta: float) -> void:
	if not is_instance_valid(target_node):
		print("%s target destroyed. Returning to IDLE." % unit.data.display_name)
		change_state(State.IDLE)
		return
	
	# Check if target moved out of range
	if unit.global_position.distance_to(target_node.global_position) > unit.data.attack_range + 16:
		print("%s target moved out of range. Re-engaging." % unit.data.display_name)
		target_position = target_position 
		change_state(State.MOVE)

# --- Signal Callback ---

func _on_attack_timer_timeout() -> void:
	"""
	This is called every time the AttackTimer finishes.
	"""
	if is_instance_valid(target_node):
		print("%s attacks %s!" % [unit.data.display_name, target_node.data.display_name])
		target_node.take_damage(unit.data.attack_damage)
	else:
		change_state(State.IDLE)

--- SCRIPT: res://scripts/buildings/SettlementBridge.gd ---
# res://scripts/buildings/SettlementBridge.gd
#
# This is the "main" script for the settlement defense scene.
#
# --- THIS IS THE CORRECT SCRIPT FOR THE TASK 5 "SACKED" LOOP ---

extends Node

# --- Preloaded Test Assets ---
var test_building_data: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
var raider_scene: PackedScene = preload("res://scenes/units/VikingRaider.tscn")
var hall_data: BuildingData = preload("res://data/buildings/Bldg_GreatHall.tres")

# --- Scene Node References ---
@onready var defensive_micro: Node2D = $DefensiveMicro
@onready var unit_container: Node2D = $UnitContainer
@onready var label: Label = $UI/Label

# --- State Variables ---
var great_hall_instance: BaseBuilding = null
var game_is_over: bool = false

# --- Provisional Spawn Points ---
const HALL_GRID_POS: Vector2i = Vector2i(25, 15)
const RAIDER_SPAWN_POS: Vector2 = Vector2(50, 50)


func _ready() -> void:
	_spawn_great_hall()
	_spawn_raider_for_test()

func _spawn_great_hall() -> void:
	"""
	Spawns the Great Hall and connects to its destruction signal.
	"""
	if not hall_data:
		push_error("Great Hall data not found!")
		return
		
	# Use the SettlementManager to place the hall
	SettlementManager.place_building(hall_data, HALL_GRID_POS)
	
	# The manager just placed it, so we can get it from the container.
	# We get the last child added.
	great_hall_instance = SettlementManager.building_container.get_child(
		SettlementManager.building_container.get_child_count() - 1
	)
	
	# --- This is the GDD's "connect" logic ---
	if great_hall_instance:
		great_hall_instance.building_destroyed.connect(_on_great_hall_destroyed)
		print("Great Hall spawned. Listening for its destruction.")
	else:
		push_error("Failed to get Great Hall instance after spawn.")

func _spawn_raider_for_test() -> void:
	if not great_hall_instance:
		push_error("Cannot spawn raider: Great Hall does not exist.")
		return
		
	var raider_instance: BaseUnit = raider_scene.instantiate()
	
	# Add unit to the UnitContainer
	unit_container.add_child(raider_instance)
	
	# Set position *after* adding to scene
	raider_instance.global_position = RAIDER_SPAWN_POS
	
	# --- THIS IS THE FIX ---
	# Tell the raider what to attack
	raider_instance.set_attack_target(great_hall_instance)

# --- Main "Sacked" Loop Logic ---

func _on_great_hall_destroyed(building: BaseBuilding) -> void:
	"""
	This is the "Sacked" state. It's called when the Hall's
	'building_destroyed' signal is emitted.
	"""
	print("GAME OVER: The Great Hall has been destroyed!")
	game_is_over = true
	
	# 1. Update the UI
	label.text = "YOU HAVE BEEN SACKED."
	
	# 2. Update the SettlementManager as per GDD
	SettlementManager.update_building_status(HALL_GRID_POS, "Destroyed")
	
	# 3. End the "battle"
	_destroy_all_enemies()

func _destroy_all_enemies() -> void:
	"""
	Cleans up all active enemy units.
	"""
	for enemy in unit_container.get_children():
		enemy.queue_free()
	print("All surviving enemies have been removed.")

# --- Player Input (for placing walls) ---

func _unhandled_input(event: InputEvent) -> void:
	# Don't allow building if game is over
	if game_is_over:
		return
		
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed():
		
		if not test_building_data:
			return

		var mouse_pos: Vector2 = get_viewport().get_mouse_position()
		var grid_pos: Vector2i = Vector2i(mouse_pos / SettlementManager.astar_grid.cell_size)
		
		EventBus.build_request_made.emit(test_building_data, grid_pos)
		get_viewport().set_input_as_handled()

--- SCRIPT: res://scripts/units/Base_Unit.gd ---
# res://scenes/units/Base_Unit.gd
#
# --- MODIFIED: Added AttackTimer reference ---

class_name BaseUnit
extends CharacterBody2D

@export var data: UnitData
var fsm: UnitFSM
var current_health: int = 50

# --- ADDED ---
@onready var attack_timer: Timer = $AttackTimer

func _ready() -> void:
	if not data:
		push_warning("BaseUnit scene is missing its BuildingData resource.")
		return
	
	current_health = data.max_health
	
	# --- MODIFIED ---
	# Pass the timer reference to the FSM
	fsm = UnitFSM.new(self, attack_timer)
	
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	if fsm and fsm.current_state == UnitFSM.State.MOVE:
		fsm.recalculate_path()

func _physics_process(delta: float) -> void:
	if fsm:
		fsm.update(delta)
	
	if not fsm or fsm.current_state != UnitFSM.State.MOVE:
		velocity = Vector2.ZERO
		move_and_slide()

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been killed." % data.display_name)
	queue_free()

--- SCRIPT: res://scripts/units/VikingRaider.gd ---
# res://scripts/units/VikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Target position is now adjacent to the Hall ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set the node (for attacking)
	fsm.target_node = target
	
	# --- THIS IS THE FIX ---
	# Set the position (for moving) to be one tile *below*
	# the Hall's center. This is a walkable tile, so
	# pathfinding will succeed.
	fsm.target_position = target.global_position + Vector2(0, 32)
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVE)
	print("Viking Raider initialized and moving to target: %s" % target.data.display_name)
--- END OF CODEBASE ---

---
