### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. Project Context`**: The technical project dump, including:
    *   `2.1. Project Settings`
    *   `2.2. Resource Files`
    *   `2.3. Scene Structures`
    *   `2.4. Codebase`

---
### **2. Project Context**

#### **2.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Viking Dynasty"
run/main_scene="uid://c53k15q2w8c1a"
config/features=PackedStringArray("4.5", "GL Compatibility")

[autoload]

EventBus="*res://autoload/EventBus.gd"
SettlementManager="*res://autoload/SettlementManager.tscn"
SceneManager="*res://autoload/SceneManager.gd"

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg")

[input]

debug_time_travel="{\"deadzone\": 0.5, \"events\": [{\"physical_keycode\": 84, \"type\": \"key\"}]}"

[plugins]

enemy_base_editor/enabled=true
--- END OF PROJECT SETTINGS ---

#### **2.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://assets/placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 32
height = 32
noise = SubResource("FastNoiseLite_cemhj")

--- RESOURCE: res://data/buildings/Bldg_Wall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=4 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Texture2D" uid="uid://csni4uyao275g" path="res://textures/placeholders/wall_stone_texture.png" id="1_n45a8"]
[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
building_texture = ExtResource("1_n45a8")
build_cost = {
"stone": 25
}
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/GreatHall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 100,
"wood": 250
}
max_health = 50
grid_size = Vector2i(4, 4)
is_player_buildable = true

--- RESOURCE: res://data/buildings/LumberYard.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://drx4sih8numo1"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="Texture2D" uid="uid://cvtmpipin3j4" path="res://textures/placeholders/lumber_mill_placeholder.png" id="1_plclm"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
display_name = "Lumber Yard"
scene_to_spawn = ExtResource("2_fghij")
building_texture = ExtResource("1_plclm")
build_cost = {
"wood": 50
}
max_health = 75
grid_size = Vector2i(2, 2)
is_player_buildable = true

--- RESOURCE: res://data/buildings/Monastery_Chapel.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b7p70u4vm3uem"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 25
storage_cap = 200
display_name = "Monastery Chapel"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 100,
"stone": 80,
"wood": 40
}
max_health = 120
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Granary.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bscr3flprg5ts"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "food"
fixed_payout_amount = 20
storage_cap = 300
display_name = "Monastery Granary"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 60,
"stone": 40,
"wood": 100
}
max_health = 90
grid_size = Vector2i(2, 3)

--- RESOURCE: res://data/buildings/Monastery_Library.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bfb0hbf1m2lgf"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 35
storage_cap = 250
display_name = "Monastery Library"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 150,
"stone": 60,
"wood": 80
}
max_health = 80
grid_size = Vector2i(3, 2)

--- RESOURCE: res://data/buildings/Monastery_Scriptorium.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b6dkpjrewc1q6"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 30
storage_cap = 180
display_name = "Monastery Scriptorium"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 120,
"stone": 30,
"wood": 90
}
max_health = 70
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Watchtower.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://ckedcnw210a8k"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Monastery Watchtower"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 80,
"stone": 120,
"wood": 60
}
max_health = 150
is_defensive_structure = true
attack_damage = 15
attack_range = 250.0
attack_speed = 1.5

--- RESOURCE: res://data/settlements/economic_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://chtd3i4qtdv31"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_e06fl"]

[resource]
script = ExtResource("1_e06fl")
treasury = {
"food": 315,
"gold": 1600,
"stone": 150,
"wood": 520
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 8),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(8, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 8
}

--- RESOURCE: res://data/settlements/fortress_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c2nrib7nroeas"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 150,
"gold": 1200,
"stone": 500,
"wood": 600
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/Bldg_GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 8
}

--- RESOURCE: res://data/settlements/home_base_fixed.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 530,
"gold": 3190,
"stone": 1025,
"wood": 60
}
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 9
}
metadata/_custom_type_script = "uid://hlb8s5g0yp6k"

--- RESOURCE: res://data/settlements/monastery_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://okf2novkg804"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_pnvr3"]

[resource]
script = ExtResource("1_pnvr3")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/monastery_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://6kk36f5nlwns"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 300,
"gold": 800,
"stone": 200,
"wood": 400
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/sample_fortress_gui.tres ---
[gd_resource type="SettlementData" script_class="SettlementData" load_steps=2 format=3 uid="uid://cl3pbg7tiqyng"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1"]

[resource]
resource_local_to_scene = false
resource_name = ""
script = ExtResource("1")
treasury = {
"food": 300,
"gold": 1000,
"stone": 400,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(30, 20),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(29, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(29, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(28, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(28, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(27, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(33, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 4,
"res://data/units/Unit_Raider.tres": 8
}

--- RESOURCE: res://data/settlements/small_defensive.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c5wkbqulshkqe"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_mtb34"]

[resource]
script = ExtResource("1_mtb34")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(11, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(4, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(14, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(6, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/traits/Trait_Cowardly.tres ---
[gd_resource type="TraitData" format=3 uid="uid://bivw1rejl06qi"]

[resource]
resource_local_to_scene = false
resource_name = ""
display_name = "Cowardly"
description = "This character has shown cowardice in battle, losing the respect of their people."
is_visible = true
command_modifier = -3
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -2.0
vassal_opinion_modifier = -10
alliance_cost_modifier = 1.2
is_wounded_trait = false
is_dishonorable_trait = true

--- RESOURCE: res://data/traits/Trait_Legendary.tres ---
[gd_resource type="TraitData" format=3 uid="uid://c6a8qce5fgub0"]

[resource]
resource_local_to_scene = false
resource_name = ""
display_name = "Legendary"
description = "This character has achieved legendary status through glorious deeds and successful raids."
is_visible = true
command_modifier = 5
stewardship_modifier = 2
intrigue_modifier = 3
renown_per_year_modifier = 5.0
vassal_opinion_modifier = 20
alliance_cost_modifier = 0.8
is_wounded_trait = false
is_dishonorable_trait = false

--- RESOURCE: res://data/traits/Trait_Maimed.tres ---
[gd_resource type="TraitData" format=3 uid="uid://bbiwlkmmne5md"]

[resource]
resource_local_to_scene = false
resource_name = ""
display_name = "Maimed"
description = "This character has suffered a permanent injury that affects their combat ability."
is_visible = true
command_modifier = -2
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -1.0
vassal_opinion_modifier = -5
alliance_cost_modifier = 1.1
is_wounded_trait = true
is_dishonorable_trait = false

--- RESOURCE: res://data/units/Unit_PlayerRaider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=4 format=3 uid="uid://ejxn3hg8xcu6"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_tcvvg"]
[ext_resource type="PackedScene" uid="uid://cfanwutbtfcp2" path="res://scenes/units/PlayerVikingRaider.tscn" id="2_spawn_scene"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="3_6go6j"]

[resource]
script = ExtResource("1_tcvvg")
display_name = "Player Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
spawn_cost = {
"food": 25,
"gold": 10
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 80.0
attack_speed = 1.0
visual_texture = ExtResource("3_6go6j")

--- RESOURCE: res://data/units/Unit_Raider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=3 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://dsv0s4yq8c8m5" path="res://scenes/units/VikingRaider.tscn" id="2_spawn_scene"]

[resource]
script = ExtResource("1_abcde")
display_name = "Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
spawn_cost = {
"food": 30,
"gold": 15
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 50.0
attack_speed = 1.0

--- RESOURCE: res://textures/placeholders/building_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://ds2w780g4nf1t"]

[resource]
size = Vector2(128, 128)

--- RESOURCE: res://textures/placeholders/defensive_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://db3pfgf4u4pql"]

[resource]
size = Vector2(96, 96)

--- RESOURCE: res://textures/placeholders/unit_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://bg2e08mncpjg1"]

[resource]
size = Vector2(64, 64)

--- RESOURCE: res://textures/placeholders/unit_texture.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://cybqs3wt5wpg3"]

[resource]

--- RESOURCE: res://ui/themes/VikingDynastyTheme.tres ---
[gd_resource type="Theme" load_steps=0 format=3 uid="uid://63duv3n1vwhg"]

[resource]
--- END OF RESOURCE FILES ---

#### **2.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://autoload/SettlementManager.tscn ---
SettlementManager (Node)
> script: res://autoload/SettlementManager.gd
> scene: res://autoload/SettlementManager.tscn
> tile_size = 32
> grid_width = 120
> grid_height = 120
> auto_resize_for_scene = true
> settlement_grid_size = (60, 40)
> raid_grid_size = (120, 80)
> defense_grid_size = (80, 60)
> BuildingContainer (Node2D)

--- SCENE: res://player/RTSController.tscn ---
RTSController (Node)
> script: res://player/RTSController.gd
> scene: res://player/RTSController.tscn

--- SCENE: res://scenes/buildings/Base_Building.tscn ---
Base_Building (StaticBody2D)
> script: res://data/buildings/Base_Building.gd
> scene: res://scenes/buildings/Base_Building.tscn
> Sprite2D (Sprite2D)
> > scale = (0.088867, 0.083008)
> > texture = res://textures/placeholders/building_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/buildings/Base_Building.tscn::RectangleShape2D_b5w0v

--- SCENE: res://scenes/levels/DefensiveMicro.tscn ---
DefensiveMicro (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/levels/DefensiveMicro.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> victory_bonus_loot = {"gold":200}
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> is_defensive_mission = true
> TileMap (TileMap)
> > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]

--- SCENE: res://scenes/levels/SettlementBridge.tscn ---
SettlementBridge (Node)
> script: res://scripts/buildings/SettlementBridge.gd
> scene: res://scenes/levels/SettlementBridge.tscn
> home_base_data = res://data/settlements/home_base_fixed.tres
> welcome_popup_scene = res://ui/WelcomeHome_Popup.tscn
> world_map_scene_path = "res://scenes/world_map/WorldMap_Stub.tscn"
> cell_size = 16
> UnitContainer (Node2D)
> UI (CanvasLayer)
>   Label (Label)
>   > offset_left = 19.0
>   > offset_top = 16.0
>   > offset_right = 328.0
>   > offset_bottom = 39.0
>   > text = "Purchase buildings from the storefront below, then place them on your settlement"
>   Storefront_UI (Control)
>     script: res://ui/StorefrontUI.gd
>     scene: res://ui/Storefront_UI.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > available_buildings = []
>   > available_units = []
>   > default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
>   > auto_load_units_from_directory = true
>     PanelContainer (PanelContainer)
>     > layout_mode = 1
>     > anchors_preset = -1
>     > anchor_top = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = 20.0
>     > offset_top = -140.0
>     > offset_right = 480.0
>     > offset_bottom = -20.0
>     > grow_vertical = 0
>       MarginContainer (MarginContainer)
>       > layout_mode = 2
>         TabContainer (TabContainer)
>         > layout_mode = 2
>         > current_tab = 0
>           BuildTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             TreasuryDisplay (HBoxContainer)
>             > layout_mode = 2
>               GoldLabel (Label)
>               > layout_mode = 2
>               > text = "Gold: 0"
>               WoodLabel (Label)
>               > layout_mode = 2
>               > text = "Wood: 0"
>               FoodLabel (Label)
>               > layout_mode = 2
>               > text = "Food: 0"
>               StoneLabel (Label)
>               > layout_mode = 2
>               > text = "Stone: 0"
>             BuildButtonsContainer (VBoxContainer)
>             > layout_mode = 2
>           RecruitTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             RecruitButtons (VBoxContainer)
>             > layout_mode = 2
>             GarrisonList (VBoxContainer)
>             > layout_mode = 2
>   RestartButton (Button)
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -84.0
>   > offset_top = -15.5
>   > offset_right = 84.0
>   > offset_bottom = 15.5
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "Return to Settlement"
>   StartRaidButton (Button)
>   > offset_left = 200.0
>   > offset_top = 20.0
>   > offset_right = 350.0
>   > offset_bottom = 60.0
>   > text = "World Map"
> BuildingCursor (Node2D)
>   script: res://scripts/ui/BuildingPreviewCursor.gd

--- SCENE: res://scenes/missions/RaidMission.tscn ---
RaidMission (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/missions/RaidMission.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> victory_bonus_loot = {"gold":200}
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> is_defensive_mission = false
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> CanvasLayer (CanvasLayer)
>   SelectionBox (Control)
>     script: res://ui/SelectionBox.gd
>     scene: res://ui/SelectionBox.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://ui/themes/VikingDynastyTheme.tres
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]

--- SCENE: res://scenes/units/Base_Unit.tscn ---
Base_Unit (CharacterBody2D)
> script: res://scripts/units/Base_Unit.gd
> scene: res://scenes/units/Base_Unit.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/PlayerVikingRaider.tscn ---
PlayerVikingRaider (CharacterBody2D)
> script: res://scripts/units/PlayerVikingRaider.gd
> scene: res://scenes/units/PlayerVikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > scale = (0.058594, 0.061523)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/VikingRaider.tscn ---
VikingRaider (CharacterBody2D)
> script: res://scripts/units/EnemyVikingRaider.gd
> scene: res://scenes/units/VikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/world_map/WorldMap_Stub.tscn ---
WorldMapStub (Control)
> script: res://scenes/world_map/WorldMap_Stub.gd
> scene: res://scenes/world_map/WorldMap_Stub.tscn
> raid_mission_scene_path = "res://scenes/missions/RaidMission.tscn"
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> Background (ColorRect)
> > layout_mode = 0
> > color = (0.0, 0.0, 0.0, 1.0)
> TitleLabel (Label)
> > layout_mode = 0
> > offset_top = 50.0
> > offset_right = 141.0
> > offset_bottom = 73.0
> > text = "Select Your Target"
> > horizontal_alignment = 1
> ButtonContainer (VBoxContainer)
> > layout_mode = 0
> > offset_top = 150.0
> > offset_right = 190.0
> > offset_bottom = 216.0
> > alignment = 1
>   RaidMonasteryButton (Button)
>   > layout_mode = 2
>   > text = "Raid: Nearby Monastery"
>   Spacer (HSeparator)
>   > layout_mode = 2
>   BackButton (Button)
>   > layout_mode = 2
>   > text = "Return to Settlement"
> Phase3Test (Node)
>   script: res://tools/test_phase3.gd

--- SCENE: res://tools/main_test.tscn ---
Main Test (Node2D)
> scene: res://tools/main_test.tscn

--- SCENE: res://ui/BuildingPreviewCursor.tscn ---
BuildingPreviewCursor (Node2D)
> script: res://scripts/ui/BuildingPreviewCursor.gd
> scene: res://ui/BuildingPreviewCursor.tscn

--- SCENE: res://ui/SelectionBox.tscn ---
SelectionBox (Control)
> script: res://ui/SelectionBox.gd
> scene: res://ui/SelectionBox.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> theme = res://ui/themes/VikingDynastyTheme.tres

--- SCENE: res://ui/Storefront_UI.tscn ---
Main (Control)
> script: res://ui/StorefrontUI.gd
> scene: res://ui/Storefront_UI.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> available_buildings = []
> available_units = []
> default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
> auto_load_units_from_directory = true
> PanelContainer (PanelContainer)
> > layout_mode = 1
> > anchors_preset = -1
> > anchor_top = 1.0
> > anchor_bottom = 1.0
> > offset_left = 20.0
> > offset_top = -140.0
> > offset_right = 480.0
> > offset_bottom = -20.0
> > grow_vertical = 0
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     TabContainer (TabContainer)
>     > layout_mode = 2
>     > current_tab = 0
>       BuildTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         TreasuryDisplay (HBoxContainer)
>         > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           > text = "Gold: 0"
>           WoodLabel (Label)
>           > layout_mode = 2
>           > text = "Wood: 0"
>           FoodLabel (Label)
>           > layout_mode = 2
>           > text = "Food: 0"
>           StoneLabel (Label)
>           > layout_mode = 2
>           > text = "Stone: 0"
>         BuildButtonsContainer (VBoxContainer)
>         > layout_mode = 2
>       RecruitTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         RecruitButtons (VBoxContainer)
>         > layout_mode = 2
>         GarrisonList (VBoxContainer)
>         > layout_mode = 2

--- SCENE: res://ui/WelcomeHome_Popup.tscn ---
Main (PanelContainer)
> script: res://ui/WelcomeHomePopup.gd
> scene: res://ui/WelcomeHome_Popup.tscn
> anchor_left = 0.5
> anchor_top = 0.5
> anchor_right = 0.5
> anchor_bottom = 0.5
> offset_left = -150.0
> offset_top = -75.0
> offset_right = 150.0
> offset_bottom = 75.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 4
> size_flags_vertical = 4
> theme = res://ui/themes/VikingDynastyTheme.tres
> MarginContainer (MarginContainer)
> > layout_mode = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     PayoutLabel (Label)
>     > layout_mode = 2
>     > text = "Welcome home! ..."
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     CollectButton (Button)
>     > custom_minimum_size = (120.0, 40.0)
>     > layout_mode = 2
>     > text = "Collect"
--- END OF SCENE STRUCTURES ---

#### **2.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://autoload/EventBus.gd ---
# res://autoload/EventBus.gd
#
# A global Singleton (Autoload) that acts as a central "switchboard"
# for decoupled signal communication between major systems.

extends Node

# --- Build System Signals ---
# TODO: Connect this signal when implementing advanced building system
# @warning_ignore("unused_signal")
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)

# --- Pathfinding Signals ---
signal pathfinding_grid_updated(grid_position: Vector2i)

# --- Treasury & Economy Signals (Phase 2) ---
signal treasury_updated(new_treasury: Dictionary)
signal purchase_successful(item_name: String)
signal purchase_failed(reason: String)

# --- Navigation Signals (Phase 3) ---
signal scene_change_requested(scene_path: String)
signal world_map_opened()
signal raid_mission_started(target_type: String)

# --- Settlement Management Signals ---
signal settlement_loaded(settlement_data: SettlementData)

# --- Unit Management Signals ---
signal player_unit_died(unit: Node2D)

# --- NEW: RTS Command Signals (GDD Section 10) ---
# Emitted by SelectionBox.gd, consumed by RTSController.gd

# Emitted on left-click or drag-release
signal select_command(select_rect: Rect2, is_box_select: bool)

# Emitted on right-click on the ground
signal move_command(target_position: Vector2)

# Emitted on right-click on an enemy
signal attack_command(target_node: Node2D)

# --- NEW: Building Cursor System Signals ---
# Emitted when a building is purchased and ready for cursor placement
signal building_ready_for_placement(building_data: BuildingData)

# Emitted when building placement is cancelled (should refund cost)
signal building_placement_cancelled(building_data: BuildingData)

--- SCRIPT: res://autoload/SceneManager.gd ---
# res://autoload/SceneManager.gd
#
# A global Singleton (Autoload) that handles all scene transitions.
# It listens for a signal on the EventBus and performs the change.
# This decouples all scenes from each other, preventing circular dependencies.

extends Node

func _ready() -> void:
	# Connect to the EventBus signal that all other scenes will use 
	EventBus.scene_change_requested.connect(_on_scene_change_requested)

func _on_scene_change_requested(scene_path: String) -> void:
	if scene_path.is_empty():
		push_error("SceneManager: scene_change_requested received an empty path.")
		return
	
	print("SceneManager: Changing to scene: %s" % scene_path)
	var error = get_tree().change_scene_to_file(scene_path)
	
	if error != OK:
		push_error("SceneManager: Failed to change to scene '%s'. Error code: %s" % [scene_path, error])

--- SCRIPT: res://autoload/SettlementManager.gd ---
# res://autoload/SettlementManager.gd

extends Node

var current_settlement: SettlementData
var astar_grid: AStarGrid2D
@onready var building_container: Node2D = $BuildingContainer

# --- Configurable Grid Settings ---
@export_group("Grid Configuration")
@export var tile_size: int = 32
@export var grid_width: int = 120  # Increased from 50
@export var grid_height: int = 80  # Increased from 30
@export var auto_resize_for_scene: bool = true  # Enable automatic scene detection

# Scene-specific overrides (optional)
@export_subgroup("Scene Overrides")
@export var settlement_grid_size: Vector2i = Vector2i(60, 40)
@export var raid_grid_size: Vector2i = Vector2i(120, 80)  # Increased for raid missions
@export var defense_grid_size: Vector2i = Vector2i(80, 60)  # Increased for defensive missions

func _ready() -> void:
	# Initialize the grid as soon as the manager is ready.
	# This ensures astar_grid is never null after this point.
	_initialize_grid()

func _initialize_grid() -> void:
	"""Initialize the AStarGrid2D with proper error handling"""
	# Auto-detect scene type and adjust grid size if enabled
	if auto_resize_for_scene:
		_detect_and_set_grid_size()
	
	astar_grid = AStarGrid2D.new()
	var playable_rect := Rect2i(0, 0, grid_width, grid_height)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(tile_size, tile_size)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar_grid.update()
	print("Settlement Grid Initialized: %dx%d cells (auto-detected: %s)" % [grid_width, grid_height, auto_resize_for_scene])

func load_settlement(data: SettlementData) -> void:
	if not data:
		push_error("SettlementManager: load_settlement called with null data.")
		return
	
	current_settlement = data
	
	# Ensure resource_path is set for saving later
	if not current_settlement.resource_path or current_settlement.resource_path.is_empty():
		# Try to determine the path from how it was loaded
		if data.resource_path and not data.resource_path.is_empty():
			current_settlement.resource_path = data.resource_path
		else:
			# Fallback: assume it's the home base file
			current_settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
			print("SettlementManager: Set fallback resource_path to: %s" % current_settlement.resource_path)
	
	print("SettlementManager: Settlement loaded - %s" % current_settlement.resource_path)
	print("SettlementManager: Garrison units: %s" % current_settlement.garrisoned_units)
	
	# The grid already exists. Clear its state before loading new buildings.
	# Note: clear() resets the region to (0,0,0,0), so we must reinitialize
	astar_grid.clear()
	
	# Reinitialize grid parameters after clear()
	var playable_rect := Rect2i(0, 0, grid_width, grid_height)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(tile_size, tile_size)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	
	# CRITICAL: Update the grid after setting parameters
	astar_grid.update()
	print("AStarGrid reinitialized: %dx%d cells" % [grid_width, grid_height])
	
	for child in building_container.get_children():
		child.queue_free()

	for building_entry in current_settlement.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if building_data:
			place_building(building_data, grid_pos)
		else:
			push_error("Failed to load building resource from path: %s" % building_res_path)
	
	# Update the grid once after all new solid points have been set
	astar_grid.update()
	print("Settlement loaded with %d buildings." % building_container.get_child_count())


func place_building(building_data: BuildingData, grid_position: Vector2i) -> BaseBuilding:
	if not building_data or not building_data.scene_to_spawn:
		push_error("Build request failed: BuildingData or scene_to_spawn is null.")
		return null
	
	# Use new, robust validation check
	if not is_placement_valid(grid_position, building_data.grid_size):
		push_error("Cannot place building at %s: position is invalid, out of bounds, or occupied." % grid_position)
		return null
	
	var new_building: BaseBuilding = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	
	var world_pos_top_left: Vector2 = Vector2(grid_position) * astar_grid.cell_size
	var half_cell_offset: Vector2 = astar_grid.cell_size / 2.0
	new_building.global_position = world_pos_top_left + half_cell_offset
	
	building_container.add_child(new_building)
	
	# --- MODIFIED: This is the critical fix ---
	# Mark *all* cells occupied by the building as solid, not just the top-left corner.
	if building_data.blocks_pathfinding:
		if astar_grid and astar_grid.region.size.x > 0 and astar_grid.region.size.y > 0:
			for x in range(building_data.grid_size.x):
				for y in range(building_data.grid_size.y):
					var cell_pos = grid_position + Vector2i(x, y)
					# Check if cell is *within* bounds before setting it
					if _is_cell_within_bounds(cell_pos):
						astar_grid.set_point_solid(cell_pos, true)
			
			astar_grid.update() # Update grid *after* all points are set
			EventBus.pathfinding_grid_updated.emit(grid_position)
		else:
			push_warning("AStarGrid not properly initialized, skipping pathfinding update for building at %s" % grid_position)
	# --- END MODIFICATION ---
		
	return new_building

func deposit_resources(loot: Dictionary) -> void:
	if not current_settlement: return
	for resource_type in loot:
		if current_settlement.treasury.has(resource_type):
			# Payouts should respect the storage cap of the building that generated them,
			# but the main treasury can be considered unlimited for now.
			current_settlement.treasury[resource_type] += loot[resource_type]
		else:
			current_settlement.treasury[resource_type] = loot[resource_type]
	EventBus.treasury_updated.emit(current_settlement.treasury)
	print("Loot deposited. New treasury: %s" % current_settlement.treasury)
	save_settlement()

func attempt_purchase(item_cost: Dictionary) -> bool:
	if not current_settlement: return false
	
	for resource_type in item_cost:
		if not current_settlement.treasury.has(resource_type) or \
		current_settlement.treasury[resource_type] < item_cost[resource_type]:
			var reason = "Insufficient %s" % resource_type
			print("Purchase failed. %s." % reason)
			EventBus.purchase_failed.emit(reason)
			return false
			
	for resource_type in item_cost:
		current_settlement.treasury[resource_type] -= item_cost[resource_type]
	
	EventBus.treasury_updated.emit(current_settlement.treasury)
	EventBus.purchase_successful.emit("Unnamed Item") # Placeholder
	print("Purchase successful. New treasury: %s" % current_settlement.treasury)
	return true

func calculate_payout() -> Dictionary:
	if not current_settlement:
		return {}

	var total_payout: Dictionary = {}

	for building_entry in current_settlement.placed_buildings:
		var building_data: BuildingData = load(building_entry["resource_path"])
		if building_data is EconomicBuildingData:
			var eco_data: EconomicBuildingData = building_data
			var resource_type: String = eco_data.resource_type
			
			if not total_payout.has(resource_type):
				total_payout[resource_type] = 0
			
			# The payout is now a simple, fixed amount per building.
			# The storage_cap is now effectively the treasury cap, handled in deposit_loot.
			total_payout[resource_type] += eco_data.fixed_payout_amount

	if not total_payout.is_empty():
		print("Calculated fixed payout: %s" % total_payout)
	return total_payout

func get_astar_path(start_pos: Vector2, end_pos: Vector2) -> PackedVector2Array:
	if not astar_grid:
		push_error("AStarGrid is not initialized!")
		return PackedVector2Array()
	
	# Check if grid region is properly set
	if astar_grid.region.size.x <= 0 or astar_grid.region.size.y <= 0:
		push_error("AStarGrid region is invalid: %s. Grid was likely cleared but not reinitialized." % astar_grid.region)
		return PackedVector2Array()
	
	var start_id: Vector2i = Vector2i(start_pos / astar_grid.cell_size)
	var end_id: Vector2i = Vector2i(end_pos / astar_grid.cell_size)
	
	# Check bounds before calling get_point_path
	if start_id.x < 0 or start_id.x >= astar_grid.region.size.x or start_id.y < 0 or start_id.y >= astar_grid.region.size.y:
		push_error("Start position (%s) -> grid_id (%s) is out of bounds. Grid size: %s" % [start_pos, start_id, astar_grid.region.size])
		return PackedVector2Array()
	
	if end_id.x < 0 or end_id.x >= astar_grid.region.size.x or end_id.y < 0 or end_id.y >= astar_grid.region.size.y:
		push_error("End position (%s) -> grid_id (%s) is out of bounds. Grid size: %s" % [end_pos, end_id, astar_grid.region.size])
		return PackedVector2Array()
	
	return astar_grid.get_point_path(start_id, end_id)

func recruit_unit(unit_data: UnitData) -> void:
	"""Add a unit to the garrison"""
	if not current_settlement:
		push_error("Cannot recruit unit: no current settlement")
		return
	
	if not unit_data:
		push_error("Cannot recruit: UnitData is null")
		return
	
	var unit_path: String = unit_data.resource_path
	if unit_path.is_empty():
		push_error("Cannot recruit: UnitData has no resource_path")
		return
	
	# Increment the count for this unit type
	if current_settlement.garrisoned_units.has(unit_path):
		current_settlement.garrisoned_units[unit_path] += 1
	else:
		current_settlement.garrisoned_units[unit_path] = 1
	
	print("Recruited %s. Garrison count: %d" % [unit_data.display_name, current_settlement.garrisoned_units[unit_path]])
	
	# Save the updated settlement
	save_settlement()
	
	# Emit event for UI updates
	EventBus.purchase_successful.emit(unit_data.display_name)

func save_settlement() -> void:
	if not current_settlement:
		push_error("Attempted to save a null settlement.")
		return
	
	if current_settlement.resource_path and not current_settlement.resource_path.is_empty():
		# Ensure the settlement uses the external SettlementData script class
		# This prevents inline script conflicts when saving
		if not current_settlement.get_script():
			current_settlement.set_script(preload("res://data/settlements/SettlementData.gd"))
		
		var error = ResourceSaver.save(current_settlement, current_settlement.resource_path)
		if error == OK:
			print("Settlement data saved successfully to: %s" % current_settlement.resource_path)
		else:
			push_error("Failed to save settlement data to path: %s. Error code: %s" % [current_settlement.resource_path, error])
	else:
		push_warning("SettlementData has no resource_path, cannot save settlement.")

func has_current_settlement() -> bool:
	"""Check if there's a valid current settlement loaded"""
	return current_settlement != null

func get_settlement_status() -> String:
	"""Get debug information about the current settlement"""
	if not current_settlement:
		return "No settlement loaded"
	
	var garrison_count = 0
	for unit_path in current_settlement.garrisoned_units:
		garrison_count += current_settlement.garrisoned_units[unit_path]
	
	return "Settlement: %s | Buildings: %d | Garrison units: %d" % [
		current_settlement.resource_path.get_file(),
		current_settlement.placed_buildings.size(),
		garrison_count
	]

# --- NEW FUNCTION ---
func is_placement_valid(grid_position: Vector2i, building_size: Vector2i) -> bool:
	"""
	Checks if a building can be placed at a location.
	This is now the single source of truth for placement.
	"""
	if not astar_grid:
		push_error("is_placement_valid: AStarGrid is not initialized!")
		return false
	
	# Check all cells the building would occupy
	for x in range(building_size.x):
		for y in range(building_size.y):
			var cell_pos = grid_position + Vector2i(x, y)
			
			# 1. Check if cell is within grid bounds
			if not _is_cell_within_bounds(cell_pos):
				return false
			
			# 2. Check if cell is already solid (occupied)
			if astar_grid.is_point_solid(cell_pos):
				return false
	
	# All cells are valid and unoccupied
	return true

# --- RENAMED FUNCTION (was _is_position_valid) ---
func _is_cell_within_bounds(grid_position: Vector2i) -> bool:
	"""Check if a *single* grid cell is within the AStarGrid bounds"""
	return grid_position.x >= 0 and grid_position.x < grid_width and \
		   grid_position.y >= 0 and grid_position.y < grid_height

# --- REMOVED FUNCTION ---
# _is_position_occupied() is no longer needed, as its logic
# is now correctly handled by is_placement_valid() checking the AStarGrid.

func set_astar_point_solid(grid_position: Vector2i, solid: bool) -> void:
	"""Public interface to set pathfinding grid points as solid/passable"""
	if not astar_grid:
		push_warning("AStarGrid not initialized")
		return
	
	if not _is_cell_within_bounds(grid_position):
		push_warning("Grid position %s is out of bounds" % grid_position)
		return
	
	if astar_grid.region.size.x <= 0 or astar_grid.region.size.y <= 0:
		push_warning("AStarGrid region is invalid")
		return
	
	astar_grid.set_point_solid(grid_position, solid)
	# Don't call update() here - let caller decide when to batch update

func _detect_and_set_grid_size() -> void:
	"""Auto-detect the current scene type and set appropriate grid size"""
	var current_scene = get_tree().current_scene
	if not current_scene:
		print("SettlementManager: No current scene found for auto-detection")
		return
	
	var scene_name = current_scene.name.to_lower()
	var scene_path = current_scene.scene_file_path.to_lower()
	
	print("SettlementManager: Detecting scene type from '%s' (%s)" % [scene_name, scene_path])
	
	# Detect raid missions
	if "raid" in scene_name or "raid" in scene_path:
		grid_width = raid_grid_size.x
		grid_height = raid_grid_size.y
		print("SettlementManager: Auto-detected RAID mission - using grid %dx%d" % [grid_width, grid_height])
	
	# Detect defensive missions
	elif "defensive" in scene_name or "defense" in scene_path or "sacked" in scene_name:
		grid_width = defense_grid_size.x
		grid_height = defense_grid_size.y
		print("SettlementManager: Auto-detected DEFENSIVE mission - using grid %dx%d" % [grid_width, grid_height])
	
	# Detect settlement/bridge scenes
	elif "settlement" in scene_name or "bridge" in scene_path:
		grid_width = settlement_grid_size.x
		grid_height = settlement_grid_size.y
		print("SettlementManager: Auto-detected SETTLEMENT scene - using grid %dx%d" % [grid_width, grid_height])
	
	# Use large default for unknown scenes
	else:
		print("SettlementManager: Unknown scene type - using default large grid %dx%d" % [grid_width, grid_height])

--- SCRIPT: res://data/buildings/Base_Building.gd ---
# res://scenes/buildings/Base_Building.gd
#
# --- MODIFIED: Added debug warnings and robust checks ---

class_name BaseBuilding
extends StaticBody2D

## This signal is emitted when health reaches zero.
## GDD Ref:
signal building_destroyed(building: BaseBuilding)

@export var data: BuildingData
var current_health: int = 100

# Get a reference to the nodes
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision_shape: CollisionShape2D = $CollisionShape2D

func _ready() -> void:
	if not data:
		push_warning("BaseBuilding: Node is missing its 'BuildingData' resource. Cannot initialize.")
		return
	
	current_health = data.max_health
	
	# --- Apply Texture and Scaling ---
	_apply_texture_and_scale()

func _apply_texture_and_scale() -> void:
	"""
	Applies the texture from 'data' and scales both the
	sprite and collision shape to match the 'data.grid_size'.
	"""
	
	# 1. Validate SettlementManager and tile_size
	if not SettlementManager or SettlementManager.tile_size <= 0:
		push_error("BaseBuilding: SettlementManager not ready or tile_size is invalid (<= 0). Cannot scale '%s'." % data.display_name)
		return
		
	# 2. Get the target size based on grid
	var tile_size: float = SettlementManager.tile_size
	var target_size: Vector2 = Vector2(data.grid_size) * tile_size
	
	if target_size.x <= 0 or target_size.y <= 0:
		push_warning("BaseBuilding: '%s' has a grid_size of %s, resulting in an invalid target_size." % [data.display_name, data.grid_size])
		return

	# 3. Apply and Scale the Sprite
	if data.building_texture:
		sprite.texture = data.building_texture
		var texture_size: Vector2 = sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			# Non-uniform scaling to fill the grid space
			var new_scale: Vector2 = target_size / texture_size
			sprite.scale = new_scale
		else:
			push_warning("BaseBuilding: Texture for '%s' has an invalid size of %s. Cannot scale sprite." % [data.display_name, texture_size])
	else:
		push_warning("BaseBuilding: '%s' is missing its 'building_texture'. Sprite will be blank or use placeholder." % data.display_name)
		
	# 4. Scale the Collision Shape
	if collision_shape and collision_shape.shape is RectangleShape2D:
		# Set extents to *half* the target size (from center)
		collision_shape.shape.extents = target_size / 2.0
	else:
		push_warning("BaseBuilding: '%s' is missing its CollisionShape2D node or its shape is not a RectangleShape2D. Collision will not match visuals." % data.display_name)

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	# Removed the print statement for cleaner debug output
	# print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been destroyed." % data.display_name)
	
	# Add visual feedback for destruction
	_show_destruction_effect()
	
	# Emit the signal *before* queue_free() so listeners
	# can react before the node is deleted.
	building_destroyed.emit(self)
	
	# Remove from groups before deletion
	remove_from_group("enemy_buildings")
	
	# Queue for deletion on the next frame
	print("Building %s queued for removal from scene" % data.display_name)
	queue_free()

func _show_destruction_effect() -> void:
	"""Add a simple visual destruction effect"""
	# Create a simple destruction tween for visual feedback
	var tween = create_tween()
	
	# Scale down and fade out
	tween.parallel().tween_property(self, "scale", Vector2(0.1, 0.1), 0.3)
	tween.parallel().tween_property(self, "modulate", Color.TRANSPARENT, 0.3)
	
	# Optional: Add rotation for dramatic effect
	tween.parallel().tween_property(self, "rotation", randf() * TAU, 0.3)

--- SCRIPT: res://data/buildings/BuildingData.gd ---
# res://data/buildings/BuildingData.gd
#
# Defines the core data for any building in the game.
#
# --- MODIFIED: Added 'class_name BuildingData' ---

class_name BuildingData
extends Resource

## The name displayed in the UI (e.g., "Stone Wall", "Watchtower").
@export var display_name: String = "New Building"

## The scene that will be instanced when this building is placed.
@export var scene_to_spawn: PackedScene

## The icon shown in the build menu.
@export var icon: Texture2D

## Texture shown on screen
@export var building_texture: Texture2D

## The cost in 'Resources' (e.g., wood, gold) to build this.
@export var build_cost: Dictionary

## The building's maximum hit points.
@export var max_health: int = 100

## If true, this building blocks enemy pathfinding.
@export var blocks_pathfinding: bool = true

## The size of the building on the AStarGrid2D.
@export var grid_size: Vector2i = Vector2i.ONE

## If true, this building will appear in the player's Storefront UI.
@export var is_player_buildable: bool = false

@export_group("Defensive Stats")
## If true, this building can attack enemies (e.g., Watchtower).
@export var is_defensive_structure: bool = false

## Damage dealt per attack (if defensive).
@export var attack_damage: int = 5

## Range in pixels (if defensive).
@export var attack_range: float = 200.0

## Attacks per second (if defensive).
@export var attack_speed: float = 1.0

--- SCRIPT: res://data/buildings/EconomicBuildingData.gd ---
# res://data/buildings/EconomicBuildingData.gd
extends BuildingData
class_name EconomicBuildingData

@export_group("Economic Stats")
## The type of resource this building generates (e.g., "wood", "food", "gold").
@export var resource_type: String = "wood"

## The fixed amount of resources generated after each successful attack.
@export var fixed_payout_amount: int = 10

## The maximum amount of the resource that can be stored before collection.
@export var storage_cap: int = 100

--- SCRIPT: res://data/characters/JarlData.gd ---
# res://data/characters/JarlData.gd
#
# Defines the persistent data for a Jarl character in Viking Dynasty.
# This resource stores all the attributes that persist across the dynasty layer.
# GDD Ref: Section 2.A (Macro Layer), Appendix A.2 (Renown & Succession Loop)

class_name JarlData
extends Resource

## The Jarl's name displayed in the UI
@export var display_name: String = "New Jarl"

## The Jarl's portrait/icon for the UI
@export var portrait: Texture2D

## The Jarl's age in years
@export var age: int = 25

## The Jarl's gender (affects marriage and succession options)
@export var gender: String = "Male"  # "Male", "Female"


@export_group("Dynasty & Authority")
## Total Renown accumulated by this Jarl (persistent XP/Legacy score)
@export var renown: int = 0

## Current Renown Tier (determines Authority cap per year)
## Tiers: 0="Petty Jarl", 1="High Jarl", 2="Kingmaker", etc.
@export var renown_tier: int = 0

## Authority remaining for this year (action points for Macro layer)
@export var current_authority: int = 3

## Maximum Authority this Jarl can generate per year (based on Renown Tier)
@export var max_authority: int = 3

## Years since last offensive action (for Renown Decay calculations)
@export var years_since_action: int = 0


@export_group("Base Skills")
## Combat leadership and personal prowess
@export var command: int = 10

## Diplomatic skills and charm
@export var diplomacy: int = 10

## Strategic planning and administration
@export var stewardship: int = 10

## Religious knowledge and mysticism
@export var learning: int = 10

## Personal combat skill and courage
@export var prowess: int = 10

## Ability to inspire and lead
@export var charisma: int = 10


@export_group("Traits")
## Array of TraitData resources that modify the Jarl's abilities and story
@export var traits: Array[TraitData] = []

## Legacy trait names for backward compatibility (can be removed later)
@export var legacy_trait_names: Array[String] = []

## Whether this Jarl is currently wounded (affects stats temporarily)
@export var is_wounded: bool = false

## Number of turns remaining for wound recovery
@export var wound_recovery_turns: int = 0


@export_group("Family & Succession")
## The Jarl's spouse (if any)
@export var spouse_name: String = ""

## Array of heir names in order of succession priority
@export var heirs: Array[String] = []

## Whether this Jarl has a designated heir
@export var has_valid_heir: bool = false

## Number of living children
@export var children_count: int = 0


@export_group("Political Status")
## Current title/rank in the political hierarchy
@export var title: String = "Jarl"

## Number of vassals under this Jarl's rule
@export var vassal_count: int = 0

## Overall diplomatic reputation with other Jarls
@export var reputation: int = 0

## Whether this Jarl is currently in exile or displaced
@export var is_in_exile: bool = false


@export_group("Combat & Mission State")
## Whether the Jarl is currently leading a raid (affects vulnerability)
@export var is_on_mission: bool = false

## Number of battles this Jarl has fought
@export var battles_fought: int = 0

## Number of battles this Jarl has won
@export var battles_won: int = 0

## Total successful raids completed
@export var successful_raids: int = 0


## Get the effective skill value including trait modifiers
func get_effective_skill(skill_name: String) -> int:
	var base_value: int = 0
	
	match skill_name.to_lower():
		"command":
			base_value = command
		"diplomacy":
			base_value = diplomacy
		"stewardship":
			base_value = stewardship
		"learning":
			base_value = learning
		"prowess":
			base_value = prowess
		"charisma":
			base_value = charisma
		_:
			return 0
	
	# Apply trait modifiers
	var trait_modifier: int = 0
	for trait in traits:
		if trait == null:
			continue
		
		match skill_name.to_lower():
			"command":
				trait_modifier += trait.command_modifier
			"stewardship":
				trait_modifier += trait.stewardship_modifier
			"intrigue":
				trait_modifier += trait.intrigue_modifier
	
	return base_value + trait_modifier


## Add a trait to the Jarl (if not already present)
func add_trait(trait_data: TraitData) -> void:
	if trait_data == null:
		return
	# Check if we already have this trait (by display name)
	for existing_trait in traits:
		if existing_trait != null and existing_trait.display_name == trait_data.display_name:
			return
	traits.append(trait_data)


## Check if Jarl has a specific trait by display name
func has_trait(trait_name: String) -> bool:
	for trait in traits:
		if trait != null and trait.display_name == trait_name:
			return true
	return false


## Get the Jarl's Authority cap based on Renown Tier (GDD reference)
func get_authority_cap() -> int:
	match renown_tier:
		0: return 3  # Petty Jarl
		1: return 5  # High Jarl
		2: return 7  # Kingmaker
		_: return 3 + renown_tier  # Future tiers


## Check if the Jarl can take an action (has Authority remaining)
func can_take_action(authority_cost: int = 1) -> bool:
	return current_authority >= authority_cost


## Spend Authority for an action
func spend_authority(cost: int = 1) -> bool:
	if can_take_action(cost):
		current_authority -= cost
		return true
	return false


## Award Renown for completing a major action
func award_renown(amount: int) -> void:
	renown += amount
	years_since_action = 0
	_update_renown_tier()


## Update Renown Tier based on current Renown
func _update_renown_tier() -> void:
	if renown >= 1000:
		renown_tier = 3
	elif renown >= 500:
		renown_tier = 2
	elif renown >= 200:
		renown_tier = 1
	else:
		renown_tier = 0


## Reset Authority at the start of a new year
func reset_authority() -> void:
	max_authority = get_authority_cap()
	current_authority = max_authority


## Apply aging effects to the Jarl
func age_jarl(years: int = 1) -> void:
	age += years
	years_since_action += years
	
	# Apply age-related skill changes
	if age > 60:
		# Older Jarls lose prowess but gain wisdom
		prowess = max(1, prowess - 1)
		learning = min(20, learning + 1)


## Get a summary string of the Jarl's current status
func get_status_summary() -> String:
	var status_parts: Array[String] = []
	
	status_parts.append("Age: %d" % age)
	status_parts.append("Renown: %d (Tier %d)" % [renown, renown_tier])
	status_parts.append("Authority: %d/%d" % [current_authority, max_authority])
	
	if is_wounded:
		status_parts.append("WOUNDED (%d turns)" % wound_recovery_turns)
	
	if is_on_mission:
		status_parts.append("ON MISSION")
	
	return " | ".join(status_parts)


## Remove a trait by display name
func remove_trait(trait_name: String) -> bool:
	for i in range(traits.size()):
		if traits[i] != null and traits[i].display_name == trait_name:
			traits.remove_at(i)
			return true
	return false


## Get all trait names as a string array (for easy saving/display)
func get_trait_names() -> Array[String]:
	var trait_names: Array[String] = []
	for trait in traits:
		if trait != null:
			trait_names.append(trait.display_name)
	return trait_names

--- SCRIPT: res://data/missions/RaidLootData.gd ---
# res://data/missions/RaidLootData.gd
# Resource for tracking loot collected during raids
# GDD Ref: Phase 3 Task 7 - Resource-Driven Payout

extends Resource
class_name RaidLootData

@export var collected_loot: Dictionary = {}

func _init() -> void:
	# Initialize with default resource types
	collected_loot = {
		"gold": 0,
		"wood": 0,
		"food": 0,
		"stone": 0
	}

func add_loot(resource_type: String, amount: int) -> void:
	"""Add loot to the collection"""
	if collected_loot.has(resource_type):
		collected_loot[resource_type] += amount
	else:
		collected_loot[resource_type] = amount
	
	print("Loot added: %d %s (Total: %d)" % [amount, resource_type, collected_loot[resource_type]])

func add_loot_from_building(building_data: BuildingData) -> void:
	"""Extract loot from a destroyed building"""
	if not building_data:
		return
	
	# For EconomicBuildingData, give loot based on the resource type
	if building_data is EconomicBuildingData:
		var eco_data: EconomicBuildingData = building_data
		var loot_amount = eco_data.fixed_payout_amount * 3  # 3x the daily payout as loot
		add_loot(eco_data.resource_type, loot_amount)
	else:
		# Default loot for other buildings
		add_loot("gold", 50)

func get_total_loot() -> Dictionary:
	"""Get a copy of the collected loot"""
	return collected_loot.duplicate()

func clear_loot() -> void:
	"""Reset all loot to zero"""
	for resource_type in collected_loot:
		collected_loot[resource_type] = 0

func get_loot_summary() -> String:
	"""Get a formatted string of collected loot"""
	var summary_parts: Array[String] = []
	for resource_type in collected_loot:
		if collected_loot[resource_type] > 0:
			summary_parts.append("%d %s" % [collected_loot[resource_type], resource_type])
	
	if summary_parts.is_empty():
		return "No loot collected"
	else:
		return "Loot: " + ", ".join(summary_parts)

--- SCRIPT: res://data/settlements/SettlementData.gd ---
extends Resource
class_name SettlementData

@export var treasury: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}

# Stores building data and position. Structure:
# {"resource_path": "res://...", "grid_position": Vector2i(x, y)}
@export var placed_buildings: Array[Dictionary] = []

# Stores unit type (path) and count (int)
# Example: {"res://data/units/Unit_Raider.tres": 3}
@export var garrisoned_units: Dictionary = {}

--- SCRIPT: res://data/traits/TraitData.gd ---
# This resource defines the statistical and diplomatic impact of a single trait.
class_name TraitData
extends Resource

## General Information
@export var display_name: String = ""
@export var description: String = ""
@export var is_visible: bool = true # Should the player/AI know about this trait?

## Character Skill Modifiers (Permanent)
# Used to adjust the Jarl's base skills (Command, Stewardship, Intrigue)
@export_group("Skill Modifiers")
@export var command_modifier: int = 0
@export var stewardship_modifier: int = 0
@export var intrigue_modifier: int = 0

## Macro Layer Modifiers (Diplomacy/Renown)
@export_group("Macro Modifiers")
@export var renown_per_year_modifier: float = 0.0 # Used for passive Renown gain/loss
@export var vassal_opinion_modifier: int = 0  # Global change to vassal opinion of Jarl
@export var alliance_cost_modifier: float = 1.0 # Multiplier for alliance Authority cost

## Behavioral Flags (For AI and Event Triggers)
@export_group("Behavior Flags")
@export var is_wounded_trait: bool = false # e.g., Maimed, Crippled
@export var is_dishonorable_trait: bool = false # e.g., Betrayer, Cowardly

--- SCRIPT: res://data/units/UnitData.gd ---
# res://data/units/UnitData.gd
#
# Defines the core data for any unit in the game.
# This resource is used by Base_Unit.tscn to configure instances.
# GDD Ref: 7.C.1.b

class_name UnitData
extends Resource

## The name displayed in the UI (e.g., "Viking Raider").
@export var display_name: String = "New Unit"

## The scene that will be instanced when this unit is spawned.
@export var scene_to_spawn: PackedScene

## The icon shown in the training menu.
@export var icon: Texture2D

## The cost in 'Resources' to train this unit.
@export var spawn_cost: Dictionary = {"food": 25}


@export_group("Combat Stats")
## The unit's maximum hit points.
@export var max_health: int = 50

## Movement speed in pixels per second.
@export var move_speed: float = 75.0

## Damage dealt per attack.
@export var attack_damage: int = 8

## Range in pixels. (e.g., 10 for melee, 300 for archer).
@export var attack_range: float = 10.0

## Attacks per second.
@export var attack_speed: float = 1.2


@export_group("Visuals")
## The texture to use for the unit's sprite.
@export var visual_texture: Texture2D

## The target gameplay size in pixels (e.g., 32x32).
@export var target_pixel_size: Vector2 = Vector2(32, 32)

--- SCRIPT: res://player/RTSCamera.gd ---
# res://player/RTSCamera.gd
# Basic RTS-style camera controller for Phase 3
# Provides WASD movement and mouse edge panning
# Keeps camera controls simple and focused on tactical gameplay

extends Camera2D
class_name RTSCamera

@export var camera_speed: float = 400.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_wasd_movement: bool = true

# Movement bounds to keep camera on battlefield
@export var bounds_enabled: bool = false
@export var bounds_rect: Rect2 = Rect2(-500, -500, 1500, 1200)

func _ready() -> void:
	# Make this the current camera
	make_current()

func _process(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	
	# WASD camera movement (as specified in GDD Phase 3)
	if enable_wasd_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Mouse edge panning (common RTS feature)
	if enable_edge_panning:
		var mouse_pos = get_viewport().get_mouse_position()
		var viewport_size = get_viewport().get_visible_rect().size
		
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
			
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		global_position += movement_vector * camera_speed * delta
		
		# Apply bounds if enabled
		if bounds_enabled:
			global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.position.x + bounds_rect.size.x)
			global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.position.y + bounds_rect.size.y)

--- SCRIPT: res://player/RTSController.gd ---
# res://player/RTSController.gd
#
# --- REFACTORED ---
# This script is now decoupled from input.
# It listens for clean signals from the EventBus
# (which are fired by SelectionBox.gd).
# It also correctly cleans up dead units.

extends Node
class_name RTSController

var selected_units: Array[BaseUnit] = []
var controllable_units: Array[BaseUnit] = []
var current_formation: SquadFormation.FormationType = SquadFormation.FormationType.LINE

func _ready() -> void:
	# Connect to the clean signals from our new EventBus/SelectionBox
	EventBus.select_command.connect(_on_select_command)
	EventBus.move_command.connect(_on_move_command)
	EventBus.attack_command.connect(_on_attack_command)

func _input(event: InputEvent) -> void:
	# Formation hotkeys
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_1:
				current_formation = SquadFormation.FormationType.LINE
				print("Formation: LINE")
			KEY_2:
				current_formation = SquadFormation.FormationType.COLUMN
				print("Formation: COLUMN")
			KEY_3:
				current_formation = SquadFormation.FormationType.WEDGE
				print("Formation: WEDGE")
			KEY_4:
				current_formation = SquadFormation.FormationType.BOX
				print("Formation: BOX")

# --- PUBLIC API ---

func add_unit_to_group(unit: Node2D) -> void:
	# Verify the unit is a BaseUnit (which has 'destroyed' signal)
	if not unit is BaseUnit:
		push_error("RTSController: Tried to add unit '%s' that doesn't extend BaseUnit." % unit.name)
		return
		
	if unit in controllable_units:
		return

	controllable_units.append(unit)
	
	# --- THIS IS THE DEAD UNIT CRASH FIX ---
	# Connect to this unit's 'destroyed' signal.
	# When it's destroyed, we'll clean it up.
	# We use CONNECT_DEFERRED to avoid race conditions.
	if unit.has_signal("destroyed"):
		unit.destroyed.connect(remove_unit.bind(unit), CONNECT_DEFERRED)
	else:
		# This check is vital. Our old debug units will fail this.
		push_warning("Unit %s does not have 'destroyed' signal!" % unit.name)

func remove_unit(unit: BaseUnit) -> void:
	"""Removes a unit from tracking. Called by the unit's 'destroyed' signal."""
	print("RTSController: Unit %s was destroyed/removed." % unit.name)
	
	if unit in selected_units:
		selected_units.erase(unit)
		if is_instance_valid(unit):
			# set_selected is a function on BaseUnit
			unit.set_selected(false)
			
	if unit in controllable_units:
		controllable_units.erase(unit)
		
	# Check if this was the last unit
	if controllable_units.is_empty():
		print("RTSController: All units are gone.")

# --- REMOVED ---
# _on_global_input, _draw, _process, _handle_selection,
# and _handle_command are all removed.
# They are replaced by the functions below.
# -----------------

# --- NEW: EVENTBUS HANDLERS ---

func _on_select_command(select_rect: Rect2, is_box_select: bool) -> void:
	_clear_selection()
	
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	if not main_camera:
		push_error("RTSController: No Camera2D found to perform selection.")
		return
	
	if is_box_select:
		# Box select - convert screen rect to world coordinates instead
		# This is more reliable than converting world to screen for each unit
		var camera_pos = main_camera.get_screen_center_position()
		var camera_zoom = main_camera.zoom
		var viewport_size = get_viewport().get_visible_rect().size
		
		# Convert screen rectangle to world coordinates
		var world_rect_min = camera_pos - (viewport_size / (2.0 * camera_zoom)) + (select_rect.position / camera_zoom)
		var world_rect_max = world_rect_min + (select_rect.size / camera_zoom)
		var world_rect = Rect2(world_rect_min, world_rect_max - world_rect_min)
		
		for unit in controllable_units:
			if world_rect.has_point(unit.global_position):
				selected_units.append(unit)
				unit.set_selected(true)
	else:
		# Single select (find closest unit to the click)
		# We must get the world position from the camera
		var click_world_pos := main_camera.get_global_mouse_position()
		var closest_unit: BaseUnit = null
		var min_dist_sq = INF
		
		for unit in controllable_units:
			var dist_sq = unit.global_position.distance_squared_to(click_world_pos)
			# 40px click radius
			if dist_sq < min_dist_sq and dist_sq < (40 * 40): 
				min_dist_sq = dist_sq
				closest_unit = unit
				
		if closest_unit:
			selected_units.append(closest_unit)
			closest_unit.set_selected(true)

func _on_move_command(target_position: Vector2) -> void:
	if selected_units.is_empty():
		return
	
	if selected_units.size() == 1:
		# Single unit - direct movement
		selected_units[0].command_move_to(target_position)
	else:
		# Multiple units - use formation
		var units_as_node2d: Array[Node2D] = []
		for unit in selected_units:
			units_as_node2d.append(unit)
		
		var formation = SquadFormation.new(units_as_node2d)
		formation.formation_type = current_formation
		formation.unit_spacing = 45.0
		formation.move_to_position(target_position)

func _on_attack_command(target_node: Node2D) -> void:
	if selected_units.is_empty():
		return
		
	for unit in selected_units:
		unit.command_attack(target_node)

func _clear_selection() -> void:
	for unit in selected_units:
		# Check if it's valid, it might have been destroyed
		if is_instance_valid(unit):
			unit.set_selected(false)
	selected_units.clear()

--- SCRIPT: res://scenes/missions/RaidMission.gd ---
# res://scenes/missions/RaidMission.gd
# Raid Mission Controller for Phase 3
# GDD Ref: Phase 3 Task 7
#
# --- REFACTORED ---
# This script is now decoupled from input.
# It gets a reference to the RTSController node
# and simply hands units to it.
extends Node2D

# --- Exported Mission Configuration ---
@export var enemy_base_data: SettlementData
@export var default_enemy_base_path: String = "res://data/settlements/monastery_base.tres"
@export_group("Enemy Base Presets")
@export var available_enemy_bases: Array[String] = [
	"res://data/settlements/monastery_base.tres",
	"res://data/settlements/fortress_base.tres"
]
@export var victory_bonus_loot: Dictionary = {"gold": 200}
@export var player_spawn_formation: Dictionary = {"units_per_row": 5, "spacing": 40}
@export var mission_difficulty: float = 1.0
@export var allow_retreat: bool = true

## The scene to return to after the mission ends (e.g., SettlementBridge.tscn)
# --- REMOVED ---
# @export var settlement_bridge_scene: PackedScene
# --- ADDED ---
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"


## If true, this mission will *not* check for the "all units destroyed" loss condition.
## This should be TRUE for the Sacked/Defensive mission.
@export var is_defensive_mission: bool = false

# --- MODIFIED: Node References ---
@onready var player_spawn_pos: Marker2D = $PlayerStartPosition
@onready var rts_controller: RTSController = $RTSController
# ---------------------------------

var enemy_hall: Node2D = null
var raid_loot: RaidLootData = null

# --- REMOVED ---
# var player_units: Array[Node2D] = []
# The RTSController now tracks all units.
# -----------------

func _ready() -> void:
	# Connect to the settlement_loaded signal - this works for both standalone and child scenarios
	EventBus.settlement_loaded.connect(_on_settlement_ready_for_mission)
	
	# If no settlement is currently loaded (standalone mode), load a test settlement
	if not SettlementManager.has_current_settlement():
		print("RaidMission: No current settlement - loading test settlement for standalone mode")
		_load_test_settlement()
		call_deferred("initialize_mission")
	else:
		print("RaidMission: Settlement already loaded - initializing mission")
		call_deferred("initialize_mission")

func _load_test_settlement() -> void:
	"""Load a test settlement with garrison units for standalone testing"""
	var test_settlement_path = "res://data/settlements/home_base_fixed.tres"
	var test_settlement = load(test_settlement_path) as SettlementData
	
	if test_settlement:
		print("RaidMission: Loading test settlement: %s" % test_settlement_path)
		print("RaidMission: Test settlement garrison: %s" % test_settlement.garrisoned_units)
		SettlementManager.load_settlement(test_settlement)
	else:
		push_error("RaidMission: Failed to load test settlement from %s" % test_settlement_path)

func _on_settlement_ready_for_mission(settlement_data: SettlementData) -> void:
	"""Called when settlement is loaded - only initialize if we haven't already"""
	if not raid_loot:  # Check if we've already initialized
		print("RaidMission: Settlement loaded - initializing mission")
		initialize_mission()


func initialize_mission() -> void:
	"""
	This function now contains all the logic that used to be in _ready().
	It is called either by _ready() (if standalone) or by SettlementBridge.gd.
	"""
	print("RaidMission starting...")
	
	# Verify controller was found
	if rts_controller == null:
		push_error("RaidMission: Critical error! RTSController node not found.")
		get_tree().quit() # This is a fatal error
		return
	
	raid_loot = RaidLootData.new()
	
	if not enemy_base_data:
		enemy_base_data = load(default_enemy_base_path)
		if not enemy_base_data:
			push_error("Could not load enemy base data from default path.")
			return
	
	_load_enemy_base()
	_update_astar_grid_for_enemy_base()
	_spawn_player_garrison()
	_setup_win_loss_conditions()

func _load_enemy_base() -> void:
	"""Load and instance the enemy's base from SettlementData"""
	print("Loading enemy base...")
	
	if not enemy_base_data:
		push_error("No enemy base data provided")
		return
	
	# Instance each building from the enemy's placed_buildings array
	for building_entry in enemy_base_data.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var loaded_resource = load(building_res_path)
		var building_data: BuildingData = loaded_resource as BuildingData
		
		if not building_data:
			push_error("Failed to load building resource as BuildingData: %s (loaded as %s)" % [building_res_path, loaded_resource.get_class() if loaded_resource else "null"])
			continue
		
		if not building_data.scene_to_spawn:
			push_error("Failed to load building: %s" % building_res_path)
			continue
		
		# Instance the building
		var building_instance: Node2D = building_data.scene_to_spawn.instantiate()
		building_instance.name = building_data.display_name + "_Enemy"
		
		# Set building data
		if "data" in building_instance:
			building_instance.data = building_data
		
		# Position the building (convert grid to world position)
		var world_pos: Vector2 = Vector2(grid_pos) * 32 + Vector2(16, 16) # 32 = tile size
		building_instance.global_position = world_pos
		
		# Add to enemy groups for targeting
		building_instance.add_to_group("enemy_buildings")
		
		# Set collision layer for right-click detection and targeting
		if building_instance.has_method("set_collision_layer"):
			building_instance.set_collision_layer(4)  # Layer 3 for enemy buildings
			building_instance.set_collision_mask(0)   # Don't physically collide with anything
			print("Building %s collision setup: layer=4, mask=0" % building_data.display_name)
		else:
			push_warning("Building %s does not have collision layer methods!" % building_data.display_name)
		
		# Verify collision shape exists
		var collision_shape = building_instance.get_node("CollisionShape2D")
		if collision_shape and collision_shape.shape:
			print("Building %s has collision shape: %s" % [building_data.display_name, collision_shape.shape.get_class()])
		else:
			push_error("Building %s missing collision shape!" % building_data.display_name)
		
		# Add debug area for targeting verification
		building_instance.set_meta("building_data", building_data)
		building_instance.set_meta("is_enemy_building", true)
		
		# Check if this is the Great Hall (main target)
		if building_data.display_name.to_lower().contains("hall"):
			enemy_hall = building_instance
			print("Found enemy hall: %s" % building_data.display_name)
			# Connect to building destroyed signal for win condition
			if building_instance.has_signal("building_destroyed"):
				building_instance.building_destroyed.connect(_on_enemy_hall_destroyed)
		
		# Connect ALL buildings to loot collection system
		if building_instance.has_signal("building_destroyed"):
			building_instance.building_destroyed.connect(_on_enemy_building_destroyed)
		
		# Add to scene
		add_child(building_instance)

func _update_astar_grid_for_enemy_base() -> void:
	"""Update the A* pathfinding grid to account for enemy buildings"""
	print("Updating A* grid for enemy base...")
	
	if not enemy_base_data:
		return
	
	# Process each building to update pathfinding grid
	for building_entry in enemy_base_data.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if not building_data:
			continue
		
		# Only block pathfinding for buildings that should block movement
		if building_data.blocks_pathfinding:
			var grid_size: Vector2i = building_data.grid_size
			
			# Mark all grid cells occupied by this building as blocked
			for x in range(grid_size.x):
				for y in range(grid_size.y):
					var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
					SettlementManager.set_astar_point_solid(cell_pos, true)
			
			print("Blocked pathfinding for %s at %s (size: %s)" % [
				building_data.display_name, grid_pos, grid_size
			])
		else:
			print("Building %s does not block pathfinding" % building_data.display_name)
	
	# Update the grid once after all buildings are processed
	if SettlementManager.astar_grid:
		SettlementManager.astar_grid.update()
		print("A* grid updated for enemy base with %d buildings" % enemy_base_data.placed_buildings.size())

func _spawn_player_garrison() -> void:
	"""Spawn player units from the garrison"""
	print("=== SPAWNING PLAYER GARRISON ===")
	
	if not SettlementManager.current_settlement:
		print("No current settlement found - spawning test units for demo")
		_spawn_test_units() 
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	if garrison.is_empty():
		print("No units in garrison to spawn")
		# We must still check for a loss condition
		# --- MODIFIED: Check if this is a defensive mission ---
		if not is_defensive_mission:
			call_deferred("_check_loss_condition")
		# -----------------------------------------------------
		return
	
	var units_per_row: int = player_spawn_formation.get("units_per_row", 5)
	var spacing: float = player_spawn_formation.get("spacing", 40.0)
	var current_row: int = 0
	var current_col: int = 0
	
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if not unit_data or not unit_data.scene_to_spawn:
			push_error("Failed to load unit data: %s" % unit_path)
			continue
		
		for i in range(unit_count):
			var unit_instance: Node2D = unit_data.scene_to_spawn.instantiate()
			
			# This is a critical check
			if not unit_instance is BaseUnit:
				push_error("Unit scene %s does not extend BaseUnit!" % unit_data.scene_to_spawn.get_path())
				continue
				
			unit_instance.name = unit_data.display_name + "_" + str(i)
			if "data" in unit_instance:
				unit_instance.data = unit_data
			
			var spawn_pos: Vector2 = player_spawn_pos.global_position
			spawn_pos.x += current_col * spacing
			spawn_pos.y += current_row * spacing
			unit_instance.global_position = spawn_pos
			
			unit_instance.add_to_group("player_units")
			
			# --- MODIFIED: This is the new, clean way ---
			# We hand the unit to our controller.
			rts_controller.add_unit_to_group(unit_instance)
			# --------------------------------------------
			
			add_child(unit_instance)
			
			current_col += 1
			if current_col >= units_per_row:
				current_col = 0
				current_row += 1


func _spawn_test_units() -> void:
	"""
	Spawn test units for demonstration.
	NOTE: This debug code is brittle as it creates
	units that are not BaseUnit.
	"""
	print("Spawning test units for box selection demo...")
	
	var units_per_row: int = 3
	var current_row: int = 0
	var current_col: int = 0
	
	for i in range(6):
		var test_unit = CharacterBody2D.new()
		# ... (rest of the test unit creation code) ...
		var script_source = """
extends CharacterBody2D
var is_selected: bool = false; var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0; var is_moving: bool = false
func set_selected(selected: bool) -> void: is_selected = selected; queue_redraw()
func _draw() -> void:
	if is_selected: draw_circle(Vector2.ZERO, 15.0, Color(1,1,0,0.8), false, 2.0)
func command_move_to(target_pos: Vector2) -> void: target_position = target_pos; is_moving = true
func command_attack(target: Node2D) -> void: print('%s attacking %s' % [name, target.name])
func set_target_position(pos: Vector2) -> void: target_position = pos; is_moving = true
func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var dir = (target_position - global_position).normalized()
		if global_position.distance_to(target_position) < 5.0:
			is_moving = false; velocity = Vector2.ZERO
		else: velocity = dir * move_speed
		move_and_slide()
"""
		var temp_script = GDScript.new(); temp_script.source_code = script_source
		temp_script.reload(); test_unit.set_script(temp_script)
		
		# ... (code to position and add_child the unit) ...
		var spawn_pos: Vector2 = player_spawn_pos.global_position
		spawn_pos.x += current_col * 60
		spawn_pos.y += current_row * 60
		test_unit.global_position = spawn_pos
		test_unit.add_to_group("player_units")
		add_child(test_unit)

		# --- MODIFIED: Register test unit with controller ---
		# We must check if it's a BaseUnit, which it is not.
		# This debug code will not work with our new system
		# without a significant rewrite.
		if test_unit is BaseUnit:
			rts_controller.add_unit_to_group(test_unit)
		else:
			push_warning("Test unit '%s' is not a BaseUnit. Skipping add to RTSController." % test_unit.name)
		# ----------------------------------------------------
		
		current_col += 1
		if current_col >= units_per_row:
			current_col = 0
			current_row += 1

# --- REMOVED ---
# The _setup_rts_controller() function is now gone.
# -----------------

func _on_enemy_building_destroyed(building: BaseBuilding) -> void:
	"""Called when any enemy building is destroyed - collect loot and update grid"""
	var building_data = building.data as BuildingData
	
	if raid_loot and building_data:
		raid_loot.add_loot_from_building(building_data)
		print("Building destroyed: %s | %s" % [building_data.display_name, raid_loot.get_loot_summary()])
	
	# Update pathfinding grid to make the area passable again
	_clear_building_from_pathfinding_grid(building)
	
	# Count remaining buildings for mission tracking
	var remaining_buildings = get_tree().get_nodes_in_group("enemy_buildings").size()
	print("Buildings remaining: %d" % remaining_buildings)

func _clear_building_from_pathfinding_grid(building: BaseBuilding) -> void:
	"""Remove building's collision from pathfinding grid"""
	if not building.data:
		return
		
	# Calculate the grid position from the building's world position
	var world_pos = building.global_position
	var grid_pos = Vector2i((world_pos - Vector2(16, 16)) / 32)  # Reverse the positioning logic
	var grid_size = building.data.grid_size
	
	# Clear all grid cells that were occupied by this building
	for x in range(grid_size.x):
		for y in range(grid_size.y):
			var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
			SettlementManager.set_astar_point_solid(cell_pos, false)
	
	# Update the grid
	if SettlementManager.astar_grid:
		SettlementManager.astar_grid.update()
		print("Cleared pathfinding for destroyed building at %s (size: %s)" % [grid_pos, grid_size])

func _setup_win_loss_conditions() -> void:
	"""Setup win/loss condition monitoring"""
	# --- MODIFIED: Check if this is a defensive mission ---
	if not is_defensive_mission:
		# Start periodic check for loss condition
		_check_loss_condition()
	else:
		print("RaidMission: Skipping 'all units destroyed' loss check for defensive mission.")
	# -----------------------------------------------------

func _check_loss_condition() -> void:
	"""Check if all player units are destroyed (loss condition)"""
	# This is a recursive timer loop.
	await get_tree().create_timer(1.0).timeout
	
	# --- MODIFIED: Ask the controller ---
	# The RTSController is now the single source of truth for unit counts.
	var remaining_units = 0
	if is_instance_valid(rts_controller):
		remaining_units = rts_controller.controllable_units.size()
	# ------------------------------------
	
	print("Loss check: %d units remaining" % remaining_units)
	
	if remaining_units == 0:
		_on_mission_failed()
		return # Stop the loop
	
	# Continue checking if mission is still active
	if is_instance_valid(enemy_hall):
		_check_loss_condition()
	else:
		print("Loss condition checking stopped - enemy hall destroyed")

func _on_mission_failed() -> void:
	"""Called when all player units are destroyed"""
	print("Mission Failed! All units destroyed.")
	
	_show_failure_message()
	
	await get_tree().create_timer(3.0).timeout
	
	# --- MODIFIED: Emit signal ---
	if not settlement_bridge_scene_path.is_empty():
		EventBus.scene_change_requested.emit(settlement_bridge_scene_path)
	else:
		push_error("RaidMission: settlement_bridge_scene_path is not set! Cannot return to settlement.")
	# --- END MODIFICATION ---


func _show_failure_message() -> void:
	"""Display the mission failure message to the player"""
	var failure_popup = Control.new()
	failure_popup.name = "FailurePopup"
	failure_popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	
	var bg_panel = Panel.new()
	bg_panel.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg_panel.modulate = Color(0, 0, 0, 0.7)
	failure_popup.add_child(bg_panel)
	
	var message_container = VBoxContainer.new()
	message_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	message_container.size = Vector2(300, 150)
	
	var failure_label = Label.new()
	failure_label.text = "RAID FAILED!"
	# ... (rest of label setup)
	message_container.add_child(failure_label)
	
	var subtitle_label = Label.new()
	subtitle_label.text = "All units destroyed"
	# ... (rest of label setup)
	message_container.add_child(subtitle_label)
	
	var return_label = Label.new()
	return_label.text = "Returning to settlement..."
	# ... (rest of label setup)
	message_container.add_child(return_label)
	
	failure_popup.add_child(message_container)
	add_child(failure_popup)
	print("Failure message displayed")

func _on_enemy_hall_destroyed(_building: BaseBuilding = null) -> void:
	"""Called when the enemy's Great Hall is destroyed"""
	print("Enemy Hall destroyed! Mission success!")
	
	var total_loot = raid_loot.get_total_loot()
	raid_loot.add_loot("gold", 200) # Bonus
	total_loot = raid_loot.get_total_loot()
	
	SettlementManager.deposit_resources(total_loot)
	print("Mission Complete! %s" % raid_loot.get_loot_summary())
	
	await get_tree().create_timer(2.0).timeout
	
	# --- MODIFIED: Emit signal ---
	if not settlement_bridge_scene_path.is_empty():
		EventBus.scene_change_requested.emit(settlement_bridge_scene_path)
	else:
		push_error("Ra...
		
		idMission: settlement_bridge_scene_path is not set! Cannot return to settlement.")
	# --- END MODIFICATION ---

--- SCRIPT: res://scenes/world_map/WorldMap_Stub.gd ---
# res://scenes/world_map/WorldMap_Stub.gd
# World map interface for selecting raid targets
# GDD Ref: Phase 3 Task 6

extends Control

# --- MODIFIED: Use String paths, not PackedScene ---
## The main raid mission scene to load (e.g., RaidMission.tscn)
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"

## The scene to return to (e.g., SettlementBridge.tscn)
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
# --- END MODIFICATION ---

@onready var raid_monastery_button: Button = $ButtonContainer/RaidMonasteryButton
@onready var back_button: Button = $ButtonContainer/BackButton

func _ready() -> void:
	raid_monastery_button.pressed.connect(_on_raid_monastery_pressed)
	back_button.pressed.connect(_on_back_pressed)
	
	# Validate that we can actually raid (have settlement & units)
	_validate_raid_capability()

func _validate_raid_capability() -> void:
	"""Ensure the player can actually start a raid"""
	if not SettlementManager.current_settlement:
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Settlement Loaded"
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Units Available"
		return
	
	raid_monastery_button.disabled = false

func _on_raid_monastery_pressed() -> void:
	"""Launch the raid mission"""
	print("Starting raid on nearby monastery...")
	
	# Additional validation before starting raid
	if not SettlementManager.current_settlement:
		push_error("Cannot start raid: No settlement loaded")
		return
	
	# --- MODIFIED: Emit signal ---
	if not raid_mission_scene_path.is_empty():
		EventBus.scene_change_requested.emit(raid_mission_scene_path)
	else:
		push_error("WorldMap_Stub: raid_mission_scene_path is not set! Cannot start raid.")
	# --- END MODIFICATION ---

func _on_back_pressed() -> void:
	"""Return to the settlement"""
	print("Returning to settlement...")
	
	# --- MODIFIED: Emit signal ---
	if not settlement_bridge_scene_path.is_empty():
		EventBus.scene_change_requested.emit(settlement_bridge_scene_path)
	else:
		push_error("WorldMap_Stub: settlement_bridge_scene_path is not set! Cannot return.")
	# --- END MODIFICATION ---

--- SCRIPT: res://scripts/ai/SentryAI.gd ---
# res://scripts/ai/SentryAI.gd
# Simple Sentry AI for enemy defenders in Phase 3
# GDD Ref: Phase 3 - Enemy MVP (Simple Sentry AI)

extends Node2D
class_name SentryAI

@export var detection_radius: float = 80.0
@export var attack_damage: int = 25
@export var attack_cooldown: float = 1.5

var detection_area: Area2D
var attack_timer: float = 0.0
var current_target: Node2D = null

signal enemy_detected(target: Node2D)
signal attack_executed(target: Node2D, damage: int)

func _ready() -> void:
	_setup_detection_area()
	set_process(true)

func _setup_detection_area() -> void:
	"""Create detection area for sentry"""
	detection_area = Area2D.new()
	detection_area.name = "DetectionArea"
	
	var collision_shape = CollisionShape2D.new()
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = detection_radius
	collision_shape.shape = circle_shape
	
	detection_area.add_child(collision_shape)
	add_child(detection_area)
	
	# Connect signals
	detection_area.body_entered.connect(_on_body_entered)
	detection_area.body_exited.connect(_on_body_exited)
	
	# Set collision mask to detect player units (layer 1)
	detection_area.collision_mask = 1

func _process(delta: float) -> void:
	# Update attack timer
	if attack_timer > 0:
		attack_timer -= delta
	
	# Check for and attack valid targets
	if current_target and is_instance_valid(current_target):
		if attack_timer <= 0:
			_attack_target(current_target)
			attack_timer = attack_cooldown
	else:
		current_target = null

func _on_body_entered(body: Node2D) -> void:
	"""Handle detection of player units"""
	if body.is_in_group("player_units") and not current_target:
		current_target = body
		enemy_detected.emit(body)
		print("%s detected enemy: %s" % [get_parent().name, body.name])

func _on_body_exited(body: Node2D) -> void:
	"""Handle player units leaving detection range"""
	if body == current_target:
		current_target = null
		print("%s lost target: %s" % [get_parent().name, body.name])

func _attack_target(target: Node2D) -> void:
	"""Execute attack on target"""
	if not target or not is_instance_valid(target):
		return
	
	# Check if target is still in range
	var distance = global_position.distance_to(target.global_position)
	if distance > detection_radius:
		current_target = null
		return
	
	print("%s attacking %s for %d damage" % [get_parent().name, target.name, attack_damage])
	
	# Apply damage if target has take_damage method
	if target.has_method("take_damage"):
		target.take_damage(attack_damage)
	elif target.has_method("receive_damage"):
		target.receive_damage(attack_damage)
	else:
		# Fallback: just remove the target for demo purposes
		print("Target %s destroyed by sentry attack" % target.name)
		target.queue_free()
	
	attack_executed.emit(target, attack_damage)

func get_detection_radius() -> float:
	"""Get current detection radius"""
	return detection_radius

func set_detection_radius(new_radius: float) -> void:
	"""Update detection radius"""
	detection_radius = new_radius
	if detection_area:
		var collision_shape = detection_area.get_child(0) as CollisionShape2D
		if collision_shape and collision_shape.shape is CircleShape2D:
			collision_shape.shape.radius = detection_radius

func is_actively_defending() -> bool:
	"""Check if sentry is currently engaged with a target"""
	return current_target != null and is_instance_valid(current_target)

--- SCRIPT: res://scripts/ai/UnitFSM.gd ---
# res://scripts/ai/UnitFSM.gd
# Refactored UnitFSM for Phase 3 RTS commands
# GDD Ref: Phase 3 Task 4

class_name UnitFSM

enum State { IDLE, MOVING, ATTACKING }
enum Stance { DEFENSIVE, HOLD_POSITION } # Future-proofed for other stances

# Unit References
var unit: BaseUnit
var attack_timer: Timer

# State Data
var current_state: State = State.IDLE
var stance: Stance = Stance.DEFENSIVE
var path: Array = []

# Target Data
var target_position: Vector2 = Vector2.ZERO
var target_unit: Node2D = null # Can be BaseBuilding or BaseUnit
var move_command_position: Vector2 = Vector2.ZERO

func _init(p_unit: BaseUnit, p_timer: Timer) -> void:
	unit = p_unit
	attack_timer = p_timer
	
	# Connect the timer's timeout signal to our attack function
	attack_timer.timeout.connect(_on_attack_timer_timeout)

func change_state(new_state: State) -> void:
	if current_state == new_state:
		return
	
	_exit_state(current_state)
	current_state = new_state
	# Notify unit visuals of state change
	if unit and unit.has_method("on_state_changed"):
		unit.on_state_changed(current_state)
	_enter_state(current_state)

func _enter_state(state: State) -> void:
	match state:
		State.IDLE:
			print("%s entering IDLE state." % unit.data.display_name)
			unit.velocity = Vector2.ZERO
			
		State.MOVING:
			print("%s entering MOVING state to %s." % [unit.data.display_name, target_position])
			_recalculate_path()
			
		State.ATTACKING:
			print("%s entering ATTACKING state." % unit.data.display_name)
			unit.velocity = Vector2.ZERO
			# Set timer wait time based on unit's attack speed
			attack_timer.wait_time = 1.0 / unit.data.attack_speed
			attack_timer.start()
			# Attack immediately on entering state
			_on_attack_timer_timeout()

func _exit_state(state: State) -> void:
	match state:
		State.MOVING:
			path.clear()
		State.ATTACKING:
			attack_timer.stop()

func _recalculate_path() -> void:
	path = SettlementManager.get_astar_path(unit.global_position, target_position)
	if path.is_empty():
		print("Unit at %s failed to find a path to %s." % [unit.global_position, target_position])
		# Visual error feedback
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		# If we can't find a path, check if we're already close to the target
		if unit.global_position.distance_to(target_position) < (unit.data.attack_range + 16):
			if target_unit:
				change_state(State.ATTACKING)
			else:
				change_state(State.IDLE)
		else:
			change_state(State.IDLE)
	else:
		print("Unit found new path. Waypoints: %d" % path.size())

# --- RTS Command Functions ---

func command_move_to(target_pos: Vector2) -> void:
	"""Command the unit to move to a specific position"""
	target_position = target_pos
	move_command_position = target_pos
	target_unit = null # Clear any attack target
	change_state(State.MOVING)

func command_attack(target: Node2D) -> void:
	"""Command the unit to attack a specific target"""
	print("DEBUG: %s received attack command on target: %s" % [unit.data.display_name, target.name])
	
	if not is_instance_valid(target):
		print("Cannot attack invalid target")
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		return
		
	target_unit = target
	target_position = target.global_position
	
	# Check if we're already in range
	var distance: float = unit.global_position.distance_to(target.global_position)
	print("DEBUG: Current distance to target: %s, attack range: %s" % [distance, unit.data.attack_range])
	
	if distance <= unit.data.attack_range:
		print("DEBUG: Target in range, transitioning to ATTACKING")
		change_state(State.ATTACKING)
	else:
		print("DEBUG: Target out of range, transitioning to MOVING")
		change_state(State.MOVING)

# --- State Machine Update ---

func update(delta: float) -> void:
	match current_state:
		State.IDLE:
			_idle_state(delta)
		State.MOVING:
			_move_state(delta)
		State.ATTACKING:
			_attack_state(delta)

# --- State Logic Functions ---

func _idle_state(_delta: float) -> void:
	# In idle state, unit stands still
	unit.velocity = Vector2.ZERO

func _move_state(delta: float) -> void:
	# First priority: Check if we have a valid attack target and are in range
	if is_instance_valid(target_unit):
		var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
		print("DEBUG MOVE: %s distance to %s: %.1f (range: %.1f)" % [
			unit.data.display_name, 
			target_unit.name, 
			distance_to_target, 
			unit.data.attack_range
		])
		if distance_to_target <= unit.data.attack_range:
			print("Unit in attack range, switching to ATTACKING.")
			change_state(State.ATTACKING)
			return
		else:
			# Update target position if target moved
			target_position = target_unit.global_position
	
	# Handle defensive stance: Check for nearby enemies if being attacked
	if stance == Stance.DEFENSIVE:
		_check_defensive_response()
	
	# If we're not in range, check if our path is empty
	if path.is_empty():
		# If we have an attack target but no path, try to recalculate
		if is_instance_valid(target_unit):
			_recalculate_path()
			return
		else:
			# No target and no path, we've reached our destination
			print("Unit reached destination.")
			change_state(State.IDLE)
			return
	
	# Move along the path
	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	unit.move_and_slide()
	
	# Check if we've reached the current waypoint
	var arrival_radius: float = 8.0 
	if unit.global_position.distance_to(next_waypoint) < arrival_radius:
		path.pop_front()
		
		# If that was the last waypoint, check what to do next
		if path.is_empty():
			if is_instance_valid(target_unit):
				var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
				if distance_to_target <= unit.data.attack_range:
					change_state(State.ATTACKING)
				else:
					# Target moved, recalculate path
					_recalculate_path()
			else:
				# Just a move command, we're done
				change_state(State.IDLE)

func _attack_state(_delta: float) -> void:
	# Debug output for attack state
	print("DEBUG: %s in ATTACKING state - timer running: %s" % [unit.data.display_name, not attack_timer.is_stopped()])
	
	# Check if target is still valid
	if not is_instance_valid(target_unit):
		print("%s target destroyed or invalid. Returning to IDLE." % unit.data.display_name)
		change_state(State.IDLE)
		return
	
	# Check if target moved out of range
	var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
	print("DEBUG: Distance to target: %s, Attack range: %s" % [distance_to_target, unit.data.attack_range])
	
	if distance_to_target > unit.data.attack_range + 8: # Reduced buffer to avoid oscillation
		print("%s target moved out of range. Re-engaging." % unit.data.display_name)
		target_position = target_unit.global_position
		change_state(State.MOVING)

func _check_defensive_response() -> void:
	"""Check if unit should respond defensively to being attacked"""
	# This is a placeholder for future implementation
	# In a real implementation, this might check for nearby enemies
	# or respond to damage events
	pass

# --- Signal Callback ---

func _on_attack_timer_timeout() -> void:
	"""Called every time the AttackTimer finishes"""
	if current_state != State.ATTACKING:
		return
		
	if is_instance_valid(target_unit):
		print("%s attacks %s!" % [unit.data.display_name, target_unit.name])
		
		# Check if target has a take_damage method
		if target_unit.has_method("take_damage"):
			target_unit.take_damage(unit.data.attack_damage)
		else:
			print("Target %s does not have take_damage method" % target_unit.name)
	else:
		print("Attack timer fired but no valid target")
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		change_state(State.IDLE)

--- SCRIPT: res://scripts/buildings/SettlementBridge.gd ---
# res://scripts/buildings/SettlementBridge.gd

extends Node

# --- Exported Resources ---
@export var home_base_data: SettlementData
@export var test_building_data: BuildingData
@export var raider_scene: PackedScene
@export var welcome_popup_scene: PackedScene

## The scene for the world map (e.g., WorldMap_Stub.tscn)
# --- REMOVED ---
# @export var world_map_scene: PackedScene
# --- ADDED ---
@export var world_map_scene_path: String = "res://scenes/world_map/WorldMap_Stub.tscn"


##Size of the cell for the grid helper
@export var cell_size: int = 32
# --- Default Assets (fallback) ---
var default_test_building: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
# --- FIX: Removed preload() to break circular dependency ---
var default_raider_scene: PackedScene 
var default_welcome_popup: PackedScene = preload("res://ui/WelcomeHome_Popup.tscn")

# --- Scene Node References ---
@onready var unit_container: Node2D = $UnitContainer
@onready var ui_layer: CanvasLayer = $UI
@onready var restart_button: Button = $UI/RestartButton
@onready var start_raid_button: Button = $UI/StartRaidButton
@onready var storefront_ui: Control = $UI/Storefront_UI
@onready var building_cursor: Node2D = $BuildingCursor
var welcome_popup: PanelContainer

# --- State Variables ---
var great_hall_instance: BaseBuilding = null
var game_is_over: bool = false
var awaiting_placement: BuildingData = null
const RAIDER_SPAWN_POS: Vector2 = Vector2(50, 50)


func _ready() -> void:
	_setup_default_resources()
	_initialize_settlement()
	_setup_ui()
	_connect_signals()
	_handle_welcome_payout()

func _setup_default_resources() -> void:
	"""Initialize default resources and handle missing inspector assignments"""
	# Setup fallback resources if not set in inspector
	if not test_building_data:
		test_building_data = default_test_building
	
	# Load the default raider scene at runtime to avoid circular dependencies
	if not raider_scene:
		raider_scene = load("res://scenes/units/VikingRaider.tscn")
		
	if not welcome_popup_scene: 
		welcome_popup_scene = default_welcome_popup

func _initialize_settlement() -> void:
	"""Initialize or load settlement data"""
	# Use inspector data if available, otherwise create default
	if not home_base_data:
		home_base_data = _create_default_settlement()
		print("SettlementBridge: Created default settlement data")
	else:
		# Verify inspector data is valid
		if not home_base_data is SettlementData:
			push_warning("SettlementBridge: Inspector data is not SettlementData, creating default")
			home_base_data = _create_default_settlement()
		else:
			print("SettlementBridge: Using inspector settlement data")
	
	# Ensure resource path is set for saving
	if home_base_data and (not home_base_data.resource_path or home_base_data.resource_path.is_empty()):
		# Set the resource path based on the expected file name
		home_base_data.resource_path = "res://data/settlements/home_base_fixed.tres"
		print("SettlementBridge: Set resource_path to: %s" % home_base_data.resource_path)
	
	# Load the settlement into the manager
	SettlementManager.load_settlement(home_base_data)
	
	# Let child nodes handle their own initialization via signals
	EventBus.settlement_loaded.emit(home_base_data)

func _create_default_settlement() -> SettlementData:
	"""Create a default settlement with basic resources"""
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 100, "stone": 200}
	var empty_buildings: Array[Dictionary] = []
	settlement.placed_buildings = empty_buildings
	settlement.garrisoned_units = {}
	
	# Set resource path for saving
	settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
	
	return settlement

func _setup_ui() -> void:
	"""Initialize UI components"""
	welcome_popup = welcome_popup_scene.instantiate()
	ui_layer.add_child(welcome_popup)
	welcome_popup.collect_button_pressed.connect(_on_payout_collected)

func _connect_signals() -> void:
	"""Connect button signals"""
	restart_button.pressed.connect(_on_restart_pressed)
	start_raid_button.pressed.connect(_on_start_raid_pressed)
	
	# Connect to EventBus for loose coupling
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	EventBus.building_ready_for_placement.connect(_on_building_ready_for_placement)
	EventBus.building_placement_cancelled.connect(_on_building_placement_cancelled)
	
	# Connect BuildingPreviewCursor signals
	if building_cursor:
		building_cursor.placement_completed.connect(_on_building_placement_completed)
		building_cursor.placement_cancelled.connect(_on_building_placement_cancelled_by_cursor)

func _handle_welcome_payout() -> void:
	"""Handle any pending payout when returning to settlement"""
	var payout = SettlementManager.calculate_payout()
	if not payout.is_empty():
		welcome_popup.display_payout(payout)
		storefront_ui.hide()

func _on_settlement_loaded(_settlement_data: SettlementData) -> void:
	"""Called when settlement is fully loaded - find and setup buildings"""
	call_deferred("_find_and_setup_great_hall")


func _input(event: InputEvent) -> void:
	# This runs BEFORE GUI input, so we can consume it.
	if event.is_action_pressed("ui_accept"):
		if game_is_over or welcome_popup.visible:
			return # Don't grant loot if game over screen or popup is visible
		
		print("DEBUG: SettlementManager.current_settlement before deposit: ", SettlementManager.current_settlement)
		var sample_loot = {"gold": 100, "wood": 50, "food": 25, "stone": 75}
		print("DEBUG: Granting sample loot via key press.")
		SettlementManager.deposit_resources(sample_loot)
		
		# DEBUG: Ensure storefront UI is visible to see the update
		if not storefront_ui.visible:
			storefront_ui.show()
			print("DEBUG: Showed storefront UI to display updated treasury")
		
		get_viewport().set_input_as_handled() # CRITICAL: Stop event from reaching buttons


func _unhandled_input(event: InputEvent) -> void:
	# This runs AFTER GUI input, so it's safe for non-UI actions like placing buildings.
	if game_is_over or (welcome_popup and welcome_popup.visible):
		return
	
	# --- COORDINATE FINDER LOGIC (for debugging) ---
	# Use a keyboard shortcut (e.g., Spacebar/ui_accept) to print coordinates
	if event.is_action_pressed("ui_accept") and not awaiting_placement:
		if SettlementManager.astar_grid:
			var mouse_pos = get_viewport().get_mouse_position()
			var grid_coord = Vector2i(int(mouse_pos.x / cell_size), int(mouse_pos.y / cell_size)) 
			print("CLICKED GRID COORDINATE: ", grid_coord)
			get_viewport().set_input_as_handled()
		else:
			print("Cannot find coordinate: AStarGrid not initialized")

func _on_payout_collected(payout: Dictionary) -> void:
	SettlementManager.deposit_resources(payout)
	storefront_ui.show()

func _find_and_setup_great_hall() -> void:
	for building in SettlementManager.building_container.get_children():
		if building is BaseBuilding and building.data.display_name == "Great Hall":
			great_hall_instance = building
			great_hall_instance.building_destroyed.connect(_on_great_hall_destroyed)
			print("Great Hall found and connected.")
			return
	push_error("SettlementBridge: Could not find Great Hall instance after loading settlement.")


func _on_great_hall_destroyed(_building: BaseBuilding) -> void:
	print("GAME OVER: The Great Hall has been destroyed!")
	game_is_over = true
	var label : Label = $UI/Label
	label.text = "YOU HAVE BEEN SACKED."
	restart_button.show()
	_destroy_all_enemies()

func _destroy_all_enemies() -> void:
	for enemy in unit_container.get_children():
		enemy.queue_free()
	print("All surviving enemies have been removed.")

func _on_restart_pressed() -> void:
	get_tree().reload_current_scene()

func _on_start_raid_pressed() -> void:
	"""Navigate to the world map to select targets"""
	print("Opening world map...")
	
	# Validate that we have a settlement loaded
	if not SettlementManager.current_settlement:
		push_error("Cannot open world map: No settlement loaded")
		return
	
	
	# Ensure we have some units in the garrison for raiding
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		print("Warning: No units in garrison. Adding test unit.")
		# Add a test unit so raids can proceed
		var test_unit_path = "res://data/units/Unit_Raider.tres"
		SettlementManager.current_settlement.garrisoned_units[test_unit_path] = 2
		SettlementManager.save_settlement()
	
	print("Settlement loaded with garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
	
	# --- MODIFIED: Emit signal instead of changing scene ---
	if not world_map_scene_path.is_empty():
		EventBus.scene_change_requested.emit(world_map_scene_path)
	else:
		push_error("world_map_scene_path is not set! Cannot change scene.")
	# --- END MODIFICATION ---

# --- NEW BUILDING CURSOR SYSTEM FUNCTIONS ---

func _on_building_ready_for_placement(building_data: BuildingData) -> void:
	"""Handle when a building is purchased and ready for cursor placement"""
	awaiting_placement = building_data
	building_cursor.set_building_preview(building_data)
	print("Building ready for placement: %s" % building_data.display_name)

func _on_building_placement_cancelled(building_data: BuildingData) -> void:
	"""Handle when building placement is cancelled - for future use"""
	print("Building placement cancelled: %s" % building_data.display_name)

func _handle_building_placement() -> void:
	"""Place building at cursor position and complete the placement"""
	if not awaiting_placement:
		return
	
	var mouse_pos = get_viewport().get_mouse_position()
	var grid_pos: Vector2i
	
	if SettlementManager.astar_grid and SettlementManager.astar_grid.cell_size != Vector2.ZERO:
		grid_pos = Vector2i(mouse_pos / SettlementManager.astar_grid.cell_size)
	else:
		grid_pos = Vector2i(mouse_pos / cell_size)
	
	# Check if placement is valid
	if SettlementManager.astar_grid and SettlementManager.astar_grid.is_point_solid(grid_pos):
		print("Cannot place building: Position occupied")
		return
	
	# Place the building
	var new_building = SettlementManager.place_building(awaiting_placement, grid_pos)
	
	if new_building and SettlementManager.current_settlement:
		var building_entry = {
			"resource_path": awaiting_placement.resource_path,
			"grid_position": grid_pos
		}
		SettlementManager.current_settlement.placed_buildings.append(building_entry)
		print("Placed %s at %s via cursor system." % [awaiting_placement.display_name, grid_pos])
		SettlementManager.save_settlement()
		
		# Complete the placement
		_complete_building_placement()
	else:
		print("Failed to place building")

func _cancel_building_placement() -> void:
	"""Cancel building placement and refund the cost"""
	if not awaiting_placement:
		return
	
	# Refund the cost
	SettlementManager.deposit_resources(awaiting_placement.build_cost)
	print("Cancelled placement of %s and refunded cost" % awaiting_placement.display_name)
	
	# Complete the cancellation
	_complete_building_placement()

func _complete_building_placement() -> void:
	"""Clean up after building placement (successful or cancelled)"""
	building_cursor.cancel_preview()
	awaiting_placement = null

func _on_building_placement_completed() -> void:
	"""Handle successful building placement"""
	print("Building placement completed successfully")
	
	# Save the settlement with the new building
	if SettlementManager.current_settlement:
		SettlementManager.save_settlement()
	
	# Clean up placement state
	awaiting_placement = null

func _on_building_placement_cancelled_by_cursor() -> void:
	"""Handle building placement cancellation from cursor (right-click)"""
	if awaiting_placement:
		# Refund the cost
		SettlementManager.deposit_resources(awaiting_placement.build_cost)
		print("Building placement cancelled by cursor, refunded: %s" % awaiting_placement.build_cost)
		
		# Clean up placement state
		awaiting_placement = null

--- SCRIPT: res://scripts/formations/SquadFormation.gd ---
# res://scripts/formations/SquadFormation.gd
# Squad Formation Manager - Company of Heroes style formations
# Handles formation positioning and movement for multiple units

class_name SquadFormation

enum FormationType {
	LINE,      # Horizontal line formation  
	COLUMN,    # Vertical column formation
	WEDGE,     # V-shaped formation
	BOX,       # Rectangular formation
	CIRCLE     # Circular formation
}

# Formation settings
var formation_type: FormationType = FormationType.LINE
var unit_spacing: float = 40.0
var max_units_per_row: int = 4

# Squad data
var units: Array[Node2D] = []
var leader_position: Vector2 = Vector2.ZERO
var target_position: Vector2 = Vector2.ZERO
var formation_center: Vector2 = Vector2.ZERO

# Movement state
var is_moving: bool = false
var move_speed: float = 100.0

func _init(squad_units: Array[Node2D] = []) -> void:
	units = squad_units
	if not units.is_empty():
		formation_center = _calculate_center_position()

func add_unit(unit: Node2D) -> void:
	"""Add a unit to the squad"""
	if unit not in units:
		units.append(unit)
		_update_formation_positions()

func remove_unit(unit: Node2D) -> void:
	"""Remove a unit from the squad"""
	units.erase(unit)
	_update_formation_positions()

func set_formation_type(new_type: FormationType) -> void:
	"""Change the formation type"""
	formation_type = new_type
	_update_formation_positions()

func move_to_position(target_pos: Vector2) -> void:
	"""Command the entire squad to move to a target position"""
	target_position = target_pos
	is_moving = true
	
	# Calculate formation positions around the target
	var formation_positions = _calculate_formation_positions(target_pos)
	
	# Assign each unit a position in the formation
	for i in range(min(units.size(), formation_positions.size())):
		var unit = units[i]
		var target_formation_pos = formation_positions[i]
		
		# Move the unit to its formation position
		_move_unit_to_position(unit, target_formation_pos)
	
	print("Squad moving to %s in %s formation with %d units" % [target_pos, FormationType.keys()[formation_type], units.size()])

func _calculate_formation_positions(center_pos: Vector2) -> Array[Vector2]:
	"""Calculate formation positions based on formation type"""
	var positions: Array[Vector2] = []
	var unit_count = units.size()
	
	match formation_type:
		FormationType.LINE:
			positions = _calculate_line_formation(center_pos, unit_count)
		FormationType.COLUMN:
			positions = _calculate_column_formation(center_pos, unit_count)
		FormationType.WEDGE:
			positions = _calculate_wedge_formation(center_pos, unit_count)
		FormationType.BOX:
			positions = _calculate_box_formation(center_pos, unit_count)
		FormationType.CIRCLE:
			positions = _calculate_circle_formation(center_pos, unit_count)
	
	return positions

func _calculate_line_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate horizontal line formation positions"""
	var positions: Array[Vector2] = []
	var start_x = center_pos.x - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(start_x + i * unit_spacing, center_pos.y)
		positions.append(pos)
	
	return positions

func _calculate_column_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate vertical column formation positions"""
	var positions: Array[Vector2] = []
	var start_y = center_pos.y - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(center_pos.x, start_y + i * unit_spacing)
		positions.append(pos)
	
	return positions

func _calculate_wedge_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate V-shaped wedge formation positions"""
	var positions: Array[Vector2] = []
	
	# Leader at the front
	positions.append(center_pos)
	
	# Place remaining units in V formation behind the leader
	var side_offset = unit_spacing * 0.7  # 70% spacing for tighter formation
	var rear_offset = unit_spacing
	
	for i in range(1, unit_count):
		var row = (i + 1) / 2  # Which row behind the leader
		var side = 1 if i % 2 == 1 else -1  # Left or right side
		
		var pos = Vector2(
			center_pos.x + side * side_offset * row,
			center_pos.y + rear_offset * row
		)
		positions.append(pos)
	
	return positions

func _calculate_box_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate rectangular box formation positions"""
	var positions: Array[Vector2] = []
	
	var rows = int(ceil(float(unit_count) / max_units_per_row))
	var cols = min(unit_count, max_units_per_row)
	
	var start_x = center_pos.x - (cols - 1) * unit_spacing * 0.5
	var start_y = center_pos.y - (rows - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var row = i / max_units_per_row
		var col = i % max_units_per_row
		
		# Center the last row if it has fewer units
		var row_unit_count = min(max_units_per_row, unit_count - row * max_units_per_row)
		var row_start_x = center_pos.x - (row_unit_count - 1) * unit_spacing * 0.5
		
		var pos = Vector2(
			row_start_x + col * unit_spacing,
			start_y + row * unit_spacing
		)
		positions.append(pos)
	
	return positions

func _calculate_circle_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate circular formation positions"""
	var positions: Array[Vector2] = []
	var radius = max(unit_spacing, unit_count * unit_spacing / (2 * PI))
	
	for i in range(unit_count):
		var angle = (2 * PI * i) / unit_count
		var pos = Vector2(
			center_pos.x + cos(angle) * radius,
			center_pos.y + sin(angle) * radius
		)
		positions.append(pos)
	
	return positions

func _move_unit_to_position(unit: Node2D, target_pos: Vector2) -> void:
	"""Move a specific unit to a target position"""
	if not is_instance_valid(unit):
		return
	
	# Check if unit has FSM (proper unit system)
	if "fsm" in unit and unit.fsm != null:
		unit.fsm.command_move_to(target_pos)
	# Check if unit has direct movement method
	elif unit.has_method("command_move_to"):
		unit.command_move_to(target_pos)
	# Fallback: simple movement for test units
	else:
		_simple_unit_movement(unit, target_pos)

func _simple_unit_movement(unit: Node2D, target_pos: Vector2) -> void:
	"""Simple movement system for test units without FSM"""
	if not unit.has_method("set_target_position"):
		# Add simple movement script to unit if it doesn't have one
		var movement_script = """
var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0
var is_moving: bool = false

func set_target_position(pos: Vector2) -> void:
	target_position = pos
	is_moving = true

func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var direction = (target_position - global_position).normalized()
		var distance = global_position.distance_to(target_position)
		
		if distance < 5.0:
			is_moving = false
			velocity = Vector2.ZERO
		else:
			velocity = direction * move_speed
		
		move_and_slide()
"""
		# Create and attach movement behavior
		var script = GDScript.new()
		script.source_code = unit.get_script().source_code + "\n" + movement_script
		script.reload()
		unit.set_script(script)
	
	# Set the target position
	unit.set_target_position(target_pos)

func _update_formation_positions() -> void:
	"""Update formation positions for current units"""
	if not units.is_empty():
		formation_center = _calculate_center_position()

func _calculate_center_position() -> Vector2:
	"""Calculate the center position of all units"""
	if units.is_empty():
		return Vector2.ZERO
	
	var total_pos = Vector2.ZERO
	for unit in units:
		if is_instance_valid(unit):
			total_pos += unit.global_position
	
	return total_pos / units.size()

func get_unit_count() -> int:
	"""Get the number of units in the squad"""
	return units.size()

func is_squad_moving() -> bool:
	"""Check if the squad is currently moving"""
	return is_moving

func get_formation_info() -> Dictionary:
	"""Get information about the current formation"""
	return {
		"type": FormationType.keys()[formation_type],
		"unit_count": units.size(),
		"spacing": unit_spacing,
		"center": formation_center,
		"is_moving": is_moving
	}

--- SCRIPT: res://scripts/ui/BuildingPreviewCursor.gd ---
# BuildingPreviewCursor.gd - RTS-style building placement system
extends Node2D
class_name BuildingPreviewCursor

# Building preview components
var current_building_data: BuildingData
var preview_sprite: Sprite2D
var is_active: bool = false

# Grid and placement
var cell_size: int = 32 # Default fallback
var grid_overlay: Node2D
var can_place: bool = false

# Visual feedback
var valid_color: Color = Color(0.0, 1.0, 0.0, 0.7)    # Green for valid placement
var invalid_color: Color = Color(1.0, 0.0, 0.0, 0.7)  # Red for invalid placement

signal placement_completed
signal placement_cancelled

func _ready() -> void:
	# Ensure we're always on top for visibility
	z_index = 100
	
	# Create grid overlay for visual feedback
	grid_overlay = Node2D.new()
	grid_overlay.name = "GridOverlay"
	add_child(grid_overlay)
	
	# --- MODIFIED: Unify grid size source (from review) ---
	# Use SettlementManager as the single source of truth for grid size.
	if SettlementManager and SettlementManager.tile_size > 0:
		cell_size = int(SettlementManager.tile_size)
	else:
		# Use the local 32 only as a fallback if the manager fails
		push_warning("BuildingPreviewCursor: SettlementManager not ready or tile_size invalid. Defaulting to %d." % cell_size)
	# --- END MODIFICATION ---
	
	print("BuildingPreviewCursor ready with cell_size: %d" % cell_size)

func set_building_preview(building_data: BuildingData) -> void:
	"""Start building placement mode with the specified building"""
	if not building_data:
		print("ERROR: No building data provided to set_building_preview")
		return
	
	print("Setting building preview for: %s" % building_data.display_name)
	current_building_data = building_data
	
	# Clean up any existing preview
	_cleanup_preview()
	
	# Create new preview sprite
	preview_sprite = Sprite2D.new()
	preview_sprite.name = "PreviewSprite"
	
	# Set up the building texture
	if building_data.building_texture:
		preview_sprite.texture = building_data.building_texture
		# print("Using building texture for preview") # No longer needed
	else:
		# Create a simple colored rectangle if no texture
		var texture = _create_building_texture(building_data)
		preview_sprite.texture = texture
		print("Created fallback texture for preview")
	
	
	# --- Automatic Scaling Logic ---
	
	# 1. Get the target size based on grid
	# We can now safely use our local 'cell_size' because it's synced.
	var target_size: Vector2 = Vector2(building_data.grid_size) * cell_size
	
	# 2. Scale the Sprite (if texture exists)
	if preview_sprite.texture:
		var texture_size: Vector2 = preview_sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			var new_scale: Vector2 = target_size / texture_size
			preview_sprite.scale = new_scale
		else:
			push_warning("BuildingPreviewCursor: Texture for '%s' has invalid size %s. Cannot scale preview." % [building_data.display_name, texture_size])
	else:
		push_warning("BuildingPreviewCursor: No texture for '%s' preview." % building_data.display_name)
			
	# --- END SCALING LOGIC ---

	
	# Set semi-transparent
	preview_sprite.modulate = valid_color
	add_child(preview_sprite)
	
	# Create grid outline to show building footprint
	# This now correctly uses the synced 'cell_size'
	_create_grid_outline(building_data.grid_size)
	
	# Activate placement mode
	is_active = true
	visible = true
	
	# print("Building preview activated for %s (grid size: %s)" % [building_data.display_name, building_data.grid_size])

func _create_building_texture(building_data: BuildingData) -> ImageTexture:
	"""Create a simple colored texture for buildings without textures"""
	var size = Vector2i(
		building_data.grid_size.x * cell_size,
		building_data.grid_size.y * cell_size
	)
	
	var image = Image.create(size.x, size.y, false, Image.FORMAT_RGBA8)
	var color = _get_building_color(building_data)
	image.fill(color)
	
	var texture = ImageTexture.new()
	texture.set_image(image)
	return texture

func _create_grid_outline(grid_size: Vector2i) -> void:
	"""Create a visual outline showing the building's grid footprint"""
	_clear_grid_overlay()
	
	var outline_color = Color.WHITE
	var line_width = 2.0
	
	# This var 'rect_size' now correctly uses the synced 'cell_size'
	var rect_size = Vector2(grid_size.x * cell_size, grid_size.y * cell_size)
	
	# Create outline using Line2D nodes for each edge
	var lines = []
	
	# Top line
	var top_line = Line2D.new()
	top_line.add_point(Vector2(0, 0))
	top_line.add_point(Vector2(rect_size.x, 0))
	top_line.width = line_width
	top_line.default_color = outline_color
	lines.append(top_line)
	
	# Right line
	var right_line = Line2D.new()
	right_line.add_point(Vector2(rect_size.x, 0))
	right_line.add_point(Vector2(rect_size.x, rect_size.y))
	right_line.width = line_width
	right_line.default_color = outline_color
	lines.append(right_line)
	
	# Bottom line
	var bottom_line = Line2D.new()
	bottom_line.add_point(Vector2(rect_size.x, rect_size.y))
	bottom_line.add_point(Vector2(0, rect_size.y))
	bottom_line.width = line_width
	bottom_line.default_color = outline_color
	lines.append(bottom_line)
	
	# Left line
	var left_line = Line2D.new()
	left_line.add_point(Vector2(0, rect_size.y))
	left_line.add_point(Vector2(0, 0))
	left_line.width = line_width
	left_line.default_color = outline_color
	lines.append(left_line)
	
	# Add lines to grid overlay
	for line in lines:
		grid_overlay.add_child(line)

func _clear_grid_overlay() -> void:
	"""Clear the grid overlay visual elements"""
	for child in grid_overlay.get_children():
		child.queue_free()

func _get_building_color(building_data: BuildingData) -> Color:
	"""Get a representative color for the building type"""
	var name = building_data.display_name.to_lower()
	if "wall" in name:
		return Color(0.7, 0.5, 0.3, 1.0) # Brown
	elif "hall" in name:
		return Color(0.8, 0.8, 0.2, 1.0) # Yellow
	elif "tower" in name or "watchtower" in name:
		return Color(0.5, 0.5, 0.8, 1.0) # Blue
	elif "lumber" in name:
		return Color(0.3, 0.8, 0.3, 1.0) # Green
	elif "granary" in name:
		return Color(0.9, 0.6, 0.2, 1.0) # Orange
	elif "chapel" in name or "library" in name or "scriptorium" in name:
		return Color(0.8, 0.4, 0.8, 1.0) # Purple
	else:
		return Color(0.6, 0.6, 0.6, 1.0) # Gray

func _process(_delta: float) -> void:
	"""Update cursor position and placement validity"""
	if not is_active or not current_building_data:
		return
	
	# Get mouse position and snap to grid
	var mouse_pos = get_global_mouse_position()
	var grid_pos = _world_to_grid(mouse_pos)
	var snapped_world_pos = _grid_to_world(grid_pos)
	
	# Update cursor position
	global_position = snapped_world_pos
	
	# Check placement validity
	can_place = _can_place_at_position(grid_pos)
	
	# Update visual feedback
	_update_visual_feedback()

func _world_to_grid(world_pos: Vector2) -> Vector2i:
	"""Convert world position to grid coordinates"""
	# Now safely uses the synced 'cell_size'
	return Vector2i(int(world_pos.x / cell_size), int(world_pos.y / cell_size))

func _grid_to_world(grid_pos: Vector2i) -> Vector2:
	"""Convert grid coordinates to world position (centered on cell)"""
	# Now safely uses the synced 'cell_size'
	return Vector2(grid_pos.x * cell_size, grid_pos.y * cell_size)

func _can_place_at_position(grid_pos: Vector2i) -> bool:
	"""Check if building can be placed by asking the SettlementManager."""
	if not SettlementManager or not current_building_data:
		return false
	
	# Delegate the check to the manager, which is the single source of truth
	return SettlementManager.is_placement_valid(grid_pos, current_building_data.grid_size)

func _update_visual_feedback() -> void:
	"""Update the visual appearance based on placement validity"""
	if not preview_sprite:
		return
	
	# Change color based on placement validity
	if can_place:
		preview_sprite.modulate = valid_color
		_set_grid_overlay_color(Color.GREEN)
	else:
		preview_sprite.modulate = invalid_color
		_set_grid_overlay_color(Color.RED)

func _set_grid_overlay_color(color: Color) -> void:
	"""Set the color of the grid overlay lines"""
	for child in grid_overlay.get_children():
		if child is Line2D:
			child.default_color = color

func place_building() -> bool:
	"""Attempt to place the building at current position"""
	if not is_active or not current_building_data or not can_place:
		print("Cannot place building: not active (%s), no data (%s), or invalid position (%s)" % [is_active, current_building_data != null, can_place])
		return false
	
	var grid_pos = _world_to_grid(global_position)
	
	print("Attempting to place %s at grid position %s" % [current_building_data.display_name, grid_pos])
	
	# Place building through SettlementManager
	var new_building = SettlementManager.place_building(current_building_data, grid_pos)
	
	if new_building:
		print("Successfully placed building: %s" % current_building_data.display_name)
		placement_completed.emit()
		cancel_preview()
		return true
	else:
		print("Failed to place building through SettlementManager")
		return false

func cancel_preview() -> void:
	"""Cancel building placement and clean up"""
	print("Cancelling building preview")
	
	is_active = false
	visible = false
	current_building_data = null
	can_place = false
	
	_cleanup_preview()
	placement_cancelled.emit()

func _cleanup_preview() -> void:
	"""Clean up preview visual elements"""
	if preview_sprite:
		preview_sprite.queue_free()
		preview_sprite = null
	
	_clear_grid_overlay()

func _input(event: InputEvent) -> void:
	"""Handle input for building placement"""
	if not is_active:
		return
	
	if event is InputEventMouseButton and event.is_pressed():
		if event.button_index == MOUSE_BUTTON_LEFT:
			# Attempt to place building
			if place_building():
				print("Building placed successfully")
			else:
				print("Failed to place building")
			get_viewport().set_input_as_handled()
		
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			# Cancel placement
			print("Building placement cancelled by right click")
			cancel_preview()
			get_viewport().set_input_as_handled()

--- SCRIPT: res://scripts/units/Base_Unit.gd ---
# res://scenes/units/Base_Unit.gd
#
# --- MODIFIED: Added auto-scaling for texture and collision ---

class_name BaseUnit
extends CharacterBody2D

signal destroyed

@export var data: UnitData
var fsm: UnitFSM
var current_health: int = 50

# Node refs
@onready var attack_timer: Timer = $AttackTimer
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision_shape: CollisionShape2D = $CollisionShape2D

# Color tweening
var _color_tween: Tween
const STATE_COLORS := {
	UnitFSM.State.IDLE: Color(0.3, 0.6, 1.0),     # Blue
	UnitFSM.State.MOVING: Color(0.4, 1.0, 0.4),   # Green
	UnitFSM.State.ATTACKING: Color(1.0, 0.3, 0.3) # Red
}
const ERROR_COLOR := Color(0.7, 0.3, 1.0)         # Purple

func _ready() -> void:
	if not data:
		push_warning("BaseUnit: Node is missing its 'UnitData' resource. Cannot initialize.")
		return
	
	current_health = data.max_health
	
	# --- ADDED: Apply Texture and Scaling ---
	_apply_texture_and_scale()
	
	# Pass the timer reference to the FSM
	fsm = UnitFSM.new(self, attack_timer)
	
	# Initialize visual to current state color (IDLE by default)
	sprite.modulate = STATE_COLORS.get(UnitFSM.State.IDLE, Color.WHITE)
	
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)

func _apply_texture_and_scale() -> void:
	"""
	Applies the texture from 'data' and scales both the
	sprite and collision shape to match the 'data.target_pixel_size'.
	"""
	
	# 1. Validate the target size
	if data.target_pixel_size.x <= 0 or data.target_pixel_size.y <= 0:
		push_warning("BaseUnit: '%s' has a target_pixel_size of %s, which is invalid." % [data.display_name, data.target_pixel_size])
		return
		
	var target_size: Vector2 = data.target_pixel_size

	# 2. Apply and Scale the Sprite
	if data.visual_texture:
		sprite.texture = data.visual_texture
		var texture_size: Vector2 = sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			# Non-uniform scaling to fill the target size
			var new_scale: Vector2 = target_size / texture_size
			sprite.scale = new_scale
		else:
			push_warning("BaseUnit: Texture for '%s' has an invalid size of %s. Cannot scale sprite." % [data.display_name, texture_size])
	else:
		push_warning("BaseUnit: '%s' is missing its 'visual_texture'. Sprite will be blank or use placeholder." % data.display_name)
		
	# 3. Scale the Collision Shape
	if collision_shape and collision_shape.shape is RectangleShape2D:
		# Set extents to *half* the target size (from center)
		collision_shape.shape.extents = target_size / 2.0
	else:
		push_warning("BaseUnit: '%s' is missing its CollisionShape2D node or its shape is not a RectangleShape2D. Collision will not match visuals." % data.display_name)
# --- END ADDED ---

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	if fsm and fsm.current_state == UnitFSM.State.MOVING:
		fsm._recalculate_path()

func _physics_process(delta: float) -> void:
	if fsm:
		fsm.update(delta)
	
	if not fsm or fsm.current_state != UnitFSM.State.MOVING:
		velocity = Vector2.ZERO
		move_and_slide()

# --- Visual State Hooks ---
func on_state_changed(state: UnitFSM.State) -> void:
	var to_color: Color = STATE_COLORS.get(state, Color.WHITE)
	_tween_color(to_color, 0.2)

func flash_error_color() -> void:
	# Quick flash to purple, then return to current state color
	var back_color: Color = STATE_COLORS.get(fsm.current_state, Color.WHITE)
	var t := create_tween()
	t.tween_property(sprite, "modulate", ERROR_COLOR, 0.08).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
	t.tween_property(sprite, "modulate", back_color, 0.18).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func _tween_color(to_color: Color, duration: float = 0.2) -> void:
	if _color_tween and _color_tween.is_running():
		_color_tween.kill()
	_color_tween = create_tween()
	_color_tween.tween_property(sprite, "modulate", to_color, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	# print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been killed." % data.display_name)
	destroyed.emit()
	queue_free()

# --- RTS Command Interface ---

func command_move_to(target_pos: Vector2) -> void:
	"""Command this unit to move to a position"""
	if fsm:
		fsm.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	"""Command this unit to attack a target"""
	if fsm:
		fsm.command_attack(target)

# --- Selection System ---

var is_selected: bool = false

func set_selected(selected: bool) -> void:
	"""Set the unit's selection state"""
	is_selected = selected
	
	if is_selected:
		_show_selection_indicator()
		# print("%s selected" % data.display_name) # Too noisy
	else:
		_hide_selection_indicator()
		# print("%s deselected" % data.display_name) # Too noisy

func _show_selection_indicator() -> void:
	"""Show visual selection indicator"""
	queue_redraw()

func _hide_selection_indicator() -> void:
	"""Hide visual selection indicator"""
	queue_redraw()

func _draw() -> void:
	"""Draw unit-specific visuals"""
	if is_selected:
		# Draw selection circle around the unit
		var radius = 25.0
		var color = Color.YELLOW
		color.a = 0.8
		draw_circle(Vector2.ZERO, radius, color, false, 3.0)

--- SCRIPT: res://scripts/units/EnemyVikingRaider.gd ---
# res://scripts/units/VikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Target position is now adjacent to the Hall ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set the node (for attacking)
	fsm.target_unit = target
	
	# --- THIS IS THE FIX ---
	# Set the position (for moving) to be one tile *below*
	# the Hall's center. This is a walkable tile, so
	# pathfinding will succeed.
	fsm.target_position = target.global_position + Vector2(0, 32)
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVING)
	print("Viking Raider initialized and moving to target: %s" % target.data.display_name)

--- SCRIPT: res://scripts/units/PlayerVikingRaider.gd ---
# res://scripts/units/PlayerVikingRaider.gd
#
# Player-controlled Viking Raider unit with full RTS integration.
# Extends BaseUnit to inherit all core unit functionality and adds
# player-specific behaviors for selection, command, and group management.

extends BaseUnit
class_name PlayerVikingRaider

func _ready() -> void:
	# Call parent _ready first to initialize base unit systems
	super._ready()
	
	# Add to player units group for RTS selection and control
	add_to_group("player_units")
	
	# Initialize player-specific behaviors
	_setup_player_behaviors()
	
	print("PlayerVikingRaider '%s' initialized and ready for RTS control" % name)

func _setup_player_behaviors() -> void:
	"""Initialize player-specific unit behaviors and properties"""
	# Ensure the unit can be selected and commanded
	# The BaseUnit already provides the necessary methods:
	# - command_move_to()
	# - command_attack() 
	# - set_selected()
	
	# Set any player-specific properties
	if data:
		print("Player Viking Raider ready: %s (Health: %d)" % [data.display_name, current_health])

# Override command methods to add player-specific feedback and behavior
func command_move_to(target_pos: Vector2) -> void:
	"""Enhanced move command with player feedback"""
	print("Player Viking Raider '%s' moving to position %s" % [name, target_pos])
	super.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	"""Enhanced attack command with player feedback"""
	if not fsm or not is_instance_valid(target):
		push_warning("Player Raider FSM or target is not valid.")
		return

	print("Player Viking Raider '%s' attacking %s" % [name, target.name])

	# --- Logic copied from EnemyVikingRaider ---
	# Set the node (for attacking)
	fsm.target_unit = target
	
	# Set the position (for moving) to be adjacent to the target
	# This ensures pathfinding can succeed. Adjust offset as needed.
	fsm.target_position = target.global_position + Vector2(0, 32) 
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVING)
	# ---------------------------------------------

# Override selection methods to provide enhanced player feedback
func set_selected(selected: bool) -> void:
	"""Enhanced selection with player-specific visual feedback"""
	super.set_selected(selected)
	
	if selected:
		# Could add player-specific selection effects here
		# e.g., special sound effects, enhanced visual indicators
		pass
	else:
		# Handle deselection
		pass

# Player-specific utility methods
func get_unit_status() -> Dictionary:
	"""Get comprehensive unit status for UI display"""
	return {
		"name": name,
		"display_name": data.display_name if data else "Unknown",
		"health": current_health,
		"max_health": data.max_health if data else 100,
		"is_selected": is_selected,
		"current_state": fsm.current_state if fsm else "None",
		"position": global_position
	}

func is_player_controlled() -> bool:
	"""Identify this as a player-controlled unit"""
	return true

# Override die method to handle player unit death
func die() -> void:
	"""Handle player unit death with proper cleanup"""
	# Remove from player units group
	remove_from_group("player_units")
	
	# Notify other systems about unit death
	EventBus.emit_signal("player_unit_died", self)
	
	print("Player Viking Raider '%s' has fallen in battle!" % name)
	
	# Call parent die method
	super.die()

--- SCRIPT: res://tools/EnemyBaseEditor.gd ---
@tool
extends EditorScript

# Simple Enemy Base Layout Editor
# Usage: Tools -> Execute Script to run this

func _run():
	print("=== ENEMY BASE LAYOUT EDITOR ===")
	
	var settlement_path = "res://data/settlements/monastery_base.tres"
	var settlement_data: SettlementData = load(settlement_path)
	
	if not settlement_data:
		print("ERROR: Could not load settlement data!")
		return
	
	print("Current layout for: " + settlement_path)
	print("Grid positions (format: Building @ X,Y):")
	print("-".repeat(40))
	
	for i in range(settlement_data.placed_buildings.size()):
		var building = settlement_data.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("-".repeat(40))
	print("To modify layout:")
	print("1. Edit grid_position values in the .tres file")
	print("2. Or use this script to create new layouts")
	print("3. Grid range: 0-%d (width), 0-%d (height)" % [
		SettlementManager.grid_width-1, 
		SettlementManager.grid_height-1
	])

# Helper function to create new enemy base layouts
static func create_enemy_base_layout(buildings: Array[Dictionary], save_path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 500, "wood": 200, "food": 150, "stone": 100}
	settlement.placed_buildings = buildings
	
	ResourceSaver.save(settlement, save_path)
	print("Created new enemy base: " + save_path)

# Example usage:
# EnemyBaseEditor.create_fortress_layout()
static func create_fortress_layout():
	var buildings = [
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(32, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	create_enemy_base_layout(buildings, "res://data/settlements/fortress_base.tres")

--- SCRIPT: res://tools/SettlementLayoutEditor.gd ---
# SettlementLayoutEditor.gd
# Tool to help create custom settlement layouts
@tool
extends EditorScript

# Define available buildings with their paths
const BUILDINGS = {
	"Great Hall": "res://data/buildings/GreatHall.tres",
	"Wall": "res://data/buildings/Bldg_Wall.tres", 
	"Lumber Yard": "res://data/buildings/LumberYard.tres",
	"Chapel": "res://data/buildings/Monastery_Chapel.tres",
	"Granary": "res://data/buildings/Monastery_Granary.tres",
	"Library": "res://data/buildings/Monastery_Library.tres",
	"Scriptorium": "res://data/buildings/Monastery_Scriptorium.tres",
	"Watchtower": "res://data/buildings/Monastery_Watchtower.tres"
}

func _run():
	print("=== SETTLEMENT LAYOUT EDITOR ===")
	print("Available buildings:")
	for name in BUILDINGS.keys():
		print("  - %s: %s" % [name, BUILDINGS[name]])
	
	print("\n=== EXAMPLE LAYOUTS ===")
	
	# Example 1: Small Defensive Settlement
	var small_defensive = create_small_defensive_layout()
	print("\n1. SMALL DEFENSIVE LAYOUT:")
	print_layout(small_defensive)
	save_layout(small_defensive, "res://data/settlements/small_defensive.tres")
	
	# Example 2: Economic Settlement
	var economic = create_economic_layout()
	print("\n2. ECONOMIC LAYOUT:")
	print_layout(economic)
	save_layout(economic, "res://data/settlements/economic_base.tres")
	
	# Example 3: Monastery Layout
	var monastery = create_monastery_layout()
	print("\n3. MONASTERY LAYOUT:")
	print_layout(monastery)
	save_layout(monastery, "res://data/settlements/monastery_base.tres")
	
	print("\n=== LAYOUT FILES CREATED ===")
	print("You can now use these layouts by:")
	print("1. Loading them in the Inspector on SettlementBridge")
	print("2. Or copying the placement arrays manually")

func create_small_defensive_layout() -> Array[Dictionary]:
	return [
		# Great Hall in center
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(8, 6)},
		
		# Defensive walls around perimeter
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(7, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(11, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(13, 4)},
		
		# Watchtowers at corners
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(4, 3)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(14, 3)},
		
		# Basic resource building
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 8)}
	]

func create_economic_layout() -> Array[Dictionary]:
	return [
		# Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 8)},
		
		# Economic buildings clustered together
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(8, 6)},
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(12, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(14, 6)},
		
		# Minimal defenses
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(10, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(10, 3)}
	]

func create_monastery_layout() -> Array[Dictionary]:
	return [
		# Central Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 10)},
		
		# Monastery buildings in organized pattern
		{"resource_path": BUILDINGS["Chapel"], "grid_position": Vector2i(8, 7)},
		{"resource_path": BUILDINGS["Library"], "grid_position": Vector2i(12, 7)},
		{"resource_path": BUILDINGS["Scriptorium"], "grid_position": Vector2i(8, 13)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(12, 13)},
		
		# Outer walls for protection
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(14, 5)},
		
		# Watchtowers
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 15)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 15)}
	]

func print_layout(layout: Array[Dictionary]):
	for i in range(layout.size()):
		var building = layout[i]
		var name = get_building_name(building["resource_path"])
		var pos = building["grid_position"]
		print("  [%d] %s at (%d, %d)" % [i, name, pos.x, pos.y])

func get_building_name(path: String) -> String:
	for name in BUILDINGS.keys():
		if BUILDINGS[name] == path:
			return name
	return "Unknown"

func save_layout(layout: Array[Dictionary], path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 200, "stone": 300}
	settlement.placed_buildings = layout
	settlement.garrisoned_units = {"res://data/units/Unit_PlayerRaider.tres": 3}
	
	var error = ResourceSaver.save(settlement, path)
	if error == OK:
		print(" Saved layout to: %s" % path)
	else:
		print(" Failed to save layout to: %s" % path)

--- SCRIPT: res://tools/test_phase3.gd ---
# Test script for Phase 3 functionality
extends Node

func _ready():
	print("=== PHASE 3 TEST STARTING ===")
	test_garrison_system()
	test_raid_system()

func test_garrison_system():
	print("\n--- Testing Garrison System (Pillar 1) ---")
	if SettlementManager.current_settlement:
		print("Current treasury: %s" % SettlementManager.current_settlement.treasury)
		print("Current garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
		
		# Test unit recruitment
		var player_unit_data = load("res://data/units/Unit_PlayerRaider.tres") as UnitData
		if player_unit_data:
			print("Found player unit data: %s" % player_unit_data.display_name)
			print("Unit spawn cost: %s" % player_unit_data.spawn_cost)
			
			# Try to recruit one unit
			if SettlementManager.attempt_purchase(player_unit_data.spawn_cost):
				SettlementManager.recruit_unit(player_unit_data)
				print("Successfully recruited %s!" % player_unit_data.display_name)
			else:
				print("Cannot afford to recruit %s" % player_unit_data.display_name)
		else:
			print("ERROR: Could not load player unit data")
	else:
		print("ERROR: No settlement loaded")

func test_raid_system():
	print("\n--- Testing Raid System (Pillar 3) ---")
	if SettlementManager.current_settlement:
		var garrison = SettlementManager.current_settlement.garrisoned_units
		if not garrison.is_empty():
			print("Garrison ready for raid with %d unit types" % garrison.size())
			var total_units = 0
			for unit_path in garrison:
				total_units += garrison[unit_path]
			print("Total units available: %d" % total_units)
			print("Phase 3 raid system ready!")
		else:
			print("No units in garrison - cannot start raid")
	else:
		print("ERROR: No settlement loaded")
	
	print("\n=== PHASE 3 TEST COMPLETE ===")

--- SCRIPT: res://ui/SelectionBox.gd ---
# res://ui/SelectionBox.gd
# This Control node covers the entire screen. It listens for
# raw input, draws the selection box, and emits clean,
# intent-based signals to the EventBus. It also uses
# accept_event() to stop input from passing through the UI.
extends Control

var is_dragging := false
var start_pos := Vector2.ZERO

func _ready() -> void:
	# This node handles its own input via _gui_input,
	# so it doesn't need to connect to the EventRouter.
	pass

func _gui_input(event: InputEvent) -> void:
	# We use _gui_input, which is only called if the mouse
	# is over this Control. Since it's fullscreen,
	# this will always be the case.
	
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.is_pressed():
				is_dragging = true
				start_pos = get_local_mouse_position()
				# This is the UI-bug-fix. We consume the
				# event so nothing else can process it.
				accept_event()
			elif is_dragging: # On Left-Click Release
				is_dragging = false
				var end_pos := get_local_mouse_position()
				var rect := Rect2(start_pos, end_pos - start_pos).abs()
				
				# Check if it was a "drag" or just a "click"
				# A 'click' is a box with a very small area.
				var is_box_select = rect.size.length_squared() > 100 # 10x10 px
				
				# Emit the clean command for the RTSController
				EventBus.emit_signal("select_command", rect, is_box_select)
				
				queue_redraw() # Clear the box
				accept_event()
		
		elif event.button_index == MOUSE_BUTTON_RIGHT and event.is_pressed():
			# This is a "smart command"
			_handle_smart_command(get_local_mouse_position())
			accept_event()
	
	elif event is InputEventMouseMotion and is_dragging:
		# Update the draw loop as the mouse moves
		queue_redraw()
		accept_event()

func _handle_smart_command(screen_pos: Vector2) -> void:
	# This function determines if a right-click
	# is a "move" or "attack" command.
	var world_space: PhysicsDirectSpaceState2D = get_world_2d().direct_space_state
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	
	if not main_camera:
		push_error("SelectionBox: No Camera2D found in viewport.")
		return
		
	# Convert screen position to world position
	var world_pos: Vector2 = main_camera.get_global_mouse_position()
	
	var query := PhysicsPointQueryParameters2D.new()
	query.position = world_pos
	query.collide_with_areas = true
	query.collide_with_bodies = true
	# We only want to hit "enemy" things
	# GDD: "right-click is the 'smart' command (move on ground, attack on enemy)"
	# We assume layer 2 is "enemy_units" and layer 3 is "enemy_buildings"
	query.collision_mask = 6 # (Binary 0110 = Layers 2 and 3)
	
	var results: Array = world_space.intersect_point(query)
	
	if not results.is_empty():
		# We hit an enemy! Emit an attack command.
		var target = results[0].collider
		EventBus.emit_signal("attack_command", target)
	else:
		# We hit the ground. Emit a move command.
		EventBus.emit_signal("move_command", world_pos)

func _draw() -> void:
	# This function draws the selection box
	if is_dragging:
		var current_pos := get_local_mouse_position()
		var rect := Rect2(start_pos, current_pos - start_pos).abs()
		
		# Draw a semi-transparent fill
		draw_rect(rect, Color(0.8, 0.8, 1.0, 0.2), true)
		# Draw a solid outline
		draw_rect(rect, Color(0.8, 0.8, 1.0, 1.0), false, 1.0)

--- SCRIPT: res://ui/StorefrontUI.gd ---
# res://ui/StorefrontUI.gd (Fully Refactored)
extends Control

# --- Node References ---
@onready var gold_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/GoldLabel
@onready var wood_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/WoodLabel
@onready var food_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/FoodLabel
@onready var stone_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/StoneLabel

# --- REMOVED ---
# @onready var buy_wall_button: Button = ...
# @onready var buy_lumber_yard_button: Button = ...

# --- ADDED ---
@onready var build_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/BuildTab/BuildButtonsContainer
# --- END ADDED ---

@onready var recruit_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/RecruitButtons
@onready var garrison_list_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/GarrisonList

# --- Exported Data ---
@export var available_buildings: Array[BuildingData] = [] # This can now be deprecated or used for manual overrides
@export var available_units: Array[UnitData] = []
@export var default_treasury_display: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}
@export var auto_load_units_from_directory: bool = true

# --- REMOVED ---
# var wall_data: BuildingData = ...
# var lumber_yard_data: BuildingData = ...

func _ready() -> void:
	EventBus.treasury_updated.connect(_update_treasury_display)
	EventBus.purchase_successful.connect(_on_purchase_successful)
	
	if SettlementManager.current_settlement:
		_update_treasury_display(SettlementManager.current_settlement.treasury)
	else:
		_update_treasury_display(default_treasury_display)

	# --- REMOVED ---
	# buy_wall_button.pressed.connect(...)
	# buy_lumber_yard_button.pressed.connect(...)
	
	# --- ADDED ---
	_load_building_data()
	# --- END ADDED ---

	# Load and setup recruit buttons
	_load_unit_data()
	_setup_recruit_buttons()
	_update_garrison_display()

# --- ADDED NEW FUNCTION ---
func _load_building_data() -> void:
	"""Scan res://data/buildings/ for buildable .tres files and create buttons."""
	var dir = DirAccess.open("res://data/buildings/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var building_path = "res://data/buildings/" + file_name
				var building_data = load(building_path) as BuildingData
				
				# Check if the building is valid AND flagged for the player
				if building_data and building_data.is_player_buildable:
					print("Found player-buildable building: %s" % building_data.display_name)
					_create_building_button(building_data)
					
			file_name = dir.get_next()
# --- END ADDED ---

# --- ADDED NEW FUNCTION ---
func _create_building_button(building_data: BuildingData) -> void:
	"""Creates and connects a single button for the build tab."""
	var button = Button.new()
	button.text = "%s (Cost: %s)" % [building_data.display_name, _format_cost(building_data.build_cost)]
	button.custom_minimum_size = Vector2(200, 36) # Matches GDD spec [cite: 405]
	button.pressed.connect(_on_buy_button_pressed.bind(building_data))
	build_buttons_container.add_child(button)
# --- END ADDED ---

func _load_unit_data() -> void:
	"""Scan res://data/units/ directory for .tres files and load them as UnitData"""
	var dir = DirAccess.open("res://data/units/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var unit_path = "res://data/units/" + file_name
				var unit_data = load(unit_path) as UnitData
				if unit_data:
					# Only load player-appropriate units (exclude enemy-only units)
					# Player units should have "Player" in their display name or specific naming convention
					if _is_player_unit(unit_data):
						available_units.append(unit_data)
						print("Loaded player unit data: %s" % unit_data.display_name)
					else:
						print("Skipped enemy unit data: %s" % unit_data.display_name)
			file_name = dir.get_next()
		print("Total player units loaded: %d" % available_units.size())

func _setup_recruit_buttons() -> void:
	"""Create recruit buttons for each available unit"""
	for unit_data in available_units:
		var button = Button.new()
		button.text = "%s (Cost: %s)" % [unit_data.display_name, _format_cost(unit_data.spawn_cost)]
		button.custom_minimum_size = Vector2(200, 36)
		button.pressed.connect(_on_recruit_button_pressed.bind(unit_data))
		recruit_buttons_container.add_child(button)

func _is_player_unit(unit_data: UnitData) -> bool:
	"""Check if a unit is appropriate for player recruitment"""
	if not unit_data:
		return false
	
	# Check if the unit has "Player" in its display name
	if "Player" in unit_data.display_name:
		return true
	
	# Check if the unit data resource path contains "Player" 
	if "Player" in unit_data.resource_path:
		return true
	
	# Check if the scene points to a PlayerVikingRaider or other player unit
	if unit_data.scene_to_spawn:
		var scene_path = unit_data.scene_to_spawn.resource_path
		if "Player" in scene_path:
			return true
	
	# Fallback: exclude known enemy units by name
	var enemy_unit_names = ["Viking Raider"] # This is the enemy version
	if unit_data.display_name in enemy_unit_names:
		return false
	
	# Default to true for backwards compatibility with existing units
	return true

func _format_cost(cost: Dictionary) -> String:
	"""Format cost dictionary as readable string"""
	var cost_parts: Array[String] = []
	for resource in cost:
		cost_parts.append("%d %s" % [cost[resource], resource])
	return ", ".join(cost_parts)

func _get_safe_placement_position() -> Vector2i:
	"""Find a safe position to place a building, avoiding overlaps"""
	if not SettlementManager.current_settlement:
		return Vector2i(10, 15) # Fallback position
	
	# Get grid bounds from SettlementManager
	var grid_width = SettlementManager.grid_width
	var grid_height = SettlementManager.grid_height
	
	# Create a set of occupied positions for quick lookup
	var occupied_positions: Array[Vector2i] = []
	for building_entry in SettlementManager.current_settlement.placed_buildings:
		occupied_positions.append(building_entry["grid_position"])
	
	# Find the first available position using a spiral search pattern
	var center_x = grid_width / 2.0
	var center_y = grid_height / 2.0
	var max_radius = min(grid_width, grid_height) / 2.0
	
	# Start from center and spiral outward
	for radius in range(1, int(max_radius) + 1):
		for angle_step in range(8 * radius): # More points for larger radii
			var angle = (angle_step * 2.0 * PI) / (8 * radius)
			var test_x = center_x + int(radius * cos(angle))
			var test_y = center_y + int(radius * sin(angle))
			var test_pos = Vector2i(test_x, test_y)
			
			# Check bounds
			if test_pos.x < 0 or test_pos.x >= grid_width or test_pos.y < 0 or test_pos.y >= grid_height:
				continue
			
			# Check if position is free
			if not test_pos in occupied_positions:
				print("Found safe placement position: %s" % test_pos)
				return test_pos
	
	# If no free position found, use a fallback with warning
	push_warning("No free placement position found, using fallback")
	return Vector2i(10, 15)

func _update_treasury_display(new_treasury: Dictionary) -> void:
	gold_label.text = "Gold: %d" % new_treasury.get("gold", 0)
	wood_label.text = "Wood: %d" % new_treasury.get("wood", 0)
	food_label.text = "Food: %d" % new_treasury.get("food", 0)
	stone_label.text = "Stone: %d" % new_treasury.get("stone", 0)

func _on_buy_button_pressed(item_data: BuildingData) -> void:
	if not item_data:
		return
	
	print("UI attempting to purchase '%s'." % item_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(item_data.build_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % item_data.display_name)
		# Emit signal for cursor-based placement instead of auto-placing
		EventBus.building_ready_for_placement.emit(item_data)
	else:
		print("UI received purchase failure for '%s'." % item_data.display_name)

func _on_recruit_button_pressed(unit_data: UnitData) -> void:
	"""Handle recruit button press"""
	if not unit_data:
		return
	
	print("UI attempting to recruit '%s'." % unit_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(unit_data.spawn_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % unit_data.display_name)
		SettlementManager.recruit_unit(unit_data)
	else:
		print("UI received purchase failure for '%s'." % unit_data.display_name)

func _on_purchase_successful(item_name: String) -> void:
	"""Handle purchase success event - refresh garrison display"""
	_update_garrison_display()

func _update_garrison_display() -> void:
	"""Update the garrison list display with current garrisoned units"""
	if not garrison_list_container:
		return
	
	# Clear existing display
	for child in garrison_list_container.get_children():
		child.queue_free()
	
	if not SettlementManager.current_settlement:
		var no_settlement_label = Label.new()
		no_settlement_label.text = "No settlement loaded"
		garrison_list_container.add_child(no_settlement_label)
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	
	if garrison.is_empty():
		var empty_garrison_label = Label.new()
		empty_garrison_label.text = "No units in garrison"
		garrison_list_container.add_child(empty_garrison_label)
		return
	
	# Add header
	var header_label = Label.new()
	header_label.text = "Current Garrison:"
	header_label.add_theme_font_size_override("font_size", 16)
	garrison_list_container.add_child(header_label)
	
	# Display each unit type and count
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if unit_data:
			var unit_label = Label.new()
			unit_label.text = " %s x%d" % [unit_data.display_name, unit_count]
			garrison_list_container.add_child(unit_label)
		else:
			var error_label = Label.new()
			error_label.text = " Unknown unit x%d" % unit_count
			garrison_list_container.add_child(error_label)
	
	# Add total count
	var total_units = 0
	for unit_path in garrison:
		total_units += garrison[unit_path]
	
	var total_label = Label.new()
	total_label.text = "Total units: %d" % total_units
	total_label.add_theme_font_size_override("font_size", 12)
	garrison_list_container.add_child(total_label)

--- SCRIPT: res://ui/WelcomeHomePopup.gd ---
# res://ui/WelcomeHomePopup.gd
extends PanelContainer

signal collect_button_pressed(payout: Dictionary)

@onready var payout_label: Label = $MarginContainer/VBoxContainer/PayoutLabel
@onready var collect_button: Button = $MarginContainer/VBoxContainer/CollectButton

var _current_payout: Dictionary = {}

func _ready() -> void:
	collect_button.pressed.connect(_on_collect_pressed)
	hide()

func display_payout(payout: Dictionary) -> void:
	if payout.is_empty():
		return

	_current_payout = payout
	var payout_text: String = "Welcome home!\n\nResources gathered:\n"
	for resource_type in payout:
		payout_text += "- %s: %d\n" % [resource_type.capitalize(), payout[resource_type]]
	
	payout_label.text = payout_text
	show()

func _on_collect_pressed() -> void:
	collect_button_pressed.emit(_current_payout)
	hide()
--- END OF CODEBASE ---

---
