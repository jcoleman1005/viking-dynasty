### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. Project Context`**: The technical project dump, including:
	*   `2.1. Project Settings`
	*   `2.2. Resource Files`
	*   `2.3. Scene Structures`
	*   `2.4. Codebase`

---
### **2. Project Context**

#### **2.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Viking Dynasty"
run/main_scene="uid://c53k15q2w8c1a"
config/features=PackedStringArray("4.5", "GL Compatibility")

[autoload]

EventBus="*res://autoload/EventBus.gd"
SettlementManager="*res://autoload/SettlementManager.tscn"

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg", "res://addons/enemy_base_editor/plugin.cfg")

[input]

debug_time_travel="{\"deadzone\": 0.5, \"events\": [{\"physical_keycode\": 84, \"type\": \"key\"}]}"

[plugins]

enemy_base_editor/enabled=true
--- END OF PROJECT SETTINGS ---

#### **2.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://.ai-checkpoints/placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 32
height = 32
noise = SubResource("FastNoiseLite_cemhj")

--- RESOURCE: res://data/buildings/Bldg_GreatHall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 100,
"wood": 250
}
max_health = 50
grid_size = Vector2i(3, 2)

--- RESOURCE: res://data/buildings/Bldg_Wall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
build_cost = {
"stone": 25
}
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/LumberYard.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://drx4sih8numo1"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
display_name = "Lumber Yard"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"wood": 50
}
max_health = 75
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Chapel.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b7p70u4vm3uem"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 25
storage_cap = 200
display_name = "Monastery Chapel"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 100,
"stone": 80,
"wood": 40
}
max_health = 120
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Granary.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bscr3flprg5ts"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "food"
fixed_payout_amount = 20
storage_cap = 300
display_name = "Monastery Granary"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 60,
"stone": 40,
"wood": 100
}
max_health = 90
grid_size = Vector2i(2, 3)

--- RESOURCE: res://data/buildings/Monastery_Library.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bfb0hbf1m2lgf"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 35
storage_cap = 250
display_name = "Monastery Library"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 150,
"stone": 60,
"wood": 80
}
max_health = 80
grid_size = Vector2i(3, 2)

--- RESOURCE: res://data/buildings/Monastery_Scriptorium.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b6dkpjrewc1q6"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 30
storage_cap = 180
display_name = "Monastery Scriptorium"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 120,
"stone": 30,
"wood": 90
}
max_health = 70
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Watchtower.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://ckedcnw210a8k"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Monastery Watchtower"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 80,
"stone": 120,
"wood": 60
}
max_health = 150
is_defensive_structure = true
attack_damage = 15
attack_range = 250.0
attack_speed = 1.5

--- RESOURCE: res://data/settlements/home_base_fixed.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://dtg4x722cnuog"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_abcde"]

[resource]
script = ExtResource("1_abcde")
treasury = {
"food": 0,
"gold": 3460,
"stone": 150,
"wood": 280
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 15),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 15),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 15),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(26, 15),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(25, 15),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 12
}
metadata/_custom_type_script = "uid://hlb8s5g0yp6k"

--- RESOURCE: res://data/settlements/monastery_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://okf2novkg804"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_abcde"]

[resource]
script = ExtResource("1_abcde")
treasury = {
"food": 200,
"gold": 500,
"stone": 150,
"wood": 250
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(25, 15),
"resource_path": "res://data/buildings/Bldg_GreatHall.tres"
}, {
"grid_position": Vector2i(20, 12),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(30, 12),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(23, 20),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(27, 8),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(17, 10),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(35, 10),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(17, 20),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(35, 20),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(24, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(26, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(24, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(26, 16),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(19, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(20, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(21, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(22, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(28, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(29, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(32, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(33, 11),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}])

--- RESOURCE: res://data/settlements/sample_fortress_gui.tres ---
[gd_resource type="SettlementData" script_class="SettlementData" load_steps=2 format=3 uid="uid://cl3pbg7tiqyng"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1"]

[resource]
resource_local_to_scene = false
resource_name = ""
script = ExtResource("1")
treasury = {
"food": 300,
"gold": 1000,
"stone": 400,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(30, 20),
"resource_path": "res://data/buildings/Bldg_GreatHall.tres"
}, {
"grid_position": Vector2i(29, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(29, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(28, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(28, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(27, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(33, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Base_Unit.tres": 4,
"res://data/units/VikingRaider.tres": 8
}

--- RESOURCE: res://data/units/Unit_PlayerRaider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=3 format=3 uid="uid://ejxn3hg8xcu6"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_tcvvg"]
[ext_resource type="PackedScene" uid="uid://cfanwutbtfcp2" path="res://scenes/units/PlayerVikingRaider.tscn" id="2_spawn_scene"]

[resource]
script = ExtResource("1_tcvvg")
display_name = "Player Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
spawn_cost = {
"food": 25,
"gold": 10
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 80.0
attack_speed = 1.0

--- RESOURCE: res://data/units/Unit_Raider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=3 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://dsv0s4yq8c8m5" path="res://scenes/units/VikingRaider.tscn" id="2_spawn_scene"]

[resource]
script = ExtResource("1_abcde")
display_name = "Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
spawn_cost = {
"food": 30,
"gold": 15
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 50.0
attack_speed = 1.0

--- RESOURCE: res://placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 32
height = 32
noise = SubResource("FastNoiseLite_cemhj")

--- RESOURCE: res://textures/placeholders/building_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://ds2w780g4nf1t"]

[resource]
size = Vector2(128, 128)

--- RESOURCE: res://textures/placeholders/defensive_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://db3pfgf4u4pql"]

[resource]
size = Vector2(96, 96)

--- RESOURCE: res://textures/placeholders/unit_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://bg2e08mncpjg1"]

[resource]
size = Vector2(64, 64)

--- RESOURCE: res://textures/placeholders/unit_texture.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://cybqs3wt5wpg3"]

[resource]

--- RESOURCE: res://ui/themes/VikingDynastyTheme.tres ---
[gd_resource type="Theme" load_steps=0 format=3 uid="uid://63duv3n1vwhg"]

[resource]
--- END OF RESOURCE FILES ---

#### **2.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://.ai-checkpoints/main_test.tscn ---
Main Test (Node2D)
> scene: res://.ai-checkpoints/main_test.tscn

--- SCENE: res://addons/enemy_base_editor/EnemyBaseEditorDock.tscn ---
Main (Control)
> script: res://addons/enemy_base_editor/EnemyBaseEditorDock.gd
> scene: res://addons/enemy_base_editor/EnemyBaseEditorDock.tscn

--- SCENE: res://addons/enemy_base_editor/EnemyBaseEditorDock_Simple.tscn ---
EnemyBaseEditorDockSimple (Control)
> script: res://addons/enemy_base_editor/EnemyBaseEditorDock_Simple.gd
> scene: res://addons/enemy_base_editor/EnemyBaseEditorDock_Simple.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2

--- SCENE: res://autoload/SettlementManager.tscn ---
SettlementManager (Node)
> script: res://autoload/SettlementManager.gd
> scene: res://autoload/SettlementManager.tscn
> tile_size = 32
> grid_width = 120
> grid_height = 120
> auto_resize_for_scene = true
> settlement_grid_size = (60, 40)
> raid_grid_size = (120, 80)
> defense_grid_size = (80, 60)
> BuildingContainer (Node2D)

--- SCENE: res://main_test.tscn ---
Main Test (Node2D)
> scene: res://main_test.tscn

--- SCENE: res://player/RTSController.tscn ---
RTSController (Node)
> script: res://player/RTSController.gd
> scene: res://player/RTSController.tscn

--- SCENE: res://scenes/buildings/Base_Building.tscn ---
Base_Building (StaticBody2D)
> script: res://data/buildings/base_building.gd
> scene: res://scenes/buildings/Base_Building.tscn
> Sprite2D (Sprite2D)
> > scale = (0.088867, 0.083008)
> > texture = res://textures/placeholders/building_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/buildings/Base_Building.tscn::RectangleShape2D_b5w0v

--- SCENE: res://scenes/levels/DefensiveMicro.tscn ---
DefensiveMicro (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/levels/DefensiveMicro.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> victory_bonus_loot = {"gold":200}
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> is_defensive_mission = true
> TileMap (TileMap)
> > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]

--- SCENE: res://scenes/levels/SettlementBridge.tscn ---
SettlementBridge (Node)
> script: res://scripts/buildings/SettlementBridge.gd
> scene: res://scenes/levels/SettlementBridge.tscn
> home_base_data = res://data/settlements/home_base_fixed.tres
> welcome_popup_scene = res://ui/WelcomeHome_Popup.tscn
> DefensiveMicro (Node2D)
>   script: res://scenes/missions/RaidMission.gd
>   scene: res://scenes/levels/DefensiveMicro.tscn
> > default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> > available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> > victory_bonus_loot = {"gold":200}
> > player_spawn_formation = {"units_per_row":5,"spacing":40}
> > mission_difficulty = 1.0
> > allow_retreat = true
> > is_defensive_mission = true
>   TileMap (TileMap)
>   > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
>   PlayerStartPosition (Marker2D)
>   > position = (100.0, 400.0)
>   RTSController (Node)
>     script: res://player/RTSController.gd
>     scene: res://player/RTSController.tscn
>   RTSCamera (Camera2D)
>     script: res://player/RTSCamera.gd
>   > position = (400.0, 300.0)
>   > camera_speed = 400.0
>   > edge_pan_margin = 20.0
>   > enable_edge_panning = true
>   > enable_wasd_movement = true
>   > bounds_enabled = false
>   > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]
> UnitContainer (Node2D)
> UI (CanvasLayer)
>   Label (Label)
>   > anchors_preset = -1
>   > offset_left = 19.0
>   > offset_top = 16.0
>   > offset_right = 328.0
>   > offset_bottom = 39.0
>   > text = "Click to build a Wall. Defend the Great Hall!"
>   Storefront_UI (Control)
>     script: res://ui/StorefrontUI.gd
>     scene: res://ui/Storefront_UI.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > available_buildings = []
>   > available_units = []
>   > default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
>   > auto_load_units_from_directory = true
>     PanelContainer (PanelContainer)
>     > layout_mode = 1
>     > anchors_preset = -1
>     > anchor_top = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = 20.0
>     > offset_top = -140.0
>     > offset_right = 480.0
>     > offset_bottom = -20.0
>     > grow_vertical = 0
>       MarginContainer (MarginContainer)
>       > layout_mode = 2
>         TabContainer (TabContainer)
>         > layout_mode = 2
>         > current_tab = 0
>           BuildTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             TreasuryDisplay (HBoxContainer)
>             > layout_mode = 2
>               GoldLabel (Label)
>               > layout_mode = 2
>               > text = "Gold: 0"
>               WoodLabel (Label)
>               > layout_mode = 2
>               > text = "Wood: 0"
>               FoodLabel (Label)
>               > layout_mode = 2
>               > text = "Food: 0"
>               StoneLabel (Label)
>               > layout_mode = 2
>               > text = "Stone: 0"
>             BuildButtons (HBoxContainer)
>             > layout_mode = 2
>               BuyWallButton (Button)
>               > custom_minimum_size = (100.0, 36.0)
>               > layout_mode = 2
>               > text = "Wall"
>               BuyLumberYardButton (Button)
>               > custom_minimum_size = (100.0, 36.0)
>               > layout_mode = 2
>               > text = "Lumber Yard"
>           RecruitTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             RecruitButtons (VBoxContainer)
>             > layout_mode = 2
>             GarrisonList (VBoxContainer)
>             > layout_mode = 2
>   RestartButton (Button)
>   > visible = false
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -84.0
>   > offset_top = -15.5
>   > offset_right = 84.0
>   > offset_bottom = 15.5
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "Return to Settlement"
>   StartAttackButton (Button)
>   > anchors_preset = -1
>   > anchor_left = 1.0
>   > anchor_right = 1.0
>   > offset_left = -110.0
>   > offset_right = -10.0
>   > offset_bottom = 31.0
>   > grow_horizontal = 0
>   > text = "Start Attack"
>   StartRaidButton (Button)
>   > anchors_preset = -1
>   > offset_left = 200.0
>   > offset_top = 20.0
>   > offset_right = 350.0
>   > offset_bottom = 60.0
>   > text = "World Map"

--- SCENE: res://scenes/missions/RaidMission.tscn ---
RaidMission (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/missions/RaidMission.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> victory_bonus_loot = {"gold":200}
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> settlement_bridge_scene = res://scenes/levels/SettlementBridge.tscn
> is_defensive_mission = false
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> CanvasLayer (CanvasLayer)
>   SelectionBox (Control)
>     script: res://ui/SelectionBox.gd
>     scene: res://ui/SelectionBox.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://ui/themes/VikingDynastyTheme.tres
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]

--- SCENE: res://scenes/units/Base_Unit.tscn ---
Base_Unit (CharacterBody2D)
> script: res://scripts/units/Base_Unit.gd
> scene: res://scenes/units/Base_Unit.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/PlayerVikingRaider.tscn ---
PlayerVikingRaider (CharacterBody2D)
> script: res://scripts/units/PlayerVikingRaider.gd
> scene: res://scenes/units/PlayerVikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > scale = (0.058594, 0.061523)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/VikingRaider.tscn ---
VikingRaider (CharacterBody2D)
> script: res://scripts/units/EnemyVikingRaider.gd
> scene: res://scenes/units/VikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)

--- SCENE: res://scenes/units/VikingRaider_Fixed.tscn ---
Main (CharacterBody2D)
> scene: res://scenes/units/VikingRaider_Fixed.tscn

--- SCENE: res://scenes/world_map/WorldMap_Stub.tscn ---
WorldMapStub (Control)
> script: res://scenes/world_map/WorldMap_Stub.gd
> scene: res://scenes/world_map/WorldMap_Stub.tscn
> raid_mission_scene = res://scenes/missions/RaidMission.tscn
> settlement_bridge_scene = res://scenes/levels/SettlementBridge.tscn
> Background (ColorRect)
> > layout_mode = 0
> > color = (0.0, 0.0, 0.0, 1.0)
> TitleLabel (Label)
> > layout_mode = 0
> > offset_top = 50.0
> > offset_right = 141.0
> > offset_bottom = 73.0
> > text = "Select Your Target"
> > horizontal_alignment = 1
> ButtonContainer (VBoxContainer)
> > layout_mode = 0
> > offset_top = 150.0
> > offset_right = 190.0
> > offset_bottom = 216.0
> > alignment = 1
>   RaidMonasteryButton (Button)
>   > layout_mode = 2
>   > text = "Raid: Nearby Monastery"
>   Spacer (HSeparator)
>   > layout_mode = 2
>   BackButton (Button)
>   > layout_mode = 2
>   > text = "Return to Settlement"
> Phase3Test (Node)
>   script: res://test_phase3.gd

--- SCENE: res://ui/SelectionBox.tscn ---
SelectionBox (Control)
> script: res://ui/SelectionBox.gd
> scene: res://ui/SelectionBox.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> theme = res://ui/themes/VikingDynastyTheme.tres

--- SCENE: res://ui/Storefront_UI.tscn ---
Main (Control)
> script: res://ui/StorefrontUI.gd
> scene: res://ui/Storefront_UI.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> available_buildings = []
> available_units = []
> default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
> auto_load_units_from_directory = true
> PanelContainer (PanelContainer)
> > layout_mode = 1
> > anchors_preset = -1
> > anchor_top = 1.0
> > anchor_bottom = 1.0
> > offset_left = 20.0
> > offset_top = -140.0
> > offset_right = 480.0
> > offset_bottom = -20.0
> > grow_vertical = 0
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     TabContainer (TabContainer)
>     > layout_mode = 2
>     > current_tab = 0
>       BuildTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         TreasuryDisplay (HBoxContainer)
>         > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           > text = "Gold: 0"
>           WoodLabel (Label)
>           > layout_mode = 2
>           > text = "Wood: 0"
>           FoodLabel (Label)
>           > layout_mode = 2
>           > text = "Food: 0"
>           StoneLabel (Label)
>           > layout_mode = 2
>           > text = "Stone: 0"
>         BuildButtons (HBoxContainer)
>         > layout_mode = 2
>           BuyWallButton (Button)
>           > custom_minimum_size = (100.0, 36.0)
>           > layout_mode = 2
>           > text = "Wall"
>           BuyLumberYardButton (Button)
>           > custom_minimum_size = (100.0, 36.0)
>           > layout_mode = 2
>           > text = "Lumber Yard"
>       RecruitTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         RecruitButtons (VBoxContainer)
>         > layout_mode = 2
>         GarrisonList (VBoxContainer)
>         > layout_mode = 2

--- SCENE: res://ui/WelcomeHome_Popup.tscn ---
Main (PanelContainer)
> script: res://ui/WelcomeHomePopup.gd
> scene: res://ui/WelcomeHome_Popup.tscn
> anchor_left = 0.5
> anchor_top = 0.5
> anchor_right = 0.5
> anchor_bottom = 0.5
> offset_left = -150.0
> offset_top = -75.0
> offset_right = 150.0
> offset_bottom = 75.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 4
> size_flags_vertical = 4
> theme = res://ui/themes/VikingDynastyTheme.tres
> MarginContainer (MarginContainer)
> > layout_mode = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     PayoutLabel (Label)
>     > layout_mode = 2
>     > text = "Welcome home! ..."
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     CollectButton (Button)
>     > custom_minimum_size = (120.0, 40.0)
>     > layout_mode = 2
>     > text = "Collect"
--- END OF SCENE STRUCTURES ---

#### **2.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://.ai-checkpoints/test_phase3.gd ---
# Test script for Phase 3 functionality
extends Node

func _ready():
	print("=== PHASE 3 TEST STARTING ===")
	test_garrison_system()
	test_raid_system()

func test_garrison_system():
	print("\n--- Testing Garrison System (Pillar 1) ---")
	if SettlementManager.current_settlement:
		print("Current treasury: %s" % SettlementManager.current_settlement.treasury)
		print("Current garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
		
		# Test unit recruitment
		var player_unit_data = load("res://data/units/Unit_PlayerRaider.tres") as UnitData
		if player_unit_data:
			print("Found player unit data: %s" % player_unit_data.display_name)
			print("Unit spawn cost: %s" % player_unit_data.spawn_cost)
			
			# Try to recruit one unit
			if SettlementManager.attempt_purchase(player_unit_data.spawn_cost):
				SettlementManager.recruit_unit(player_unit_data)
				print("Successfully recruited %s!" % player_unit_data.display_name)
			else:
				print("Cannot afford to recruit %s" % player_unit_data.display_name)
		else:
			print("ERROR: Could not load player unit data")
	else:
		print("ERROR: No settlement loaded")

func test_raid_system():
	print("\n--- Testing Raid System (Pillar 3) ---")
	if SettlementManager.current_settlement:
		var garrison = SettlementManager.current_settlement.garrisoned_units
		if not garrison.is_empty():
			print("Garrison ready for raid with %d unit types" % garrison.size())
			var total_units = 0
			for unit_path in garrison:
				total_units += garrison[unit_path]
			print("Total units available: %d" % total_units)
			print("Phase 3 raid system ready!")
		else:
			print("No units in garrison - cannot start raid")
	else:
		print("ERROR: No settlement loaded")
	
	print("\n=== PHASE 3 TEST COMPLETE ===")

--- SCRIPT: res://addons/enemy_base_editor/BuildingPalette.gd ---
@tool
extends VBoxContainer
class_name BuildingPalette

signal building_selected(building_data: BuildingData)

# UI Elements
var search_line_edit: LineEdit
var category_option: OptionButton
var buildings_scroll: ScrollContainer
var buildings_container: VBoxContainer

# Data
var all_buildings: Array[BuildingData] = []
var filtered_buildings: Array[BuildingData] = []
var selected_building_button: Button = null

# Categories
enum BuildingCategory {
	ALL,
	DEFENSIVE,
	ECONOMIC,
	RESIDENTIAL,
	RELIGIOUS,
	UTILITY
}

var category_names = {
	BuildingCategory.ALL: "All Buildings",
	BuildingCategory.DEFENSIVE: "Defensive",
	BuildingCategory.ECONOMIC: "Economic", 
	BuildingCategory.RESIDENTIAL: "Residential",
	BuildingCategory.RELIGIOUS: "Religious",
	BuildingCategory.UTILITY: "Utility"
}

func _ready():
	name = "BuildingPalette"
	setup_ui()

func setup_ui():
	# Header
	var header = Label.new()
	header.text = "Building Palette"
	header.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	add_child(header)
	
	# Search
	var search_container = HBoxContainer.new()
	add_child(search_container)
	
	var search_label = Label.new()
	search_label.text = "Search:"
	search_container.add_child(search_label)
	
	search_line_edit = LineEdit.new()
	search_line_edit.placeholder_text = "Filter buildings..."
	search_line_edit.text_changed.connect(_on_search_changed)
	search_container.add_child(search_line_edit)
	
	# Category filter
	var category_container = HBoxContainer.new()
	add_child(category_container)
	
	var category_label = Label.new()
	category_label.text = "Category:"
	category_container.add_child(category_label)
	
	category_option = OptionButton.new()
	for category in category_names:
		category_option.add_item(category_names[category])
	category_option.selected = BuildingCategory.ALL
	category_option.item_selected.connect(_on_category_changed)
	category_container.add_child(category_option)
	
	# Separator
	var separator = HSeparator.new()
	add_child(separator)
	
	# Buildings list
	buildings_scroll = ScrollContainer.new()
	buildings_scroll.custom_minimum_size = Vector2(0, 300)
	add_child(buildings_scroll)
	
	buildings_container = VBoxContainer.new()
	buildings_scroll.add_child(buildings_container)

func set_buildings(buildings: Array[BuildingData]):
	all_buildings = buildings
	_update_building_list()

func _update_building_list():
	# Clear existing buttons
	for child in buildings_container.get_children():
		child.queue_free()
	
	# Filter buildings
	_filter_buildings()
	
	# Create buttons for filtered buildings
	for building_data in filtered_buildings:
		_create_building_button(building_data)

func _filter_buildings():
	filtered_buildings.clear()
	
	var search_text = search_line_edit.text.to_lower() if search_line_edit else ""
	var selected_category = category_option.selected if category_option else BuildingCategory.ALL
	
	for building_data in all_buildings:
		# Apply search filter
		if search_text != "" and not building_data.display_name.to_lower().contains(search_text):
			continue
		
		# Apply category filter
		if selected_category != BuildingCategory.ALL:
			var building_category = _get_building_category(building_data)
			if building_category != selected_category:
				continue
		
		filtered_buildings.append(building_data)

func _get_building_category(building_data: BuildingData) -> BuildingCategory:
	var name = building_data.display_name.to_lower()
	
	if building_data.is_defensive_structure or "wall" in name or "tower" in name or "watchtower" in name:
		return BuildingCategory.DEFENSIVE
	elif building_data is EconomicBuildingData or "lumber" in name or "yard" in name or "mine" in name:
		return BuildingCategory.ECONOMIC
	elif "chapel" in name or "library" in name or "scriptorium" in name or "monastery" in name:
		return BuildingCategory.RELIGIOUS
	elif "hall" in name or "house" in name or "quarters" in name:
		return BuildingCategory.RESIDENTIAL
	else:
		return BuildingCategory.UTILITY

func _create_building_button(building_data: BuildingData):
	var button_container = HBoxContainer.new()
	buildings_container.add_child(button_container)
	
	# Building button
	var button = Button.new()
	button.custom_minimum_size = Vector2(200, 48)
	button.alignment = HORIZONTAL_ALIGNMENT_LEFT
	button_container.add_child(button)
	
	# Icon (if available)
	if building_data.icon:
		button.icon = building_data.icon
	
	# Building info
	var info_text = building_data.display_name
	if building_data.build_cost and not building_data.build_cost.is_empty():
		info_text += "\n"
		var cost_parts: Array[String] = []
		for resource in building_data.build_cost:
			cost_parts.append("%s: %d" % [resource.capitalize(), building_data.build_cost[resource]])
		info_text += "Cost: " + ", ".join(cost_parts)
	
	button.text = info_text
	button.pressed.connect(_on_building_button_pressed.bind(building_data, button))
	
	# Health/stats info
	var stats_label = Label.new()
	var stats_text = "HP: %d" % building_data.max_health
	if building_data.is_defensive_structure:
		stats_text += " | DMG: %d | Range: %.0f" % [building_data.attack_damage, building_data.attack_range]
	stats_label.text = stats_text
	stats_label.add_theme_font_size_override("font_size", 10)
	button_container.add_child(stats_label)

func _on_building_button_pressed(building_data: BuildingData, button: Button):
	# Update selection visual
	if selected_building_button:
		selected_building_button.modulate = Color.WHITE
	
	selected_building_button = button
	button.modulate = Color(1.2, 1.2, 0.8)  # Highlight selected
	
	# Emit signal
	building_selected.emit(building_data)

func _on_search_changed(new_text: String):
	_update_building_list()

func _on_category_changed(index: int):
	_update_building_list()

func clear_selection():
	if selected_building_button:
		selected_building_button.modulate = Color.WHITE
		selected_building_button = null

# Utility function to get building info for tooltips
func get_building_tooltip(building_data: BuildingData) -> String:
	var tooltip = building_data.display_name + "\n\n"
	
	# Health
	tooltip += "Health: %d HP\n" % building_data.max_health
	
	# Cost
	if building_data.build_cost and not building_data.build_cost.is_empty():
		tooltip += "Cost: "
		var cost_parts: Array[String] = []
		for resource in building_data.build_cost:
			cost_parts.append("%s %d" % [resource.capitalize(), building_data.build_cost[resource]])
		tooltip += ", ".join(cost_parts) + "\n"
	
	# Defensive stats
	if building_data.is_defensive_structure:
		tooltip += "Damage: %d\n" % building_data.attack_damage
		tooltip += "Range: %.0f\n" % building_data.attack_range
		tooltip += "Attack Speed: %.1f/sec\n" % building_data.attack_speed
	
	# Economic info
	if building_data is EconomicBuildingData:
		var eco_data = building_data as EconomicBuildingData
		tooltip += "Produces: %s (%d per cycle)\n" % [eco_data.resource_type.capitalize(), eco_data.fixed_payout_amount]
	
	# Grid size
	tooltip += "Size: %dx%d" % [building_data.grid_size.x, building_data.grid_size.y]
	
	return tooltip

--- SCRIPT: res://addons/enemy_base_editor/CollapsibleGroup.gd ---
@tool
extends VBoxContainer
class_name CollapsibleGroup

var title: String = "Group"
var expanded: bool = true

var header_button: Button
var content_container: VBoxContainer

func _init():
	setup_ui()

func setup_ui():
	# Header button
	header_button = Button.new()
	header_button.alignment = HORIZONTAL_ALIGNMENT_LEFT
	header_button.pressed.connect(_on_header_pressed)
	super.add_child(header_button)
	
	# Content container
	content_container = VBoxContainer.new()
	super.add_child(content_container)
	
	_update_header()

func _update_header():
	var arrow = "‚ñº " if expanded else "‚ñ∂ "
	header_button.text = arrow + title
	content_container.visible = expanded

func _on_header_pressed():
	expanded = !expanded
	_update_header()

func add_child(node, force_readable_name: bool = false, internal: int = INTERNAL_MODE_DISABLED):
	if content_container and node != header_button and node != content_container:
		content_container.add_child(node, force_readable_name, internal)
	else:
		super.add_child(node, force_readable_name, internal)

--- SCRIPT: res://addons/enemy_base_editor/EnemyBaseEditor.gd ---
@tool
extends EditorScript

# Enemy Base Layout Editor - EditorScript version
# This script will appear in Tools -> Execute Script menu

func _run():
	print("=== ENEMY BASE LAYOUT EDITOR ===")
	
	var settlement_path = "res://data/settlements/monastery_base.tres"
	var settlement_data: SettlementData = load(settlement_path)
	
	if not settlement_data:
		print("ERROR: Could not load settlement data!")
		push_error("Could not load settlement data from: " + settlement_path)
		return
	
	print("Current layout for: " + settlement_path)
	print("Grid positions (format: Building @ X,Y):")
	print("-".repeat(40))
	
	for i in range(settlement_data.placed_buildings.size()):
		var building = settlement_data.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("-".repeat(40))
	print("To modify layout:")
	print("1. Edit grid_position values in the .tres file")
	print("2. Or use EnemyBaseEditor.create_fortress_layout() in debugger")
	print("3. Grid range: 0-%d (width), 0-%d (height)" % [
		SettlementManager.grid_width-1, 
		SettlementManager.grid_height-1
	])
	
	print("=== ANALYSIS COMPLETE ===")

# Helper function to create new enemy base layouts
static func create_enemy_base_layout(buildings: Array[Dictionary], save_path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 500, "wood": 200, "food": 150, "stone": 100}
	settlement.placed_buildings = buildings
	
	var error = ResourceSaver.save(settlement, save_path)
	if error == OK:
		print("‚úÖ Created new enemy base: " + save_path)
	else:
		push_error("‚ùå Failed to save enemy base to: " + save_path)

# Example fortress layout - call this function to create a sample fortress
static func create_fortress_layout():
	print("üè∞ Creating fortress layout...")
	var buildings = [
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(32, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	create_enemy_base_layout(buildings, "res://data/settlements/fortress_base.tres")

--- SCRIPT: res://addons/enemy_base_editor/EnemyBaseEditorDock.gd ---
@tool
extends Control
class_name EnemyBaseEditorDock

# Core components
var current_settlement: SettlementData
var grid_editor: SettlementGridEditor
var building_palette: BuildingPalette
var property_panel: SettlementProperties

# UI References
var main_container: VBoxContainer
var toolbar: HBoxContainer
var content_hsplit: HSplitContainer
var grid_scroll: ScrollContainer
var right_panel: VBoxContainer

# UI Elements
var new_button: Button
var load_button: Button
var save_button: Button
var save_as_button: Button
var validate_button: Button
var file_dialog: FileDialog
var current_file_label: Label

# Available buildings cache
var available_buildings: Array[BuildingData] = []

# Selected building for placement
var selected_building: BuildingData = null

# Undo/Redo system
var undo_stack: Array[Dictionary] = []
var redo_stack: Array[Dictionary] = []
const MAX_UNDO_STEPS = 50

func _ready():
	name = "EnemyBaseEditorDock"
	setup_ui()
	load_available_buildings()
	create_new_settlement()

func setup_ui():
	# Create main layout
	if not main_container:
		var vbox = VBoxContainer.new()
		vbox.name = "VBoxContainer"
		add_child(vbox)
		main_container = vbox
	
	# Create toolbar
	create_toolbar()
	
	# Create content area
	create_content_area()
	
	# Setup file dialog
	setup_file_dialog()

func create_toolbar():
	var toolbar_container = HBoxContainer.new()
	toolbar_container.name = "Toolbar"
	main_container.add_child(toolbar_container)
	toolbar = toolbar_container
	
	# File operations
	new_button = Button.new()
	new_button.text = "New"
	new_button.tooltip_text = "Create a new settlement"
	new_button.pressed.connect(_on_new_pressed)
	toolbar.add_child(new_button)
	
	load_button = Button.new()
	load_button.text = "Load"
	load_button.tooltip_text = "Load an existing settlement"
	load_button.pressed.connect(_on_load_pressed)
	toolbar.add_child(load_button)
	
	save_button = Button.new()
	save_button.text = "Save"
	save_button.tooltip_text = "Save current settlement"
	save_button.pressed.connect(_on_save_pressed)
	toolbar.add_child(save_button)
	
	save_as_button = Button.new()
	save_as_button.text = "Save As"
	save_as_button.tooltip_text = "Save settlement with new name"
	save_as_button.pressed.connect(_on_save_as_pressed)
	toolbar.add_child(save_as_button)
	
	# Add separator
	var separator1 = VSeparator.new()
	toolbar.add_child(separator1)
	
	# Templates dropdown
	var templates_button = MenuButton.new()
	templates_button.text = "Templates"
	templates_button.tooltip_text = "Load settlement templates"
	var templates_popup = templates_button.get_popup()
	for template_name in SettlementTemplates.get_template_names():
		templates_popup.add_item(template_name)
	templates_popup.id_pressed.connect(_on_template_selected)
	toolbar.add_child(templates_button)
	
	# Add separator
	var separator2 = VSeparator.new()
	toolbar.add_child(separator2)
	
	# Validation
	validate_button = Button.new()
	validate_button.text = "Validate"
	validate_button.tooltip_text = "Check settlement for errors"
	validate_button.pressed.connect(_on_validate_pressed)
	toolbar.add_child(validate_button)
	
	# Current file label
	current_file_label = Label.new()
	current_file_label.text = "New Settlement"
	current_file_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	toolbar.add_child(current_file_label)

func create_content_area():
	var hsplit = HSplitContainer.new()
	hsplit.name = "ContentHSplit"
	hsplit.split_offset = 600
	main_container.add_child(hsplit)
	content_hsplit = hsplit
	
	# Left side - Grid editor
	var scroll = ScrollContainer.new()
	scroll.name = "GridScrollContainer"
	scroll.custom_minimum_size = Vector2(600, 400)
	hsplit.add_child(scroll)
	grid_scroll = scroll
	
	# Create grid editor
	grid_editor = SettlementGridEditor.new()
	grid_editor.building_placed.connect(_on_building_placed)
	grid_editor.building_removed.connect(_on_building_removed)
	grid_editor.building_selected.connect(_on_building_selected)
	scroll.add_child(grid_editor)
	
	# Right side - Controls
	var right_vbox = VBoxContainer.new()
	right_vbox.name = "RightPanel"
	right_vbox.custom_minimum_size = Vector2(300, 0)
	hsplit.add_child(right_vbox)
	right_panel = right_vbox
	
	# Building palette
	building_palette = BuildingPalette.new()
	building_palette.building_selected.connect(_on_palette_building_selected)
	right_panel.add_child(building_palette)
	
	# Property panel
	property_panel = SettlementProperties.new()
	property_panel.treasury_changed.connect(_on_treasury_changed)
	property_panel.units_changed.connect(_on_units_changed)
	right_panel.add_child(property_panel)

func setup_file_dialog():
	file_dialog = FileDialog.new()
	file_dialog.file_mode = FileDialog.FILE_MODE_OPEN_FILE
	file_dialog.add_filter("*.tres", "Settlement Data Files")
	file_dialog.current_dir = "res://data/settlements"
	file_dialog.file_selected.connect(_on_file_selected)
	add_child(file_dialog)

func load_available_buildings():
	available_buildings.clear()
	
	# Load all building data files
	var dir = DirAccess.open("res://data/buildings")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				print("Enemy Base Editor: Attempting to load building file: ", file_name)
				var building_data = load("res://data/buildings/" + file_name) as BuildingData
				if building_data:
					print("Enemy Base Editor: Successfully loaded building: ", building_data.display_name)
					available_buildings.append(building_data)
				else:
					print("Enemy Base Editor: Failed to load building from: ", file_name)
			file_name = dir.get_next()
		dir.list_dir_end()
	else:
		print("Enemy Base Editor: Failed to open buildings directory")
	
	# Update building palette
	if building_palette:
		print("Enemy Base Editor: Setting buildings in palette: ", available_buildings.size())
		building_palette.set_buildings(available_buildings)
	else:
		print("Enemy Base Editor: Building palette not found!")
	
	print("Enemy Base Editor: Loaded %d building types" % available_buildings.size())

func create_new_settlement():
	current_settlement = SettlementData.new()
	current_settlement.treasury = {"gold": 1000, "wood": 500, "food": 300, "stone": 200}
	current_settlement.placed_buildings = []
	current_settlement.garrisoned_units = {}
	
	_update_ui()
	_clear_undo_history()
	current_file_label.text = "New Settlement"
	print("Enemy Base Editor: Created new settlement")

func _update_ui():
	if grid_editor:
		grid_editor.set_settlement(current_settlement)
	if property_panel:
		property_panel.set_settlement(current_settlement)
	
	# Update save button state
	if save_button:
		save_button.disabled = not current_settlement or current_settlement.resource_path.is_empty()

func _on_new_pressed():
	create_new_settlement()

func _on_load_pressed():
	file_dialog.file_mode = FileDialog.FILE_MODE_OPEN_FILE
	file_dialog.popup_centered(Vector2i(800, 600))

func _on_save_pressed():
	if not current_settlement:
		return
	
	if current_settlement.resource_path.is_empty():
		_on_save_as_pressed()
		return
	
	_save_settlement(current_settlement.resource_path)

func _on_save_as_pressed():
	if not current_settlement:
		return
	
	file_dialog.file_mode = FileDialog.FILE_MODE_SAVE_FILE
	file_dialog.popup_centered(Vector2i(800, 600))

func _on_validate_pressed():
	if not current_settlement:
		return
	
	var errors = _validate_settlement()
	var dialog = AcceptDialog.new()
	
	if errors.is_empty():
		dialog.dialog_text = "‚úÖ Settlement validation passed!\n\nNo errors found."
		dialog.title = "Validation Success"
	else:
		dialog.dialog_text = "‚ùå Settlement validation failed:\n\n" + "\n".join(errors)
		dialog.title = "Validation Errors"
	
	add_child(dialog)
	dialog.popup_centered()
	dialog.confirmed.connect(func(): dialog.queue_free())

func _on_file_selected(path: String):
	if file_dialog.file_mode == FileDialog.FILE_MODE_OPEN_FILE:
		_load_settlement(path)
	else:
		_save_settlement(path)

func _load_settlement(path: String):
	var settlement = load(path) as SettlementData
	if not settlement:
		_show_error("Failed to load settlement from: " + path)
		return
	
	current_settlement = settlement
	current_settlement.resource_path = path
	_update_ui()
	_clear_undo_history()
	current_file_label.text = path.get_file()
	print("Enemy Base Editor: Loaded settlement from " + path)

func _save_settlement(path: String):
	if not current_settlement:
		return
	
	current_settlement.resource_path = path
	var error = ResourceSaver.save(current_settlement, path)
	
	if error == OK:
		current_file_label.text = path.get_file()
		_update_ui()
		print("Enemy Base Editor: Saved settlement to " + path)
		_show_success("Settlement saved successfully!")
	else:
		_show_error("Failed to save settlement to: " + path + "\nError: " + str(error))

func _on_palette_building_selected(building_data: BuildingData):
	selected_building = building_data
	if grid_editor:
		grid_editor.set_selected_building(building_data)

func _on_building_placed(building_data: BuildingData, position: Vector2i):
	if not current_settlement:
		return
	
	# Save state for undo
	_save_state_for_undo()
	
	# Add building to settlement data
	var building_entry = {
		"resource_path": building_data.resource_path,
		"grid_position": position
	}
	current_settlement.placed_buildings.append(building_entry)
	
	# Refresh the grid editor to show the new building
	if grid_editor:
		grid_editor.set_settlement(current_settlement)
	
	print("Enemy Base Editor: Placed %s at %s" % [building_data.display_name, position])

func _on_building_removed(position: Vector2i):
	if not current_settlement:
		return
	
	# Save state for undo
	_save_state_for_undo()
	
	# Remove building from settlement data
	for i in range(current_settlement.placed_buildings.size() - 1, -1, -1):
		var building = current_settlement.placed_buildings[i]
		if building["grid_position"] == position:
			current_settlement.placed_buildings.remove_at(i)
			print("Enemy Base Editor: Removed building at %s" % position)
			break
	
	# Refresh the grid editor to update the visual
	if grid_editor:
		grid_editor.set_settlement(current_settlement)

func _on_building_selected(building_data: BuildingData, position: Vector2i):
	# Update property panel to show building details
	pass

func _on_treasury_changed(new_treasury: Dictionary):
	if current_settlement:
		current_settlement.treasury = new_treasury

func _on_units_changed(new_units: Dictionary):
	if current_settlement:
		current_settlement.garrisoned_units = new_units

func _validate_settlement() -> Array[String]:
	var errors: Array[String] = []
	
	if not current_settlement:
		errors.append("No settlement loaded")
		return errors
	
	# Check for building overlaps
	var occupied_positions: Array[Vector2i] = []
	for building_entry in current_settlement.placed_buildings:
		var pos = building_entry["grid_position"]
		if pos in occupied_positions:
			errors.append("Building overlap detected at position " + str(pos))
		else:
			occupied_positions.append(pos)
	
	# Validate building positions are in bounds
	for building_entry in current_settlement.placed_buildings:
		var pos = building_entry["grid_position"]
		if pos.x < 0 or pos.x >= 120 or pos.y < 0 or pos.y >= 80:
			errors.append("Building at " + str(pos) + " is outside grid bounds")
	
	# Check if settlement has essential buildings
	var has_main_hall = false
	for building_entry in current_settlement.placed_buildings:
		var building_data = load(building_entry["resource_path"]) as BuildingData
		if building_data and "hall" in building_data.display_name.to_lower():
			has_main_hall = true
			break
	
	if not has_main_hall:
		errors.append("Settlement should have a main hall or similar central building")
	
	return errors

func _save_state_for_undo():
	if not current_settlement:
		return
	
	var state = {
		"buildings": current_settlement.placed_buildings.duplicate(true),
		"treasury": current_settlement.treasury.duplicate(),
		"units": current_settlement.garrisoned_units.duplicate()
	}
	
	undo_stack.append(state)
	redo_stack.clear()
	
	# Limit undo stack size
	while undo_stack.size() > MAX_UNDO_STEPS:
		undo_stack.pop_front()

func _clear_undo_history():
	undo_stack.clear()
	redo_stack.clear()

func _show_error(message: String):
	var dialog = AcceptDialog.new()
	dialog.dialog_text = "‚ùå Error: " + message
	dialog.title = "Error"
	add_child(dialog)
	dialog.popup_centered()
	dialog.confirmed.connect(func(): dialog.queue_free())

func _show_success(message: String):
	var dialog = AcceptDialog.new()
	dialog.dialog_text = "‚úÖ " + message
	dialog.title = "Success"
	add_child(dialog)
	dialog.popup_centered()
	dialog.confirmed.connect(func(): dialog.queue_free())

func _on_template_selected(id: int):
	var template_names = SettlementTemplates.get_template_names()
	if id >= 0 and id < template_names.size():
		var template_name = template_names[id]
		
		# Show confirmation dialog with template description
		var dialog = ConfirmationDialog.new()
		dialog.title = "Load Template: " + template_name
		dialog.dialog_text = SettlementTemplates.get_template_description(template_name) + "

This will replace the current settlement. Continue?"
		
		dialog.confirmed.connect(_load_template.bind(template_name))
		dialog.canceled.connect(func(): dialog.queue_free())
		
		add_child(dialog)
		dialog.popup_centered()

func _load_template(template_name: String):
	# Save state for undo
	_save_state_for_undo()
	
	# Load template
	current_settlement = SettlementTemplates.create_template_by_name(template_name)
	_update_ui()
	current_file_label.text = "Template: " + template_name
	
	_show_success("Loaded template: " + template_name)
	print("Enemy Base Editor: Loaded template '%s' with %d buildings" % [template_name, current_settlement.placed_buildings.size()])

func show_legacy_analysis():
	# Legacy function for backwards compatibility
	if not current_settlement:
		_show_error("No settlement loaded for analysis")
		return
	
	print("=== ENEMY BASE LAYOUT ANALYSIS ===")
	print("Buildings: %d" % current_settlement.placed_buildings.size())
	
	for i in range(current_settlement.placed_buildings.size()):
		var building = current_settlement.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("=== ANALYSIS COMPLETE ===")

--- SCRIPT: res://addons/enemy_base_editor/EnemyBaseEditorDock_Simple.gd ---
@tool
extends Control
class_name EnemyBaseEditorDockSimple

# Simple version without programmatic UI creation
# Available buildings cache
var available_buildings: Array[BuildingData] = []

func _ready():
	name = "EnemyBaseEditorDock"
	# Create a simple label to start
	var label = Label.new()
	label.text = "Enemy Base Editor - Simple Version"
	add_child(label)
	
	# Load buildings
	load_available_buildings()

func load_available_buildings():
	available_buildings.clear()
	
	# Load all building data files
	var dir = DirAccess.open("res://data/buildings")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				print("Enemy Base Editor: Attempting to load building file: ", file_name)
				var building_data = load("res://data/buildings/" + file_name)
				# Try to cast to BuildingData or any subclass
				if building_data is BuildingData:
					building_data = building_data as BuildingData
				else:
					building_data = null
				if building_data:
					print("Enemy Base Editor: Successfully loaded building: ", building_data.display_name)
					available_buildings.append(building_data)
				else:
					print("Enemy Base Editor: Failed to load building from: ", file_name)
			file_name = dir.get_next()
		dir.list_dir_end()
	else:
		print("Enemy Base Editor: Failed to open buildings directory")
	
	print("Enemy Base Editor: Loaded %d building types" % available_buildings.size())

--- SCRIPT: res://addons/enemy_base_editor/plugin.gd ---
@tool
extends EditorPlugin

var dock

func _enter_tree():
	# Create and add the custom dock
	dock = preload("res://addons/enemy_base_editor/EnemyBaseEditorDock.tscn").instantiate()
	add_control_to_dock(DOCK_SLOT_LEFT_UR, dock)
	
	# Also add the tool menu for backwards compatibility
	add_tool_menu_item("Enemy Base Layout Editor", _open_legacy_editor)

func _exit_tree():
	# Remove the dock and menu item
	if dock:
		remove_control_from_docks(dock)
		dock = null
	remove_tool_menu_item("Enemy Base Layout Editor")

func _open_legacy_editor():
	# Legacy function - redirect to dock
	if dock:
		dock.show_legacy_analysis()
	else:
		print("Enemy Base Editor dock not available")

--- SCRIPT: res://addons/enemy_base_editor/SettlementGridEditor.gd ---
@tool
extends Control
class_name SettlementGridEditor

signal building_placed(building_data: BuildingData, position: Vector2i)
signal building_removed(position: Vector2i)
signal building_selected(building_data: BuildingData, position: Vector2i)

# Grid settings
const CELL_SIZE = 32
const GRID_WIDTH = 120
const GRID_HEIGHT = 80

# Visual settings
const GRID_COLOR = Color(0.3, 0.3, 0.3, 0.5)
const SELECTION_COLOR = Color(1.0, 1.0, 0.0, 0.8)
const VALID_PLACEMENT_COLOR = Color(0.0, 1.0, 0.0, 0.5)
const INVALID_PLACEMENT_COLOR = Color(1.0, 0.0, 0.0, 0.5)

# State
var current_settlement: SettlementData
var selected_building: BuildingData
var hovered_position: Vector2i = Vector2i(-1, -1)
var dragging: bool = false
var drag_start_position: Vector2i

# Visual elements
var grid_tiles: Array[Array] = []
var building_sprites: Dictionary = {} # position -> Sprite2D

func _ready():
	name = "SettlementGridEditor"
	custom_minimum_size = Vector2(GRID_WIDTH * CELL_SIZE, GRID_HEIGHT * CELL_SIZE)
	setup_grid()
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)

func setup_grid():
	# Initialize grid tiles array
	grid_tiles.resize(GRID_WIDTH)
	for x in range(GRID_WIDTH):
		grid_tiles[x] = []
		grid_tiles[x].resize(GRID_HEIGHT)
		for y in range(GRID_HEIGHT):
			grid_tiles[x][y] = null

func set_settlement(settlement: SettlementData):
	current_settlement = settlement
	_update_visual_buildings()

func set_selected_building(building: BuildingData):
	selected_building = building
	queue_redraw()

func _update_visual_buildings():
	# Clear existing building sprites
	for sprite in building_sprites.values():
		if is_instance_valid(sprite):
			sprite.queue_free()
	building_sprites.clear()
	
	if not current_settlement:
		return
	
	# Create sprites for each building
	for building_entry in current_settlement.placed_buildings:
		var pos = building_entry["grid_position"]
		var building_data = load(building_entry["resource_path"]) as BuildingData
		if building_data:
			_create_building_sprite(building_data, pos)
	
	queue_redraw()

func _create_building_sprite(building_data: BuildingData, position: Vector2i):
	var sprite = Sprite2D.new()
	sprite.position = Vector2(position * CELL_SIZE) + Vector2(CELL_SIZE, CELL_SIZE) * 0.5
	
	# Use building texture if available, otherwise create a colored rectangle
	if building_data.building_texture:
		sprite.texture = building_data.building_texture
		sprite.scale = Vector2(CELL_SIZE, CELL_SIZE) / sprite.texture.get_size()
	else:
		# Create a simple colored texture
		var texture = ImageTexture.new()
		var image = Image.create(CELL_SIZE, CELL_SIZE, false, Image.FORMAT_RGBA8)
		var color = _get_building_color(building_data)
		image.fill(color)
		texture.set_image(image)
		sprite.texture = texture
	
	add_child(sprite)
	building_sprites[position] = sprite

func _get_building_color(building_data: BuildingData) -> Color:
	# Assign colors based on building type
	var name = building_data.display_name.to_lower()
	if "wall" in name:
		return Color(0.7, 0.5, 0.3, 1.0) # Brown
	elif "hall" in name:
		return Color(0.8, 0.8, 0.2, 1.0) # Yellow
	elif "tower" in name or "watchtower" in name:
		return Color(0.5, 0.5, 0.8, 1.0) # Blue
	elif "lumber" in name or "wood" in name:
		return Color(0.3, 0.8, 0.3, 1.0) # Green
	elif "chapel" in name or "library" in name:
		return Color(0.8, 0.3, 0.8, 1.0) # Purple
	else:
		return Color(0.6, 0.6, 0.6, 1.0) # Gray

func _draw():
	_draw_grid()
	_draw_hover_preview()

func _draw_grid():
	# Draw grid lines
	for x in range(GRID_WIDTH + 1):
		var start_pos = Vector2(x * CELL_SIZE, 0)
		var end_pos = Vector2(x * CELL_SIZE, GRID_HEIGHT * CELL_SIZE)
		draw_line(start_pos, end_pos, GRID_COLOR, 1.0)
	
	for y in range(GRID_HEIGHT + 1):
		var start_pos = Vector2(0, y * CELL_SIZE)
		var end_pos = Vector2(GRID_WIDTH * CELL_SIZE, y * CELL_SIZE)
		draw_line(start_pos, end_pos, GRID_COLOR, 1.0)

func _draw_hover_preview():
	if hovered_position.x < 0 or hovered_position.y < 0:
		return
	
	var rect = Rect2(Vector2(hovered_position * CELL_SIZE), Vector2(CELL_SIZE, CELL_SIZE))
	
	# Draw selection highlight
	draw_rect(rect, SELECTION_COLOR, false, 2.0)
	
	# Draw placement preview if building is selected
	if selected_building:
		var can_place = _can_place_building(selected_building, hovered_position)
		var preview_color = VALID_PLACEMENT_COLOR if can_place else INVALID_PLACEMENT_COLOR
		draw_rect(rect, preview_color)
		
		# Draw building name
		var font = ThemeDB.fallback_font
		var text = selected_building.display_name
		var text_size = font.get_string_size(text, HORIZONTAL_ALIGNMENT_LEFT, -1, 12)
		var text_pos = rect.position + (rect.size - text_size) * 0.5
		draw_string(font, text_pos, text, HORIZONTAL_ALIGNMENT_CENTER, -1, 12, Color.WHITE)

func _gui_input(event):
	if event is InputEventMouseMotion:
		_handle_mouse_motion(event)
	elif event is InputEventMouseButton:
		_handle_mouse_button(event)

func _handle_mouse_motion(event: InputEventMouseMotion):
	var local_pos = event.position
	var grid_pos = Vector2i(local_pos / CELL_SIZE)
	
	if grid_pos.x >= 0 and grid_pos.x < GRID_WIDTH and grid_pos.y >= 0 and grid_pos.y < GRID_HEIGHT:
		if hovered_position != grid_pos:
			hovered_position = grid_pos
			queue_redraw()
	else:
		if hovered_position != Vector2i(-1, -1):
			hovered_position = Vector2i(-1, -1)
			queue_redraw()

func _handle_mouse_button(event: InputEventMouseButton):
	if not event.pressed:
		return
	
	var local_pos = event.position
	var grid_pos = Vector2i(local_pos / CELL_SIZE)
	
	if grid_pos.x < 0 or grid_pos.x >= GRID_WIDTH or grid_pos.y < 0 or grid_pos.y >= GRID_HEIGHT:
		return
	
	if event.button_index == MOUSE_BUTTON_LEFT:
		_handle_left_click(grid_pos)
	elif event.button_index == MOUSE_BUTTON_RIGHT:
		_handle_right_click(grid_pos)

func _handle_left_click(grid_pos: Vector2i):
	var existing_building = _get_building_at_position(grid_pos)
	
	if existing_building:
		# Select existing building
		building_selected.emit(existing_building, grid_pos)
	elif selected_building:
		# Try to place new building
		if _can_place_building(selected_building, grid_pos):
			building_placed.emit(selected_building, grid_pos)
			# Note: Don't create sprite here - let the main dock update settlement data
			# and then refresh the visual buildings through _update_visual_buildings()

func _handle_right_click(grid_pos: Vector2i):
	var existing_building = _get_building_at_position(grid_pos)
	if existing_building:
		# Remove building - the main dock will handle the data update and refresh
		building_removed.emit(grid_pos)

func _get_building_at_position(grid_pos: Vector2i) -> BuildingData:
	if not current_settlement:
		return null
	
	for building_entry in current_settlement.placed_buildings:
		if building_entry["grid_position"] == grid_pos:
			return load(building_entry["resource_path"]) as BuildingData
	
	return null

func _can_place_building(building_data, position: Vector2i) -> bool:
	if not current_settlement:
		return false
	
	# Check if position is within grid bounds
	if position.x < 0 or position.x >= GRID_WIDTH or position.y < 0 or position.y >= GRID_HEIGHT:
		return false
	
	# Check for building overlap
	return _get_building_at_position(position) == null

func _on_mouse_entered():
	pass

func _on_mouse_exited():
	hovered_position = Vector2i(-1, -1)
	queue_redraw()

# Utility functions for external access
func get_grid_size() -> Vector2i:
	return Vector2i(GRID_WIDTH, GRID_HEIGHT)

func get_cell_size() -> int:
	return CELL_SIZE

func world_to_grid(world_pos: Vector2) -> Vector2i:
	return Vector2i(world_pos / CELL_SIZE)

func grid_to_world(grid_pos: Vector2i) -> Vector2:
	return Vector2(grid_pos * CELL_SIZE) + Vector2(CELL_SIZE, CELL_SIZE) * 0.5

--- SCRIPT: res://addons/enemy_base_editor/SettlementProperties.gd ---
@tool
extends VBoxContainer
class_name SettlementProperties

signal treasury_changed(new_treasury: Dictionary)
signal units_changed(new_units: Dictionary)

# UI Elements
var treasury_group: CollapsibleGroup
var units_group: CollapsibleGroup

# Treasury controls
var gold_spinbox: SpinBox
var wood_spinbox: SpinBox
var food_spinbox: SpinBox
var stone_spinbox: SpinBox

# Units controls
var units_container: VBoxContainer
var add_unit_button: Button
var unit_selection_dialog: AcceptDialog

# Data
var current_settlement: SettlementData
var available_units: Array[String] = []

func _ready():
	name = "SettlementProperties"
	setup_ui()
	load_available_units()

func setup_ui():
	# Header
	var header = Label.new()
	header.text = "Settlement Properties"
	header.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	add_child(header)
	
	var separator = HSeparator.new()
	add_child(separator)
	
	# Treasury section
	setup_treasury_section()
	
	# Units section
	setup_units_section()

func setup_treasury_section():
	treasury_group = CollapsibleGroup.new()
	treasury_group.title = "Treasury"
	treasury_group.expanded = true
	add_child(treasury_group)
	
	var treasury_container = VBoxContainer.new()
	treasury_group.add_child(treasury_container)
	
	# Gold
	var gold_container = create_resource_control("Gold:", 0, 99999)
	gold_spinbox = gold_container.get_child(1) as SpinBox
	gold_spinbox.value_changed.connect(_on_treasury_changed)
	treasury_container.add_child(gold_container)
	
	# Wood
	var wood_container = create_resource_control("Wood:", 0, 99999)
	wood_spinbox = wood_container.get_child(1) as SpinBox
	wood_spinbox.value_changed.connect(_on_treasury_changed)
	treasury_container.add_child(wood_container)
	
	# Food
	var food_container = create_resource_control("Food:", 0, 99999)
	food_spinbox = food_container.get_child(1) as SpinBox
	food_spinbox.value_changed.connect(_on_treasury_changed)
	treasury_container.add_child(food_container)
	
	# Stone
	var stone_container = create_resource_control("Stone:", 0, 99999)
	stone_spinbox = stone_container.get_child(1) as SpinBox
	stone_spinbox.value_changed.connect(_on_treasury_changed)
	treasury_container.add_child(stone_container)

func setup_units_section():
	units_group = CollapsibleGroup.new()
	units_group.title = "Garrisoned Units"
	units_group.expanded = false
	add_child(units_group)
	
	var units_main_container = VBoxContainer.new()
	units_group.add_child(units_main_container)
	
	# Add unit button
	add_unit_button = Button.new()
	add_unit_button.text = "Add Unit Type"
	add_unit_button.pressed.connect(_on_add_unit_pressed)
	units_main_container.add_child(add_unit_button)
	
	# Units list
	units_container = VBoxContainer.new()
	units_main_container.add_child(units_container)

func create_resource_control(label_text: String, min_val: float, max_val: float) -> HBoxContainer:
	var container = HBoxContainer.new()
	
	var label = Label.new()
	label.text = label_text
	label.custom_minimum_size = Vector2(60, 0)
	container.add_child(label)
	
	var spinbox = SpinBox.new()
	spinbox.min_value = min_val
	spinbox.max_value = max_val
	spinbox.step = 1
	spinbox.custom_minimum_size = Vector2(120, 0)
	container.add_child(spinbox)
	
	return container

func set_settlement(settlement: SettlementData):
	current_settlement = settlement
	_update_ui()

func _update_ui():
	if not current_settlement:
		return
	
	# Update treasury values
	gold_spinbox.value = current_settlement.treasury.get("gold", 0)
	wood_spinbox.value = current_settlement.treasury.get("wood", 0)
	food_spinbox.value = current_settlement.treasury.get("food", 0)
	stone_spinbox.value = current_settlement.treasury.get("stone", 0)
	
	# Update units
	_update_units_list()

func _update_units_list():
	# Clear existing unit controls
	for child in units_container.get_children():
		child.queue_free()
	
	if not current_settlement:
		return
	
	# Create controls for each unit type
	for unit_path in current_settlement.garrisoned_units:
		var count = current_settlement.garrisoned_units[unit_path]
		_create_unit_control(unit_path, count)

func _create_unit_control(unit_path: String, count: int):
	var container = HBoxContainer.new()
	units_container.add_child(container)
	
	# Unit name
	var unit_name = unit_path.get_file().get_basename()
	var label = Label.new()
	label.text = unit_name + ":"
	label.custom_minimum_size = Vector2(100, 0)
	container.add_child(label)
	
	# Count spinbox
	var spinbox = SpinBox.new()
	spinbox.min_value = 0
	spinbox.max_value = 999
	spinbox.step = 1
	spinbox.value = count
	spinbox.custom_minimum_size = Vector2(80, 0)
	spinbox.value_changed.connect(_on_unit_count_changed.bind(unit_path))
	container.add_child(spinbox)
	
	# Remove button
	var remove_button = Button.new()
	remove_button.text = "X"
	remove_button.custom_minimum_size = Vector2(30, 0)
	remove_button.pressed.connect(_on_remove_unit_pressed.bind(unit_path))
	container.add_child(remove_button)

func load_available_units():
	available_units.clear()
	
	# Load all unit data files
	var dir = DirAccess.open("res://data/units")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				available_units.append("res://data/units/" + file_name)
			file_name = dir.get_next()
		dir.list_dir_end()

func _on_treasury_changed(value: float):
	if not current_settlement:
		return
	
	# Update settlement treasury
	current_settlement.treasury["gold"] = int(gold_spinbox.value)
	current_settlement.treasury["wood"] = int(wood_spinbox.value)
	current_settlement.treasury["food"] = int(food_spinbox.value)
	current_settlement.treasury["stone"] = int(stone_spinbox.value)
	
	# Emit signal
	treasury_changed.emit(current_settlement.treasury)

func _on_unit_count_changed(unit_path: String, new_count: float):
	if not current_settlement:
		return
	
	var count = int(new_count)
	if count <= 0:
		current_settlement.garrisoned_units.erase(unit_path)
	else:
		current_settlement.garrisoned_units[unit_path] = count
	
	# Emit signal
	units_changed.emit(current_settlement.garrisoned_units)

func _on_remove_unit_pressed(unit_path: String):
	if not current_settlement:
		return
	
	current_settlement.garrisoned_units.erase(unit_path)
	_update_units_list()
	
	# Emit signal
	units_changed.emit(current_settlement.garrisoned_units)

func _on_add_unit_pressed():
	_show_unit_selection_dialog()

func _show_unit_selection_dialog():
	# Create unit selection dialog
	var dialog = AcceptDialog.new()
	dialog.title = "Select Unit Type"
	dialog.custom_minimum_size = Vector2(400, 300)
	add_child(dialog)
	
	var vbox = VBoxContainer.new()
	dialog.add_child(vbox)
	
	var scroll = ScrollContainer.new()
	scroll.custom_minimum_size = Vector2(0, 200)
	vbox.add_child(scroll)
	
	var units_list = VBoxContainer.new()
	scroll.add_child(units_list)
	
	# Add buttons for each available unit
	for unit_path in available_units:
		var button = Button.new()
		var unit_name = unit_path.get_file().get_basename()
		button.text = unit_name
		button.alignment = HORIZONTAL_ALIGNMENT_LEFT
		button.pressed.connect(_on_unit_selected.bind(unit_path, dialog))
		units_list.add_child(button)
	
	dialog.popup_centered()

func _on_unit_selected(unit_path: String, dialog: AcceptDialog):
	if not current_settlement:
		return
	
	# Add unit with count of 1
	current_settlement.garrisoned_units[unit_path] = 1
	_update_units_list()
	
	# Emit signal
	units_changed.emit(current_settlement.garrisoned_units)
	
	# Close dialog
	dialog.queue_free()

# CollapsibleGroup is now in its own file

--- SCRIPT: res://addons/enemy_base_editor/SettlementTemplates.gd ---
@tool
extends RefCounted
class_name SettlementTemplates

# Pre-made settlement templates for quick creation
static func create_fortress_template() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 300, "stone": 400}
	
	settlement.placed_buildings = [
		# Central Great Hall
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		
		# Surrounding walls
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		
		# Corner towers
		{"grid_position": Vector2i(28, 18), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
		{"grid_position": Vector2i(32, 18), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
		{"grid_position": Vector2i(28, 22), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
		{"grid_position": Vector2i(32, 22), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
		
		# Economic buildings
		{"grid_position": Vector2i(27, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(33, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	settlement.garrisoned_units = {
		"res://data/units/VikingRaider.tres": 8,
		"res://data/units/Base_Unit.tres": 4
	}
	
	return settlement

static func create_monastery_template() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 800, "wood": 300, "food": 600, "stone": 200}
	
	settlement.placed_buildings = [
		# Central chapel
		{"grid_position": Vector2i(25, 25), "resource_path": "res://data/buildings/Monastery_Chapel.tres"},
		
		# Library and scriptorium
		{"grid_position": Vector2i(23, 25), "resource_path": "res://data/buildings/Monastery_Library.tres"},
		{"grid_position": Vector2i(27, 25), "resource_path": "res://data/buildings/Monastery_Scriptorium.tres"},
		
		# Storage and resources
		{"grid_position": Vector2i(25, 23), "resource_path": "res://data/buildings/Monastery_Granary.tres"},
		
		# Defensive watchtower
		{"grid_position": Vector2i(25, 27), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
		
		# Outer walls for protection
		{"grid_position": Vector2i(22, 24), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(22, 25), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(22, 26), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 24), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 25), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 26), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
	]
	
	settlement.garrisoned_units = {
		"res://data/units/Base_Unit.tres": 6
	}
	
	return settlement

static func create_village_template() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 600, "wood": 400, "food": 200, "stone": 100}
	
	settlement.placed_buildings = [
		# Great Hall (village center)
		{"grid_position": Vector2i(15, 15), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		
		# Economic buildings scattered around
		{"grid_position": Vector2i(13, 15), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(17, 15), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(15, 13), "resource_path": "res://data/buildings/Monastery_Granary.tres"},
		{"grid_position": Vector2i(15, 17), "resource_path": "res://data/buildings/Monastery_Granary.tres"},
		
		# Minimal defensive structures
		{"grid_position": Vector2i(12, 12), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
		{"grid_position": Vector2i(18, 18), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
	]
	
	settlement.garrisoned_units = {
		"res://data/units/Base_Unit.tres": 3
	}
	
	return settlement

static func create_outpost_template() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 300, "wood": 200, "food": 100, "stone": 150}
	
	settlement.placed_buildings = [
		# Single watchtower as main structure
		{"grid_position": Vector2i(10, 10), "resource_path": "res://data/buildings/Monastery_Watchtower.tres"},
		
		# Surrounding walls for basic protection
		{"grid_position": Vector2i(9, 9), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(10, 9), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(11, 9), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(9, 11), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(10, 11), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(11, 11), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		
		# Basic economic support
		{"grid_position": Vector2i(8, 10), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	settlement.garrisoned_units = {
		"res://data/units/Base_Unit.tres": 2
	}
	
	return settlement

static func get_template_names() -> Array[String]:
	return ["Fortress", "Monastery", "Village", "Outpost"]

static func create_template_by_name(template_name: String) -> SettlementData:
	match template_name:
		"Fortress":
			return create_fortress_template()
		"Monastery":
			return create_monastery_template()
		"Village":
			return create_village_template()
		"Outpost":
			return create_outpost_template()
		_:
			print("Unknown template: " + template_name)
			return SettlementData.new()

static func get_template_description(template_name: String) -> String:
	match template_name:
		"Fortress":
			return "A heavily fortified settlement with walls, towers, and strong defenses. Good for challenging raids."
		"Monastery":
			return "A peaceful religious settlement with chapel, library, and scriptorium. Moderate defenses."
		"Village":
			return "A basic settlement with economic buildings and minimal defenses. Good for early game raids."
		"Outpost":
			return "A small military outpost with basic walls and a watchtower. Minimal resources but strategic placement."
		_:
			return "No description available."

--- SCRIPT: res://autoload/EventBus.gd ---
# res://autoload/EventBus.gd
#
# A global Singleton (Autoload) that acts as a central "switchboard"
# for decoupled signal communication between major systems.

extends Node

# --- Build System Signals ---
# TODO: Connect this signal when implementing advanced building system
# @warning_ignore("unused_signal")
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)

# --- Pathfinding Signals ---
signal pathfinding_grid_updated(grid_position: Vector2i)

# --- Treasury & Economy Signals (Phase 2) ---
signal treasury_updated(new_treasury: Dictionary)
signal purchase_successful(item_name: String)
signal purchase_failed(reason: String)

# --- Navigation Signals (Phase 3) ---
signal scene_change_requested(scene_path: String)
signal world_map_opened()
signal raid_mission_started(target_type: String)

# --- Settlement Management Signals ---
signal settlement_loaded(settlement_data: SettlementData)

# --- Unit Management Signals ---
signal player_unit_died(unit: Node2D)

# --- NEW: RTS Command Signals (GDD Section 10) ---
# Emitted by SelectionBox.gd, consumed by RTSController.gd

# Emitted on left-click or drag-release
signal select_command(select_rect: Rect2, is_box_select: bool)

# Emitted on right-click on the ground
signal move_command(target_position: Vector2)

# Emitted on right-click on an enemy
signal attack_command(target_node: Node2D)

--- SCRIPT: res://autoload/SettlementManager.gd ---
# res://autoload/SettlementManager.gd

extends Node

var current_settlement: SettlementData
var astar_grid: AStarGrid2D
@onready var building_container: Node2D = $BuildingContainer

# --- Configurable Grid Settings ---
@export_group("Grid Configuration")
@export var tile_size: int = 32
@export var grid_width: int = 120  # Increased from 50
@export var grid_height: int = 80  # Increased from 30
@export var auto_resize_for_scene: bool = true  # Enable automatic scene detection

# Scene-specific overrides (optional)
@export_subgroup("Scene Overrides")
@export var settlement_grid_size: Vector2i = Vector2i(60, 40)
@export var raid_grid_size: Vector2i = Vector2i(120, 80)  # Increased for raid missions
@export var defense_grid_size: Vector2i = Vector2i(80, 60)  # Increased for defensive missions

func _ready() -> void:
	# Initialize the grid as soon as the manager is ready.
	# This ensures astar_grid is never null after this point.
	_initialize_grid()

func _initialize_grid() -> void:
	"""Initialize the AStarGrid2D with proper error handling"""
	# Auto-detect scene type and adjust grid size if enabled
	if auto_resize_for_scene:
		_detect_and_set_grid_size()
	
	astar_grid = AStarGrid2D.new()
	var playable_rect := Rect2i(0, 0, grid_width, grid_height)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(tile_size, tile_size)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar_grid.update()
	print("Settlement Grid Initialized: %dx%d cells (auto-detected: %s)" % [grid_width, grid_height, auto_resize_for_scene])

func load_settlement(data: SettlementData) -> void:
	if not data:
		push_error("SettlementManager: load_settlement called with null data.")
		return
	
	current_settlement = data
	
	# Ensure resource_path is set for saving later
	if not current_settlement.resource_path or current_settlement.resource_path.is_empty():
		# Try to determine the path from how it was loaded
		if data.resource_path and not data.resource_path.is_empty():
			current_settlement.resource_path = data.resource_path
		else:
			# Fallback: assume it's the home base file
			current_settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
			print("SettlementManager: Set fallback resource_path to: %s" % current_settlement.resource_path)
	
	print("SettlementManager: Settlement loaded - %s" % current_settlement.resource_path)
	print("SettlementManager: Garrison units: %s" % current_settlement.garrisoned_units)
	
	# The grid already exists. Clear its state before loading new buildings.
	# Note: clear() resets the region to (0,0,0,0), so we must reinitialize
	astar_grid.clear()
	
	# Reinitialize grid parameters after clear()
	var playable_rect := Rect2i(0, 0, grid_width, grid_height)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(tile_size, tile_size)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	
	# CRITICAL: Update the grid after setting parameters
	astar_grid.update()
	print("AStarGrid reinitialized: %dx%d cells" % [grid_width, grid_height])
	
	for child in building_container.get_children():
		child.queue_free()

	for building_entry in current_settlement.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if building_data:
			place_building(building_data, grid_pos)
		else:
			push_error("Failed to load building resource from path: %s" % building_res_path)
	
	# Update the grid once after all new solid points have been set
	astar_grid.update()
	print("Settlement loaded with %d buildings." % building_container.get_child_count())


func place_building(building_data: BuildingData, grid_position: Vector2i) -> BaseBuilding:
	if not building_data or not building_data.scene_to_spawn:
		push_error("Build request failed: BuildingData or scene_to_spawn is null.")
		return null
	
	# Validate grid position is within bounds
	if not _is_position_valid(grid_position):
		push_error("Cannot place building at %s: position is outside grid bounds (%d x %d)." % [grid_position, grid_width, grid_height])
		return null
	
	# Check for existing building at this position
	if _is_position_occupied(grid_position):
		push_error("Cannot place building at %s: position is already occupied." % grid_position)
		return null
	
	var new_building: BaseBuilding = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	
	var world_pos_top_left: Vector2 = Vector2(grid_position) * astar_grid.cell_size
	var half_cell_offset: Vector2 = astar_grid.cell_size / 2.0
	new_building.global_position = world_pos_top_left + half_cell_offset
	
	building_container.add_child(new_building)
	
	# Only update pathfinding if position is valid and building blocks pathfinding
	if building_data.blocks_pathfinding and _is_position_valid(grid_position):
		# Ensure grid is properly initialized before setting solid points
		if astar_grid and astar_grid.region.size.x > 0 and astar_grid.region.size.y > 0:
			astar_grid.set_point_solid(grid_position, true)
			astar_grid.update()
			EventBus.pathfinding_grid_updated.emit(grid_position)
		else:
			push_warning("AStarGrid not properly initialized, skipping pathfinding update for building at %s" % grid_position)
		
	return new_building

func deposit_resources(loot: Dictionary) -> void:
	if not current_settlement: return
	for resource_type in loot:
		if current_settlement.treasury.has(resource_type):
			# Payouts should respect the storage cap of the building that generated them,
			# but the main treasury can be considered unlimited for now.
			current_settlement.treasury[resource_type] += loot[resource_type]
		else:
			current_settlement.treasury[resource_type] = loot[resource_type]
	EventBus.treasury_updated.emit(current_settlement.treasury)
	print("Loot deposited. New treasury: %s" % current_settlement.treasury)
	save_settlement()

func attempt_purchase(item_cost: Dictionary) -> bool:
	if not current_settlement: return false
	
	for resource_type in item_cost:
		if not current_settlement.treasury.has(resource_type) or \
		current_settlement.treasury[resource_type] < item_cost[resource_type]:
			var reason = "Insufficient %s" % resource_type
			print("Purchase failed. %s." % reason)
			EventBus.purchase_failed.emit(reason)
			return false
			
	for resource_type in item_cost:
		current_settlement.treasury[resource_type] -= item_cost[resource_type]
	
	EventBus.treasury_updated.emit(current_settlement.treasury)
	EventBus.purchase_successful.emit("Unnamed Item") # Placeholder
	print("Purchase successful. New treasury: %s" % current_settlement.treasury)
	return true

func calculate_payout() -> Dictionary:
	if not current_settlement:
		return {}

	var total_payout: Dictionary = {}

	for building_entry in current_settlement.placed_buildings:
		var building_data: BuildingData = load(building_entry["resource_path"])
		if building_data is EconomicBuildingData:
			var eco_data: EconomicBuildingData = building_data
			var resource_type: String = eco_data.resource_type
			
			if not total_payout.has(resource_type):
				total_payout[resource_type] = 0
			
			# The payout is now a simple, fixed amount per building.
			# The storage_cap is now effectively the treasury cap, handled in deposit_loot.
			total_payout[resource_type] += eco_data.fixed_payout_amount

	if not total_payout.is_empty():
		print("Calculated fixed payout: %s" % total_payout)
	return total_payout

func get_astar_path(start_pos: Vector2, end_pos: Vector2) -> PackedVector2Array:
	if not astar_grid:
		push_error("AStarGrid is not initialized!")
		return PackedVector2Array()
	
	# Check if grid region is properly set
	if astar_grid.region.size.x <= 0 or astar_grid.region.size.y <= 0:
		push_error("AStarGrid region is invalid: %s. Grid was likely cleared but not reinitialized." % astar_grid.region)
		return PackedVector2Array()
	
	var start_id: Vector2i = Vector2i(start_pos / astar_grid.cell_size)
	var end_id: Vector2i = Vector2i(end_pos / astar_grid.cell_size)
	
	# Check bounds before calling get_point_path
	if start_id.x < 0 or start_id.x >= astar_grid.region.size.x or start_id.y < 0 or start_id.y >= astar_grid.region.size.y:
		push_error("Start position (%s) -> grid_id (%s) is out of bounds. Grid size: %s" % [start_pos, start_id, astar_grid.region.size])
		return PackedVector2Array()
	
	if end_id.x < 0 or end_id.x >= astar_grid.region.size.x or end_id.y < 0 or end_id.y >= astar_grid.region.size.y:
		push_error("End position (%s) -> grid_id (%s) is out of bounds. Grid size: %s" % [end_pos, end_id, astar_grid.region.size])
		return PackedVector2Array()
	
	return astar_grid.get_point_path(start_id, end_id)

func recruit_unit(unit_data: UnitData) -> void:
	"""Add a unit to the garrison"""
	if not current_settlement:
		push_error("Cannot recruit unit: no current settlement")
		return
	
	if not unit_data:
		push_error("Cannot recruit: UnitData is null")
		return
	
	var unit_path: String = unit_data.resource_path
	if unit_path.is_empty():
		push_error("Cannot recruit: UnitData has no resource_path")
		return
	
	# Increment the count for this unit type
	if current_settlement.garrisoned_units.has(unit_path):
		current_settlement.garrisoned_units[unit_path] += 1
	else:
		current_settlement.garrisoned_units[unit_path] = 1
	
	print("Recruited %s. Garrison count: %d" % [unit_data.display_name, current_settlement.garrisoned_units[unit_path]])
	
	# Save the updated settlement
	save_settlement()
	
	# Emit event for UI updates
	EventBus.purchase_successful.emit(unit_data.display_name)

func save_settlement() -> void:
	if not current_settlement:
		push_error("Attempted to save a null settlement.")
		return
	
	if current_settlement.resource_path and not current_settlement.resource_path.is_empty():
		# Ensure the settlement uses the external SettlementData script class
		# This prevents inline script conflicts when saving
		if not current_settlement.get_script():
			current_settlement.set_script(preload("res://data/settlements/SettlementData.gd"))
		
		var error = ResourceSaver.save(current_settlement, current_settlement.resource_path)
		if error == OK:
			print("Settlement data saved successfully to: %s" % current_settlement.resource_path)
		else:
			push_error("Failed to save settlement data to path: %s. Error code: %s" % [current_settlement.resource_path, error])
	else:
		push_warning("SettlementData has no resource_path, cannot save settlement.")

func has_current_settlement() -> bool:
	"""Check if there's a valid current settlement loaded"""
	return current_settlement != null

func get_settlement_status() -> String:
	"""Get debug information about the current settlement"""
	if not current_settlement:
		return "No settlement loaded"
	
	var garrison_count = 0
	for unit_path in current_settlement.garrisoned_units:
		garrison_count += current_settlement.garrisoned_units[unit_path]
	
	return "Settlement: %s | Buildings: %d | Garrison units: %d" % [
		current_settlement.resource_path.get_file(),
		current_settlement.placed_buildings.size(),
		garrison_count
	]

func _is_position_valid(grid_position: Vector2i) -> bool:
	"""Check if a grid position is within the AStarGrid bounds"""
	return grid_position.x >= 0 and grid_position.x < grid_width and \
		   grid_position.y >= 0 and grid_position.y < grid_height

func _is_position_occupied(grid_position: Vector2i) -> bool:
	"""Check if a grid position is already occupied by a building"""
	if not current_settlement:
		return false
	
	for building_entry in current_settlement.placed_buildings:
		var existing_pos: Vector2i = building_entry["grid_position"]
		if existing_pos == grid_position:
			return true
	
	return false

func set_astar_point_solid(grid_position: Vector2i, solid: bool) -> void:
	"""Public interface to set pathfinding grid points as solid/passable"""
	if not astar_grid:
		push_warning("AStarGrid not initialized")
		return
	
	if not _is_position_valid(grid_position):
		push_warning("Grid position %s is out of bounds" % grid_position)
		return
	
	if astar_grid.region.size.x <= 0 or astar_grid.region.size.y <= 0:
		push_warning("AStarGrid region is invalid")
		return
	
	astar_grid.set_point_solid(grid_position, solid)
	# Don't call update() here - let caller decide when to batch update

func _detect_and_set_grid_size() -> void:
	"""Auto-detect the current scene type and set appropriate grid size"""
	var current_scene = get_tree().current_scene
	if not current_scene:
		print("SettlementManager: No current scene found for auto-detection")
		return
	
	var scene_name = current_scene.name.to_lower()
	var scene_path = current_scene.scene_file_path.to_lower()
	
	print("SettlementManager: Detecting scene type from '%s' (%s)" % [scene_name, scene_path])
	
	# Detect raid missions
	if "raid" in scene_name or "raid" in scene_path:
		grid_width = raid_grid_size.x
		grid_height = raid_grid_size.y
		print("SettlementManager: Auto-detected RAID mission - using grid %dx%d" % [grid_width, grid_height])
	
	# Detect defensive missions
	elif "defensive" in scene_name or "defense" in scene_path or "sacked" in scene_name:
		grid_width = defense_grid_size.x
		grid_height = defense_grid_size.y
		print("SettlementManager: Auto-detected DEFENSIVE mission - using grid %dx%d" % [grid_width, grid_height])
	
	# Detect settlement/bridge scenes
	elif "settlement" in scene_name or "bridge" in scene_path:
		grid_width = settlement_grid_size.x
		grid_height = settlement_grid_size.y
		print("SettlementManager: Auto-detected SETTLEMENT scene - using grid %dx%d" % [grid_width, grid_height])
	
	# Use large default for unknown scenes
	else:
		print("SettlementManager: Unknown scene type - using default large grid %dx%d" % [grid_width, grid_height])

--- SCRIPT: res://data/buildings/base_building.gd ---
# res://scenes/buildings/Base_Building.gd
#
# --- MODIFIED: Added 'building_destroyed' signal ---

class_name BaseBuilding
extends StaticBody2D

## This signal is emitted when health reaches zero.
## GDD Ref:
signal building_destroyed(building: BaseBuilding)

@export var data: BuildingData
var current_health: int = 100

func _ready() -> void:
	if not data:
		push_warning("BaseBuilding scene is missing its BuildingData resource.")
		return
	
	current_health = data.max_health

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been destroyed." % data.display_name)
	
	# Add visual feedback for destruction
	_show_destruction_effect()
	
	# --- ADDED ---
	# Emit the signal *before* queue_free() so listeners
	# can react before the node is deleted.
	building_destroyed.emit(self)
	
	# Remove from groups before deletion
	remove_from_group("enemy_buildings")
	
	# Queue for deletion on the next frame
	print("Building %s queued for removal from scene" % data.display_name)
	queue_free()

func _show_destruction_effect() -> void:
	"""Add a simple visual destruction effect"""
	# Create a simple destruction tween for visual feedback
	var tween = create_tween()
	
	# Scale down and fade out
	tween.parallel().tween_property(self, "scale", Vector2(0.1, 0.1), 0.3)
	tween.parallel().tween_property(self, "modulate", Color.TRANSPARENT, 0.3)
	
	# Optional: Add rotation for dramatic effect
	tween.parallel().tween_property(self, "rotation", randf() * TAU, 0.3)

--- SCRIPT: res://data/buildings/BuildingData.gd ---
# res://data/buildings/BuildingData.gd
#
# Defines the core data for any building in the game.
#
# --- MODIFIED: Added 'class_name BuildingData' ---

class_name BuildingData
extends Resource

## The name displayed in the UI (e.g., "Stone Wall", "Watchtower").
@export var display_name: String = "New Building"

## The scene that will be instanced when this building is placed.
@export var scene_to_spawn: PackedScene

## The icon shown in the build menu.
@export var icon: Texture2D

## Texture shown on screen
@export var building_texture: Texture2D

## The cost in 'Resources' (e.g., wood, gold) to build this.
@export var build_cost: Dictionary

## The building's maximum hit points.
@export var max_health: int = 100

## If true, this building blocks enemy pathfinding.
@export var blocks_pathfinding: bool = true

## The size of the building on the AStarGrid2D.
@export var grid_size: Vector2i = Vector2i.ONE


@export_group("Defensive Stats")
## If true, this building can attack enemies (e.g., Watchtower).
@export var is_defensive_structure: bool = false

## Damage dealt per attack (if defensive).
@export var attack_damage: int = 5

## Range in pixels (if defensive).
@export var attack_range: float = 200.0

## Attacks per second (if defensive).
@export var attack_speed: float = 1.0

--- SCRIPT: res://data/buildings/EconomicBuildingData.gd ---
# res://data/buildings/EconomicBuildingData.gd
extends BuildingData
class_name EconomicBuildingData

@export_group("Economic Stats")
## The type of resource this building generates (e.g., "wood", "food", "gold").
@export var resource_type: String = "wood"

## The fixed amount of resources generated after each successful attack.
@export var fixed_payout_amount: int = 10

## The maximum amount of the resource that can be stored before collection.
@export var storage_cap: int = 100

--- SCRIPT: res://data/missions/RaidLootData.gd ---
# res://data/missions/RaidLootData.gd
# Resource for tracking loot collected during raids
# GDD Ref: Phase 3 Task 7 - Resource-Driven Payout

extends Resource
class_name RaidLootData

@export var collected_loot: Dictionary = {}

func _init() -> void:
	# Initialize with default resource types
	collected_loot = {
		"gold": 0,
		"wood": 0,
		"food": 0,
		"stone": 0
	}

func add_loot(resource_type: String, amount: int) -> void:
	"""Add loot to the collection"""
	if collected_loot.has(resource_type):
		collected_loot[resource_type] += amount
	else:
		collected_loot[resource_type] = amount
	
	print("Loot added: %d %s (Total: %d)" % [amount, resource_type, collected_loot[resource_type]])

func add_loot_from_building(building_data: BuildingData) -> void:
	"""Extract loot from a destroyed building"""
	if not building_data:
		return
	
	# For EconomicBuildingData, give loot based on the resource type
	if building_data is EconomicBuildingData:
		var eco_data: EconomicBuildingData = building_data
		var loot_amount = eco_data.fixed_payout_amount * 3  # 3x the daily payout as loot
		add_loot(eco_data.resource_type, loot_amount)
	else:
		# Default loot for other buildings
		add_loot("gold", 50)

func get_total_loot() -> Dictionary:
	"""Get a copy of the collected loot"""
	return collected_loot.duplicate()

func clear_loot() -> void:
	"""Reset all loot to zero"""
	for resource_type in collected_loot:
		collected_loot[resource_type] = 0

func get_loot_summary() -> String:
	"""Get a formatted string of collected loot"""
	var summary_parts: Array[String] = []
	for resource_type in collected_loot:
		if collected_loot[resource_type] > 0:
			summary_parts.append("%d %s" % [collected_loot[resource_type], resource_type])
	
	if summary_parts.is_empty():
		return "No loot collected"
	else:
		return "Loot: " + ", ".join(summary_parts)

--- SCRIPT: res://data/settlements/SettlementData.gd ---
extends Resource
class_name SettlementData

@export var treasury: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}

# Stores building data and position. Structure:
# {"resource_path": "res://...", "grid_position": Vector2i(x, y)}
@export var placed_buildings: Array[Dictionary] = []

# Stores unit type (path) and count (int)
# Example: {"res://data/units/Unit_Raider.tres": 3}
@export var garrisoned_units: Dictionary = {}

--- SCRIPT: res://data/units/UnitData.gd ---
# res://data/units/UnitData.gd
#
# Defines the core data for any unit in the game.
# This resource is used by Base_Unit.tscn to configure instances.
# GDD Ref: 7.C.1.b

class_name UnitData
extends Resource

## The name displayed in the UI (e.g., "Viking Raider").
@export var display_name: String = "New Unit"

## The scene that will be instanced when this unit is spawned.
@export var scene_to_spawn: PackedScene

## The icon shown in the training menu.
@export var icon: Texture2D

## The cost in 'Resources' to train this unit.
@export var spawn_cost: Dictionary = {"food": 25}


@export_group("Combat Stats")
## The unit's maximum hit points.
@export var max_health: int = 50

## Movement speed in pixels per second.
@export var move_speed: float = 75.0

## Damage dealt per attack.
@export var attack_damage: int = 8

## Range in pixels. (e.g., 10 for melee, 300 for archer).
@export var attack_range: float = 10.0

## Attacks per second.
@export var attack_speed: float = 1.2

--- SCRIPT: res://player/RTSCamera.gd ---
# res://player/RTSCamera.gd
# Basic RTS-style camera controller for Phase 3
# Provides WASD movement and mouse edge panning
# Keeps camera controls simple and focused on tactical gameplay

extends Camera2D
class_name RTSCamera

@export var camera_speed: float = 400.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_wasd_movement: bool = true

# Movement bounds to keep camera on battlefield
@export var bounds_enabled: bool = false
@export var bounds_rect: Rect2 = Rect2(-500, -500, 1500, 1200)

func _ready() -> void:
	# Make this the current camera
	make_current()

func _process(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	
	# WASD camera movement (as specified in GDD Phase 3)
	if enable_wasd_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Mouse edge panning (common RTS feature)
	if enable_edge_panning:
		var mouse_pos = get_viewport().get_mouse_position()
		var viewport_size = get_viewport().get_visible_rect().size
		
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
			
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		global_position += movement_vector * camera_speed * delta
		
		# Apply bounds if enabled
		if bounds_enabled:
			global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.position.x + bounds_rect.size.x)
			global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.position.y + bounds_rect.size.y)

--- SCRIPT: res://player/RTSController.gd ---
# res://player/RTSController.gd
#
# --- REFACTORED ---
# This script is now decoupled from input.
# It listens for clean signals from the EventBus
# (which are fired by SelectionBox.gd).
# It also correctly cleans up dead units.

extends Node
class_name RTSController

var selected_units: Array[BaseUnit] = []
var controllable_units: Array[BaseUnit] = []
var current_formation: SquadFormation.FormationType = SquadFormation.FormationType.LINE

func _ready() -> void:
	# Connect to the clean signals from our new EventBus/SelectionBox
	EventBus.select_command.connect(_on_select_command)
	EventBus.move_command.connect(_on_move_command)
	EventBus.attack_command.connect(_on_attack_command)

func _input(event: InputEvent) -> void:
	# Formation hotkeys
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_1:
				current_formation = SquadFormation.FormationType.LINE
				print("Formation: LINE")
			KEY_2:
				current_formation = SquadFormation.FormationType.COLUMN
				print("Formation: COLUMN")
			KEY_3:
				current_formation = SquadFormation.FormationType.WEDGE
				print("Formation: WEDGE")
			KEY_4:
				current_formation = SquadFormation.FormationType.BOX
				print("Formation: BOX")

# --- PUBLIC API ---

func add_unit_to_group(unit: Node2D) -> void:
	# Verify the unit is a BaseUnit (which has 'destroyed' signal)
	if not unit is BaseUnit:
		push_error("RTSController: Tried to add unit '%s' that doesn't extend BaseUnit." % unit.name)
		return
		
	if unit in controllable_units:
		return

	controllable_units.append(unit)
	
	# --- THIS IS THE DEAD UNIT CRASH FIX ---
	# Connect to this unit's 'destroyed' signal.
	# When it's destroyed, we'll clean it up.
	# We use CONNECT_DEFERRED to avoid race conditions.
	if unit.has_signal("destroyed"):
		unit.destroyed.connect(remove_unit.bind(unit), CONNECT_DEFERRED)
	else:
		# This check is vital. Our old debug units will fail this.
		push_warning("Unit %s does not have 'destroyed' signal!" % unit.name)

func remove_unit(unit: BaseUnit) -> void:
	"""Removes a unit from tracking. Called by the unit's 'destroyed' signal."""
	print("RTSController: Unit %s was destroyed/removed." % unit.name)
	
	if unit in selected_units:
		selected_units.erase(unit)
		if is_instance_valid(unit):
			# set_selected is a function on BaseUnit
			unit.set_selected(false)
			
	if unit in controllable_units:
		controllable_units.erase(unit)
		
	# Check if this was the last unit
	if controllable_units.is_empty():
		print("RTSController: All units are gone.")

# --- REMOVED ---
# _on_global_input, _draw, _process, _handle_selection,
# and _handle_command are all removed.
# They are replaced by the functions below.
# -----------------

# --- NEW: EVENTBUS HANDLERS ---

func _on_select_command(select_rect: Rect2, is_box_select: bool) -> void:
	_clear_selection()
	
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	if not main_camera:
		push_error("RTSController: No Camera2D found to perform selection.")
		return
	
	if is_box_select:
		# Box select - convert screen rect to world coordinates instead
		# This is more reliable than converting world to screen for each unit
		var camera_pos = main_camera.get_screen_center_position()
		var camera_zoom = main_camera.zoom
		var viewport_size = get_viewport().get_visible_rect().size
		
		# Convert screen rectangle to world coordinates
		var world_rect_min = camera_pos - (viewport_size / (2.0 * camera_zoom)) + (select_rect.position / camera_zoom)
		var world_rect_max = world_rect_min + (select_rect.size / camera_zoom)
		var world_rect = Rect2(world_rect_min, world_rect_max - world_rect_min)
		
		for unit in controllable_units:
			if world_rect.has_point(unit.global_position):
				selected_units.append(unit)
				unit.set_selected(true)
	else:
		# Single select (find closest unit to the click)
		# We must get the world position from the camera
		var click_world_pos := main_camera.get_global_mouse_position()
		var closest_unit: BaseUnit = null
		var min_dist_sq = INF
		
		for unit in controllable_units:
			var dist_sq = unit.global_position.distance_squared_to(click_world_pos)
			# 40px click radius
			if dist_sq < min_dist_sq and dist_sq < (40 * 40): 
				min_dist_sq = dist_sq
				closest_unit = unit
				
		if closest_unit:
			selected_units.append(closest_unit)
			closest_unit.set_selected(true)

func _on_move_command(target_position: Vector2) -> void:
	if selected_units.is_empty():
		return
	
	if selected_units.size() == 1:
		# Single unit - direct movement
		selected_units[0].command_move_to(target_position)
	else:
		# Multiple units - use formation
		var units_as_node2d: Array[Node2D] = []
		for unit in selected_units:
			units_as_node2d.append(unit)
		
		var formation = SquadFormation.new(units_as_node2d)
		formation.formation_type = current_formation
		formation.unit_spacing = 45.0
		formation.move_to_position(target_position)

func _on_attack_command(target_node: Node2D) -> void:
	if selected_units.is_empty():
		return
		
	for unit in selected_units:
		unit.command_attack(target_node)

func _clear_selection() -> void:
	for unit in selected_units:
		# Check if it's valid, it might have been destroyed
		if is_instance_valid(unit):
			unit.set_selected(false)
	selected_units.clear()

--- SCRIPT: res://scenes/missions/RaidMission.gd ---
# res://scenes/missions/RaidMission.gd
# Raid Mission Controller for Phase 3
# GDD Ref: Phase 3 Task 7
#
# --- REFACTORED ---
# This script is now decoupled from input.
# It gets a reference to the RTSController node
# and simply hands units to it.
extends Node2D

# --- Exported Mission Configuration ---
@export var enemy_base_data: SettlementData
@export var default_enemy_base_path: String = "res://data/settlements/monastery_base.tres"
@export_group("Enemy Base Presets")
@export var available_enemy_bases: Array[String] = [
	"res://data/settlements/monastery_base.tres",
	"res://data/settlements/fortress_base.tres"
]
@export var victory_bonus_loot: Dictionary = {"gold": 200}
@export var player_spawn_formation: Dictionary = {"units_per_row": 5, "spacing": 40}
@export var mission_difficulty: float = 1.0
@export var allow_retreat: bool = true

## The scene to return to after the mission ends (e.g., SettlementBridge.tscn)
@export var settlement_bridge_scene: PackedScene

## If true, this mission will *not* check for the "all units destroyed" loss condition.
## This should be TRUE for the Sacked/Defensive mission.
@export var is_defensive_mission: bool = false

# --- MODIFIED: Node References ---
@onready var player_spawn_pos: Marker2D = $PlayerStartPosition
@onready var rts_controller: RTSController = $RTSController
# ---------------------------------

var enemy_hall: Node2D = null
var raid_loot: RaidLootData = null

# --- REMOVED ---
# var player_units: Array[Node2D] = []
# The RTSController now tracks all units.
# -----------------

func _ready() -> void:
	# Connect to the settlement_loaded signal - this works for both standalone and child scenarios
	EventBus.settlement_loaded.connect(_on_settlement_ready_for_mission)
	
	# If no settlement is currently loaded (standalone mode), load a test settlement
	if not SettlementManager.has_current_settlement():
		print("RaidMission: No current settlement - loading test settlement for standalone mode")
		_load_test_settlement()
		call_deferred("initialize_mission")
	else:
		print("RaidMission: Settlement already loaded - initializing mission")
		call_deferred("initialize_mission")

func _load_test_settlement() -> void:
	"""Load a test settlement with garrison units for standalone testing"""
	var test_settlement_path = "res://data/settlements/home_base_fixed.tres"
	var test_settlement = load(test_settlement_path) as SettlementData
	
	if test_settlement:
		print("RaidMission: Loading test settlement: %s" % test_settlement_path)
		print("RaidMission: Test settlement garrison: %s" % test_settlement.garrisoned_units)
		SettlementManager.load_settlement(test_settlement)
	else:
		push_error("RaidMission: Failed to load test settlement from %s" % test_settlement_path)

func _on_settlement_ready_for_mission(settlement_data: SettlementData) -> void:
	"""Called when settlement is loaded - only initialize if we haven't already"""
	if not raid_loot:  # Check if we've already initialized
		print("RaidMission: Settlement loaded - initializing mission")
		initialize_mission()


func initialize_mission() -> void:
	"""
	This function now contains all the logic that used to be in _ready().
	It is called either by _ready() (if standalone) or by SettlementBridge.gd.
	"""
	print("RaidMission starting...")
	
	# Verify controller was found
	if rts_controller == null:
		push_error("RaidMission: Critical error! RTSController node not found.")
		get_tree().quit() # This is a fatal error
		return
	
	raid_loot = RaidLootData.new()
	
	if not enemy_base_data:
		enemy_base_data = load(default_enemy_base_path)
		if not enemy_base_data:
			push_error("Could not load enemy base data from default path.")
			return
	
	_load_enemy_base()
	_update_astar_grid_for_enemy_base()
	_spawn_player_garrison()
	_setup_win_loss_conditions()

func _load_enemy_base() -> void:
	"""Load and instance the enemy's base from SettlementData"""
	print("Loading enemy base...")
	
	if not enemy_base_data:
		push_error("No enemy base data provided")
		return
	
	# Instance each building from the enemy's placed_buildings array
	for building_entry in enemy_base_data.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var loaded_resource = load(building_res_path)
		var building_data: BuildingData = loaded_resource as BuildingData
		
		if not building_data:
			push_error("Failed to load building resource as BuildingData: %s (loaded as %s)" % [building_res_path, loaded_resource.get_class() if loaded_resource else "null"])
			continue
		
		if not building_data.scene_to_spawn:
			push_error("Failed to load building: %s" % building_res_path)
			continue
		
		# Instance the building
		var building_instance: Node2D = building_data.scene_to_spawn.instantiate()
		building_instance.name = building_data.display_name + "_Enemy"
		
		# Set building data
		if "data" in building_instance:
			building_instance.data = building_data
		
		# Position the building (convert grid to world position)
		var world_pos: Vector2 = Vector2(grid_pos) * 32 + Vector2(16, 16) # 32 = tile size
		building_instance.global_position = world_pos
		
		# Add to enemy groups for targeting
		building_instance.add_to_group("enemy_buildings")
		
		# Set collision layer for right-click detection and targeting
		if building_instance.has_method("set_collision_layer"):
			building_instance.set_collision_layer(4)  # Layer 3 for enemy buildings
			building_instance.set_collision_mask(0)   # Don't physically collide with anything
			print("Building %s collision setup: layer=4, mask=0" % building_data.display_name)
		else:
			push_warning("Building %s does not have collision layer methods!" % building_data.display_name)
		
		# Verify collision shape exists
		var collision_shape = building_instance.get_node("CollisionShape2D")
		if collision_shape and collision_shape.shape:
			print("Building %s has collision shape: %s" % [building_data.display_name, collision_shape.shape.get_class()])
		else:
			push_error("Building %s missing collision shape!" % building_data.display_name)
		
		# Add debug area for targeting verification
		building_instance.set_meta("building_data", building_data)
		building_instance.set_meta("is_enemy_building", true)
		
		# Check if this is the Great Hall (main target)
		if building_data.display_name.to_lower().contains("hall"):
			enemy_hall = building_instance
			print("Found enemy hall: %s" % building_data.display_name)
			# Connect to building destroyed signal for win condition
			if building_instance.has_signal("building_destroyed"):
				building_instance.building_destroyed.connect(_on_enemy_hall_destroyed)
		
		# Connect ALL buildings to loot collection system
		if building_instance.has_signal("building_destroyed"):
			building_instance.building_destroyed.connect(_on_enemy_building_destroyed)
		
		# Add to scene
		add_child(building_instance)

func _update_astar_grid_for_enemy_base() -> void:
	"""Update the A* pathfinding grid to account for enemy buildings"""
	print("Updating A* grid for enemy base...")
	
	if not enemy_base_data:
		return
	
	# Process each building to update pathfinding grid
	for building_entry in enemy_base_data.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if not building_data:
			continue
		
		# Only block pathfinding for buildings that should block movement
		if building_data.blocks_pathfinding:
			var grid_size: Vector2i = building_data.grid_size
			
			# Mark all grid cells occupied by this building as blocked
			for x in range(grid_size.x):
				for y in range(grid_size.y):
					var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
					SettlementManager.set_astar_point_solid(cell_pos, true)
			
			print("Blocked pathfinding for %s at %s (size: %s)" % [
				building_data.display_name, grid_pos, grid_size
			])
		else:
			print("Building %s does not block pathfinding" % building_data.display_name)
	
	# Update the grid once after all buildings are processed
	if SettlementManager.astar_grid:
		SettlementManager.astar_grid.update()
		print("A* grid updated for enemy base with %d buildings" % enemy_base_data.placed_buildings.size())

func _spawn_player_garrison() -> void:
	"""Spawn player units from the garrison"""
	print("=== SPAWNING PLAYER GARRISON ===")
	
	if not SettlementManager.current_settlement:
		print("No current settlement found - spawning test units for demo")
		_spawn_test_units() 
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	if garrison.is_empty():
		print("No units in garrison to spawn")
		# We must still check for a loss condition
		# --- MODIFIED: Check if this is a defensive mission ---
		if not is_defensive_mission:
			call_deferred("_check_loss_condition")
		# -----------------------------------------------------
		return
	
	var units_per_row: int = player_spawn_formation.get("units_per_row", 5)
	var spacing: float = player_spawn_formation.get("spacing", 40.0)
	var current_row: int = 0
	var current_col: int = 0
	
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if not unit_data or not unit_data.scene_to_spawn:
			push_error("Failed to load unit data: %s" % unit_path)
			continue
		
		for i in range(unit_count):
			var unit_instance: Node2D = unit_data.scene_to_spawn.instantiate()
			
			# This is a critical check
			if not unit_instance is BaseUnit:
				push_error("Unit scene %s does not extend BaseUnit!" % unit_data.scene_to_spawn.get_path())
				continue
				
			unit_instance.name = unit_data.display_name + "_" + str(i)
			if "data" in unit_instance:
				unit_instance.data = unit_data
			
			var spawn_pos: Vector2 = player_spawn_pos.global_position
			spawn_pos.x += current_col * spacing
			spawn_pos.y += current_row * spacing
			unit_instance.global_position = spawn_pos
			
			unit_instance.add_to_group("player_units")
			
			# --- MODIFIED: This is the new, clean way ---
			# We hand the unit to our controller.
			rts_controller.add_unit_to_group(unit_instance)
			# --------------------------------------------
			
			add_child(unit_instance)
			
			current_col += 1
			if current_col >= units_per_row:
				current_col = 0
				current_row += 1


func _spawn_test_units() -> void:
	"""
	Spawn test units for demonstration.
	NOTE: This debug code is brittle as it creates
	units that are not BaseUnit.
	"""
	print("Spawning test units for box selection demo...")
	
	var units_per_row: int = 3
	var current_row: int = 0
	var current_col: int = 0
	
	for i in range(6):
		var test_unit = CharacterBody2D.new()
		# ... (rest of the test unit creation code) ...
		var script_source = """
extends CharacterBody2D
var is_selected: bool = false; var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0; var is_moving: bool = false
func set_selected(selected: bool) -> void: is_selected = selected; queue_redraw()
func _draw() -> void:
	if is_selected: draw_circle(Vector2.ZERO, 15.0, Color(1,1,0,0.8), false, 2.0)
func command_move_to(target_pos: Vector2) -> void: target_position = target_pos; is_moving = true
func command_attack(target: Node2D) -> void: print('%s attacking %s' % [name, target.name])
func set_target_position(pos: Vector2) -> void: target_position = pos; is_moving = true
func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var dir = (target_position - global_position).normalized()
		if global_position.distance_to(target_position) < 5.0:
			is_moving = false; velocity = Vector2.ZERO
		else: velocity = dir * move_speed
		move_and_slide()
"""
		var temp_script = GDScript.new(); temp_script.source_code = script_source
		temp_script.reload(); test_unit.set_script(temp_script)
		
		# ... (code to position and add_child the unit) ...
		var spawn_pos: Vector2 = player_spawn_pos.global_position
		spawn_pos.x += current_col * 60
		spawn_pos.y += current_row * 60
		test_unit.global_position = spawn_pos
		test_unit.add_to_group("player_units")
		add_child(test_unit)

		# --- MODIFIED: Register test unit with controller ---
		# We must check if it's a BaseUnit, which it is not.
		# This debug code will not work with our new system
		# without a significant rewrite.
		if test_unit is BaseUnit:
			rts_controller.add_unit_to_group(test_unit)
		else:
			push_warning("Test unit '%s' is not a BaseUnit. Skipping add to RTSController." % test_unit.name)
		# ----------------------------------------------------
		
		current_col += 1
		if current_col >= units_per_row:
			current_col = 0
			current_row += 1

# --- REMOVED ---
# The _setup_rts_controller() function is now gone.
# -----------------

func _on_enemy_building_destroyed(building: BaseBuilding) -> void:
	"""Called when any enemy building is destroyed - collect loot and update grid"""
	var building_data = building.data as BuildingData
	
	if raid_loot and building_data:
		raid_loot.add_loot_from_building(building_data)
		print("Building destroyed: %s | %s" % [building_data.display_name, raid_loot.get_loot_summary()])
	
	# Update pathfinding grid to make the area passable again
	_clear_building_from_pathfinding_grid(building)
	
	# Count remaining buildings for mission tracking
	var remaining_buildings = get_tree().get_nodes_in_group("enemy_buildings").size()
	print("Buildings remaining: %d" % remaining_buildings)

func _clear_building_from_pathfinding_grid(building: BaseBuilding) -> void:
	"""Remove building's collision from pathfinding grid"""
	if not building.data:
		return
		
	# Calculate the grid position from the building's world position
	var world_pos = building.global_position
	var grid_pos = Vector2i((world_pos - Vector2(16, 16)) / 32)  # Reverse the positioning logic
	var grid_size = building.data.grid_size
	
	# Clear all grid cells that were occupied by this building
	for x in range(grid_size.x):
		for y in range(grid_size.y):
			var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
			SettlementManager.set_astar_point_solid(cell_pos, false)
	
	# Update the grid
	if SettlementManager.astar_grid:
		SettlementManager.astar_grid.update()
		print("Cleared pathfinding for destroyed building at %s (size: %s)" % [grid_pos, grid_size])

func _setup_win_loss_conditions() -> void:
	"""Setup win/loss condition monitoring"""
	# --- MODIFIED: Check if this is a defensive mission ---
	if not is_defensive_mission:
		# Start periodic check for loss condition
		_check_loss_condition()
	else:
		print("RaidMission: Skipping 'all units destroyed' loss check for defensive mission.")
	# -----------------------------------------------------

func _check_loss_condition() -> void:
	"""Check if all player units are destroyed (loss condition)"""
	# This is a recursive timer loop.
	await get_tree().create_timer(1.0).timeout
	
	# --- MODIFIED: Ask the controller ---
	# The RTSController is now the single source of truth for unit counts.
	var remaining_units = 0
	if is_instance_valid(rts_controller):
		remaining_units = rts_controller.controllable_units.size()
	# ------------------------------------
	
	print("Loss check: %d units remaining" % remaining_units)
	
	if remaining_units == 0:
		_on_mission_failed()
		return # Stop the loop
	
	# Continue checking if mission is still active
	if is_instance_valid(enemy_hall):
		_check_loss_condition()
	else:
		print("Loss condition checking stopped - enemy hall destroyed")

func _on_mission_failed() -> void:
	"""Called when all player units are destroyed"""
	print("Mission Failed! All units destroyed.")
	
	_show_failure_message()
	
	await get_tree().create_timer(3.0).timeout
	
	# Return to settlement bridge
	if settlement_bridge_scene:
		Engine.get_main_loop().change_scene_to_packed(settlement_bridge_scene)
	else:
		push_error("RaidMission: settlement_bridge_scene is not set! Cannot return to settlement.")


func _show_failure_message() -> void:
	"""Display the mission failure message to the player"""
	var failure_popup = Control.new()
	failure_popup.name = "FailurePopup"
	failure_popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	
	var bg_panel = Panel.new()
	bg_panel.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg_panel.modulate = Color(0, 0, 0, 0.7)
	failure_popup.add_child(bg_panel)
	
	var message_container = VBoxContainer.new()
	message_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	message_container.size = Vector2(300, 150)
	
	var failure_label = Label.new()
	failure_label.text = "RAID FAILED!"
	# ... (rest of label setup)
	message_container.add_child(failure_label)
	
	var subtitle_label = Label.new()
	subtitle_label.text = "All units destroyed"
	# ... (rest of label setup)
	message_container.add_child(subtitle_label)
	
	var return_label = Label.new()
	return_label.text = "Returning to settlement..."
	# ... (rest of label setup)
	message_container.add_child(return_label)
	
	failure_popup.add_child(message_container)
	add_child(failure_popup)
	print("Failure message displayed")

func _on_enemy_hall_destroyed(_building: BaseBuilding = null) -> void:
	"""Called when the enemy's Great Hall is destroyed"""
	print("Enemy Hall destroyed! Mission success!")
	
	var total_loot = raid_loot.get_total_loot()
	raid_loot.add_loot("gold", 200) # Bonus
	total_loot = raid_loot.get_total_loot()
	
	SettlementManager.deposit_resources(total_loot)
	print("Mission Complete! %s" % raid_loot.get_loot_summary())
	
	await get_tree().create_timer(2.0).timeout
	
	if settlement_bridge_scene:
		Engine.get_main_loop().change_scene_to_packed(settlement_bridge_scene)
	else:
		push_error("RaidMission: settlement_bridge_scene is not set! Cannot return to settlement.")

--- SCRIPT: res://scenes/world_map/WorldMap_Stub.gd ---
# res://scenes/world_map/WorldMap_Stub.gd
# World map interface for selecting raid targets
# GDD Ref: Phase 3 Task 6

extends Control

## The main raid mission scene to load (e.g., RaidMission.tscn)
@export var raid_mission_scene: PackedScene

## The scene to return to (e.g., SettlementBridge.tscn)
@export var settlement_bridge_scene: PackedScene

@onready var raid_monastery_button: Button = $ButtonContainer/RaidMonasteryButton
@onready var back_button: Button = $ButtonContainer/BackButton

func _ready() -> void:
	raid_monastery_button.pressed.connect(_on_raid_monastery_pressed)
	back_button.pressed.connect(_on_back_pressed)
	
	# Validate that we can actually raid (have settlement & units)
	_validate_raid_capability()

func _validate_raid_capability() -> void:
	"""Ensure the player can actually start a raid"""
	if not SettlementManager.current_settlement:
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Settlement Loaded"
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Units Available"
		return
	
	raid_monastery_button.disabled = false

func _on_raid_monastery_pressed() -> void:
	"""Launch the raid mission"""
	print("Starting raid on nearby monastery...")
	
	# Additional validation before starting raid
	if not SettlementManager.current_settlement:
		push_error("Cannot start raid: No settlement loaded")
		return
	
	# Transition to raid mission
	if raid_mission_scene:
		get_tree().change_scene_to_packed(raid_mission_scene)
	else:
		push_error("WorldMap_Stub: raid_mission_scene is not set! Cannot start raid.")

func _on_back_pressed() -> void:
	"""Return to the settlement"""
	print("Returning to settlement...")
	if settlement_bridge_scene:
		get_tree().change_scene_to_packed(settlement_bridge_scene)
	else:
		push_error("WorldMap_Stub: settlement_bridge_scene is not set! Cannot return.")

--- SCRIPT: res://scripts/ai/SentryAI.gd ---
# res://scripts/ai/SentryAI.gd
# Simple Sentry AI for enemy defenders in Phase 3
# GDD Ref: Phase 3 - Enemy MVP (Simple Sentry AI)

extends Node2D
class_name SentryAI

@export var detection_radius: float = 80.0
@export var attack_damage: int = 25
@export var attack_cooldown: float = 1.5

var detection_area: Area2D
var attack_timer: float = 0.0
var current_target: Node2D = null

signal enemy_detected(target: Node2D)
signal attack_executed(target: Node2D, damage: int)

func _ready() -> void:
	_setup_detection_area()
	set_process(true)

func _setup_detection_area() -> void:
	"""Create detection area for sentry"""
	detection_area = Area2D.new()
	detection_area.name = "DetectionArea"
	
	var collision_shape = CollisionShape2D.new()
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = detection_radius
	collision_shape.shape = circle_shape
	
	detection_area.add_child(collision_shape)
	add_child(detection_area)
	
	# Connect signals
	detection_area.body_entered.connect(_on_body_entered)
	detection_area.body_exited.connect(_on_body_exited)
	
	# Set collision mask to detect player units (layer 1)
	detection_area.collision_mask = 1

func _process(delta: float) -> void:
	# Update attack timer
	if attack_timer > 0:
		attack_timer -= delta
	
	# Check for and attack valid targets
	if current_target and is_instance_valid(current_target):
		if attack_timer <= 0:
			_attack_target(current_target)
			attack_timer = attack_cooldown
	else:
		current_target = null

func _on_body_entered(body: Node2D) -> void:
	"""Handle detection of player units"""
	if body.is_in_group("player_units") and not current_target:
		current_target = body
		enemy_detected.emit(body)
		print("%s detected enemy: %s" % [get_parent().name, body.name])

func _on_body_exited(body: Node2D) -> void:
	"""Handle player units leaving detection range"""
	if body == current_target:
		current_target = null
		print("%s lost target: %s" % [get_parent().name, body.name])

func _attack_target(target: Node2D) -> void:
	"""Execute attack on target"""
	if not target or not is_instance_valid(target):
		return
	
	# Check if target is still in range
	var distance = global_position.distance_to(target.global_position)
	if distance > detection_radius:
		current_target = null
		return
	
	print("%s attacking %s for %d damage" % [get_parent().name, target.name, attack_damage])
	
	# Apply damage if target has take_damage method
	if target.has_method("take_damage"):
		target.take_damage(attack_damage)
	elif target.has_method("receive_damage"):
		target.receive_damage(attack_damage)
	else:
		# Fallback: just remove the target for demo purposes
		print("Target %s destroyed by sentry attack" % target.name)
		target.queue_free()
	
	attack_executed.emit(target, attack_damage)

func get_detection_radius() -> float:
	"""Get current detection radius"""
	return detection_radius

func set_detection_radius(new_radius: float) -> void:
	"""Update detection radius"""
	detection_radius = new_radius
	if detection_area:
		var collision_shape = detection_area.get_child(0) as CollisionShape2D
		if collision_shape and collision_shape.shape is CircleShape2D:
			collision_shape.shape.radius = detection_radius

func is_actively_defending() -> bool:
	"""Check if sentry is currently engaged with a target"""
	return current_target != null and is_instance_valid(current_target)

--- SCRIPT: res://scripts/ai/UnitFSM.gd ---
# res://scripts/ai/UnitFSM.gd
# Refactored UnitFSM for Phase 3 RTS commands
# GDD Ref: Phase 3 Task 4

class_name UnitFSM

enum State { IDLE, MOVING, ATTACKING }
enum Stance { DEFENSIVE, HOLD_POSITION } # Future-proofed for other stances

# Unit References
var unit: BaseUnit
var attack_timer: Timer

# State Data
var current_state: State = State.IDLE
var stance: Stance = Stance.DEFENSIVE
var path: Array = []

# Target Data
var target_position: Vector2 = Vector2.ZERO
var target_unit: Node2D = null # Can be BaseBuilding or BaseUnit
var move_command_position: Vector2 = Vector2.ZERO

func _init(p_unit: BaseUnit, p_timer: Timer) -> void:
	unit = p_unit
	attack_timer = p_timer
	
	# Connect the timer's timeout signal to our attack function
	attack_timer.timeout.connect(_on_attack_timer_timeout)

func change_state(new_state: State) -> void:
	if current_state == new_state:
		return
	
	_exit_state(current_state)
	current_state = new_state
	# Notify unit visuals of state change
	if unit and unit.has_method("on_state_changed"):
		unit.on_state_changed(current_state)
	_enter_state(current_state)

func _enter_state(state: State) -> void:
	match state:
		State.IDLE:
			print("%s entering IDLE state." % unit.data.display_name)
			unit.velocity = Vector2.ZERO
			
		State.MOVING:
			print("%s entering MOVING state to %s." % [unit.data.display_name, target_position])
			_recalculate_path()
			
		State.ATTACKING:
			print("%s entering ATTACKING state." % unit.data.display_name)
			unit.velocity = Vector2.ZERO
			# Set timer wait time based on unit's attack speed
			attack_timer.wait_time = 1.0 / unit.data.attack_speed
			attack_timer.start()
			# Attack immediately on entering state
			_on_attack_timer_timeout()

func _exit_state(state: State) -> void:
	match state:
		State.MOVING:
			path.clear()
		State.ATTACKING:
			attack_timer.stop()

func _recalculate_path() -> void:
	path = SettlementManager.get_astar_path(unit.global_position, target_position)
	if path.is_empty():
		print("Unit at %s failed to find a path to %s." % [unit.global_position, target_position])
		# Visual error feedback
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		# If we can't find a path, check if we're already close to the target
		if unit.global_position.distance_to(target_position) < (unit.data.attack_range + 16):
			if target_unit:
				change_state(State.ATTACKING)
			else:
				change_state(State.IDLE)
		else:
			change_state(State.IDLE)
	else:
		print("Unit found new path. Waypoints: %d" % path.size())

# --- RTS Command Functions ---

func command_move_to(target_pos: Vector2) -> void:
	"""Command the unit to move to a specific position"""
	target_position = target_pos
	move_command_position = target_pos
	target_unit = null # Clear any attack target
	change_state(State.MOVING)

func command_attack(target: Node2D) -> void:
	"""Command the unit to attack a specific target"""
	print("DEBUG: %s received attack command on target: %s" % [unit.data.display_name, target.name])
	
	if not is_instance_valid(target):
		print("Cannot attack invalid target")
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		return
		
	target_unit = target
	target_position = target.global_position
	
	# Check if we're already in range
	var distance: float = unit.global_position.distance_to(target.global_position)
	print("DEBUG: Current distance to target: %s, attack range: %s" % [distance, unit.data.attack_range])
	
	if distance <= unit.data.attack_range:
		print("DEBUG: Target in range, transitioning to ATTACKING")
		change_state(State.ATTACKING)
	else:
		print("DEBUG: Target out of range, transitioning to MOVING")
		change_state(State.MOVING)

# --- State Machine Update ---

func update(delta: float) -> void:
	match current_state:
		State.IDLE:
			_idle_state(delta)
		State.MOVING:
			_move_state(delta)
		State.ATTACKING:
			_attack_state(delta)

# --- State Logic Functions ---

func _idle_state(_delta: float) -> void:
	# In idle state, unit stands still
	unit.velocity = Vector2.ZERO

func _move_state(delta: float) -> void:
	# First priority: Check if we have a valid attack target and are in range
	if is_instance_valid(target_unit):
		var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
		print("DEBUG MOVE: %s distance to %s: %.1f (range: %.1f)" % [
			unit.data.display_name, 
			target_unit.name, 
			distance_to_target, 
			unit.data.attack_range
		])
		if distance_to_target <= unit.data.attack_range:
			print("Unit in attack range, switching to ATTACKING.")
			change_state(State.ATTACKING)
			return
		else:
			# Update target position if target moved
			target_position = target_unit.global_position
	
	# Handle defensive stance: Check for nearby enemies if being attacked
	if stance == Stance.DEFENSIVE:
		_check_defensive_response()
	
	# If we're not in range, check if our path is empty
	if path.is_empty():
		# If we have an attack target but no path, try to recalculate
		if is_instance_valid(target_unit):
			_recalculate_path()
			return
		else:
			# No target and no path, we've reached our destination
			print("Unit reached destination.")
			change_state(State.IDLE)
			return
	
	# Move along the path
	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	unit.move_and_slide()
	
	# Check if we've reached the current waypoint
	var arrival_radius: float = 8.0 
	if unit.global_position.distance_to(next_waypoint) < arrival_radius:
		path.pop_front()
		
		# If that was the last waypoint, check what to do next
		if path.is_empty():
			if is_instance_valid(target_unit):
				var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
				if distance_to_target <= unit.data.attack_range:
					change_state(State.ATTACKING)
				else:
					# Target moved, recalculate path
					_recalculate_path()
			else:
				# Just a move command, we're done
				change_state(State.IDLE)

func _attack_state(_delta: float) -> void:
	# Debug output for attack state
	print("DEBUG: %s in ATTACKING state - timer running: %s" % [unit.data.display_name, not attack_timer.is_stopped()])
	
	# Check if target is still valid
	if not is_instance_valid(target_unit):
		print("%s target destroyed or invalid. Returning to IDLE." % unit.data.display_name)
		change_state(State.IDLE)
		return
	
	# Check if target moved out of range
	var distance_to_target: float = unit.global_position.distance_to(target_unit.global_position)
	print("DEBUG: Distance to target: %s, Attack range: %s" % [distance_to_target, unit.data.attack_range])
	
	if distance_to_target > unit.data.attack_range + 8: # Reduced buffer to avoid oscillation
		print("%s target moved out of range. Re-engaging." % unit.data.display_name)
		target_position = target_unit.global_position
		change_state(State.MOVING)

func _check_defensive_response() -> void:
	"""Check if unit should respond defensively to being attacked"""
	# This is a placeholder for future implementation
	# In a real implementation, this might check for nearby enemies
	# or respond to damage events
	pass

# --- Signal Callback ---

func _on_attack_timer_timeout() -> void:
	"""Called every time the AttackTimer finishes"""
	if current_state != State.ATTACKING:
		return
		
	if is_instance_valid(target_unit):
		print("%s attacks %s!" % [unit.data.display_name, target_unit.name])
		
		# Check if target has a take_damage method
		if target_unit.has_method("take_damage"):
			target_unit.take_damage(unit.data.attack_damage)
		else:
			print("Target %s does not have take_damage method" % target_unit.name)
	else:
		print("Attack timer fired but no valid target")
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		change_state(State.IDLE)

--- SCRIPT: res://scripts/buildings/SettlementBridge.gd ---
# res://scripts/buildings/SettlementBridge.gd

extends Node

# --- Exported Resources ---
@export var home_base_data: SettlementData
@export var test_building_data: BuildingData
@export var raider_scene: PackedScene
@export var welcome_popup_scene: PackedScene

## The scene for the world map (e.g., WorldMap_Stub.tscn)
@export var world_map_scene: PackedScene

# --- Default Assets (fallback) ---
var default_test_building: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
# --- FIX: Removed preload() to break circular dependency ---
var default_raider_scene: PackedScene 
var default_welcome_popup: PackedScene = preload("res://ui/WelcomeHome_Popup.tscn")

# --- Scene Node References ---
@onready var unit_container: Node2D = $UnitContainer
@onready var ui_layer: CanvasLayer = $UI
@onready var restart_button: Button = $UI/RestartButton
@onready var start_attack_button: Button = $UI/StartAttackButton
@onready var start_raid_button: Button = $UI/StartRaidButton
@onready var storefront_ui: Control = $UI/Storefront_UI
var welcome_popup: PanelContainer

# --- State Variables ---
var great_hall_instance: BaseBuilding = null
var game_is_over: bool = false
const RAIDER_SPAWN_POS: Vector2 = Vector2(50, 50)


func _ready() -> void:
	_setup_default_resources()
	_initialize_settlement()
	_setup_ui()
	_connect_signals()
	_handle_welcome_payout()

func _setup_default_resources() -> void:
	"""Initialize default resources and handle missing inspector assignments"""
	# Setup fallback resources if not set in inspector
	if not test_building_data:
		test_building_data = default_test_building
	
	# Load the default raider scene at runtime to avoid circular dependencies
	if not raider_scene:
		raider_scene = load("res://scenes/units/VikingRaider.tscn")
		
	if not welcome_popup_scene:
		welcome_popup_scene = default_welcome_popup

func _initialize_settlement() -> void:
	"""Initialize or load settlement data"""
	# Use inspector data if available, otherwise create default
	if not home_base_data:
		home_base_data = _create_default_settlement()
		print("SettlementBridge: Created default settlement data")
	else:
		# Verify inspector data is valid
		if not home_base_data is SettlementData:
			push_warning("SettlementBridge: Inspector data is not SettlementData, creating default")
			home_base_data = _create_default_settlement()
		else:
			print("SettlementBridge: Using inspector settlement data")
	
	# Ensure resource path is set for saving
	if home_base_data and (not home_base_data.resource_path or home_base_data.resource_path.is_empty()):
		# Set the resource path based on the expected file name
		home_base_data.resource_path = "res://data/settlements/home_base_fixed.tres"
		print("SettlementBridge: Set resource_path to: %s" % home_base_data.resource_path)
	
	# Load the settlement into the manager
	SettlementManager.load_settlement(home_base_data)
	
	# Let child nodes handle their own initialization via signals
	EventBus.settlement_loaded.emit(home_base_data)

func _create_default_settlement() -> SettlementData:
	"""Create a default settlement with basic resources"""
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 100, "stone": 200}
	var empty_buildings: Array[Dictionary] = []
	settlement.placed_buildings = empty_buildings
	settlement.garrisoned_units = {}
	
	# Set resource path for saving
	settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
	
	return settlement

func _setup_ui() -> void:
	"""Initialize UI components"""
	welcome_popup = welcome_popup_scene.instantiate()
	ui_layer.add_child(welcome_popup)
	welcome_popup.collect_button_pressed.connect(_on_payout_collected)

func _connect_signals() -> void:
	"""Connect button signals"""
	restart_button.pressed.connect(_on_restart_pressed)
	start_attack_button.pressed.connect(_on_start_attack_pressed)
	start_raid_button.pressed.connect(_on_start_raid_pressed)
	
	# Connect to EventBus for loose coupling
	EventBus.settlement_loaded.connect(_on_settlement_loaded)

func _handle_welcome_payout() -> void:
	"""Handle any pending payout when returning to settlement"""
	var payout = SettlementManager.calculate_payout()
	if not payout.is_empty():
		welcome_popup.display_payout(payout)
		start_attack_button.disabled = true # Disable combat until payout is collected
		storefront_ui.hide()

func _on_settlement_loaded(_settlement_data: SettlementData) -> void:
	"""Called when settlement is fully loaded - find and setup buildings"""
	call_deferred("_find_and_setup_great_hall")


func _input(event: InputEvent) -> void:
	# This runs BEFORE GUI input, so we can consume it.
	if event.is_action_pressed("ui_accept"):
		if game_is_over or welcome_popup.visible:
			return # Don't grant loot if game over screen or popup is visible
		
		print("DEBUG: SettlementManager.current_settlement before deposit: ", SettlementManager.current_settlement)
		var sample_loot = {"gold": 100, "wood": 50, "food": 25, "stone": 75}
		print("DEBUG: Granting sample loot via key press.")
		SettlementManager.deposit_resources(sample_loot)
		
		# DEBUG: Ensure storefront UI is visible to see the update
		if not storefront_ui.visible:
			storefront_ui.show()
			print("DEBUG: Showed storefront UI to display updated treasury")
		
		get_viewport().set_input_as_handled() # CRITICAL: Stop event from reaching buttons


func _unhandled_input(event: InputEvent) -> void:
	# This runs AFTER GUI input, so it's safe for non-UI actions like placing buildings.
	if game_is_over or (welcome_popup and welcome_popup.visible):
		return
		
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed():
		if SettlementManager.astar_grid and SettlementManager.astar_grid.cell_size != Vector2.ZERO:
			var mouse_pos: Vector2 = get_viewport().get_mouse_position()
			var grid_pos: Vector2i = Vector2i(mouse_pos / SettlementManager.astar_grid.cell_size)
			SettlementManager.place_building(test_building_data, grid_pos)
			get_viewport().set_input_as_handled()
		else:
			print("Cannot place building: AStarGrid not initialized")



func _on_payout_collected(payout: Dictionary) -> void:
	SettlementManager.deposit_resources(payout)
	start_attack_button.disabled = false # Re-enable combat
	storefront_ui.show()

func _find_and_setup_great_hall() -> void:
	for building in SettlementManager.building_container.get_children():
		if building is BaseBuilding and building.data.display_name == "Great Hall":
			great_hall_instance = building
			great_hall_instance.building_destroyed.connect(_on_great_hall_destroyed)
			print("Great Hall found and connected.")
			return
	push_error("SettlementBridge: Could not find Great Hall instance after loading settlement.")


func _spawn_raider_for_test() -> void:
	if not great_hall_instance:
		push_error("Cannot spawn raider: Great Hall does not exist.")
		return
		
	var raider_instance: BaseUnit = raider_scene.instantiate()
	unit_container.add_child(raider_instance)
	raider_instance.global_position = RAIDER_SPAWN_POS
	raider_instance.set_attack_target(great_hall_instance)


func _on_great_hall_destroyed(_building: BaseBuilding) -> void:
	print("GAME OVER: The Great Hall has been destroyed!")
	game_is_over = true
	var label : Label = $UI/Label
	label.text = "YOU HAVE BEEN SACKED."
	restart_button.show()
	_destroy_all_enemies()

func _destroy_all_enemies() -> void:
	for enemy in unit_container.get_children():
		enemy.queue_free()
	print("All surviving enemies have been removed.")

func _on_restart_pressed() -> void:
	get_tree().reload_current_scene()

func _on_start_attack_pressed() -> void:
	print("Start Attack button pressed. Spawning raider.")
	# Timestamps are no longer needed for a fixed-payout system.
	_spawn_raider_for_test()
	start_attack_button.hide()
	storefront_ui.hide()

func _on_start_raid_pressed() -> void:
	"""Navigate to the world map to select targets"""
	print("Opening world map...")
	
	# Validate that we have a settlement loaded
	if not SettlementManager.current_settlement:
		push_error("Cannot open world map: No settlement loaded")
		return
	
	
	# Ensure we have some units in the garrison for raiding
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		print("Warning: No units in garrison. Adding test unit.")
		# Add a test unit so raids can proceed
		var test_unit_path = "res://data/units/Unit_Raider.tres"
		SettlementManager.current_settlement.garrisoned_units[test_unit_path] = 2
		SettlementManager.save_settlement()
	
	print("Settlement loaded with garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
	
	# Navigate to world map instead of direct raid
	if world_map_scene:
		get_tree().change_scene_to_packed(world_map_scene)
	else:
		# Fallback: load world map directly if not set in inspector
		print("world_map_scene not set, loading WorldMap_Stub directly")
		get_tree().change_scene_to_file("res://scenes/world_map/WorldMap_Stub.tscn")

--- SCRIPT: res://scripts/formations/SquadFormation.gd ---
# res://scripts/formations/SquadFormation.gd
# Squad Formation Manager - Company of Heroes style formations
# Handles formation positioning and movement for multiple units

class_name SquadFormation

enum FormationType {
	LINE,      # Horizontal line formation  
	COLUMN,    # Vertical column formation
	WEDGE,     # V-shaped formation
	BOX,       # Rectangular formation
	CIRCLE     # Circular formation
}

# Formation settings
var formation_type: FormationType = FormationType.LINE
var unit_spacing: float = 40.0
var max_units_per_row: int = 4

# Squad data
var units: Array[Node2D] = []
var leader_position: Vector2 = Vector2.ZERO
var target_position: Vector2 = Vector2.ZERO
var formation_center: Vector2 = Vector2.ZERO

# Movement state
var is_moving: bool = false
var move_speed: float = 100.0

func _init(squad_units: Array[Node2D] = []) -> void:
	units = squad_units
	if not units.is_empty():
		formation_center = _calculate_center_position()

func add_unit(unit: Node2D) -> void:
	"""Add a unit to the squad"""
	if unit not in units:
		units.append(unit)
		_update_formation_positions()

func remove_unit(unit: Node2D) -> void:
	"""Remove a unit from the squad"""
	units.erase(unit)
	_update_formation_positions()

func set_formation_type(new_type: FormationType) -> void:
	"""Change the formation type"""
	formation_type = new_type
	_update_formation_positions()

func move_to_position(target_pos: Vector2) -> void:
	"""Command the entire squad to move to a target position"""
	target_position = target_pos
	is_moving = true
	
	# Calculate formation positions around the target
	var formation_positions = _calculate_formation_positions(target_pos)
	
	# Assign each unit a position in the formation
	for i in range(min(units.size(), formation_positions.size())):
		var unit = units[i]
		var target_formation_pos = formation_positions[i]
		
		# Move the unit to its formation position
		_move_unit_to_position(unit, target_formation_pos)
	
	print("Squad moving to %s in %s formation with %d units" % [target_pos, FormationType.keys()[formation_type], units.size()])

func _calculate_formation_positions(center_pos: Vector2) -> Array[Vector2]:
	"""Calculate formation positions based on formation type"""
	var positions: Array[Vector2] = []
	var unit_count = units.size()
	
	match formation_type:
		FormationType.LINE:
			positions = _calculate_line_formation(center_pos, unit_count)
		FormationType.COLUMN:
			positions = _calculate_column_formation(center_pos, unit_count)
		FormationType.WEDGE:
			positions = _calculate_wedge_formation(center_pos, unit_count)
		FormationType.BOX:
			positions = _calculate_box_formation(center_pos, unit_count)
		FormationType.CIRCLE:
			positions = _calculate_circle_formation(center_pos, unit_count)
	
	return positions

func _calculate_line_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate horizontal line formation positions"""
	var positions: Array[Vector2] = []
	var start_x = center_pos.x - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(start_x + i * unit_spacing, center_pos.y)
		positions.append(pos)
	
	return positions

func _calculate_column_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate vertical column formation positions"""
	var positions: Array[Vector2] = []
	var start_y = center_pos.y - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(center_pos.x, start_y + i * unit_spacing)
		positions.append(pos)
	
	return positions

func _calculate_wedge_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate V-shaped wedge formation positions"""
	var positions: Array[Vector2] = []
	
	# Leader at the front
	positions.append(center_pos)
	
	# Place remaining units in V formation behind the leader
	var side_offset = unit_spacing * 0.7  # 70% spacing for tighter formation
	var rear_offset = unit_spacing
	
	for i in range(1, unit_count):
		var row = (i + 1) / 2  # Which row behind the leader
		var side = 1 if i % 2 == 1 else -1  # Left or right side
		
		var pos = Vector2(
			center_pos.x + side * side_offset * row,
			center_pos.y + rear_offset * row
		)
		positions.append(pos)
	
	return positions

func _calculate_box_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate rectangular box formation positions"""
	var positions: Array[Vector2] = []
	
	var rows = int(ceil(float(unit_count) / max_units_per_row))
	var cols = min(unit_count, max_units_per_row)
	
	var start_x = center_pos.x - (cols - 1) * unit_spacing * 0.5
	var start_y = center_pos.y - (rows - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var row = i / max_units_per_row
		var col = i % max_units_per_row
		
		# Center the last row if it has fewer units
		var row_unit_count = min(max_units_per_row, unit_count - row * max_units_per_row)
		var row_start_x = center_pos.x - (row_unit_count - 1) * unit_spacing * 0.5
		
		var pos = Vector2(
			row_start_x + col * unit_spacing,
			start_y + row * unit_spacing
		)
		positions.append(pos)
	
	return positions

func _calculate_circle_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate circular formation positions"""
	var positions: Array[Vector2] = []
	var radius = max(unit_spacing, unit_count * unit_spacing / (2 * PI))
	
	for i in range(unit_count):
		var angle = (2 * PI * i) / unit_count
		var pos = Vector2(
			center_pos.x + cos(angle) * radius,
			center_pos.y + sin(angle) * radius
		)
		positions.append(pos)
	
	return positions

func _move_unit_to_position(unit: Node2D, target_pos: Vector2) -> void:
	"""Move a specific unit to a target position"""
	if not is_instance_valid(unit):
		return
	
	# Check if unit has FSM (proper unit system)
	if "fsm" in unit and unit.fsm != null:
		unit.fsm.command_move_to(target_pos)
	# Check if unit has direct movement method
	elif unit.has_method("command_move_to"):
		unit.command_move_to(target_pos)
	# Fallback: simple movement for test units
	else:
		_simple_unit_movement(unit, target_pos)

func _simple_unit_movement(unit: Node2D, target_pos: Vector2) -> void:
	"""Simple movement system for test units without FSM"""
	if not unit.has_method("set_target_position"):
		# Add simple movement script to unit if it doesn't have one
		var movement_script = """
var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0
var is_moving: bool = false

func set_target_position(pos: Vector2) -> void:
	target_position = pos
	is_moving = true

func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var direction = (target_position - global_position).normalized()
		var distance = global_position.distance_to(target_position)
		
		if distance < 5.0:
			is_moving = false
			velocity = Vector2.ZERO
		else:
			velocity = direction * move_speed
		
		move_and_slide()
"""
		# Create and attach movement behavior
		var script = GDScript.new()
		script.source_code = unit.get_script().source_code + "\n" + movement_script
		script.reload()
		unit.set_script(script)
	
	# Set the target position
	unit.set_target_position(target_pos)

func _update_formation_positions() -> void:
	"""Update formation positions for current units"""
	if not units.is_empty():
		formation_center = _calculate_center_position()

func _calculate_center_position() -> Vector2:
	"""Calculate the center position of all units"""
	if units.is_empty():
		return Vector2.ZERO
	
	var total_pos = Vector2.ZERO
	for unit in units:
		if is_instance_valid(unit):
			total_pos += unit.global_position
	
	return total_pos / units.size()

func get_unit_count() -> int:
	"""Get the number of units in the squad"""
	return units.size()

func is_squad_moving() -> bool:
	"""Check if the squad is currently moving"""
	return is_moving

func get_formation_info() -> Dictionary:
	"""Get information about the current formation"""
	return {
		"type": FormationType.keys()[formation_type],
		"unit_count": units.size(),
		"spacing": unit_spacing,
		"center": formation_center,
		"is_moving": is_moving
	}

--- SCRIPT: res://scripts/units/Base_Unit.gd ---
# res://scenes/units/Base_Unit.gd
#
# --- MODIFIED: Added AttackTimer reference and visual tweening by state ---

class_name BaseUnit
extends CharacterBody2D

signal destroyed

@export var data: UnitData
var fsm: UnitFSM
var current_health: int = 50

# Node refs
@onready var attack_timer: Timer = $AttackTimer
@onready var sprite: Sprite2D = $Sprite2D

# Color tweening
var _color_tween: Tween
const STATE_COLORS := {
	UnitFSM.State.IDLE: Color(0.3, 0.6, 1.0),     # Blue
	UnitFSM.State.MOVING: Color(0.4, 1.0, 0.4),   # Green
	UnitFSM.State.ATTACKING: Color(1.0, 0.3, 0.3) # Red
}
const ERROR_COLOR := Color(0.7, 0.3, 1.0)        # Purple

func _ready() -> void:
	if not data:
		push_warning("BaseUnit scene is missing its BuildingData resource.")
		return
	
	current_health = data.max_health
	
	# Pass the timer reference to the FSM
	fsm = UnitFSM.new(self, attack_timer)
	
	# Initialize visual to current state color (IDLE by default)
	sprite.modulate = STATE_COLORS.get(UnitFSM.State.IDLE, Color.WHITE)
	
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	if fsm and fsm.current_state == UnitFSM.State.MOVING:
		fsm._recalculate_path()

func _physics_process(delta: float) -> void:
	if fsm:
		fsm.update(delta)
	
	if not fsm or fsm.current_state != UnitFSM.State.MOVING:
		velocity = Vector2.ZERO
		move_and_slide()

# --- Visual State Hooks ---
func on_state_changed(state: UnitFSM.State) -> void:
	var to_color: Color = STATE_COLORS.get(state, Color.WHITE)
	_tween_color(to_color, 0.2)

func flash_error_color() -> void:
	# Quick flash to purple, then return to current state color
	var back_color: Color = STATE_COLORS.get(fsm.current_state, Color.WHITE)
	var t := create_tween()
	t.tween_property(sprite, "modulate", ERROR_COLOR, 0.08).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
	t.tween_property(sprite, "modulate", back_color, 0.18).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func _tween_color(to_color: Color, duration: float = 0.2) -> void:
	if _color_tween and _color_tween.is_running():
		_color_tween.kill()
	_color_tween = create_tween()
	_color_tween.tween_property(sprite, "modulate", to_color, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func take_damage(amount: int) -> void:
	current_health = max(0, current_health - amount)
	print("%s took %d damage, %d HP remaining." % [data.display_name, amount, current_health])
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been killed." % data.display_name)
	destroyed.emit()
	queue_free()

# --- RTS Command Interface ---

func command_move_to(target_pos: Vector2) -> void:
	"""Command this unit to move to a position"""
	if fsm:
		fsm.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	"""Command this unit to attack a target"""
	if fsm:
		fsm.command_attack(target)

# --- Selection System ---

var is_selected: bool = false

func set_selected(selected: bool) -> void:
	"""Set the unit's selection state"""
	is_selected = selected
	
	if is_selected:
		_show_selection_indicator()
		print("%s selected" % data.display_name)
	else:
		_hide_selection_indicator()
		print("%s deselected" % data.display_name)

func _show_selection_indicator() -> void:
	"""Show visual selection indicator"""
	queue_redraw()

func _hide_selection_indicator() -> void:
	"""Hide visual selection indicator"""
	queue_redraw()

func _draw() -> void:
	"""Draw unit-specific visuals"""
	if is_selected:
		# Draw selection circle around the unit
		var radius = 25.0
		var color = Color.YELLOW
		color.a = 0.8
		draw_circle(Vector2.ZERO, radius, color, false, 3.0)

--- SCRIPT: res://scripts/units/EnemyVikingRaider.gd ---
# res://scripts/units/VikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Target position is now adjacent to the Hall ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set the node (for attacking)
	fsm.target_unit = target
	
	# --- THIS IS THE FIX ---
	# Set the position (for moving) to be one tile *below*
	# the Hall's center. This is a walkable tile, so
	# pathfinding will succeed.
	fsm.target_position = target.global_position + Vector2(0, 32)
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVING)
	print("Viking Raider initialized and moving to target: %s" % target.data.display_name)

--- SCRIPT: res://scripts/units/PlayerVikingRaider.gd ---
# res://scripts/units/PlayerVikingRaider.gd
#
# Player-controlled Viking Raider unit with full RTS integration.
# Extends BaseUnit to inherit all core unit functionality and adds
# player-specific behaviors for selection, command, and group management.

extends BaseUnit
class_name PlayerVikingRaider

func _ready() -> void:
	# Call parent _ready first to initialize base unit systems
	super._ready()
	
	# Add to player units group for RTS selection and control
	add_to_group("player_units")
	
	# Initialize player-specific behaviors
	_setup_player_behaviors()
	
	print("PlayerVikingRaider '%s' initialized and ready for RTS control" % name)

func _setup_player_behaviors() -> void:
	"""Initialize player-specific unit behaviors and properties"""
	# Ensure the unit can be selected and commanded
	# The BaseUnit already provides the necessary methods:
	# - command_move_to()
	# - command_attack() 
	# - set_selected()
	
	# Set any player-specific properties
	if data:
		print("Player Viking Raider ready: %s (Health: %d)" % [data.display_name, current_health])

# Override command methods to add player-specific feedback and behavior
func command_move_to(target_pos: Vector2) -> void:
	"""Enhanced move command with player feedback"""
	print("Player Viking Raider '%s' moving to position %s" % [name, target_pos])
	super.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	"""Enhanced attack command with player feedback"""
	if not fsm or not is_instance_valid(target):
		push_warning("Player Raider FSM or target is not valid.")
		return

	print("Player Viking Raider '%s' attacking %s" % [name, target.name])

	# --- Logic copied from EnemyVikingRaider ---
	# Set the node (for attacking)
	fsm.target_unit = target
	
	# Set the position (for moving) to be adjacent to the target
	# This ensures pathfinding can succeed. Adjust offset as needed.
	fsm.target_position = target.global_position + Vector2(0, 32) 
	
	# Start the FSM
	fsm.change_state(UnitFSM.State.MOVING)
	# ---------------------------------------------

# Override selection methods to provide enhanced player feedback
func set_selected(selected: bool) -> void:
	"""Enhanced selection with player-specific visual feedback"""
	super.set_selected(selected)
	
	if selected:
		# Could add player-specific selection effects here
		# e.g., special sound effects, enhanced visual indicators
		pass
	else:
		# Handle deselection
		pass

# Player-specific utility methods
func get_unit_status() -> Dictionary:
	"""Get comprehensive unit status for UI display"""
	return {
		"name": name,
		"display_name": data.display_name if data else "Unknown",
		"health": current_health,
		"max_health": data.max_health if data else 100,
		"is_selected": is_selected,
		"current_state": fsm.current_state if fsm else "None",
		"position": global_position
	}

func is_player_controlled() -> bool:
	"""Identify this as a player-controlled unit"""
	return true

# Override die method to handle player unit death
func die() -> void:
	"""Handle player unit death with proper cleanup"""
	# Remove from player units group
	remove_from_group("player_units")
	
	# Notify other systems about unit death
	EventBus.emit_signal("player_unit_died", self)
	
	print("Player Viking Raider '%s' has fallen in battle!" % name)
	
	# Call parent die method
	super.die()

--- SCRIPT: res://test_phase3.gd ---
# Test script for Phase 3 functionality
extends Node

func _ready():
	print("=== PHASE 3 TEST STARTING ===")
	test_garrison_system()
	test_raid_system()

func test_garrison_system():
	print("\n--- Testing Garrison System (Pillar 1) ---")
	if SettlementManager.current_settlement:
		print("Current treasury: %s" % SettlementManager.current_settlement.treasury)
		print("Current garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
		
		# Test unit recruitment
		var player_unit_data = load("res://data/units/Unit_PlayerRaider.tres") as UnitData
		if player_unit_data:
			print("Found player unit data: %s" % player_unit_data.display_name)
			print("Unit spawn cost: %s" % player_unit_data.spawn_cost)
			
			# Try to recruit one unit
			if SettlementManager.attempt_purchase(player_unit_data.spawn_cost):
				SettlementManager.recruit_unit(player_unit_data)
				print("Successfully recruited %s!" % player_unit_data.display_name)
			else:
				print("Cannot afford to recruit %s" % player_unit_data.display_name)
		else:
			print("ERROR: Could not load player unit data")
	else:
		print("ERROR: No settlement loaded")

func test_raid_system():
	print("\n--- Testing Raid System (Pillar 3) ---")
	if SettlementManager.current_settlement:
		var garrison = SettlementManager.current_settlement.garrisoned_units
		if not garrison.is_empty():
			print("Garrison ready for raid with %d unit types" % garrison.size())
			var total_units = 0
			for unit_path in garrison:
				total_units += garrison[unit_path]
			print("Total units available: %d" % total_units)
			print("Phase 3 raid system ready!")
		else:
			print("No units in garrison - cannot start raid")
	else:
		print("ERROR: No settlement loaded")
	
	print("\n=== PHASE 3 TEST COMPLETE ===")

--- SCRIPT: res://tools/EnemyBaseEditor.gd ---
@tool
extends EditorScript

# Simple Enemy Base Layout Editor
# Usage: Tools -> Execute Script to run this

func _run():
	print("=== ENEMY BASE LAYOUT EDITOR ===")
	
	var settlement_path = "res://data/settlements/monastery_base.tres"
	var settlement_data: SettlementData = load(settlement_path)
	
	if not settlement_data:
		print("ERROR: Could not load settlement data!")
		return
	
	print("Current layout for: " + settlement_path)
	print("Grid positions (format: Building @ X,Y):")
	print("-".repeat(40))
	
	for i in range(settlement_data.placed_buildings.size()):
		var building = settlement_data.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("-".repeat(40))
	print("To modify layout:")
	print("1. Edit grid_position values in the .tres file")
	print("2. Or use this script to create new layouts")
	print("3. Grid range: 0-%d (width), 0-%d (height)" % [
		SettlementManager.grid_width-1, 
		SettlementManager.grid_height-1
	])

# Helper function to create new enemy base layouts
static func create_enemy_base_layout(buildings: Array[Dictionary], save_path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 500, "wood": 200, "food": 150, "stone": 100}
	settlement.placed_buildings = buildings
	
	ResourceSaver.save(settlement, save_path)
	print("Created new enemy base: " + save_path)

# Example usage:
# EnemyBaseEditor.create_fortress_layout()
static func create_fortress_layout():
	var buildings = [
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(32, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	create_enemy_base_layout(buildings, "res://data/settlements/fortress_base.tres")

--- SCRIPT: res://ui/SelectionBox.gd ---
# res://ui/SelectionBox.gd
# This Control node covers the entire screen. It listens for
# raw input, draws the selection box, and emits clean,
# intent-based signals to the EventBus. It also uses
# accept_event() to stop input from passing through the UI.
extends Control

var is_dragging := false
var start_pos := Vector2.ZERO

func _ready() -> void:
	# This node handles its own input via _gui_input,
	# so it doesn't need to connect to the EventRouter.
	pass

func _gui_input(event: InputEvent) -> void:
	# We use _gui_input, which is only called if the mouse
	# is over this Control. Since it's fullscreen,
	# this will always be the case.
	
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.is_pressed():
				is_dragging = true
				start_pos = get_local_mouse_position()
				# This is the UI-bug-fix. We consume the
				# event so nothing else can process it.
				accept_event()
			elif is_dragging: # On Left-Click Release
				is_dragging = false
				var end_pos := get_local_mouse_position()
				var rect := Rect2(start_pos, end_pos - start_pos).abs()
				
				# Check if it was a "drag" or just a "click"
				# A 'click' is a box with a very small area.
				var is_box_select = rect.size.length_squared() > 100 # 10x10 px
				
				# Emit the clean command for the RTSController
				EventBus.emit_signal("select_command", rect, is_box_select)
				
				queue_redraw() # Clear the box
				accept_event()
		
		elif event.button_index == MOUSE_BUTTON_RIGHT and event.is_pressed():
			# This is a "smart command"
			_handle_smart_command(get_local_mouse_position())
			accept_event()
	
	elif event is InputEventMouseMotion and is_dragging:
		# Update the draw loop as the mouse moves
		queue_redraw()
		accept_event()

func _handle_smart_command(screen_pos: Vector2) -> void:
	# This function determines if a right-click
	# is a "move" or "attack" command.
	var world_space: PhysicsDirectSpaceState2D = get_world_2d().direct_space_state
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	
	if not main_camera:
		push_error("SelectionBox: No Camera2D found in viewport.")
		return
		
	# Convert screen position to world position
	var world_pos: Vector2 = main_camera.get_global_mouse_position()
	
	var query := PhysicsPointQueryParameters2D.new()
	query.position = world_pos
	query.collide_with_areas = true
	query.collide_with_bodies = true
	# We only want to hit "enemy" things
	# GDD: "right-click is the 'smart' command (move on ground, attack on enemy)"
	# We assume layer 2 is "enemy_units" and layer 3 is "enemy_buildings"
	query.collision_mask = 6 # (Binary 0110 = Layers 2 and 3)
	
	var results: Array = world_space.intersect_point(query)
	
	if not results.is_empty():
		# We hit an enemy! Emit an attack command.
		var target = results[0].collider
		EventBus.emit_signal("attack_command", target)
	else:
		# We hit the ground. Emit a move command.
		EventBus.emit_signal("move_command", world_pos)

func _draw() -> void:
	# This function draws the selection box
	if is_dragging:
		var current_pos := get_local_mouse_position()
		var rect := Rect2(start_pos, current_pos - start_pos).abs()
		
		# Draw a semi-transparent fill
		draw_rect(rect, Color(0.8, 0.8, 1.0, 0.2), true)
		# Draw a solid outline
		draw_rect(rect, Color(0.8, 0.8, 1.0, 1.0), false, 1.0)

--- SCRIPT: res://ui/StorefrontUI.gd ---
# res://ui/StorefrontUI.gd
extends Control

# --- Node References ---
@onready var gold_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/GoldLabel
@onready var wood_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/WoodLabel
@onready var food_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/FoodLabel
@onready var stone_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/StoneLabel
@onready var buy_wall_button: Button = $PanelContainer/MarginContainer/TabContainer/BuildTab/BuildButtons/BuyWallButton
@onready var buy_lumber_yard_button: Button = $PanelContainer/MarginContainer/TabContainer/BuildTab/BuildButtons/BuyLumberYardButton
@onready var recruit_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/RecruitButtons
@onready var garrison_list_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/GarrisonList

# --- Exported Data ---
@export var available_buildings: Array[BuildingData] = []
@export var available_units: Array[UnitData] = []
@export var default_treasury_display: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}
@export var auto_load_units_from_directory: bool = true

# Legacy data (kept for fallback)
var wall_data: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
var lumber_yard_data: BuildingData = preload("res://data/buildings/LumberYard.tres")

func _ready() -> void:
	EventBus.treasury_updated.connect(_update_treasury_display)
	EventBus.purchase_successful.connect(_on_purchase_successful)
	
	if SettlementManager.current_settlement:
		_update_treasury_display(SettlementManager.current_settlement.treasury)
	else:
		_update_treasury_display(default_treasury_display)

	buy_wall_button.pressed.connect(_on_buy_button_pressed.bind(wall_data))
	buy_lumber_yard_button.pressed.connect(_on_buy_button_pressed.bind(lumber_yard_data))
	
	# Load and setup recruit buttons
	_load_unit_data()
	_setup_recruit_buttons()
	_update_garrison_display()

func _load_unit_data() -> void:
	"""Scan res://data/units/ directory for .tres files and load them as UnitData"""
	var dir = DirAccess.open("res://data/units/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var unit_path = "res://data/units/" + file_name
				var unit_data = load(unit_path) as UnitData
				if unit_data:
					# Only load player-appropriate units (exclude enemy-only units)
					# Player units should have "Player" in their display name or specific naming convention
					if _is_player_unit(unit_data):
						available_units.append(unit_data)
						print("Loaded player unit data: %s" % unit_data.display_name)
					else:
						print("Skipped enemy unit data: %s" % unit_data.display_name)
			file_name = dir.get_next()
		print("Total player units loaded: %d" % available_units.size())

func _setup_recruit_buttons() -> void:
	"""Create recruit buttons for each available unit"""
	for unit_data in available_units:
		var button = Button.new()
		button.text = "%s (Cost: %s)" % [unit_data.display_name, _format_cost(unit_data.spawn_cost)]
		button.custom_minimum_size = Vector2(200, 36)
		button.pressed.connect(_on_recruit_button_pressed.bind(unit_data))
		recruit_buttons_container.add_child(button)

func _is_player_unit(unit_data: UnitData) -> bool:
	"""Check if a unit is appropriate for player recruitment"""
	if not unit_data:
		return false
	
	# Check if the unit has "Player" in its display name
	if "Player" in unit_data.display_name:
		return true
	
	# Check if the unit data resource path contains "Player" 
	if "Player" in unit_data.resource_path:
		return true
	
	# Check if the scene points to a PlayerVikingRaider or other player unit
	if unit_data.scene_to_spawn:
		var scene_path = unit_data.scene_to_spawn.resource_path
		if "Player" in scene_path:
			return true
	
	# Fallback: exclude known enemy units by name
	var enemy_unit_names = ["Viking Raider"] # This is the enemy version
	if unit_data.display_name in enemy_unit_names:
		return false
	
	# Default to true for backwards compatibility with existing units
	return true

func _format_cost(cost: Dictionary) -> String:
	"""Format cost dictionary as readable string"""
	var cost_parts: Array[String] = []
	for resource in cost:
		cost_parts.append("%d %s" % [cost[resource], resource])
	return ", ".join(cost_parts)

func _get_safe_placement_position() -> Vector2i:
	"""Find a safe position to place a building, avoiding overlaps"""
	if not SettlementManager.current_settlement:
		return Vector2i(10, 15) # Fallback position
	
	# Get grid bounds from SettlementManager
	var grid_width = SettlementManager.grid_width
	var grid_height = SettlementManager.grid_height
	
	# Create a set of occupied positions for quick lookup
	var occupied_positions: Array[Vector2i] = []
	for building_entry in SettlementManager.current_settlement.placed_buildings:
		occupied_positions.append(building_entry["grid_position"])
	
	# Find the first available position using a spiral search pattern
	var center_x = grid_width / 2
	var center_y = grid_height / 2
	var max_radius = min(grid_width, grid_height) / 2
	
	# Start from center and spiral outward
	for radius in range(1, max_radius + 1):
		for angle_step in range(8 * radius): # More points for larger radii
			var angle = (angle_step * 2.0 * PI) / (8 * radius)
			var test_x = center_x + int(radius * cos(angle))
			var test_y = center_y + int(radius * sin(angle))
			var test_pos = Vector2i(test_x, test_y)
			
			# Check bounds
			if test_pos.x < 0 or test_pos.x >= grid_width or test_pos.y < 0 or test_pos.y >= grid_height:
				continue
			
			# Check if position is free
			if not test_pos in occupied_positions:
				print("Found safe placement position: %s" % test_pos)
				return test_pos
	
	# If no free position found, use a fallback with warning
	push_warning("No free placement position found, using fallback")
	return Vector2i(10, 15)

func _update_treasury_display(new_treasury: Dictionary) -> void:
	gold_label.text = "Gold: %d" % new_treasury.get("gold", 0)
	wood_label.text = "Wood: %d" % new_treasury.get("wood", 0)
	food_label.text = "Food: %d" % new_treasury.get("food", 0)
	stone_label.text = "Stone: %d" % new_treasury.get("stone", 0)

func _on_buy_button_pressed(item_data: BuildingData) -> void:
	if not item_data:
		return
	
	print("UI attempting to purchase '%s'." % item_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(item_data.build_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % item_data.display_name)
		var placement_pos = _get_safe_placement_position()
		var new_building = SettlementManager.place_building(item_data, placement_pos)
		
		if new_building and SettlementManager.current_settlement:
			var building_entry = {
				"resource_path": item_data.resource_path,
				"grid_position": placement_pos
			}
			SettlementManager.current_settlement.placed_buildings.append(building_entry)
			print("Added %s to persistent settlement data at %s." % [item_data.display_name, placement_pos])
			SettlementManager.save_settlement()
	else:
		print("UI received purchase failure for '%s'." % item_data.display_name)

func _on_recruit_button_pressed(unit_data: UnitData) -> void:
	"""Handle recruit button press"""
	if not unit_data:
		return
	
	print("UI attempting to recruit '%s'." % unit_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(unit_data.spawn_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % unit_data.display_name)
		SettlementManager.recruit_unit(unit_data)
	else:
		print("UI received purchase failure for '%s'." % unit_data.display_name)

func _on_purchase_successful(item_name: String) -> void:
	"""Handle purchase success event - refresh garrison display"""
	_update_garrison_display()

func _update_garrison_display() -> void:
	"""Update the garrison list display with current garrisoned units"""
	if not garrison_list_container:
		return
	
	# Clear existing display
	for child in garrison_list_container.get_children():
		child.queue_free()
	
	if not SettlementManager.current_settlement:
		var no_settlement_label = Label.new()
		no_settlement_label.text = "No settlement loaded"
		garrison_list_container.add_child(no_settlement_label)
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	
	if garrison.is_empty():
		var empty_garrison_label = Label.new()
		empty_garrison_label.text = "No units in garrison"
		garrison_list_container.add_child(empty_garrison_label)
		return
	
	# Add header
	var header_label = Label.new()
	header_label.text = "Current Garrison:"
	header_label.add_theme_font_size_override("font_size", 16)
	garrison_list_container.add_child(header_label)
	
	# Display each unit type and count
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if unit_data:
			var unit_label = Label.new()
			unit_label.text = "‚Ä¢ %s x%d" % [unit_data.display_name, unit_count]
			garrison_list_container.add_child(unit_label)
		else:
			var error_label = Label.new()
			error_label.text = "‚Ä¢ Unknown unit x%d" % unit_count
			garrison_list_container.add_child(error_label)
	
	# Add total count
	var total_units = 0
	for unit_path in garrison:
		total_units += garrison[unit_path]
	
	var total_label = Label.new()
	total_label.text = "Total units: %d" % total_units
	total_label.add_theme_font_size_override("font_size", 12)
	garrison_list_container.add_child(total_label)

--- SCRIPT: res://ui/WelcomeHomePopup.gd ---
# res://ui/WelcomeHomePopup.gd
extends PanelContainer

signal collect_button_pressed(payout: Dictionary)

@onready var payout_label: Label = $MarginContainer/VBoxContainer/PayoutLabel
@onready var collect_button: Button = $MarginContainer/VBoxContainer/CollectButton

var _current_payout: Dictionary = {}

func _ready() -> void:
	collect_button.pressed.connect(_on_collect_pressed)
	hide()

func display_payout(payout: Dictionary) -> void:
	if payout.is_empty():
		return

	_current_payout = payout
	var payout_text: String = "Welcome home!\n\nResources gathered:\n"
	for resource_type in payout:
		payout_text += "- %s: %d\n" % [resource_type.capitalize(), payout[resource_type]]
	
	payout_label.text = payout_text
	show()

func _on_collect_pressed() -> void:
	collect_button_pressed.emit(_current_payout)
	hide()
--- END OF CODEBASE ---

---
