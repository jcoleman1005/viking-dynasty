### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. Project Context`**: The technical project dump, including:
    *   `2.1. Project Settings`
    *   `2.2. Resource Files`
    *   `2.3. Scene Structures`
    *   `2.4. Codebase`

---
### **2. Project Context**

#### **2.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Viking Dynasty"
run/main_scene="uid://c53k15q2w8c1a"
config/features=PackedStringArray("4.5", "GL Compatibility")

[autoload]

EventBus="*res://autoload/EventBus.gd"
SettlementManager="*res://autoload/SettlementManager.gd"
PauseManager="*res://autoload/PauseManager.tscn"
DynastyManager="*res://autoload/DynastyManager.gd"
SceneManager="*res://autoload/SceneManager.tscn"
EventManager="*res://autoload/EventManager.tscn"
ProjectilePoolManager="*res://autoload/ProjectilePoolManager.gd"

[editor]

naming/scene_name_casing=1
naming/script_name_casing=1

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg")

[input]

debug_time_travel="{\"deadzone\": 0.5, \"events\": [{\"physical_keycode\": 84, \"type\": \"key\"}]}"
ui_pause={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="Environment"
2d_physics/layer_2="Player_Units"
2d_physics/layer_3="Enemy_Units"
2d_physics/layer_4="Enemy_Buildings"

[plugins]

enemy_base_editor/enabled=true
--- END OF PROJECT SETTINGS ---

#### **2.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://assets/placeholder_tile.tres ---
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://c6v2d1q8q7e3j"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_cemhj"]
noise_type = 2
frequency = 0.1153

[resource]
width = 100
height = 100
noise = SubResource("FastNoiseLite_cemhj")

--- RESOURCE: res://data/buildings/Bldg_Wall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=4 format=3 uid="uid://b2356vlfukf14"]

[ext_resource type="Texture2D" uid="uid://csni4uyao275g" path="res://textures/placeholders/wall_stone_texture.png" id="1_n45a8"]
[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_t76rl"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="1_vluf5"]

[resource]
script = ExtResource("1_t76rl")
display_name = "Stone Wall"
scene_to_spawn = ExtResource("1_vluf5")
building_texture = ExtResource("1_n45a8")
build_cost = {
"stone": 25
}
dev_color = Color(0.4, 0.4, 0.8, 1)
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/GreatHall.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bs1e1mgqnldwq"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Great Hall"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 100,
"wood": 250
}
max_health = 50
grid_size = Vector2i(4, 4)
is_player_buildable = true

--- RESOURCE: res://data/buildings/LumberYard.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://drx4sih8numo1"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="Texture2D" uid="uid://cvtmpipin3j4" path="res://textures/placeholders/lumber_mill_placeholder.png" id="1_plclm"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
fixed_payout_amount = 50
display_name = "Lumber Yard"
scene_to_spawn = ExtResource("2_fghij")
building_texture = ExtResource("1_plclm")
build_cost = {
"wood": 50
}
max_health = 75
grid_size = Vector2i(2, 2)
is_player_buildable = true

--- RESOURCE: res://data/buildings/Monastery_Chapel.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b7p70u4vm3uem"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 25
storage_cap = 200
display_name = "Monastery Chapel"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 100,
"stone": 80,
"wood": 40
}
max_health = 120
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Granary.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bscr3flprg5ts"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "food"
fixed_payout_amount = 20
storage_cap = 300
display_name = "Monastery Granary"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 60,
"stone": 40,
"wood": 100
}
max_health = 90
grid_size = Vector2i(2, 3)

--- RESOURCE: res://data/buildings/Monastery_Library.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://bfb0hbf1m2lgf"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 35
storage_cap = 250
display_name = "Monastery Library"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 150,
"stone": 60,
"wood": 80
}
max_health = 80
grid_size = Vector2i(3, 2)

--- RESOURCE: res://data/buildings/Monastery_Scriptorium.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=3 format=3 uid="uid://b6dkpjrewc1q6"]

[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="1_abcde"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_fghij"]

[resource]
script = ExtResource("1_abcde")
resource_type = "gold"
fixed_payout_amount = 30
storage_cap = 180
display_name = "Monastery Scriptorium"
scene_to_spawn = ExtResource("2_fghij")
build_cost = {
"gold": 120,
"stone": 30,
"wood": 90
}
max_health = 70
grid_size = Vector2i(2, 2)

--- RESOURCE: res://data/buildings/Monastery_Watchtower.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=5 format=3 uid="uid://ckedcnw210a8k"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]
[ext_resource type="PackedScene" path="res://scenes/components/AttackAI.tscn" id="3_ai"]
[ext_resource type="PackedScene" path="res://scenes/effects/Projectile.tscn" id="4_proj"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Monastery Watchtower"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"gold": 80,
"stone": 120,
"wood": 60
}
max_health = 150
dev_color = Color(0.8, 0.2, 0.2, 1)
is_defensive_structure = true
attack_damage = 15
attack_range = 250.0
attack_speed = 1.5
ai_component_scene = ExtResource("3_ai")
projectile_scene = ExtResource("4_proj")
projectile_speed = 500.0

--- RESOURCE: res://data/buildings/Player_Barracks.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=4 format=3 uid="uid://c0ih7mriv2h1g"]

[ext_resource type="Texture2D" uid="uid://csni4uyao275g" path="res://textures/placeholders/wall_stone_texture.png" id="1_e5dmt"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_n2ory"]
[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="3_yutc8"]

[resource]
script = ExtResource("3_yutc8")
display_name = "Barracks"
scene_to_spawn = ExtResource("2_n2ory")
building_texture = ExtResource("1_e5dmt")
build_cost = {
"stone": 50,
"wood": 100
}
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/buildings/Player_Farm.tres ---
[gd_resource type="Resource" script_class="EconomicBuildingData" load_steps=4 format=3 uid="uid://y7xhmemltm28"]

[ext_resource type="Texture2D" uid="uid://cvtmpipin3j4" path="res://textures/placeholders/lumber_mill_placeholder.png" id="1_lr1ah"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_mixjq"]
[ext_resource type="Script" uid="uid://d33smw07vm6y4" path="res://data/buildings/EconomicBuildingData.gd" id="3_svyis"]

[resource]
script = ExtResource("3_svyis")
resource_type = "food"
fixed_payout_amount = 75
display_name = "Farm"
scene_to_spawn = ExtResource("2_mixjq")
building_texture = ExtResource("1_lr1ah")
build_cost = {
"wood": 75
}
max_health = 75
grid_size = Vector2i(2, 2)
dev_color = Color(0.2, 0.8, 0.2, 1)
is_player_buildable = true

--- RESOURCE: res://data/buildings/Test_Large_Building.tres ---
[gd_resource type="Resource" script_class="BuildingData" load_steps=3 format=3 uid="uid://bk4qd2jfm3kgp"]

[ext_resource type="Script" uid="uid://js4bbqgeyd6c" path="res://data/buildings/BuildingData.gd" id="1_i2pmy"]
[ext_resource type="PackedScene" uid="uid://cws6xle5x52g4" path="res://scenes/buildings/Base_Building.tscn" id="2_hptna"]

[resource]
script = ExtResource("1_i2pmy")
display_name = "Large Test Building"
scene_to_spawn = ExtResource("2_hptna")
build_cost = {
"wood": 100
}
max_health = 200
grid_size = Vector2i(3, 3)
dev_color = Color(0.8, 0.6, 0.2, 1)
is_player_buildable = true
attack_damage = 0
attack_range = 0.0
attack_speed = 0.0

--- RESOURCE: res://data/characters/heirs/Ragnar.tres ---
[gd_resource type="Resource" format=3 uid="uid://c2ilgcmlp12pb"]

[resource]
metadata/_custom_type_script = "uid://cql5qpafvywy1"

--- RESOURCE: res://data/characters/heirs/TestHeir.tres ---
[gd_resource type="Resource" script_class="JarlHeirData" load_steps=2 format=3 uid="uid://dgxbmto5mqee5"]

[ext_resource type="Script" uid="uid://cql5qpafvywy1" path="res://data/characters/JarlHeirData.gd" id="1_iui4g"]

[resource]
script = ExtResource("1_iui4g")
display_name = "Ragnar (Test)"
metadata/_custom_type_script = "uid://cql5qpafvywy1"

--- RESOURCE: res://data/characters/PlayerJarl.tres ---
[gd_resource type="Resource" script_class="JarlData" load_steps=7 format=3]

[ext_resource type="Script" path="res://data/characters/JarlHeirData.gd" id="1_4gouw"]
[ext_resource type="Script" path="res://data/characters/JarlData.gd" id="1_jarl_data"]
[ext_resource type="Resource" path="res://data/characters/heirs/TestHeir.tres" id="2_0bn2j"]
[ext_resource type="Resource" path="res://data/traits/Trait_Pious.tres" id="2_pious_trait"]
[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="3_0bn2j"]
[ext_resource type="Resource" path="res://data/traits/Trait_Ambitious.tres" id="4_ambitious_trait"]

[resource]
script = ExtResource("1_jarl_data")
display_name = "Bjorn"
age = 30
renown = 25
legitimacy = 30
allied_regions = Array[String](["res://data/world_map/Region_Monastery.tres"])
command = 12
stewardship = 11
learning = 9
prowess = 14
traits = Array[ExtResource("3_0bn2j")]([ExtResource("2_pious_trait"), ExtResource("4_ambitious_trait")])
spouse_name = "Lagertha"
heirs = Array[ExtResource("1_4gouw")]([ExtResource("2_0bn2j")])
battles_fought = 2
battles_won = 2
successful_raids = 2
metadata/_custom_type_script = "uid://bm8qe8d38a1il"

--- RESOURCE: res://data/events/ambitious_heir.tres ---
[gd_resource type="Resource" script_class="EventData" load_steps=5 format=3 uid="uid://ddjwe73h3diq5"]

[ext_resource type="Script" uid="uid://c7lxr02yr1fn6" path="res://data/events/EventData.gd" id="1_event_data"]
[ext_resource type="Script" uid="uid://dvc7gumtvwaal" path="res://data/events/EventChoice.gd" id="2_event_choice"]

[sub_resource type="Resource" id="EventChoice_accept"]
script = ExtResource("2_event_choice")
choice_text = "Here is 100 Renown. Bring us glory!"
tooltip_text = "Spend 100 Renown."
effect_key = "accept"

[sub_resource type="Resource" id="EventChoice_decline"]
script = ExtResource("2_event_choice")
choice_text = "We cannot spare it. Be patient."
tooltip_text = "Your heir will be displeased and gain the 'Rival' trait."
effect_key = "decline"

[resource]
script = ExtResource("1_event_data")
title = "An Ambitious Heir"
description = "Your heir, Ragnar, approaches you. \"My Jarl, I am bored! I wish to lead an expedition to prove my worth. Please fund it so I may bring glory to our dynasty!\""
event_id = "ambitious_heir_1"
base_chance = 1.0
must_have_trait = "Ambitious"
min_available_heirs = 1
choices = Array[ExtResource("2_event_choice")]([SubResource("EventChoice_accept"), SubResource("EventChoice_decline")])
metadata/_custom_type_script = "uid://c7lxr02yr1fn6"

--- RESOURCE: res://data/legacy/JellingStone.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_jelling"]

[resource]
script = ExtResource("1_jelling")
display_name = "Erect Jelling Stone"
description = "Commission a great rune stone to proclaim your dynasty's glory. All future heirs will begin their rule with bonus Renown."
renown_cost = 200
authority_cost = 2
effect_key = "UPG_JELLING_STONE"
prerequisite_key = ""

--- RESOURCE: res://data/legacy/TrelleborgFortress.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_trelleborg"]

[resource]
script = ExtResource("1_trelleborg")
display_name = "Upgrade Trelleborg"
description = "Invest in the Trelleborg's defenses, permanently increasing the max garrison size for your home settlement."
renown_cost = 100
authority_cost = 3
effect_key = "UPG_TRELLEBORG"
prerequisite_key = ""

--- RESOURCE: res://data/legacy/Upg_BuildChapel.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3 uid="uid://c4qpn4hvsgkvh"]

[ext_resource type="Script" uid="uid://bot3rirdcml6f" path="res://data/legacy/LegacyUpgradeData.gd" id="1_chapel"]

[resource]
script = ExtResource("1_chapel")
display_name = "Build Chapel"
description = "Erect a small chapel, honoring the gods and securing their favor for your dynasty."
renown_cost = 50
effect_key = "UPG_BUILD_CHAPEL"
metadata/_custom_type_script = "uid://bot3rirdcml6f"

--- RESOURCE: res://data/legacy/VikingLongships.tres ---
[gd_resource type="Resource" script_class="LegacyUpgradeData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/legacy/LegacyUpgradeData.gd" id="1_longships"]

[resource]
script = ExtResource("1_longships")
display_name = "Viking Longships"
description = "Improve shipbuilding techniques, allowing for faster raids and more loot."
renown_cost = 150
authority_cost = 1
effect_key = "UPG_LONGSHIPS"
prerequisite_key = ""

--- RESOURCE: res://data/settlements/economic_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://chtd3i4qtdv31"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_e06fl"]

[resource]
script = ExtResource("1_e06fl")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 8),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(8, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(10, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/fortress_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c2nrib7nroeas"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 150,
"gold": 1200,
"stone": 500,
"wood": 600
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(6, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 6),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 14),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 5),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 8
}

--- RESOURCE: res://data/settlements/home_base_fixed.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://1dnknjyrfvxe"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 6723,
"gold": 10920,
"stone": 450,
"wood": 11704
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(11, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(11, 17),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(17, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(20, 7),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(15, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(22, 7),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(22, 9),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(20, 9),
"resource_path": "res://data/buildings/Player_Farm.tres"
}, {
"grid_position": Vector2i(20, 5),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(22, 5),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(20, 3),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(22, 3),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(8, 5),
"resource_path": "res://data/buildings/Player_Barracks.tres"
}, {
"grid_position": Vector2i(17, 12),
"resource_path": "res://data/buildings/Test_Large_Building.tres"
}, {
"grid_position": Vector2i(24, 13),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(19, 0),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(20, 0),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(16, 7),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 15
}
metadata/_custom_type_script = "uid://hlb8s5g0yp6k"

--- RESOURCE: res://data/settlements/monastery_base.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://okf2novkg804"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_pnvr3"]

[resource]
script = ExtResource("1_pnvr3")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(8, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(5, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 15),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/monastery_layout.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://6kk36f5nlwns"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_settlement_data"]

[resource]
script = ExtResource("1_settlement_data")
treasury = {
"food": 300,
"gold": 800,
"stone": 200,
"wood": 400
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(10, 10),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(8, 7),
"resource_path": "res://data/buildings/Monastery_Chapel.tres"
}, {
"grid_position": Vector2i(12, 7),
"resource_path": "res://data/buildings/Monastery_Library.tres"
}, {
"grid_position": Vector2i(8, 13),
"resource_path": "res://data/buildings/Monastery_Scriptorium.tres"
}, {
"grid_position": Vector2i(12, 13),
"resource_path": "res://data/buildings/Monastery_Granary.tres"
}, {
"grid_position": Vector2i(6, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(14, 5),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(15, 4),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/settlements/sample_fortress_gui.tres ---
[gd_resource type="SettlementData" script_class="SettlementData" load_steps=2 format=3 uid="uid://cl3pbg7tiqyng"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1"]

[resource]
resource_local_to_scene = false
resource_name = ""
script = ExtResource("1")
treasury = {
"food": 300,
"gold": 1000,
"stone": 400,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(30, 20),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(29, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 19),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(29, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(30, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(31, 21),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(28, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 18),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(28, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(32, 22),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(27, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}, {
"grid_position": Vector2i(33, 20),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 4,
"res://data/units/Unit_Raider.tres": 8
}

--- RESOURCE: res://data/settlements/small_defensive.tres ---
[gd_resource type="Resource" script_class="SettlementData" load_steps=2 format=3 uid="uid://c5wkbqulshkqe"]

[ext_resource type="Script" uid="uid://hlb8s5g0yp6k" path="res://data/settlements/SettlementData.gd" id="1_mtb34"]

[resource]
script = ExtResource("1_mtb34")
treasury = {
"food": 200,
"gold": 1000,
"stone": 300,
"wood": 500
}
placed_buildings = Array[Dictionary]([{
"grid_position": Vector2i(8, 6),
"resource_path": "res://data/buildings/GreatHall.tres"
}, {
"grid_position": Vector2i(5, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(6, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(7, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(11, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(12, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(13, 4),
"resource_path": "res://data/buildings/Bldg_Wall.tres"
}, {
"grid_position": Vector2i(4, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(14, 3),
"resource_path": "res://data/buildings/Monastery_Watchtower.tres"
}, {
"grid_position": Vector2i(6, 8),
"resource_path": "res://data/buildings/LumberYard.tres"
}])
garrisoned_units = {
"res://data/units/Unit_PlayerRaider.tres": 3
}

--- RESOURCE: res://data/traits/Trait_Ambitious.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://wo43cpcxhf4i"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Ambitious"
description = "This Jarl is driven by a burning desire for power and glory, and inspires the same in their children."
command_modifier = 2
stewardship_modifier = -1
intrigue_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"

--- RESOURCE: res://data/traits/Trait_Cowardly.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bivw1rejl06qi"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Cowardly"
description = "This character has shown cowardice in battle, losing the respect of their people."
is_visible = true
command_modifier = -3
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -2.0
vassal_opinion_modifier = -10
alliance_cost_modifier = 1.2
is_wounded_trait = false
is_dishonorable_trait = true

--- RESOURCE: res://data/traits/Trait_Legendary.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://c6a8qce5fgub0"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Legendary"
description = "This character has achieved legendary status through glorious deeds and successful raids."
is_visible = true
command_modifier = 5
stewardship_modifier = 2
intrigue_modifier = 3
renown_per_year_modifier = 5.0
vassal_opinion_modifier = 20
alliance_cost_modifier = 0.8
is_wounded_trait = false
is_dishonorable_trait = false

--- RESOURCE: res://data/traits/Trait_Maimed.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bbiwlkmmne5md"]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
resource_local_to_scene = false
resource_name = ""
display_name = "Maimed"
description = "This character has suffered a permanent injury that affects their combat ability."
is_visible = true
command_modifier = -2
stewardship_modifier = 0
intrigue_modifier = 0
renown_per_year_modifier = -1.0
vassal_opinion_modifier = -5
alliance_cost_modifier = 1.1
is_wounded_trait = true
is_dishonorable_trait = false

--- RESOURCE: res://data/traits/Trait_Pious.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://y1xcw7hwydkx"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Pious"
description = "This Jarl is known for their devotion to the gods, making religious acts cheaper and sacrilege more costly."
stewardship_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"

--- RESOURCE: res://data/traits/Trait_Rival.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3]

[ext_resource type="Script" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Rival"
description = "This character has developed a bitter rivalry with their liege."
is_visible = true
command_modifier = 1
stewardship_modifier = 0
intrigue_modifier = 2
vassal_opinion_modifier = -15

--- RESOURCE: res://data/traits/Trait_Seasoned.tres ---
[gd_resource type="Resource" script_class="JarlTraitData" load_steps=2 format=3 uid="uid://bvgxc8k7j2rqp"]

[ext_resource type="Script" uid="uid://dwh8olikns4xw" path="res://data/traits/JarlTraitData.gd" id="1_jarl_trait"]

[resource]
script = ExtResource("1_jarl_trait")
display_name = "Seasoned"
description = "This character has experience from successful expeditions, granting improved combat and leadership abilities."
command_modifier = 2
stewardship_modifier = 1
metadata/_custom_type_script = "uid://dwh8olikns4xw"

--- RESOURCE: res://data/units/EnemyVikingRaider_Data.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=6 format=3 uid="uid://brnbvjwnoyh3j"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://dsv0s4yq8c8m5" path="res://scenes/units/EnemyVikingRaider.tscn" id="2_spawn_scene"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="3_6go6j"]
[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="4_ai"]
[ext_resource type="PackedScene" uid="uid://d10havsaesr6i" path="res://scenes/effects/Projectile.tscn" id="5_proj"]

[resource]
script = ExtResource("1_script")
display_name = "Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
icon = ExtResource("3_6go6j")
spawn_cost = {
"food": 30,
"gold": 15
}
max_health = 45
move_speed = 100.0
attack_damage = 10
attack_range = 200.0
attack_speed = 0.5
ai_component_scene = ExtResource("4_ai")
projectile_scene = ExtResource("5_proj")
projectile_speed = 450.0
visual_texture = ExtResource("3_6go6j")

--- RESOURCE: res://data/units/Unit_PlayerRaider.tres ---
[gd_resource type="Resource" script_class="UnitData" load_steps=5 format=3 uid="uid://ejxn3hg8xcu6"]

[ext_resource type="Script" uid="uid://cq155t20ujb2j" path="res://data/units/UnitData.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://cfanwutbtfcp2" path="res://scenes/units/PlayerVikingRaider.tscn" id="2_spawn_scene"]
[ext_resource type="Texture2D" uid="uid://pwi4bv5ch827" path="res://textures/placeholders/unit_placeholder.png" id="3_6go6j"]
[ext_resource type="PackedScene" uid="uid://de3nko6b1rqyg" path="res://scenes/components/AttackAI.tscn" id="4_ai"]

[resource]
script = ExtResource("1_script")
display_name = "Player Viking Raider"
scene_to_spawn = ExtResource("2_spawn_scene")
icon = ExtResource("3_6go6j")
spawn_cost = {
"food": 25,
"gold": 10
}
max_health = 60
move_speed = 100.0
attack_damage = 15
attack_range = 80.0
attack_speed = 0.6000000000058208
ai_component_scene = ExtResource("4_ai")
visual_texture = ExtResource("3_6go6j")
acceleration = 12.0
linear_damping = 6.0

--- RESOURCE: res://data/world_map/Region_Monastery.tres ---
[gd_resource type="Resource" script_class="WorldRegionData" load_steps=3 format=3 uid="uid://bk6wv22mknptc"]

[ext_resource type="Resource" uid="uid://okf2novkg804" path="res://data/settlements/monastery_base.tres" id="1_settlement"]
[ext_resource type="Script" uid="uid://dqlbgeegli821" path="res://data/world_map/WorldRegionData.gd" id="2_world_region"]

[resource]
script = ExtResource("2_world_region")
display_name = "Nearby Monastery"
description = "A wealthy but poorly-defended monastery. An easy target for a quick grab."
target_settlement_data = ExtResource("1_settlement")
region_type_tag = "Monastery"
yearly_income = {
"food": 10,
"gold": 25
}
metadata/_custom_type_script = "uid://dqlbgeegli821"

--- RESOURCE: res://resources/rectangleshape2d_879319.tres ---
[gd_resource type="RectangleShape2D" format=3 uid="uid://bvjkr2ny3hnvo"]

[resource]
size = Vector2(25, 3)

--- RESOURCE: res://resources/separation_circle_shape.tres ---
[gd_resource type="CircleShape2D" format=3 uid="uid://bda7xb0judu2h"]

[resource]
radius = 40.0

--- RESOURCE: res://textures/placeholders/building_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://ds2w780g4nf1t"]

[resource]
size = Vector2(128, 128)

--- RESOURCE: res://textures/placeholders/defensive_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://db3pfgf4u4pql"]

[resource]
size = Vector2(96, 96)

--- RESOURCE: res://textures/placeholders/unit_placeholder.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://bg2e08mncpjg1"]

[resource]
size = Vector2(64, 64)

--- RESOURCE: res://textures/placeholders/unit_texture.tres ---
[gd_resource type="PlaceholderTexture2D" format=3 uid="uid://cybqs3wt5wpg3"]

[resource]
size = Vector2(10, 2)

--- RESOURCE: res://ui/themes/VikingDynastyTheme.tres ---
[gd_resource type="Theme" load_steps=0 format=3 uid="uid://63duv3n1vwhg"]

[resource]
--- END OF RESOURCE FILES ---

#### **2.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://autoload/EventManager.tscn ---
EventManager (Node)
> script: res://autoload/EventManager.gd
> scene: res://autoload/EventManager.tscn
> event_ui_scene = res://ui/Event_UI.tscn
> succession_crisis_scene = res://ui/Succession_Crisis_UI.tscn

--- SCENE: res://autoload/PauseManager.tscn ---
PauseManager (Node)
> script: res://autoload/PauseManager.gd
> scene: res://autoload/PauseManager.tscn
> pause_menu_scene = res://scripts/ui/PauseMenu.tscn

--- SCENE: res://autoload/SceneManager.tscn ---
SceneManager (Node)
> script: res://autoload/SceneManager.gd
> scene: res://autoload/SceneManager.tscn
> settlement_scene = res://scenes/levels/SettlementBridge.tscn
> world_map_scene = res://scenes/world_map/MacroMap.tscn
> raid_mission_scene = res://scenes/missions/RaidMission.tscn

--- SCENE: res://player/RTSController.tscn ---
RTSController (Node)
> script: res://player/RTSController.gd
> scene: res://player/RTSController.tscn

--- SCENE: res://scenes/buildings/Base_Building.tscn ---
Base_Building (StaticBody2D)
> script: res://data/buildings/Base_Building.gd
> scene: res://scenes/buildings/Base_Building.tscn

--- SCENE: res://scenes/components/AttackAI.tscn ---
AttackAI (Node2D)
> script: res://scenes/components/AttackAI.gd
> scene: res://scenes/components/AttackAI.tscn
> ai_mode = 0
> great_hall_los_range = 600.0
> attack_damage = 10
> attack_range = 200.0
> attack_speed = 1.0
> DetectionArea (Area2D)
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://scenes/components/AttackAI.tscn::CircleShape2D_2baay
> AttackTimer (Timer)

--- SCENE: res://scenes/effects/Projectile.tscn ---
Projectile (Area2D)
> script: res://scenes/effects/Projectile.gd
> scene: res://scenes/effects/Projectile.tscn
> scale = (2.0, 2.0)
> collision_layer = 1024
> collision_mask = 0
> monitorable = false
> Sprite2D (Sprite2D)
> > scale = (0.024707, 0.00293)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://resources/rectangleshape2d_879319.tres
> LifetimeTimer (Timer)
> > wait_time = 3.0
> > one_shot = true
> > autostart = true

--- SCENE: res://scenes/levels/DefensiveMicro.tscn ---
DefensiveMicro (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/levels/DefensiveMicro.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> is_defensive_mission = true
> enemy_spawn_position = 
> TileMap (TileMap)
> > tile_set = res://scenes/levels/DefensiveMicro.tscn::TileSet_m5xuc
> PlayerStartPosition (Marker2D)
> > position = (100.0, 400.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
> > grid_width = 60
> > grid_height = 40
> > cell_size = 32
> BuildingContainer (Node2D)
> RaidObjectiveManager (Node)
>   script: res://scenes/missions/RaidObjectiveManager.gd
> > victory_bonus_loot = {"gold":200}
> > settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> > is_defensive_mission = false
> EnemySpawnPosition (Marker2D)
> > position = (700.0, 100.0)

--- SCENE: res://scenes/levels/SettlementBridge.tscn ---
SettlementBridge (Node)
> script: res://scripts/buildings/SettlementBridge.gd
> scene: res://scenes/levels/SettlementBridge.tscn
> home_base_data = res://data/settlements/home_base_fixed.tres
> end_of_year_popup_scene = res://ui/EndOfYear_Popup.tscn
> world_map_scene_path = "res://scenes/world_map/MacroMap.tscn"
> UnitContainer (Node2D)
> UI (CanvasLayer)
>   Label (Label)
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_right = 0.5
>   > offset_left = -319.0
>   > offset_right = 319.0
>   > offset_bottom = 23.0
>   > grow_horizontal = 2
>   > text = "Purchase buildings from the storefront below, then place them on your settlement"
>   > horizontal_alignment = 1
>   Storefront_UI (Control)
>     script: res://ui/StorefrontUI.gd
>     scene: res://ui/Storefront_UI.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
>     PanelContainer (PanelContainer)
>     > layout_mode = 1
>     > anchors_preset = -1
>     > anchor_top = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = 20.0
>     > offset_top = -140.0
>     > offset_right = 480.0
>     > offset_bottom = -20.0
>     > grow_vertical = 0
>       MarginContainer (MarginContainer)
>       > layout_mode = 2
>         TabContainer (TabContainer)
>         > layout_mode = 2
>         > current_tab = 0
>           BuildTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             TreasuryDisplay (HBoxContainer)
>             > layout_mode = 2
>               GoldLabel (Label)
>               > layout_mode = 2
>               > text = "Gold: 0"
>               WoodLabel (Label)
>               > layout_mode = 2
>               > text = "Wood: 0"
>               FoodLabel (Label)
>               > layout_mode = 2
>               > text = "Food: 0"
>               StoneLabel (Label)
>               > layout_mode = 2
>               > text = "Stone: 0"
>             BuildButtonsContainer (VBoxContainer)
>             > layout_mode = 2
>           RecruitTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             RecruitButtons (VBoxContainer)
>             > layout_mode = 2
>             GarrisonList (VBoxContainer)
>             > layout_mode = 2
>           LegacyTab (VBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             JarlStatsDisplay (HBoxContainer)
>             > layout_mode = 2
>               RenownLabel (Label)
>               > layout_mode = 2
>               > text = "Renown: 0"
>               AuthorityLabel (Label)
>               > layout_mode = 2
>               > text = "Authority: 0/0"
>             Description (Label)
>             > layout_mode = 2
>             > text = "Spend Renown and Authority on permanent dynasty upgrades."
>             > autowrap_mode = 3
>             HSeparator (HSeparator)
>             > layout_mode = 2
>             LegacyButtonsContainer (VBoxContainer)
>             > layout_mode = 2
>     DebugRaidButton (Button)
>     > layout_mode = 1
>     > anchors_preset = -1
>     > anchor_left = 1.0
>     > anchor_right = 1.0
>     > offset_left = -143.0
>     > offset_bottom = 27.0
>     > grow_horizontal = 0
>     > text = "DEBUG: Start Raid"
>   RestartButton (Button)
>   > visible = false
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -84.0
>   > offset_top = -15.5
>   > offset_right = 84.0
>   > offset_bottom = 15.5
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "Return to Settlement"
>   StartRaidButton (Button)
>   > anchors_preset = -1
>   > anchor_left = 1.0
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -150.0
>   > offset_top = -40.0
>   > grow_horizontal = 0
>   > grow_vertical = 0
>   > text = "World Map"
> BuildingCursor (Node2D)
>   script: res://scripts/ui/BuildingPreviewCursor.gd
> BuildingContainer (Node2D)
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
>   scene: res://scripts/utility/GridManager.tscn
> > grid_width = 60
> > grid_height = 40
> > cell_size = 32

--- SCENE: res://scenes/missions/RaidMission.tscn ---
RaidMission (Node2D)
> script: res://scenes/missions/RaidMission.gd
> scene: res://scenes/missions/RaidMission.tscn
> default_enemy_base_path = "res://data/settlements/monastery_base.tres"
> available_enemy_bases = ["res://data/settlements/monastery_base.tres","res://data/settlements/fortress_base.tres"]
> player_spawn_formation = {"units_per_row":5,"spacing":40}
> mission_difficulty = 1.0
> allow_retreat = true
> is_defensive_mission = false
> enemy_spawn_position = EnemySpawnPosition
> PlayerStartPosition (Marker2D)
> > position = (-161.0, 606.0)
> EnemySpawnPosition (Marker2D)
> > position = (383.0, -21.0)
> RTSController (Node)
>   script: res://player/RTSController.gd
>   scene: res://player/RTSController.tscn
> CanvasLayer (CanvasLayer)
>   SelectionBox (Control)
>     script: res://ui/SelectionBox.gd
>     scene: res://ui/SelectionBox.tscn
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://ui/themes/VikingDynastyTheme.tres
> RTSCamera (Camera2D)
>   script: res://player/RTSCamera.gd
> > position = (400.0, 300.0)
> > camera_speed = 400.0
> > edge_pan_margin = 20.0
> > enable_edge_panning = true
> > enable_wasd_movement = true
> > bounds_enabled = false
> > bounds_rect = [P: (-500.0, -500.0), S: (1500.0, 1200.0)]
> GridManager (Node)
>   script: res://scripts/utility/GridManager.gd
>   scene: res://scripts/utility/GridManager.tscn
> > grid_width = 120
> > grid_height = 80
> > cell_size = 32
> BuildingContainer (Node2D)
> RaidObjectiveManager (Node)
>   script: res://scenes/missions/RaidObjectiveManager.gd
> > victory_bonus_loot = {"gold":200}
> > settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> > is_defensive_mission = false

--- SCENE: res://scenes/units/Base_Unit.tscn ---
Base_Unit (CharacterBody2D)
> script: res://scripts/units/Base_Unit.gd
> scene: res://scenes/units/Base_Unit.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/units/EnemyVikingRaider.tscn ---
EnemyVikingRaider (CharacterBody2D)
> script: res://scripts/units/EnemyVikingRaider.gd
> scene: res://scenes/units/EnemyVikingRaider.tscn
> collision_layer = 4
> collision_mask = 3
> separation_enabled = true
> separation_force = 30.0
> separation_radius = 40.0
> Sprite2D (Sprite2D)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/units/PlayerVikingRaider.tscn ---
PlayerVikingRaider (CharacterBody2D)
> script: res://scripts/units/PlayerVikingRaider.gd
> scene: res://scenes/units/PlayerVikingRaider.tscn
> collision_layer = 2
> Sprite2D (Sprite2D)
> > scale = (0.058594, 0.061523)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/units/VikingRaider.tscn ---
VikingRaider (CharacterBody2D)
> script: res://scripts/units/EnemyVikingRaider.gd
> scene: res://scenes/units/VikingRaider.tscn
> collision_layer = 4
> data = 
> separation_enabled = false
> Sprite2D (Sprite2D)
> > modulate = (0.5464, 0.0, 0.0, 1.0)
> > self_modulate = (1.0, 0.0, 0.0, 1.0)
> > scale = (0.059, 0.062)
> > texture = res://textures/placeholders/unit_placeholder.png
> CollisionShape2D (CollisionShape2D)
> > position = (-1.0, 0.0)
> > shape = res://scenes/units/Base_Unit.tscn::RectangleShape2D_n6s0a
> AttackTimer (Timer)
> SeparationArea (Area2D)
> > collision_layer = 0
> > collision_mask = 2
> > monitorable = false
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://resources/separation_circle_shape.tres

--- SCENE: res://scenes/world_map/MacroCamera.tscn ---
MacroCamera (Camera2D)
> script: res://scenes/world_map/MacroCamera.gd
> scene: res://scenes/world_map/MacroCamera.tscn
> camera_speed = 500.0
> bounds_enabled = true
> bounds_rect = [P: (0.0, 0.0), S: (1920.0, 1080.0)]

--- SCENE: res://scenes/world_map/MacroMap.tscn ---
MacroMap (Node2D)
> script: res://scenes/world_map/MacroMap.gd
> scene: res://scenes/world_map/MacroMap.tscn
> position = (131.0, 23.0)
> raid_mission_scene_path = "res://scenes/missions/RaidMission.tscn"
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> end_year_popup_scene = res://ui/EndOfYear_Popup.tscn
> enemy_raid_chance = 0.25
> MapBackground (ColorRect)
> > modulate = (0.7354, 0.7354, 0.7354, 1.0)
> > custom_minimum_size = (1920.0, 1080.0)
> > anchors_preset = -1
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_left = -703.000061035156
> > offset_top = -262.0
> > offset_right = 1217.0
> > offset_bottom = 818.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > scale = (60.0, 34.0)
> > mouse_filter = 2
> > color = (0.8314, 0.7725, 0.6275, 1.0)
> Regions (Node2D)
>   Region (Area2D)
>     script: res://scenes/world_map/Region.gd
>     scene: res://scenes/world_map/Region.tscn
>   > position = (392.0, 139.0)
>   > data = res://data/world_map/Region_Monastery.tres
>     Sprite2D (Sprite2D)
>     > modulate = (1.0, 1.0, 1.0, 0.2)
>     > texture = res://assets/placeholder_tile.tres
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://scenes/world_map/Region.tscn::RectangleShape2D_y5hem
> MacroCamera (Camera2D)
>   script: res://scenes/world_map/MacroCamera.gd
>   scene: res://scenes/world_map/MacroCamera.tscn
> > camera_speed = 500.0
> > bounds_enabled = true
> > bounds_rect = [P: (0.0, 0.0), S: (1920.0, 1080.0)]
> UI (CanvasLayer)
> > layer = 10
>   JarlInfo (PanelContainer)
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_right = 0.5
>   > offset_left = -20.0
>   > offset_right = 20.0
>   > offset_bottom = 40.0
>   > grow_horizontal = 2
>   > mouse_filter = 1
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       AuthorityLabel (Label)
>       > layout_mode = 2
>       > size_flags_horizontal = 4
>       > text = "Authority: 3/3"
>       > horizontal_alignment = 1
>       RenownLabel (Label)
>       > layout_mode = 2
>       > text = "Renown: 25"
>       > horizontal_alignment = 1
>   Actions (PanelContainer)
>   > anchors_preset = -1
>   > anchor_left = 1.0
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -40.0
>   > offset_top = -40.0
>   > grow_horizontal = 0
>   > grow_vertical = 0
>   > mouse_filter = 2
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       EndYearButton (Button)
>       > layout_mode = 2
>       > text = "End Year"
>       SettlementButton (Button)
>       > layout_mode = 2
>       > text = "Return to Settlement"
>       DynastyButton (Button)
>       > layout_mode = 2
>       > text = "Dynasty"
>   RegionInfo (PanelContainer)
>   > visible = false
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -20.0
>   > offset_top = -40.0
>   > offset_right = 20.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > mouse_filter = 1
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       RegionNameLabel (Label)
>       > layout_mode = 2
>       > horizontal_alignment = 1
>       LaunchRaidButton (Button)
>       > layout_mode = 2
>       > disabled = true
>       > text = "Launch Raid"
>       SubjugateButton (Button)
>       > layout_mode = 2
>       > disabled = true
>       > text = "Subjugate"
>       MarryButton (Button)
>       > layout_mode = 2
>       > disabled = true
>       > text = "Marry for Alliance"
>   Tooltip (PanelContainer)
>   > visible = false
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -51.5
>   > offset_top = -58.0
>   > offset_right = 98.5
>   > offset_bottom = -28.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > mouse_filter = 2
>     Label (Label)
>     > layout_mode = 2
>     > text = "Region Name"
>     > horizontal_alignment = 1
>   Dynasty_UI (PanelContainer)
>     script: res://ui/DynastyUI.gd
>     scene: res://ui/Dynasty_UI.tscn
>   > anchors_preset = -1
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -200.0
>   > offset_top = -150.0
>   > offset_right = 200.0
>   > offset_bottom = 150.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     Margin (MarginContainer)
>     > layout_mode = 2
>       VBox (VBoxContainer)
>       > layout_mode = 2
>         TitleLabel (Label)
>         > layout_mode = 2
>         > text = "Jarl Bjorn\'s Dynasty"
>         > horizontal_alignment = 1
>         HSeparator (HSeparator)
>         > layout_mode = 2
>         HeirsLabel (Label)
>         > layout_mode = 2
>         > text = "Heirs:"
>         HeirsContainer (VBoxContainer)
>         > layout_mode = 2
>         Spacer (Control)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         CloseButton (Button)
>         > layout_mode = 2
>         > text = "Close"

--- SCENE: res://scenes/world_map/Region.tscn ---
Region (Area2D)
> script: res://scenes/world_map/Region.gd
> scene: res://scenes/world_map/Region.tscn
> Sprite2D (Sprite2D)
> > modulate = (1.0, 1.0, 1.0, 0.2)
> > texture = res://assets/placeholder_tile.tres
> CollisionShape2D (CollisionShape2D)
> > shape = res://scenes/world_map/Region.tscn::RectangleShape2D_y5hem

--- SCENE: res://scenes/world_map/WorldMap_Stub.tscn ---
WorldMapStub (Control)
> script: res://scenes/world_map/WorldMap_Stub.gd
> scene: res://scenes/world_map/WorldMap_Stub.tscn
> raid_mission_scene_path = "res://scenes/missions/RaidMission.tscn"
> settlement_bridge_scene_path = "res://scenes/levels/SettlementBridge.tscn"
> Background (ColorRect)
> > layout_mode = 0
> > color = (0.0, 0.0, 0.0, 1.0)
> TitleLabel (Label)
> > layout_mode = 0
> > offset_top = 50.0
> > offset_right = 141.0
> > offset_bottom = 73.0
> > text = "Select Your Target"
> > horizontal_alignment = 1
> ButtonContainer (VBoxContainer)
> > layout_mode = 0
> > offset_top = 150.0
> > offset_right = 190.0
> > offset_bottom = 216.0
> > alignment = 1
>   RaidMonasteryButton (Button)
>   > layout_mode = 2
>   > text = "Raid: Nearby Monastery"
>   Spacer (HSeparator)
>   > layout_mode = 2
>   BackButton (Button)
>   > layout_mode = 2
>   > text = "Return to Settlement"
> Phase3Test (Node)

--- SCENE: res://scripts/ui/PauseMenu.tscn ---
PauseMenu (CanvasLayer)
> script: res://scripts/ui/PauseMenu.gd
> scene: res://scripts/ui/PauseMenu.tscn
> process_mode = 2
> PanelContainer (PanelContainer)
> > anchors_preset = -1
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -20.0
> > offset_top = -20.0
> > offset_right = 20.0
> > offset_bottom = 20.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     ResumeButton (Button)
>     > layout_mode = 2
>     > text = "Resume"
>     SaveButton (Button)
>     > layout_mode = 2
>     > text = "Save Game"
>     QuitButton (Button)
>     > layout_mode = 2
>     > text = "Quit Game"

--- SCENE: res://scripts/utility/GridManager.tscn ---
GridManager (Node)
> script: res://scripts/utility/GridManager.gd
> scene: res://scripts/utility/GridManager.tscn
> grid_width = 60
> grid_height = 40
> cell_size = 32

--- SCENE: res://ui/BuildingPreviewCursor.tscn ---
BuildingPreviewCursor (Node2D)
> script: res://scripts/ui/BuildingPreviewCursor.gd
> scene: res://ui/BuildingPreviewCursor.tscn

--- SCENE: res://ui/Dynasty_UI.tscn ---
Dynasty_UI (PanelContainer)
> script: res://ui/DynastyUI.gd
> scene: res://ui/Dynasty_UI.tscn
> anchor_left = 0.5
> anchor_top = 0.5
> anchor_right = 0.5
> anchor_bottom = 0.5
> offset_left = -200.0
> offset_top = -150.0
> offset_right = 200.0
> offset_bottom = 150.0
> grow_horizontal = 2
> grow_vertical = 2
> Margin (MarginContainer)
> > layout_mode = 2
>   VBox (VBoxContainer)
>   > layout_mode = 2
>     TitleLabel (Label)
>     > layout_mode = 2
>     > text = "Jarl Bjorn\'s Dynasty"
>     > horizontal_alignment = 1
>     HSeparator (HSeparator)
>     > layout_mode = 2
>     HeirsLabel (Label)
>     > layout_mode = 2
>     > text = "Heirs:"
>     HeirsContainer (VBoxContainer)
>     > layout_mode = 2
>     Spacer (Control)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>     CloseButton (Button)
>     > layout_mode = 2
>     > text = "Close"

--- SCENE: res://ui/EndOfYear_Popup.tscn ---
Main (PanelContainer)
> script: res://ui/EndOfYear_Popup.gd
> scene: res://ui/EndOfYear_Popup.tscn
> anchor_left = 0.5
> anchor_top = 0.5
> anchor_right = 0.5
> anchor_bottom = 0.5
> offset_left = -150.0
> offset_top = -75.0
> offset_right = 150.0
> offset_bottom = 75.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 4
> size_flags_vertical = 4
> theme = res://ui/themes/VikingDynastyTheme.tres
> MarginContainer (MarginContainer)
> > layout_mode = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>     PayoutLabel (Label)
>     > layout_mode = 2
>     > text = "Welcome home! ..."
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     CollectButton (Button)
>     > custom_minimum_size = (120.0, 40.0)
>     > layout_mode = 2
>     > text = "Collect"

--- SCENE: res://ui/Event_UI.tscn ---
Event_UI (CanvasLayer)
> script: res://ui/Event_UI.gd
> scene: res://ui/Event_UI.tscn
> process_mode = 2
> layer = 20
> PanelContainer (PanelContainer)
> > custom_minimum_size = (500.0, 300.0)
> > anchors_preset = -1
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -78.5
> > offset_top = -105.5
> > offset_right = 78.5
> > offset_bottom = 105.5
> > grow_horizontal = 2
> > grow_vertical = 2
>   Margin (MarginContainer)
>   > layout_mode = 2
>     VBox (VBoxContainer)
>     > layout_mode = 2
>       TitleLabel (Label)
>       > custom_minimum_size = (300.0, 30.0)
>       > layout_mode = 2
>       > size_flags_vertical = 1
>       > text = "Event Title"
>       > horizontal_alignment = 1
>       > autowrap_mode = 3
>       HSeparator (HSeparator)
>       > layout_mode = 2
>       HBox (HBoxContainer)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>         Portrait (TextureRect)
>         > unique_name_in_owner = true
>         > custom_minimum_size = (128.0, 128.0)
>         > layout_mode = 2
>         > texture = res://textures/placeholders/unit_placeholder.png
>         > expand_mode = 1
>         > stretch_mode = 5
>         DescriptionLabel (Label)
>         > custom_minimum_size = (200.0, 100.0)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 1
>         > text = "This is the event description text. It will be multiple lines long and explain the situation to the player, presenting them with a difficult choice."
>         > autowrap_mode = 3
>         > clip_text = true
>       HSeparator2 (HSeparator)
>       > layout_mode = 2
>       ChoiceButtonsContainer (VBoxContainer)
>       > layout_mode = 2
>       > size_flags_vertical = 10
>       > alignment = 2

--- SCENE: res://ui/SelectionBox.tscn ---
SelectionBox (Control)
> script: res://ui/SelectionBox.gd
> scene: res://ui/SelectionBox.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> theme = res://ui/themes/VikingDynastyTheme.tres

--- SCENE: res://ui/Storefront_UI.tscn ---
Main (Control)
> script: res://ui/StorefrontUI.gd
> scene: res://ui/Storefront_UI.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> available_buildings = []
> available_units = []
> default_treasury_display = {"food":100,"gold":100,"stone":100,"wood":100}
> auto_load_units_from_directory = true
> PanelContainer (PanelContainer)
> > layout_mode = 1
> > anchors_preset = -1
> > anchor_top = 1.0
> > anchor_bottom = 1.0
> > offset_left = 20.0
> > offset_top = -140.0
> > offset_right = 480.0
> > offset_bottom = -20.0
> > grow_vertical = 0
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     TabContainer (TabContainer)
>     > layout_mode = 2
>     > current_tab = 0
>       BuildTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         TreasuryDisplay (HBoxContainer)
>         > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           > text = "Gold: 0"
>           WoodLabel (Label)
>           > layout_mode = 2
>           > text = "Wood: 0"
>           FoodLabel (Label)
>           > layout_mode = 2
>           > text = "Food: 0"
>           StoneLabel (Label)
>           > layout_mode = 2
>           > text = "Stone: 0"
>         BuildButtonsContainer (VBoxContainer)
>         > layout_mode = 2
>       RecruitTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         RecruitButtons (VBoxContainer)
>         > layout_mode = 2
>         GarrisonList (VBoxContainer)
>         > layout_mode = 2
>       LegacyTab (VBoxContainer)
>       > visible = false
>       > layout_mode = 2
>         JarlStatsDisplay (HBoxContainer)
>         > layout_mode = 2
>           RenownLabel (Label)
>           > layout_mode = 2
>           > text = "Renown: 0"
>           AuthorityLabel (Label)
>           > layout_mode = 2
>           > text = "Authority: 0/0"
>         Description (Label)
>         > layout_mode = 2
>         > text = "Spend Renown and Authority on permanent dynasty upgrades."
>         > autowrap_mode = 3
>         HSeparator (HSeparator)
>         > layout_mode = 2
>         LegacyButtonsContainer (VBoxContainer)
>         > layout_mode = 2

--- SCENE: res://ui/Succession_Crisis_UI.tscn ---
Succession_Crisis_UI (CanvasLayer)
> script: res://ui/Succession_Crisis_UI.gd
> scene: res://ui/Succession_Crisis_UI.tscn
> PanelContainer (PanelContainer)
> > anchors_preset = -1
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -255.5
> > offset_top = -151.0
> > offset_right = 255.5
> > offset_bottom = 249.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       TitleLabel (Label)
>       > layout_mode = 2
>       > text = "Succession Crisis"
>       DescriptionLabel (Label)
>       > layout_mode = 2
>       > text = "The Jarl is dead. Your rule is fragile..."
>       LegitimacyLabel (Label)
>       > layout_mode = 2
>       > text = "New Legitimacy: 20/100"
>       HSeparator (HSeparator)
>       > layout_mode = 2
>       RenownTaxTitle (Label)
>       > layout_mode = 2
>       > text = "Legacy Projects"
>       RenownTaxDescription (Label)
>       > layout_mode = 2
>       > text = "Pay 50 Renown to protect your legacy, or refuse and risk setbacks."
>       RenownTaxButtons (HBoxContainer)
>       > layout_mode = 2
>         PayRenownButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Pay Renown"
>         RefuseRenownButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Refuse"
>       HSeparator2 (HSeparator)
>       > layout_mode = 2
>       GoldTaxTitle (Label)
>       > layout_mode = 2
>       > text = "Garrison Stability"
>       GoldTaxDescription (Label)
>       > layout_mode = 2
>       > text = "Pay 1000 Gold to ensure loyalty, or refuse and risk instability."
>       GoldTaxButtons (HBoxContainer)
>       > layout_mode = 2
>         PayGoldButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Pay Gold"
>         RefuseGoldButton (Button)
>         > layout_mode = 2
>         > toggle_mode = true
>         > text = "Refuse"
>       HSeparator3 (HSeparator)
>       > layout_mode = 2
>       ConfirmButton (Button)
>       > layout_mode = 2
>       > text = "Confirm"
--- END OF SCENE STRUCTURES ---

#### **2.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://autoload/DynastyManager.gd ---
# res://autoload/DynastyManager.gd
#
# A global Singleton (Autoload) that acts as a pure data manager
# for the player's Jarl and dynasty state.
# This is the "Core Pacing Engine" as defined in the GDD.
# It is the single source of truth for all Jarl data.
extends Node

## Emitted when Jarl data changes (e.g., spent Authority, ended year)
signal jarl_stats_updated(jarl_data: JarlData)
signal year_ended

var current_jarl: JarlData
var current_raid_target: SettlementData

var is_defensive_raid: bool = false

# --- NEW: Succession System ---
var minimum_inherited_legitimacy: int = 0
var loaded_legacy_upgrades: Array[LegacyUpgradeData] = []
# --- END NEW ---

# Path to the player's persistent Jarl data
const PLAYER_JARL_PATH = "res://data/characters/PlayerJarl.tres"

func _ready() -> void:
	_load_player_jarl()
	_load_legacy_upgrades_from_disk() # <-- THIS IS THE FIX
	EventBus.succession_choices_made.connect(_on_succession_choices_made) # Connect to UI

# --- THIS IS THE NEW FUNCTION ---
func _load_legacy_upgrades_from_disk() -> void:
	"""
	Scans res://data/legacy/ for .tres files and loads them.
	This manager is now the single source of truth for this data.
	"""
	loaded_legacy_upgrades.clear()
	
	var dir = DirAccess.open("res://data/legacy/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var path = "res://data/legacy/" + file_name
				var upgrade_data = load(path) as LegacyUpgradeData
				
				if upgrade_data:
					# We create a local instance/duplicate of the resource.
					# This prevents cost changes from modifying the .tres file.
					var unique_upgrade = upgrade_data.duplicate()
					
					# Check if already purchased
					if has_purchased_upgrade(unique_upgrade.effect_key):
						# This logic needs to be based on progress, not just key
						# We will need to load progress from JarlData in the future.
						# For now, this is fine, but we need to load progress *from* jarl data.
						pass
					
					loaded_legacy_upgrades.append(unique_upgrade)
					
			file_name = dir.get_next()
	print("DynastyManager: Loaded %d legacy upgrades." % loaded_legacy_upgrades.size())
# --- END NEW FUNCTION ---

func _load_player_jarl() -> void:
	if ResourceLoader.exists(PLAYER_JARL_PATH):
		current_jarl = load(PLAYER_JARL_PATH)
		print("DynastyManager: PlayerJarl.tres loaded successfully.")
	else:
		# Use push_error for missing persistent files
		push_error("DynastyManager: Failed to load Jarl data from %s. File not found!" % PLAYER_JARL_PATH)
		# Create a fallback in-memory Jarl to prevent crashes
		current_jarl = JarlData.new()
		current_jarl.display_name = "Fallback Jarl"
		current_jarl.current_authority = 3
		current_jarl.max_authority = 3
		
	# Emit initial stats
	jarl_stats_updated.emit(current_jarl)

func get_current_jarl() -> JarlData:
	if not current_jarl:
		_load_player_jarl()
	return current_jarl

func can_spend_authority(cost: int) -> bool:
	if not current_jarl:
		return false
	return current_jarl.can_take_action(cost)

func spend_authority(cost: int) -> bool:
	if not current_jarl:
		return false
		
	if current_jarl.spend_authority(cost):
		_save_jarl_data()
		jarl_stats_updated.emit(current_jarl)
		# REMOVED: print("DynastyManager: Spent %d authority. %d remaining." % [cost, current_jarl.current_authority])
		return true
	
	# RETAINED: Failure is important
	print("DynastyManager: Failed to spend %d authority. %d remaining." % [cost, current_jarl.current_authority])
	return false

func can_spend_renown(cost: int) -> bool:
	"""Check if the Jarl has enough Renown."""
	if not current_jarl:
		return false
	return current_jarl.renown >= cost

func spend_renown(cost: int) -> bool:
	"""Spend the Jarl's Renown."""
	if not can_spend_renown(cost):
		# RETAINED: Failure is important
		print("DynastyManager: Failed to spend %d renown. %d available." % [cost, current_jarl.renown])
		return false
	
	current_jarl.renown -= cost
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	# REMOVED: print("DynastyManager: Spent %d renown. %d remaining." % [cost, current_jarl.renown])
	return true

func purchase_legacy_upgrade(upgrade_key: String) -> void:
	"""Mark a legacy upgrade as purchased on the Jarl's data."""
	if not current_jarl:
		return
	if not upgrade_key in current_jarl.purchased_legacy_upgrades:
		current_jarl.purchased_legacy_upgrades.append(upgrade_key)
		_save_jarl_data()
		print("DynastyManager: Legacy upgrade '%s' purchased and saved." % upgrade_key)

func has_purchased_upgrade(upgrade_key: String) -> bool:
	"""Check if a legacy upgrade has already been purchased."""
	if not current_jarl:
		return false
	return upgrade_key in current_jarl.purchased_legacy_upgrades

# --- NEW: Unifier Pillar Functions ---
func add_conquered_region(region_path: String) -> void:
	"""Adds a region's path to the Jarl's list of conquered territories."""
	if not current_jarl:
		return
	if not region_path in current_jarl.conquered_regions:
		current_jarl.conquered_regions.append(region_path)
		_save_jarl_data()
		# RETAINED: This is a major game state change
		print("DynastyManager: Region '%s' conquered and saved." % region_path)
		# We don't emit jarl_stats_updated here because spending authority
		# will have already triggered the UI refresh.

func has_conquered_region(region_path: String) -> bool:
	"""Checks if a region has been conquered."""
	if not current_jarl:
		return false
	return region_path in current_jarl.conquered_regions

# --- NEW: Progenitor Pillar Functions ---

func get_available_heir_count() -> int:
	if not current_jarl:
		return 0
	return current_jarl.get_available_heir_count()

func start_heir_expedition(heir: JarlHeirData, expedition_duration: int = 5) -> void:
	"""
	Sends an heir on an expedition.
	This marks them as unavailable and starts a timer.
	"""
	if not current_jarl or not heir in current_jarl.heirs:
		push_error("DynastyManager: Tried to send an invalid heir on expedition.")
		return
	
	heir.status = JarlHeirData.HeirStatus.OnExpedition
	heir.expedition_years_remaining = expedition_duration
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("Heir %s sent on expedition for %d years." % [heir.display_name, expedition_duration])

func process_heir_expeditions() -> Array[String]:
	"""
	Called at the End of Year.
	Processes all heirs on expedition, returning results.
	"""
	if not current_jarl:
		return []

	var results: Array[String] = []
	var heirs_to_remove: Array[JarlHeirData] = []
	
	for heir in current_jarl.heirs:
		if heir.status == JarlHeirData.HeirStatus.OnExpedition:
			heir.expedition_years_remaining -= 1
			
			if heir.expedition_years_remaining <= 0:
				# Expedition is over, run probability check
				var roll = randf()
				if roll <= 0.7: # 70% success 
					var renown_gain = randi_range(100, 300)
					award_renown(renown_gain)
					results.append("Heir %s returned from their expedition with %d Renown!" % [heir.display_name, renown_gain])
					heir.status = JarlHeirData.HeirStatus.Available
					
					# --- NEW: Add Trait to Heir ---
					var seasoned_trait = load("res://data/traits/Trait_Seasoned.tres") # Load the trait we created
					if seasoned_trait:
						heir.traits.append(seasoned_trait)
					# --- END NEW ---
					
					# --- NEW: Add Legitimacy Boost ---
					current_jarl.legitimacy = min(100, current_jarl.legitimacy + 5) # +5 Legitimacy for successful expedition
					# --- END NEW ---
				else: # 30% failure 
					results.append("Tragic news!
Heir %s was lost at sea during their expedition." % heir.display_name)
					heir.status = JarlHeirData.HeirStatus.LostAtSea
					heirs_to_remove.append(heir) # Queue for removal
	
	# Remove lost heirs
	for heir in heirs_to_remove:
		current_jarl.remove_heir(heir)

	if not results.is_empty():
		_save_jarl_data()
		jarl_stats_updated.emit(current_jarl)
		
	return results

# --- NEW: Marry for Alliance ---
func marry_heir_for_alliance(region_path: String) -> bool:
	"""
	Spends the first available heir to form an alliance with a region.
	Returns true on success, false if no heir is available.
	"""
	if not current_jarl:
		return false
		
	var heir_to_marry = current_jarl.get_first_available_heir()
	if not heir_to_marry:
		print("DynastyManager: Marriage failed. No available heir.")
		return false
	
	# "Spend" the heir
	heir_to_marry.status = JarlHeirData.HeirStatus.MarriedOff
	
	# Add the alliance
	if not region_path in current_jarl.allied_regions:
		current_jarl.allied_regions.append(region_path)
	
	# --- NEW: Add Legitimacy Boost ---
	current_jarl.legitimacy = min(100, current_jarl.legitimacy + 10) # +10 Legitimacy
	# --- END NEW ---

	print("Heir %s married off to form alliance with %s" % [heir_to_marry.display_name, region_path])
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	return true

func is_allied_region(region_path: String) -> bool:
	"""Checks if a region is allied."""
	if not current_jarl:
		return false
	return region_path in current_jarl.allied_regions
# --- END NEW ---
func add_trait_to_heir(heir: JarlHeirData, trait_data: JarlTraitData) -> void:
	"""
	Placeholder function to add a trait to an heir.
	Currently, JarlHeirData does not store traits.
	This function will just log for now.
	"""
	# Using push_warning to flag this missing feature for development
	push_warning("EVENT: (TODO) Would add trait '%s' to heir '%s'." % [trait_data.display_name, heir.display_name])


func end_year() -> void:
	if not current_jarl:
		push_error("DynastyManager: Cannot end year, current Jarl is null.")
		return
	
	# --- MODIFIED: Death check happens *before* reset ---
	var jarl_died = _check_for_jarl_death()
	if jarl_died:
		# Succession crisis is triggered, which will emit 'event_system_finished'
		# when it's done. We stop 'end_year' here.
		return
	# --- END MODIFIED ---
	
	# Jarl did not die, proceed as normal
	current_jarl.reset_authority() # This now contains the debuff logic
	
	var expedition_results = process_heir_expeditions()
	if not expedition_results.is_empty():
		print("Expedition Results: %s" % expedition_results)
		# TODO: We will need a way to show these results to the player,
		# likely by modifying the EndOfYear_Popup.
	
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("DynastyManager: Year ended. Authority reset to %d." % current_jarl.max_authority)
	
	# Emit the signal so the EventManager can hear it.
	year_ended.emit()
	
func set_current_raid_target(data: SettlementData) -> void:
	current_raid_target = data
	# REMOVED: print("DynastyManager: Raid target set to %s" % data.resource_path)

func get_current_raid_target() -> SettlementData:
	var target = current_raid_target
	current_raid_target = null # Clear the target after getting it
	return target

func _save_jarl_data() -> void:
	if not current_jarl:
		push_error("DynastyManager: Cannot save, current_jarl is null.")
		return
		
	if current_jarl.resource_path.is_empty():
		current_jarl.resource_path = PLAYER_JARL_PATH
		
	var error = ResourceSaver.save(current_jarl, current_jarl.resource_path)
	if error != OK:
		# Using push_error to alert to critical save file failures
		push_error("DynastyManager: Failed to save Jarl data to %s. Error: %s" % [current_jarl.resource_path, error])
	# No success print needed for every save, keeps log clean

func award_renown(amount: int) -> void:
	if not current_jarl:
		push_error("DynastyManager: Cannot award renown, current Jarl is null.")
		return
	
	current_jarl.award_renown(amount)
	_save_jarl_data()
	jarl_stats_updated.emit(current_jarl)
	print("DynastyManager: Awarded %d renown.
Total: %d" % [amount, current_jarl.renown])

# --- NEW: Succession System Functions ---
func debug_kill_jarl() -> void:
	"""
	Public-facing debug function to immediately trigger succession.
	Bypasses all age and 'end_year' checks.
	"""
	print("DEBUG: debug_kill_jarl() called. Forcing succession...")
	_trigger_succession()


func _check_for_jarl_death() -> bool:
	"""Rolls for Jarl's death.
Returns true if Jarl died."""
	var jarl = get_current_jarl()
	var death_chance = 0.0
	
	if jarl.age > 80:
		death_chance = 0.5
	elif jarl.age > 65:
		death_chance = 0.25
	elif jarl.age > 50:
		death_chance = 0.1
	
	if randf() < death_chance:
		print("The Jarl has died at age %d!" % jarl.age)
		_trigger_succession()
		return true
	
	return false

func _trigger_succession() -> void:
	"""Manages the promotion of an heir and triggers the crisis event."""
	var old_jarl = current_jarl
	var heir = current_jarl.get_first_available_heir()
	
	if not heir:
		print("GAME OVER: The Jarl died with no available heir!")
		# TODO: Add game over logic
		get_tree().quit() # Placeholder
		return
	
	# Promote heir to Jarl
	var new_jarl = _promote_heir_to_jarl(heir, old_jarl)
	current_jarl.heirs.erase(heir) # Remove heir from list
	current_jarl = new_jarl
	
	# Trigger the event
	var succession_event_data = EventData.new() # Create a dummy event
	succession_event_data.event_id = "succession_crisis"
	EventManager._trigger_event(succession_event_data)

func _promote_heir_to_jarl(heir: JarlHeirData, predecessor: JarlData) -> JarlData:
	"""Creates a new JarlData resource from an heir."""
	var new_jarl = JarlData.new()
	new_jarl.display_name = heir.display_name
	new_jarl.age = heir.age
	new_jarl.command = heir.command
	new_jarl.stewardship = heir.stewardship
	new_jarl.learning = heir.learning
	new_jarl.prowess = heir.prowess
	new_jarl.traits = heir.traits
	
	# Calculate Legitimacy
	var new_legit = int(predecessor.legitimacy * 0.8) # Inherit 80%
	
	# Apply trait/skill penalties
	var penalty = (10 - new_jarl.get_effective_skill("stewardship")) * 2 # Example
	penalty += (10 - new_jarl.get_effective_skill("prowess")) # Example
	
	new_legit = max(0, new_legit - penalty)
	
	# Apply floor from Jelling Stone 
	new_legit = max(new_legit, minimum_inherited_legitimacy) 
	
	new_jarl.legitimacy = new_legit
	new_jarl.succession_debuff_years_remaining = 3 # Start the 3-year debuff
	
	return new_jarl

func _on_succession_choices_made(renown_choice: String, gold_choice: String) -> void:
	"""Applies the consequences of the succession crisis choices."""
	if renown_choice == "refuse":
		# Apply Renown Tax Consequence
		var setback_applied = false
		
		# --- THIS IS THE FIX ---
		# We iterate over our own 'loaded_legacy_upgrades' array,
		# not one from another scene.
		for upgrade in loaded_legacy_upgrades:
		# --- END FIX ---
			if not upgrade.is_purchased and upgrade.current_progress > 0:
				upgrade.current_progress = max(0, upgrade.current_progress - 2) # -2 Progress
				setback_applied = true
				break
		if setback_applied:
			print("A legacy project has lost progress!")
	
	if gold_choice == "refuse":
		# Apply Gold Tax Consequence 
		if SettlementManager.current_settlement:
			SettlementManager.current_settlement.has_stability_debuff = true
			print("Settlement instability debuff applied!")
	
	# This is the "all-clear" signal
	EventBus.event_system_finished.emit()

# --- END NEW ---

--- SCRIPT: res://autoload/EventBus.gd ---
# res://autoload/EventBus.gd
#
# A global Singleton (Autoload) that acts as a central "switchboard"
# for decoupled signal communication between major systems.

extends Node

# --- Build System Signals ---
# TODO: Connect this signal when implementing advanced building system
# @warning_ignore("unused_signal")
signal build_request_made(building_data: BuildingData, grid_position: Vector2i)

# --- Pathfinding Signals ---
signal pathfinding_grid_updated(grid_position: Vector2i)

# --- Treasury & Economy Signals (Phase 2) ---
signal treasury_updated(new_treasury: Dictionary)
signal purchase_successful(item_name: String)
signal purchase_failed(reason: String)

# --- Navigation Signals (Phase 3) ---
# MODIFIED: Now emits a string KEY name, not a full path.
signal scene_change_requested(scene_key: String)
signal world_map_opened()
signal raid_mission_started(target_type: String)

# --- Settlement Management Signals ---
signal settlement_loaded(settlement_data: SettlementData)

# --- Unit Management Signals ---
signal player_unit_died(unit: Node2D)

# --- NEW: RTS Command Signals (GDD Section 10) ---
# Emitted by SelectionBox.gd, consumed by RTSController.gd

# Emitted on left-click or drag-release
signal select_command(select_rect: Rect2, is_box_select: bool)

# Emitted on right-click on the ground
signal move_command(target_position: Vector2)

# Emitted on right-click on an enemy
signal attack_command(target_node: Node2D)

# --- NEW: Emitted on right-click-and-drag ---
signal formation_move_command(target_position: Vector2, direction_vector: Vector2)

# --- NEW: Building Cursor System Signals ---
# Emitted when a building is purchased and ready for cursor placement
signal building_ready_for_placement(building_data: BuildingData)

# Emitted when building placement is cancelled (should refund cost)
signal building_placement_cancelled(building_data: BuildingData)

# --- NEW: Event System Flow Control ---
signal event_system_finished()

# --- NEW: Succession Crisis System ---
signal succession_choices_made(renown_choice: String, gold_choice: String)

--- SCRIPT: res://autoload/EventManager.gd ---
# res://autoload/EventManager.gd
#
# Global singleton (Autoload) to manage the "Full Event System" (Phase 3b).
# This manager loads all events, checks their triggers,
# and displays them to the player.
extends Node

# Assign res://ui/Event_UI.tscn in the Autoload settings in Godot
@export var event_ui_scene: PackedScene
@export var succession_crisis_scene: PackedScene # Add this in the Inspector

var event_ui: EventUI
var available_events: Array[EventData] = []
var fired_unique_events: Array[String] = []

# Preload resources needed for consequences
const TRAIT_RIVAL = preload("res://data/traits/Trait_Rival.tres")

func _ready() -> void:
	# Defer initialization to ensure all Autoloads are ready
	call_deferred("initialize_event_system")

func initialize_event_system() -> void:
	"""Handles all initialization after the engine is stable."""
	if not event_ui_scene:
		push_error("EventManager: 'event_ui_scene' is not set in Autoload Inspector! Event system is disabled.")
		return
	
	# 1. Instance and add the UI
	event_ui = event_ui_scene.instantiate()
	add_child(event_ui)
	event_ui.choice_made.connect(_on_choice_made)
	
	# 2. Load all events
	_load_events_from_disk()
	
	# 3. Connect to the main game trigger
	if DynastyManager:
		DynastyManager.year_ended.connect(_on_year_ended)
	else:
		push_error("EventManager: DynastyManager Autoload is not found! Cannot connect year_ended signal.")

func _load_events_from_disk() -> void:
	"""Scans the res://data/events/ directory for EventData resources."""
	available_events.clear()
	var dir = DirAccess.open("res://data/events/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var path = "res://data/events/" + file_name
				var event_data = load(path) as EventData 
				if event_data:
					available_events.append(event_data)
				else:
					push_warning("EventManager: Failed to load event resource from %s." % path)
			file_name = dir.get_next()
	print("EventManager: Loaded %d events from disk." % available_events.size())

func _on_year_ended() -> void:
	"""Triggered by DynastyManager, this checks all events."""
	print("EventManager: Checking event triggers for end of year...")
	
	var event_was_triggered: bool = _check_event_triggers()
	
	# Status print remains for end-of-year summary
	if event_was_triggered:
		print("EventManager: An event was recognized and triggered.")
	else:
		print("EventManager: No events were recognized or triggered this year.")
	
	if not event_was_triggered:
		# No events were found, so we signal the "all-clear" immediately.
		EventBus.event_system_finished.emit()

func _check_event_triggers() -> bool:
	"""
	Checks all events. Returns true if an event was triggered, false otherwise.
	"""
	var jarl = DynastyManager.get_current_jarl()
	if not jarl:
		push_error("EventManager: Cannot check events, Jarl data is null.")
		return false

	for event in available_events:
		if _check_conditions(event, jarl):
			_trigger_event(event)
			return true # An event was triggered
	
	return false # No events were triggered

func _check_conditions(event: EventData, jarl: JarlData) -> bool:
	"""Checks if a single event's trigger conditions are met."""
	
	# Check if unique and already fired
	if event.is_unique and event.event_id in fired_unique_events:
		return false
		
	# Check prerequisites
	for pre_id in event.prerequisites:
		if not pre_id in fired_unique_events:
			return false 
			
	# Check Jarl stats
	if event.min_renown > -1 and jarl.renown < event.min_renown:
		return false
	if event.min_stewardship > -1 and jarl.get_effective_skill("stewardship") < event.min_stewardship:
		return false
	
	# Check Jarl traits
	if not event.must_have_trait.is_empty() and not jarl.has_trait(event.must_have_trait):
		return false
	if not event.must_not_have_trait.is_empty() and jarl.has_trait(event.must_not_have_trait):
		return false
	
	# Check Dynasty state
	if event.min_available_heirs > -1 and jarl.get_available_heir_count() < event.min_available_heirs:
		return false
	
	# Check World state
	if event.min_conquered_regions > -1 and jarl.conquered_regions.size() < event.min_conquered_regions:
		return false
		
	# Check base chance
	if randf() > event.base_chance:
		return false
	
	# All conditions passed
	print("EventManager: Conditions MET for event '%s'" % event.event_id)
	return true

func _trigger_event(event: EventData) -> void:
	"""Pauses the game and displays the event UI."""
	
	# --- NEW: Special Case for Succession ---
	if event.event_id == "succession_crisis":
		if not succession_crisis_scene:
			push_error("EventManager: succession_crisis_scene is not set!")
			return
		
		var crisis_ui = succession_crisis_scene.instantiate()
		add_child(crisis_ui)
		
		var jarl = DynastyManager.get_current_jarl()
		var settlement = SettlementManager.current_settlement
		crisis_ui.display_crisis(jarl, settlement)
		
		# The crisis UI will emit 'succession_choices_made' on its own
		# and then call EventBus.event_system_finished when it closes.
	else:
	# --- END NEW ---
		print("EventManager: Triggering event '%s'" % event.event_id)
		
		get_tree().paused = true
		event_ui.display_event(event)
	
	if event.is_unique:
		fired_unique_events.append(event.event_id)

func _on_choice_made(event: EventData, choice: EventChoice) -> void:
	"""
	Called by the EventUI.
	Applies consequences, unpauses, and signals the "all-clear".
	"""
	
	if choice:
		print("EventManager: Player chose '%s' (%s) for event '%s'" % [choice.choice_text, choice.effect_key, event.event_id])
		_apply_event_consequences(event, choice)
	else:
		print("EventManager: Event '%s' closed with no choice." % event.event_id)
		
	get_tree().paused = false
	
	# This is the "all-clear" signal.
	EventBus.event_system_finished.emit()

func _apply_event_consequences(event: EventData, choice: EventChoice) -> void:
	"""
	This is the "logic" part of the event system.
	It matches the event_id and choice.effect_key to apply results.
	"""
	
	if event.event_id == "ambitious_heir_1":
		
		if choice.effect_key == "accept":
			var success = DynastyManager.spend_renown(100)
			if not success:
				push_warning("EventManager: Tried to spend 100 Renown for event, but failed.")
			
		elif choice.effect_key == "decline":
			var heir = DynastyManager.get_current_jarl().get_first_available_heir()
			if heir and TRAIT_RIVAL:
				DynastyManager.add_trait_to_heir(heir, TRAIT_RIVAL)
			else:
				push_warning("EventManager: Could not apply 'Rival' trait. No heir or trait not loaded.")

--- SCRIPT: res://autoload/PauseManager.gd ---
# res://autoload/PauseManager.gd
#
# This is a global autoload script that listens for the 'ui_pause'
# input to pause the game.
# It is only responsible for *pausing* and instancing the menu.
# The menu itself is responsible for unpausing.

extends Node

# We will assign this scene in the Project Settings Autoload menu
@export var pause_menu_scene: PackedScene


func _unhandled_input(event: InputEvent) -> void:
	# We only listen for the pause input
	# We only pause if the game is NOT already paused
	if event.is_action_pressed("ui_pause") and not get_tree().paused:
		
		if not pause_menu_scene:
			push_error("PauseManager: 'pause_menu_scene' is not set in Project Settings!")
			return
		
		# Consume the event so nothing else (like the menu) can use it
		get_viewport().set_input_as_handled()
		
		# Pause the game
		get_tree().paused = true
		
		# Create the menu
		var menu = pause_menu_scene.instantiate()
		get_tree().root.add_child(menu)

--- SCRIPT: res://autoload/ProjectilePoolManager.gd ---
# res://autoload/ProjectilePoolManager.gd
#
# Manages an object pool of projectiles to avoid the performance
# cost of instantiating and freeing them during gameplay.

extends Node

# Set this to the scene your game uses for projectiles.
@export var projectile_scene: PackedScene = preload("res://scenes/effects/Projectile.tscn")
@export var initial_pool_size: int = 50

# This array holds the projectiles that are "on the shelf" and ready to be used.
var available_projectiles: Array[Projectile] = []

# This node just holds all projectiles so they exist in the scene tree.
var projectile_container: Node

func _ready() -> void:
	projectile_container = Node.new()
	projectile_container.name = "ProjectileContainer"
	add_child(projectile_container)
	
	# Pre-load the pool with an initial batch of projectiles
	for i in range(initial_pool_size):
		var p = projectile_scene.instantiate() as Projectile
		projectile_container.add_child(p)
		p.return_to_pool() # Deactivate it and move it off-screen
		available_projectiles.append(p)
	
	print("ProjectilePoolManager: Initialized with %d projectiles." % initial_pool_size)

func get_projectile() -> Projectile:
	"""
	Retrieves an available projectile from the pool.
	If the pool is empty, it creates a new one.
	"""
	if not available_projectiles.is_empty():
		# Get a projectile from the "shelf"
		return available_projectiles.pop_front()
	else:
		# The "shelf" is empty. This isn't ideal, but we can
		# create a new one on-the-fly to prevent errors.
		push_warning("ProjectilePoolManager: Pool depleted! Creating a new projectile.")
		var p = projectile_scene.instantiate() as Projectile
		projectile_container.add_child(p)
		return p

func return_projectile(projectile: Projectile) -> void:
	"""
	Returns a projectile to the pool, making it available again.
	"""
	projectile.return_to_pool()
	available_projectiles.append(projectile)

--- SCRIPT: res://autoload/SceneManager.gd ---
# res://autoload/SceneManager.gd
#
# A global Singleton (Autoload) that handles all scene transitions.
# It listens for a signal on the EventBus and performs the change.
# This decouples all scenes from each other, preventing circular dependencies.
extends Node

# --- Phase 1 Refactor: PackedScene Exports ---
# Assign these in the Godot Editor (Project > Project Settings > Autoload > SceneManager)
@export var settlement_scene: PackedScene
@export var world_map_scene: PackedScene
@export var raid_mission_scene: PackedScene
# ---------------------------------------------

func _ready() -> void:
	# Connect to the EventBus signal that all other scenes will use 
	EventBus.scene_change_requested.connect(_on_scene_change_requested)

func _on_scene_change_requested(scene_key: String) -> void:
	if scene_key.is_empty():
		push_error("SceneManager: scene_change_requested received an empty key.")
		return

	var target_scene: PackedScene = null
	
	# Match the string key to the exported PackedScene
	match scene_key.to_lower():
		"settlement":
			target_scene = settlement_scene
		"world_map":
			target_scene = world_map_scene
		"raid_mission":
			target_scene = raid_mission_scene
		_:
			push_error("SceneManager: Unknown scene key '%s'. No scene transition will occur." % scene_key)
			return

	if not target_scene:
		push_error("SceneManager: Scene key '%s' is valid, but its PackedScene is not assigned in the Inspector!" % scene_key)
		return

	print("SceneManager: Changing to scene: %s (Key: %s)" % [target_scene.resource_path, scene_key])
	var error = get_tree().change_scene_to_packed(target_scene)
	
	if error != OK:
		push_error("SceneManager: Failed to change to scene '%s'. Error code: %s" % [target_scene.resource_path, error])

--- SCRIPT: res://autoload/SettlementManager.gd ---
# res://autoload/SettlementManager.gd
#
# A global Singleton (Autoload) that acts as a pure data manager
# for the player's current settlement.
#
# --- REFACTORED (The "Proper Fix") ---
# This script is now data-only and has no scene dependencies.
# All node instantiation, container management, and AStarGrid logic
# has been moved to the scenes that need it (e.g., SettlementBridge.gd
# and RaidMission.gd).

extends Node

var current_settlement: SettlementData

# --- NEW: Scene Registry ---
# These variables hold references to nodes in the *active* scene
# (e.g., SettlementBridge or RaidMission).
# This lets us fix the "buildings in raid" bug while minimizing
# refactoring of other scripts, which can still call SettlementManager.
var active_astar_grid: AStarGrid2D = null
var active_building_container: Node2D = null
# ---------------------------


# --- Scene Management ---

func register_active_scene_nodes(grid: AStarGrid2D, container: Node2D) -> void:
	"""
	Called by the active scene (e.g., SettlementBridge) to register
	its local pathfinding grid and building container.
	"""
	if not is_instance_valid(grid) or not is_instance_valid(container):
		push_error("SettlementManager: Failed to register invalid scene nodes.")
		return
	active_astar_grid = grid
	active_building_container = container
	print("SettlementManager: Active scene nodes registered.")

func unregister_active_scene_nodes() -> void:
	"""Called by the active scene when it exits to clear references."""
	active_astar_grid = null
	active_building_container = null
	print("SettlementManager: Active scene nodes unregistered.")


# --- Settlement Data ---

func load_settlement(data: SettlementData) -> void:
	if not data:
		push_error("SettlementManager: load_settlement called with null data.")
		return
	
	current_settlement = data
	
	if not current_settlement.resource_path or current_settlement.resource_path.is_empty():
		if data.resource_path and not data.resource_path.is_empty():
			current_settlement.resource_path = data.resource_path
		else:
			current_settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
			# Changed print to push_warning for setting fallback path
			push_warning("SettlementManager: Set fallback resource_path to: %s" % current_settlement.resource_path)
	
	print("SettlementManager: Settlement data loaded - %s" % current_settlement.resource_path)
	print("SettlementManager: Garrison units: %s" % current_settlement.garrisoned_units)
	
	EventBus.settlement_loaded.emit(current_settlement)


func save_settlement() -> void:
	if not current_settlement:
		push_error("Attempted to save a null settlement.")
		return
	
	if current_settlement.resource_path and not current_settlement.resource_path.is_empty():
		if not current_settlement.get_script():
			current_settlement.set_script(preload("res://data/settlements/SettlementData.gd"))
		
		var error = ResourceSaver.save(current_settlement, current_settlement.resource_path)
		if error == OK:
			print("Settlement data saved successfully to: %s" % current_settlement.resource_path)
		else:
			push_error("Failed to save settlement data to path: %s. Error code: %s" % [current_settlement.resource_path, error])
	else:
		push_warning("SettlementData has no resource_path, cannot save settlement.")

func has_current_settlement() -> bool:
	return current_settlement != null


# --- Treasury & Economy ---

func deposit_resources(loot: Dictionary) -> void:
	if not current_settlement: return
	for resource_type in loot:
		if current_settlement.treasury.has(resource_type):
			current_settlement.treasury[resource_type] += loot[resource_type]
		else:
			current_settlement.treasury[resource_type] = loot[resource_type]
	EventBus.treasury_updated.emit(current_settlement.treasury)
	# Removed print("Loot deposited. New treasury: %s" % current_settlement.treasury)
	save_settlement()

func attempt_purchase(item_cost: Dictionary) -> bool:
	if not current_settlement: return false
	
	for resource_type in item_cost:
		if not current_settlement.treasury.has(resource_type) or \
		current_settlement.treasury[resource_type] < item_cost[resource_type]:
			var reason = "Insufficient %s" % resource_type
			print("Purchase failed. %s." % reason)
			EventBus.purchase_failed.emit(reason)
			return false
			
	for resource_type in item_cost:
		current_settlement.treasury[resource_type] -= item_cost[resource_type]
	
	EventBus.treasury_updated.emit(current_settlement.treasury)
	EventBus.purchase_successful.emit("Unnamed Item") # Placeholder
	# Removed print("Purchase successful. New treasury: %s" % current_settlement.treasury)
	return true

# --- MODIFIED: Added Stewardship Bonus Logic ---
func calculate_payout() -> Dictionary:
	if not current_settlement:
		return {}

	var total_payout: Dictionary = {}
	
	# 1. Get the Jarl's stewardship bonus
	var stewardship_bonus: float = 1.0
	var jarl = DynastyManager.get_current_jarl()
	if jarl:
		# Logic: +5% bonus for every point of stewardship above 10
		var stewardship_skill = jarl.get_effective_skill("stewardship")
		stewardship_bonus = 1.0 + (stewardship_skill - 10) * 0.05
		# Ensure bonus can't be negative (e.g., stewardship below 10)
		stewardship_bonus = max(0.5, stewardship_bonus) # Cap negative bonus at -50%
		# Removed: print("Jarl Stewardship: %d. Payout Multiplier: %s" % [stewardship_skill, stewardship_bonus])
	else:
		push_warning("SettlementManager: Could not get Jarl to calculate stewardship bonus.")

	# 2. Calculate payout for each building
	for building_entry in current_settlement.placed_buildings:
		var building_data: BuildingData = load(building_entry["resource_path"])
		if building_data is EconomicBuildingData:
			var eco_data: EconomicBuildingData = building_data
			var resource_type: String = eco_data.resource_type
			
			if not total_payout.has(resource_type):
				total_payout[resource_type] = 0
			
			# 3. Apply the bonus and round to the nearest integer
			var base_payout = eco_data.fixed_payout_amount
			var final_payout = int(round(base_payout * stewardship_bonus))
			
			total_payout[resource_type] += final_payout

	# --- NEW: Add income from Conquered Regions ---
	if jarl:
		for region_path in jarl.conquered_regions:
			var region_data: WorldRegionData = load(region_path)
			if not region_data:
				push_warning("Could not load conquered region data from path: %s" % region_path)
				continue
			
			for resource_type in region_data.yearly_income:
				var income_amount = region_data.yearly_income[resource_type]
				if not total_payout.has(resource_type):
					total_payout[resource_type] = 0
				
				# Apply stewardship bonus to region income as well
				var final_income = int(round(income_amount * stewardship_bonus))
				total_payout[resource_type] += final_income
				# Removed: print("Added %d %s from conquered region: %s" % [final_income, resource_type, region_data.display_name])
	# --- END NEW ---

	# --- NEW: Apply Stability Debuff ---
	if jarl:
		if current_settlement.has_stability_debuff:
			if total_payout.has("gold"):
				total_payout["gold"] = int(total_payout["gold"] * 0.75) # -25% Gold income
			# We also need to clear the debuff after it's applied
			current_settlement.has_stability_debuff = false
			save_settlement()
	# --- END NEW ---

	# Removed: if not total_payout.is_empty(): print("Calculated fixed payout (with bonus): %s" % total_payout)
	return total_payout

func recruit_unit(unit_data: UnitData) -> void:
	if not current_settlement:
		push_error("Cannot recruit unit: no current settlement")
		return
	
	if not unit_data:
		push_error("Cannot recruit: UnitData is null")
		return
	
	var unit_path: String = unit_data.resource_path
	if unit_path.is_empty():
		push_error("Cannot recruit: UnitData has no resource_path")
		return
	
	if current_settlement.garrisoned_units.has(unit_path):
		current_settlement.garrisoned_units[unit_path] += 1
	else:
		current_settlement.garrisoned_units[unit_path] = 1
	
	print("Recruited %s. Garrison count: %d" % [unit_data.display_name, current_settlement.garrisoned_units[unit_path]])
	
	save_settlement()
	EventBus.purchase_successful.emit(unit_data.display_name)


# --- Building & Pathfinding (Delegated) ---

func get_active_grid_cell_size() -> Vector2:
	"""
	Returns the cell size of the currently registered AStarGrid.
	Used by Base_Building to scale itself correctly.
	"""
	if is_instance_valid(active_astar_grid):
		return active_astar_grid.cell_size
	
	# Fallback in case no grid is registered
	push_warning("SettlementManager: get_active_grid_cell_size() called, but no grid is active. Returning default (32,32).")
	return Vector2(32, 32)

func place_building(building_data: BuildingData, grid_position: Vector2i) -> BaseBuilding:
	if not is_instance_valid(active_astar_grid) or not is_instance_valid(active_building_container):
		push_error("Place building failed: Active scene nodes are not registered.")
		return null

	if not building_data or not building_data.scene_to_spawn:
		push_error("Build request failed: BuildingData or scene_to_spawn is null.")
		return null
	
	if not is_placement_valid(grid_position, building_data.grid_size):
		push_error("Cannot place building at %s: position is invalid, out of bounds, or occupied." % grid_position)
		return null
	
	var new_building: BaseBuilding = building_data.scene_to_spawn.instantiate()
	new_building.data = building_data
	
	# Calculate the center position of the building's entire footprint
	var world_pos_top_left: Vector2 = Vector2(grid_position) * active_astar_grid.cell_size
	var building_footprint_size: Vector2 = Vector2(building_data.grid_size) * active_astar_grid.cell_size
	var building_center_offset: Vector2 = building_footprint_size / 2.0
	new_building.global_position = world_pos_top_left + building_center_offset
	
	active_building_container.add_child(new_building)
	
	if building_data.blocks_pathfinding:
		for x in range(building_data.grid_size.x):
			for y in range(building_data.grid_size.y):
				var cell_pos = grid_position + Vector2i(x, y)
				if _is_cell_within_bounds(cell_pos): # Use local helper
					active_astar_grid.set_point_solid(cell_pos, true)
		
		active_astar_grid.update()
		EventBus.pathfinding_grid_updated.emit(grid_position)
		
	return new_building

func is_placement_valid(grid_position: Vector2i, building_size: Vector2i) -> bool:
	if not is_instance_valid(active_astar_grid):
		push_error("is_placement_valid: AStarGrid is not registered!")
		return false
	
	for x in range(building_size.x):
		for y in range(building_size.y):
			var cell_pos = grid_position + Vector2i(x, y)
			
			if not _is_cell_within_bounds(cell_pos):
				return false
			
			if active_astar_grid.is_point_solid(cell_pos):
				return false
	
	return true

func _is_cell_within_bounds(grid_position: Vector2i) -> bool:
	if not is_instance_valid(active_astar_grid):
		return false
	
	var bounds = active_astar_grid.region
	return grid_position.x >= bounds.position.x and grid_position.x < bounds.end.x and \
		   grid_position.y >= bounds.position.y and grid_position.y < bounds.end.y

func get_astar_path(start_pos: Vector2, end_pos: Vector2, allow_partial_path: bool = false) -> PackedVector2Array:
	if not is_instance_valid(active_astar_grid):
		push_error("AStarGrid is not registered!")
		return PackedVector2Array()

	if active_astar_grid.region.size.x <= 0 or active_astar_grid.region.size.y <= 0:
		push_error("AStarGrid region is invalid: %s." % active_astar_grid.region)
		return PackedVector2Array()
	
	var start_id: Vector2i = Vector2i(start_pos / active_astar_grid.cell_size)
	var end_id: Vector2i = Vector2i(end_pos / active_astar_grid.cell_size)
	
	if not _is_cell_within_bounds(start_id):
		push_error("Start position (%s) -> grid_id (%s) is out of bounds." % [start_pos, start_id])
		return PackedVector2Array()
	
	if not _is_cell_within_bounds(end_id):
		# Don't error if the end_id is out of bounds, a partial path might still work
		pass
	
	# Pass the allow_partial_path flag to the real AStarGrid2D function
	return active_astar_grid.get_point_path(start_id, end_id, allow_partial_path)

func set_astar_point_solid(grid_position: Vector2i, solid: bool) -> void:
	if not is_instance_valid(active_astar_grid):
		push_warning("AStarGrid not registered")
		return
	
	if not _is_cell_within_bounds(grid_position):
		push_warning("Grid position %s is out of bounds" % grid_position)
		return
	
	active_astar_grid.set_point_solid(grid_position, solid)

--- SCRIPT: res://data/buildings/Base_Building.gd ---
# res://data/buildings/Base_Building.gd
#
# This script is attached to the Base_Building.tscn scene.
# It procedurally creates its own visual nodes
# and instances its AI component from its 'data' resource.
class_name BaseBuilding
extends StaticBody2D

signal building_destroyed(building: BaseBuilding)

@export var data: BuildingData
var current_health: int = 100

# Node refs (will be created in _ready)
var background: ColorRect
var label: Label
var collision_shape: CollisionShape2D
var hitbox_area: Area2D # --- NEW ---

# Development visual enhancements
var health_bar: ProgressBar
var border_rect: ColorRect

# AI component (optional)
var attack_ai: Node = null # Use generic Node, could be AttackAI or DefensiveAI

func _ready() -> void:
	if not data:
		push_warning("BaseBuilding: Node is missing its 'BuildingData' resource. Cannot initialize.")
		return
	
	current_health = data.max_health
	
	# --- Create core nodes ---
	collision_shape = CollisionShape2D.new()
	collision_shape.shape = RectangleShape2D.new()
	add_child(collision_shape)
	
	background = ColorRect.new()
	label = Label.new()
	background.add_child(label)
	add_child(background)
	# -------------------------
	
	# --- NEW: Create the Hitbox ---
	_create_hitbox()
	# --- END NEW ---
	
	_apply_data_and_scale()
	_create_dev_visuals()
	_setup_defensive_ai()

# --- NEW FUNCTION ---
func _create_hitbox() -> void:
	"""Creates an Area2D child to act as a detectable hitbox for projectiles."""
	hitbox_area = Area2D.new()
	hitbox_area.name = "Hitbox"
	
	# --- MODIFIED: Set Correct Layer ---
	# Check if this is a player building or enemy building
	# This assumes the Base_Building node itself has its layer set correctly
	if self.collision_layer & (1 << 0): # Layer 1 (Player Building)
		hitbox_area.collision_layer = 1 << 0
	elif self.collision_layer & (1 << 3): # Layer 4 (Enemy Building)
		hitbox_area.collision_layer = 1 << 3
	else:
		push_warning("BaseBuilding: %s on unhandled collision layer %s. Setting hitbox to Layer 1." % [name, self.collision_layer])
		hitbox_area.collision_layer = 1 << 0 # Default to Player Building
	# --- END MODIFIED ---
	
	hitbox_area.collision_mask = 0 # Doesn't need to detect anything
	
	hitbox_area.monitoring = false # Doesn't need to detect bodies or areas
	hitbox_area.monitorable = true # CAN BE detected by other areas (projectiles)
	
	# Create a shape for the hitbox
	var hitbox_shape = CollisionShape2D.new()
	hitbox_shape.shape = RectangleShape2D.new()
	hitbox_area.add_child(hitbox_shape)
	
	add_child(hitbox_area)
# --- END NEW FUNCTION ---

func _apply_data_and_scale() -> void:
	if not SettlementManager:
		push_error("BaseBuilding: SettlementManager not ready. Cannot scale '%s'." % data.display_name)
		return
	
	var cell_size: Vector2 = SettlementManager.get_active_grid_cell_size()
	if cell_size.x <= 0 or cell_size.y <= 0:
		push_error("BaseBuilding: SettlementManager returned invalid cell_size (%s). Cannot scale '%s'." % [cell_size, data.display_name])
		return
		
	var target_size: Vector2 = Vector2(data.grid_size) * cell_size
	
	if target_size.x <= 0 or target_size.y <= 0:
		push_warning("BaseBuilding: '%s' has a grid_size of %s, resulting in an invalid target_size." % [data.display_name, data.grid_size])
		return

	background.custom_minimum_size = target_size
	background.position = -target_size / 2.0
	
	_apply_visual_styling(target_size)

	if collision_shape and collision_shape.shape is RectangleShape2D:
		collision_shape.shape.size = target_size
	
	# --- NEW: Scale the hitbox shape ---
	if hitbox_area:
		var hitbox_shape = hitbox_area.get_child(0) as CollisionShape2D
		if hitbox_shape and hitbox_shape.shape is RectangleShape2D:
			hitbox_shape.shape.size = target_size
	# --- END NEW ---

# --- THIS IS THE FIX ---
func take_damage(amount: int, _attacker: Node2D = null) -> void:
# --- END FIX ---
	
	current_health = max(0, current_health - amount)
	
	if health_bar:
		health_bar.value = current_health
	
	if current_health == 0:
		die()

func die() -> void:
	print("%s has been destroyed." % data.display_name)
	
	_show_destruction_effect()
	
	building_destroyed.emit(self)
	
	remove_from_group("enemy_buildings")
	
	print("Building %s queued for removal from scene" % data.display_name)
	queue_free()

func _show_destruction_effect() -> void:
	var tween = create_tween()
	
	tween.parallel().tween_property(self, "scale", Vector2(0.1, 0.1), 0.3)
	tween.parallel().tween_property(self, "modulate", Color.TRANSPARENT, 0.3)
	tween.parallel().tween_property(self, "rotation", randf() * TAU, 0.3)

func _apply_visual_styling(target_size: Vector2) -> void:
	label.text = data.display_name
	label.custom_minimum_size = target_size
	
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
	
	if target_size.x < 64:
		label.add_theme_font_size_override("font_size", 10)
	elif target_size.x < 128:
		label.add_theme_font_size_override("font_size", 12)
	else:
		label.add_theme_font_size_override("font_size", 14)
	
	_apply_color_coding()

func _apply_color_coding() -> void:
	var base_color: Color
	
	if data.dev_color != Color.TRANSPARENT and data.dev_color != Color.GRAY:
		base_color = data.dev_color
	else:
		if data.is_defensive_structure:
			base_color = Color.CRIMSON * 0.8
		elif data.is_player_buildable:
			base_color = Color.ROYAL_BLUE * 0.8
		else:
			base_color = Color.GRAY * 0.8
	
	background.color = base_color

func _create_dev_visuals() -> void:
	if not data:
		return
		
	var target_size: Vector2 = Vector2(data.grid_size) * SettlementManager.get_active_grid_cell_size()
	
	if data.is_defensive_structure:
		_create_border(target_size)
	
	_create_health_bar(target_size)

func _create_border(target_size: Vector2) -> void:
	border_rect = ColorRect.new()
	border_rect.color = Color.DARK_RED
	border_rect.custom_minimum_size = target_size + Vector2(4, 4)
	border_rect.position = -border_rect.custom_minimum_size / 2.0
	add_child(border_rect)
	move_child(border_rect, 0)

func _create_health_bar(target_size: Vector2) -> void:
	health_bar = ProgressBar.new()
	health_bar.custom_minimum_size = Vector2(target_size.x, 6)
	health_bar.position = Vector2(-target_size.x/2, -target_size.y/2 - 10)
	health_bar.max_value = data.max_health
	health_bar.value = current_health
	
	health_bar.modulate = Color.WHITE
	add_child(health_bar)

# === DEFENSIVE AI SETUP ===

func _setup_defensive_ai() -> void:
	"""Initialize AI systems for defensive buildings"""
	if not data or not data.is_defensive_structure:
		return
	
	# --- MODIFIED: Load AI from data, not hard-coded ---
	if not data.ai_component_scene:
		print("BaseBuilding: '%s' is defensive but has no ai_component_scene assigned." % data.display_name)
		return
		
	attack_ai = data.ai_component_scene.instantiate()
	if not attack_ai:
		push_error("BaseBuilding: Failed to instantiate ai_component_scene for %s" % data.display_name)
		return
	# --- END MODIFICATION ---
	
	add_child(attack_ai)
	
	# Configure AI from building data
	# We must check for methods/properties since attack_ai is a generic Node
	if attack_ai.has_method("configure_from_data"):
		attack_ai.configure_from_data(data)
	
	# For defensive buildings, the target mask is set in Base_Building.gd
	var player_collision_mask: int = 1 << 1  # Layer 2 (bit position 1)
	
	if attack_ai.has_method("set_target_mask"):
		attack_ai.set_target_mask(player_collision_mask)
	
	# Connect AI signals for feedback (optional)
	if attack_ai.has_signal("attack_started"):
		attack_ai.attack_started.connect(_on_ai_attack_started)
	if attack_ai.has_signal("attack_stopped"):
		attack_ai.attack_stopped.connect(_on_ai_attack_stopped)

func _on_ai_attack_started(_target: Node2D) -> void:
	pass

func _on_ai_attack_stopped() -> void:
	pass

--- SCRIPT: res://data/buildings/BuildingData.gd ---
# res://data/buildings/BuildingData.gd
#
# Defines the core data for any building in the game.
#
# --- MODIFIED: Added 'class_name BuildingData' ---

class_name BuildingData
extends Resource

## The name displayed in the UI (e.g., "Stone Wall", "Watchtower").
@export var display_name: String = "New Building"

## The scene that will be instanced when this building is placed.
@export var scene_to_spawn: PackedScene

## The icon shown in the build menu.
@export var icon: Texture2D

## Texture shown on screen
@export var building_texture: Texture2D

## The cost in 'Resources' (e.g., wood, gold) to build this.
@export var build_cost: Dictionary

## The building's maximum hit points.
@export var max_health: int = 100

## If true, this building blocks enemy pathfinding.
@export var blocks_pathfinding: bool = true

## The size of the building on the AStarGrid2D.
@export var grid_size: Vector2i = Vector2i.ONE

## Development visual color for the building rectangle.
@export var dev_color: Color = Color.GRAY

## If true, this building will appear in the player's Storefront UI.
@export var is_player_buildable: bool = false

@export_group("Defensive Stats")
## If true, this building can attack enemies (e.g., Watchtower).
@export var is_defensive_structure: bool = false

## Damage dealt per attack (if defensive).
@export var attack_damage: int = 5

## Range in pixels (if defensive).
@export var attack_range: float = 200.0

## Attacks per second (if defensive).
@export var attack_speed: float = 1.0

## An optional AI scene to instance (e.g., for defensive buildings)
@export var ai_component_scene: PackedScene

## The projectile scene to spawn when this building attacks (for defensive structures).
@export var projectile_scene: PackedScene

## The speed of the projectile, in pixels per second.
@export var projectile_speed: float = 400.0

--- SCRIPT: res://data/buildings/EconomicBuildingData.gd ---
# res://data/buildings/EconomicBuildingData.gd
extends BuildingData
class_name EconomicBuildingData

@export_group("Economic Stats")
## The type of resource this building generates (e.g., "wood", "food", "gold").
@export var resource_type: String = "wood"

## The fixed amount of resources generated after each successful attack.
@export var fixed_payout_amount: int = 10

## The maximum amount of the resource that can be stored before collection.
@export var storage_cap: int = 100

--- SCRIPT: res://data/characters/JarlData.gd ---
# res://data/characters/JarlData.gd
#
# Defines the persistent data for a Jarl character in Viking Dynasty.
# This resource stores all the attributes that persist across the dynasty layer.
# GDD Ref: Section 2.A (Macro Layer), Appendix A.2 (Renown & Succession Loop)

class_name JarlData
extends Resource

## The Jarl's name displayed in the UI
@export var display_name: String = "New Jarl"

## The Jarl's portrait/icon for the UI
@export var portrait: Texture2D

## The Jarl's age in years
@export var age: int = 25

## The Jarl's gender (affects marriage and succession options)
@export var gender: String = "Male"  # "Male", "Female"


@export_group("Dynasty & Authority")
## Total Renown accumulated by this Jarl (persistent XP/Legacy score)
@export var renown: int = 0

## Current Renown Tier (determines Authority cap per year)
## Tiers: 0="Petty Jarl", 1="High Jarl", 2="Kingmaker", etc.
@export var renown_tier: int = 0

## Authority remaining for this year (action points for Macro layer)
@export var current_authority: int = 3

## Maximum Authority this Jarl can generate per year (based on Renown Tier)
@export var max_authority: int = 3

## Years since last offensive action (for Renown Decay calculations)
@export var years_since_action: int = 0

## Legitimacy score affecting succession and stability (0-100 scale)
@export var legitimacy: int = 20

## Years remaining in succession debuff (reduced Authority generation)
@export var succession_debuff_years_remaining: int = 0

# --- Builder Pillar Upgrade Properties ---
## Bonus starting renown for all future heirs (from "Erect Jelling Stone")
@export var heir_starting_renown_bonus: int = 0

## An array of unique effect_keys for one-time legacy upgrades
## (e.g., ["UPG_TRELLEBORG", "UPG_JELLING_STONE"])
@export var purchased_legacy_upgrades: Array[String] = []

# --- Unifier Pillar Property ---
## An array of resource paths to WorldRegionData files that have been subjugated.
@export var conquered_regions: Array[String] = []

# --- NEW: Progenitor Pillar Property ---
## An array of resource paths to WorldRegionData files that are allied.
@export var allied_regions: Array[String] = []
# --- END NEW ---

@export_group("Base Skills")
## Combat leadership and personal prowess
@export var command: int = 10

## Diplomatic skills and charm
@export var diplomacy: int = 10

## Strategic planning and administration
@export var stewardship: int = 10

## Religious knowledge and mysticism
@export var learning: int = 10

## Personal combat skill and courage
@export var prowess: int = 10

## Ability to inspire and lead
@export var charisma: int = 10


@export_group("Traits")
## Array of JarlTraitData resources that modify the Jarl's abilities and story
@export var traits: Array[JarlTraitData] = []

## Legacy trait names for backward compatibility (can be removed later)
@export var legacy_trait_names: Array[String] = []

## Whether this Jarl is currently wounded (affects stats temporarily)
@export var is_wounded: bool = false

## Number of turns remaining for wound recovery
@export var wound_recovery_turns: int = 0

# --- HELPER FUNCTIONS ---
# These must be defined *before* the properties that use them.

## Get the number of *available* heirs (not on expedition, etc.)
func get_available_heir_count() -> int:
	var count = 0
	for heir in heirs:
		if heir and heir.status == JarlHeirData.HeirStatus.Available:
			count += 1
	return count

## Get the first available heir resource
func get_first_available_heir() -> JarlHeirData:
	for heir in heirs:
		if heir and heir.status == JarlHeirData.HeirStatus.Available:
			return heir
	return null

## Remove an heir from the dynasty (e.g., married off or lost)
## Returns false if the heir could not be found.
func remove_heir(heir_to_remove: JarlHeirData) -> bool:
	if heir_to_remove in heirs:
		heirs.erase(heir_to_remove)
		return true
	return false

## Check if the Jarl has at least one valid, available heir
func check_has_valid_heir() -> bool:
	return get_first_available_heir() != null

# --- END HELPER FUNCTIONS ---


@export_group("Family & Succession")
## The Jarl's spouse (if any)
@export var spouse_name: String = ""

## Array of JarlHeirData resources in order of succession priority
@export var heirs: Array[JarlHeirData] = []

## DEPRECATED: Replaced with a read-only property that calls check_has_valid_heir()
var has_valid_heir: bool:
	get:
		return check_has_valid_heir()

## DEPRECATED: Replaced with a read-only property that calls get_available_heir_count()
var children_count: int:
	get:
		return get_available_heir_count()


@export_group("Political Status")
## Current title/rank in the political hierarchy
@export var title: String = "Jarl"

## Number of vassals under this Jarl's rule
@export var vassal_count: int = 0

## Overall diplomatic reputation with other Jarls
@export var reputation: int = 0

## Whether this Jarl is currently in exile or displaced
@export var is_in_exile: bool = false


@export_group("Combat & Mission State")
## Whether the Jarl is currently leading a raid (affects vulnerability)
@export var is_on_mission: bool = false

## Number of battles this Jarl has fought
@export var battles_fought: int = 0

## Number of battles this Jarl has won
@export var battles_won: int = 0

## Total successful raids completed
@export var successful_raids: int = 0


## Get the effective skill value including trait modifiers
func get_effective_skill(skill_name: String) -> int:
	var base_value: int = 0
	
	match skill_name.to_lower():
		"command":
			base_value = command
		"diplomacy":
			base_value = diplomacy
		"stewardship":
			base_value = stewardship
		"learning":
			base_value = learning
		"prowess":
			base_value = prowess
		"charisma":
			base_value = charisma
		_:
			return 0
	
	# Apply trait modifiers
	var trait_modifier: int = 0
	for jarl_trait in traits:
		if jarl_trait == null:
			continue
		
		match skill_name.to_lower():
			"command":
				trait_modifier += jarl_trait.command_modifier
			"stewardship":
				trait_modifier += jarl_trait.stewardship_modifier
			"intrigue":
				trait_modifier += jarl_trait.intrigue_modifier
	
	return base_value + trait_modifier


## Add a trait to the Jarl (if not already present)
func add_trait(trait_data: JarlTraitData) -> void:
	if trait_data == null:
		return
	# Check if we already have this trait (by display name)
	for existing_trait in traits:
		if existing_trait != null and existing_trait.display_name == trait_data.display_name:
			return
	traits.append(trait_data)


## Check if Jarl has a specific trait by display name
func has_trait(trait_name: String) -> bool:
	for jarl_trait in traits:
		if jarl_trait != null and jarl_trait.display_name == trait_name:
			return true
	return false


## Get the Jarl's Authority cap based on Renown Tier (GDD reference)
func get_authority_cap() -> int:
	match renown_tier:
		0: return 3  # Petty Jarl
		1: return 5  # High Jarl
		2: return 7  # Kingmaker
		_: return 3 + renown_tier  # Future tiers


## Check if the Jarl can take an action (has Authority remaining)
func can_take_action(authority_cost: int = 1) -> bool:
	return current_authority >= authority_cost


## Spend Authority for an action
func spend_authority(cost: int = 1) -> bool:
	if can_take_action(cost):
		current_authority -= cost
		return true
	return false


## Award Renown for completing a major action
func award_renown(amount: int) -> void:
	renown += amount
	years_since_action = 0
	_update_renown_tier()


## Update Renown Tier based on current Renown
func _update_renown_tier() -> void:
	if renown >= 1000:
		renown_tier = 3
	elif renown >= 500:
		renown_tier = 2
	elif renown >= 200:
		renown_tier = 1
	else:
		renown_tier = 0


## Reset Authority at the start of a new year
func reset_authority() -> void:
	max_authority = get_authority_cap()
	
	if succession_debuff_years_remaining > 0:
		# Jarl is still consolidating power
		
		# 1. Calculate the legitimacy multiplier (e.g., 20 Legitimacy -> 0.2)
		var legit_multiplier = legitimacy / 100.0
		
		# 2. Calculate the authority to gain (e.g., 5 * 0.2 = 1.0)
		var authority_gained = int(round(max_authority * legit_multiplier))
		
		# 3. Enforce the "min 1" rule
		current_authority = max(1, authority_gained)
		
		# 4. Count down the debuff timer
		succession_debuff_years_remaining -= 1
		
	else:
		# The Jarl is stable. Reset to normal max.
		current_authority = max_authority


## Apply aging effects to the Jarl
func age_jarl(years: int = 1) -> void:
	age += years
	years_since_action += years
	
	# Apply age-related skill changes
	if age > 60:
		# Older Jarls lose prowess but gain wisdom
		prowess = max(1, prowess - 1)
		learning = min(20, learning + 1)


## Get a summary string of the Jarl's current status
func get_status_summary() -> String:
	var status_parts: Array[String] = []
	
	status_parts.append("Age: %d" % age)
	status_parts.append("Renown: %d (Tier %d)" % [renown, renown_tier])
	status_parts.append("Authority: %d/%d" % [current_authority, max_authority])
	
	if is_wounded:
		status_parts.append("WOUNDED (%d turns)" % wound_recovery_turns)
	
	if is_on_mission:
		status_parts.append("ON MISSION")
	
	return " | ".join(status_parts)


## Remove a trait by display name
func remove_trait(trait_name: String) -> bool:
	for i in range(traits.size()):
		if traits[i] != null and traits[i].display_name == trait_name:
			traits.remove_at(i)
			return true
	return false


## Get all trait names as a string array (for easy saving/display)
func get_trait_names() -> Array[String]:
	var trait_names: Array[String] = []
	for jarl_trait in traits:
		if jarl_trait != null:
			trait_names.append(jarl_trait.display_name)
	return trait_names

--- SCRIPT: res://data/characters/JarlHeirData.gd ---
# res://data/characters/JarlHeirData.gd
#
# Defines the data for a single heir in the dynasty.
# This allows heirs to be "spent" or go on missions.
class_name JarlHeirData
extends Resource

enum HeirStatus {
	Available,
	OnExpedition,
	MarriedOff,
	LostAtSea,
	Deceased
}

## The heir's name.
@export var display_name: String = "New Heir"

## The heir's age.
@export var age: int = 16

## The heir's current status.
@export var status: HeirStatus = HeirStatus.Available

## If on expedition, how many "years" remain.
@export var expedition_years_remaining: int = 0

# --- NEW: Heir Skills & Traits ---
@export_group("Skills & Traits")
@export var command: int = 8
@export var stewardship: int = 8
@export var learning: int = 8
@export var prowess: int = 8
@export var traits: Array[JarlTraitData] = []
# --- END NEW ---

--- SCRIPT: res://data/events/EventChoice.gd ---
# res://data/events/EventChoice.gd
#
# Defines a single choice for a story event.
# This resource is designed to be embedded within an EventData resource.
class_name EventChoice
extends Resource

## The text displayed on the button for this choice.
@export var choice_text: String = "Choice Text"

## A tooltip to show what the likely (or guaranteed) outcome is.
@export var tooltip_text: String = "Tooltip"

## A unique key (e.g., "CHOICE_ACCEPT", "CHOICE_DECLINE")
## The EventManager will use this key to apply the correct consequence.
@export var effect_key: String = ""

--- SCRIPT: res://data/events/EventData.gd ---
# res://data/events/EventData.gd
#
# Defines a single, self-contained story event.
# This resource is the core of the "Full Event System" (Phase 3b).
# It is designed to be created and edited by designers in the Inspector.
class_name EventData
extends Resource

# --- The nested "class EventChoice" definition has been REMOVED ---

@export_group("Event Display")
## The title of the event window.
@export var title: String = "An Event Occurs"
## The main story text for the event.
@export_multiline var description: String = "Event description..."
## An optional icon or portrait for the event.
@export var portrait: Texture2D

@export_group("Event Triggering")
## The unique ID for this event.
@export var event_id: String = "unique_event_id"
## If true, this event can only fire once per campaign.
@export var is_unique: bool = true
## The base chance (0.0 to 1.0) for this event to fire when its
## conditions are met.
@export var base_chance: float = 0.5
## An array of prerequisite event_ids that must have fired
## *before* this event can be considered.
@export var prerequisites: Array[String] = []

@export_group("Event Conditions")
## Conditions related to the Jarl's stats.
@export var min_stewardship: int = -1
@export var min_command: int = -1
@export var min_prowess: int = -1
@export var min_renown: int = -1
## Conditions related to the Jarl's traits.
@export var must_have_trait: String = ""
@export var must_not_have_trait: String = ""
## Conditions related to the dynasty.
@export var min_available_heirs: int = -1
## Conditions related to the game world.
@export var min_conquered_regions: int = -1

@export_group("Event Choices")
## The array of choices to present to the player.
## This now correctly references the external EventChoice resource.
@export var choices: Array[EventChoice] = []

--- SCRIPT: res://data/legacy/LegacyUpgradeData.gd ---
# res://data/legacy/LegacyUpgradeData.gd
#
# Defines a permanent, one-time dynasty upgrade.
# These are purchased in the "Legacy" tab of the Storefront
# and cost Renown and Authority.
class_name LegacyUpgradeData
extends Resource

## The name displayed in the Storefront UI.
@export var display_name: String = "New Legacy Upgrade"

## The icon shown next to the upgrade name in the UI.
@export var icon: Texture2D

## The description shown in a tooltip or in the UI.
@export_multiline var description: String = "A permanent dynasty upgrade."

## The cost in Jarl's Renown.
@export var renown_cost: int = 100

## The cost in Jarl's Authority.
@export var authority_cost: int = 1

# --- NEW: Progress System ---
@export_group("Progress")
@export var required_progress: int = 1
@export var current_progress: int = 0
# --- END NEW ---

## A unique key to identify this upgrade's effect in code.
## e.g., "UPG_TRELLEBORG", "UPG_JELLING_STONE"
@export var effect_key: String = ""

## A key to check if a prerequisite upgrade has been purchased.
@export var prerequisite_key: String = ""

## 'is_purchased' is now a calculated variable, not stored.
var is_purchased: bool:
	get:
		return current_progress >= required_progress

--- SCRIPT: res://data/missions/RaidLootData.gd ---
# res://data/missions/RaidLootData.gd
# Resource for tracking loot collected during raids
# GDD Ref: Phase 3 Task 7 - Resource-Driven Payout

extends Resource
class_name RaidLootData

@export var collected_loot: Dictionary = {}

func _init() -> void:
	# Initialize with default resource types
	collected_loot = {
		"gold": 0,
		"wood": 0,
		"food": 0,
		"stone": 0
	}

func add_loot(resource_type: String, amount: int) -> void:
	"""Add loot to the collection"""
	if collected_loot.has(resource_type):
		collected_loot[resource_type] += amount
	else:
		collected_loot[resource_type] = amount
	
	print("Loot added: %d %s (Total: %d)" % [amount, resource_type, collected_loot[resource_type]])

func add_loot_from_building(building_data: BuildingData) -> void:
	"""Extract loot from a destroyed building"""
	if not building_data:
		return
	
	# For EconomicBuildingData, give loot based on the resource type
	if building_data is EconomicBuildingData:
		var eco_data: EconomicBuildingData = building_data
		var loot_amount = eco_data.fixed_payout_amount * 3  # 3x the daily payout as loot
		add_loot(eco_data.resource_type, loot_amount)
	else:
		# Default loot for other buildings
		add_loot("gold", 50)

func get_total_loot() -> Dictionary:
	"""Get a copy of the collected loot"""
	return collected_loot.duplicate()

func clear_loot() -> void:
	"""Reset all loot to zero"""
	for resource_type in collected_loot:
		collected_loot[resource_type] = 0

func get_loot_summary() -> String:
	"""Get a formatted string of collected loot"""
	var summary_parts: Array[String] = []
	for resource_type in collected_loot:
		if collected_loot[resource_type] > 0:
			summary_parts.append("%d %s" % [collected_loot[resource_type], resource_type])
	
	if summary_parts.is_empty():
		return "No loot collected"
	else:
		return "Loot: " + ", ".join(summary_parts)

--- SCRIPT: res://data/settlements/SettlementData.gd ---
extends Resource
class_name SettlementData

@export var treasury: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}

# Stores building data and position. Structure:
# {"resource_path": "res://...", "grid_position": Vector2i(x, y)}
@export var placed_buildings: Array[Dictionary] = []

# Stores unit type (path) and count (int)
# Example: {"res://data/units/Unit_Raider.tres": 3}
@export var garrisoned_units: Dictionary = {}

# --- NEW: Stability Debuff ---
@export var has_stability_debuff: bool = false
# --- END NEW ---

# --- NEW: Builder Pillar Upgrade Property ---
## Bonus max garrison size from Legacy Upgrades (e.g., "Upgrade Trelleborg")
@export var max_garrison_bonus: int = 0
# --- END NEW ---

--- SCRIPT: res://data/traits/JarlTraitData.gd ---
# res://data/traits/JarlTraitData.gd
#
# This resource defines the statistical and diplomatic impact of a single trait.
# Renamed to JarlTraitData to avoid keyword conflict with Godot's internal 'Trait'.
class_name JarlTraitData
extends Resource

## General Information
@export var display_name: String = ""
@export var description: String = ""
@export var is_visible: bool = true # Should the player/AI know about this trait?

## Character Skill Modifiers (Permanent)
# Used to adjust the Jarl's base skills (Command, Stewardship, Intrigue)
@export_group("Skill Modifiers")
@export var command_modifier: int = 0
@export var stewardship_modifier: int = 0
@export var intrigue_modifier: int = 0

## Macro Layer Modifiers (Diplomacy/Renown)
@export_group("Macro Modifiers")
@export var renown_per_year_modifier: float = 0.0 # Used for passive Renown gain/loss
@export var vassal_opinion_modifier: int = 0  # Global change to vassal opinion of Jarl
@export var alliance_cost_modifier: float = 1.0 # Multiplier for alliance Authority cost

## Behavioral Flags (For AI and Event Triggers)
@export_group("Behavior Flags")
@export var is_wounded_trait: bool = false # e.g., Maimed, Crippled
@export var is_dishonorable_trait: bool = false # e.g., Betrayer, Cowardly

--- SCRIPT: res://data/units/UnitData.gd ---
# res://data/units/UnitData.gd
#
# Defines the core data for any unit in the game.
# This resource is used by Base_Unit.tscn to configure instances.
# GDD Ref: 7.C.1.b

class_name UnitData
extends Resource

## The name displayed in the UI (e.g., "Viking Raider").
@export var display_name: String = "New Unit"

## The scene that will be instanced when this unit is spawned.
@export var scene_to_spawn: PackedScene

## The icon shown in the training menu.
@export var icon: Texture2D

## The cost in 'Resources' to train this unit.
@export var spawn_cost: Dictionary = {"food": 25}


@export_group("Combat Stats")
## The unit's maximum hit points.
@export var max_health: int = 50

## Movement speed in pixels per second.
@export var move_speed: float = 75.0

## Damage dealt per attack.
@export var attack_damage: int = 8

## Range in pixels. (e.g., 10 for melee, 300 for archer).
@export var attack_range: float = 10.0

## Attacks per second.
@export var attack_speed: float = 1.2

## An optional AI scene to instance (e.g., for ranged units)
@export var ai_component_scene: PackedScene

## The projectile scene to spawn when this unit attacks (for ranged units).
@export var projectile_scene: PackedScene

## The speed of the projectile, in pixels per second.
@export var projectile_speed: float = 400.0


@export_group("Visuals")
## The texture to use for the unit's sprite.
@export var visual_texture: Texture2D

## The target gameplay size in pixels (e.g., 32x32).
@export var target_pixel_size: Vector2 = Vector2(32, 32)


@export_group("Movement Feel")
# --- NEW: Added properties from Base_Unit ---
## How quickly the unit reaches max speed (e.g., 10.0)
@export var acceleration: float = 10.0
## How much "friction" the unit has (e.g., 5.0)
@export var linear_damping: float = 5.0
# ---------------------------------------------

--- SCRIPT: res://data/world_map/WorldRegionData.gd ---
# res://data/world_map/WorldRegionData.gd
#
# Defines the data for a single clickable region on the Macro Map.
# This allows the map to be data-driven.
class_name WorldRegionData
extends Resource

## The name displayed in tooltips and UI
@export var display_name: String = "New Region"

## The flavor text description shown when selected
@export_multiline var description: String = "A description of this region."

## The SettlementData.tres file to load for the RaidMission
@export var target_settlement_data: SettlementData

## The base Authority cost to launch a raid here
@export var base_authority_cost: int = 1

# --- NEW: Phase 2 Properties ---

## A tag for the "soft-guide" system (e.g., "Monastery", "Settlement", "Ruins")
@export var region_type_tag: String = "Settlement"

## The passive, yearly income this region provides *after* being subjugated.
@export var yearly_income: Dictionary = {"gold": 10}

# --- REMOVED ---
# @export var is_conquered: bool = false
# This is now tracked on JarlData.gd for better persistence.

--- SCRIPT: res://player/RTSCamera.gd ---
# res://player/RTSCamera.gd
# Basic RTS-style camera controller for Phase 3
# Provides WASD movement and mouse edge panning
# Keeps camera controls simple and focused on tactical gameplay

extends Camera2D
class_name RTSCamera

@export var camera_speed: float = 400.0
@export var edge_pan_margin: float = 20.0
@export var enable_edge_panning: bool = true
@export var enable_wasd_movement: bool = true

# Movement bounds to keep camera on battlefield
@export var bounds_enabled: bool = false
@export var bounds_rect: Rect2 = Rect2(-500, -500, 1500, 1200)

func _ready() -> void:
	# Make this the current camera
	make_current()

func _process(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	
	# WASD camera movement (as specified in GDD Phase 3)
	if enable_wasd_movement:
		if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
			movement_vector.x -= 1
		if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
			movement_vector.x += 1
		if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
			movement_vector.y -= 1
		if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
			movement_vector.y += 1
	
	# Mouse edge panning (common RTS feature)
	if enable_edge_panning:
		var mouse_pos = get_viewport().get_mouse_position()
		var viewport_size = get_viewport().get_visible_rect().size
		
		if mouse_pos.x <= edge_pan_margin:
			movement_vector.x -= 1
		elif mouse_pos.x >= viewport_size.x - edge_pan_margin:
			movement_vector.x += 1
			
		if mouse_pos.y <= edge_pan_margin:
			movement_vector.y -= 1
		elif mouse_pos.y >= viewport_size.y - edge_pan_margin:
			movement_vector.y += 1
	
	# Apply movement
	if movement_vector != Vector2.ZERO:
		movement_vector = movement_vector.normalized()
		global_position += movement_vector * camera_speed * delta
		
		# Apply bounds if enabled
		if bounds_enabled:
			global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.position.x + bounds_rect.size.x)
			global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.position.y + bounds_rect.size.y)

--- SCRIPT: res://player/RTSController.gd ---
# res://player/RTSController.gd
#
# --- REFACTORED ---
# This script is now decoupled from input.
# It listens for clean signals from the EventBus
# (which are fired by SelectionBox.gd).
# It also correctly cleans up dead units.
#
# --- ADDED: Control Group & Formation Drag Support ---

extends Node
class_name RTSController

var selected_units: Array[BaseUnit] = []
var controllable_units: Array[BaseUnit] = []
var current_formation: SquadFormation.FormationType = SquadFormation.FormationType.LINE

# --- NEW: Control Group Storage ---
# We store the unit instance IDs, not the nodes themselves,
# to more safely handle units dying.
var control_groups: Dictionary = {
	1: [], 2: [], 3: [], 4: [], 5: [],
	6: [], 7: [], 8: [], 9: [], 0: [],
}
# ---------------------------------


func _ready() -> void:
	# Connect to the clean signals from our new EventBus/SelectionBox
	EventBus.select_command.connect(_on_select_command)
	EventBus.move_command.connect(_on_move_command)
	EventBus.attack_command.connect(_on_attack_command)
	# --- THIS LINE IS REQUIRED FOR DRAG-FORMATIONS ---
	EventBus.formation_move_command.connect(_on_formation_move_command)

func _input(event: InputEvent) -> void:
	# --- MODIFIED: Handle Control Group logic ---
	if event is InputEventKey and event.is_pressed():
		var key = event.keycode
		
		# --- THIS IS THE FIX (Line 41) ---
		# We use the 'ctrl_pressed' *property*
		var is_ctrl_pressed: bool = event.ctrl_pressed
		# ---------------------------------

		# Handle number keys 0-9
		if key >= KEY_0 and key <= KEY_9:
			var num = key - KEY_0 # Get the integer 0-9
			
			if is_ctrl_pressed:
				# Ctrl + Number: SET group
				_set_control_group(num)
				get_viewport().set_input_as_handled()
			else:
				# Number: SELECT group
				_select_control_group(num)
				get_viewport().set_input_as_handled()
		# -------------------------------------------
		else:
			# Handle non-number-key inputs (like formations)
			match event.keycode:
				# --- MOVED to F-Keys to avoid conflict ---
				KEY_F1:
					current_formation = SquadFormation.FormationType.LINE
					print("Formation: LINE")
				KEY_F2:
					current_formation = SquadFormation.FormationType.COLUMN
					print("Formation: COLUMN")
				KEY_F3:
					current_formation = SquadFormation.FormationType.WEDGE
					print("Formation: WEDGE")
				KEY_F4:
					current_formation = SquadFormation.FormationType.BOX
					print("Formation: BOX")
				# -----------------------------------------

# --- PUBLIC API ---

func add_unit_to_group(unit: Node2D) -> void:
	# Verify the unit is a BaseUnit (which has 'destroyed' signal)
	if not unit is BaseUnit:
		push_error("RTSController: Tried to add unit '%s' that doesn't extend BaseUnit." % unit.name)
		return
		
	if unit in controllable_units:
		return

	controllable_units.append(unit)
	
	# --- THIS IS THE DEAD UNIT CRASH FIX ---
	# Connect to this unit's 'destroyed' signal.
	# When it's destroyed, we'll clean it up.
	# We use CONNECT_DEFERRED to avoid race conditions.
	if unit.has_signal("destroyed"):
		unit.destroyed.connect(remove_unit.bind(unit), CONNECT_DEFERRED)
	else:
		# This check is vital. Our old debug units will fail this.
		push_warning("Unit %s does not have 'destroyed' signal!" % unit.name)

func remove_unit(unit: BaseUnit) -> void:
	"""Removes a unit from tracking. Called by the unit's 'destroyed' signal."""
	print("RTSController: Unit %s was destroyed/removed." % unit.name)
	
	if unit in selected_units:
		selected_units.erase(unit)
		if is_instance_valid(unit):
			# set_selected is a function on BaseUnit
			unit.set_selected(false)
			
	if unit in controllable_units:
		controllable_units.erase(unit)
		
	# --- NEW: Clean up control groups ---
	var unit_id = unit.get_instance_id()
	for group_num in control_groups:
		if control_groups[group_num].has(unit_id):
			control_groups[group_num].erase(unit_id)
	# ------------------------------------
		
	# Check if this was the last unit
	if controllable_units.is_empty():
		print("RTSController: All units are gone.")

# --- EVENTBUS HANDLERS ---

func _on_select_command(select_rect: Rect2, is_box_select: bool) -> void:
	_clear_selection()
	
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	if not main_camera:
		push_error("RTSController: No Camera2D found to perform selection.")
		return
	
	if is_box_select:
		# Box select - convert screen rect to world coordinates instead
		# This is more reliable than converting world to screen for each unit
		var camera_pos = main_camera.get_screen_center_position()
		var camera_zoom = main_camera.zoom
		var viewport_size = get_viewport().get_visible_rect().size
		
		# Convert screen rectangle to world coordinates
		var world_rect_min = camera_pos - (viewport_size / (2.0 * camera_zoom)) + (select_rect.position / camera_zoom)
		var world_rect_max = world_rect_min + (select_rect.size / camera_zoom)
		var world_rect = Rect2(world_rect_min, world_rect_max - world_rect_min)
		
		for unit in controllable_units:
			if world_rect.has_point(unit.global_position):
				selected_units.append(unit)
				unit.set_selected(true)
	else:
		# Single select (find closest unit to the click)
		# We must get the world position from the camera
		var click_world_pos := main_camera.get_global_mouse_position()
		var closest_unit: BaseUnit = null
		var min_dist_sq = INF
		
		for unit in controllable_units:
			var dist_sq = unit.global_position.distance_squared_to(click_world_pos)
			# 40px click radius
			if dist_sq < min_dist_sq and dist_sq < (40 * 40): 
				min_dist_sq = dist_sq
				closest_unit = unit
				
		if closest_unit:
			selected_units.append(closest_unit)
			closest_unit.set_selected(true)

func _on_move_command(target_position: Vector2) -> void:
	if selected_units.is_empty():
		return
	
	if selected_units.size() == 1:
		# Single unit - direct movement
		selected_units[0].command_move_to(target_position)
	else:
		# Multiple units - use formation
		var units_as_node2d: Array[Node2D] = []
		for unit in selected_units:
			units_as_node2d.append(unit)
		
		var formation = SquadFormation.new(units_as_node2d)
		formation.formation_type = current_formation
		formation.unit_spacing = 45.0
		
		# --- MODIFIED: Calculate direction ---
		# For a simple right-click, we just face the destination
		var group_center = formation.formation_center
		var direction = (target_position - group_center).normalized()
		if direction.is_zero_approx():
			direction = Vector2.DOWN # Default fallback
		formation.move_to_position(target_position, direction)
		# -------------------------------------

# --- THIS IS THE NEW FUNCTION FOR DRAG-FORMATIONS ---
func _on_formation_move_command(target_position: Vector2, direction_vector: Vector2):
	# --- DEBUG ---
	print("==================================================")
	print("RTSController: Received formation_move_command.")
	print("  -> Target Center: %s, Direction: %s" % [target_position, direction_vector])
	# --- END DEBUG ---
	
	if selected_units.is_empty():
		return

	if selected_units.size() == 1:
		# Single unit - just move, ignore direction
		selected_units[0].command_move_to(target_position)
	else:
		# Multiple units - use formation
		var units_as_node2d: Array[Node2D] = []
		for unit in selected_units:
			units_as_node2d.append(unit)
		
		var formation = SquadFormation.new(units_as_node2d)
		formation.formation_type = current_formation
		formation.unit_spacing = 45.0
		# Pass the specific direction from the drag
		formation.move_to_position(target_position, direction_vector)
# ---------------------------------------------

func _on_attack_command(target_node: Node2D) -> void:
	if selected_units.is_empty():
		return
		
	for unit in selected_units:
		unit.command_attack(target_node)

func _clear_selection() -> void:
	for unit in selected_units:
		# Check if it's valid, it might have been destroyed
		if is_instance_valid(unit):
			unit.set_selected(false)
	selected_units.clear()

# --- Control Group Functions ---

func _set_control_group(num: int) -> void:
	print("Setting control group %d" % num)
	# Clear the old group
	control_groups[num].clear()
	# Add all currently selected units by their ID
	for unit in selected_units:
		control_groups[num].append(unit.get_instance_id())

func _select_control_group(num: int) -> void:
	print("Selecting control group %d" % num)
	_clear_selection()
	
	var new_group_ids = control_groups[num]
	var still_valid_ids = []
	
	for unit_id in new_group_ids:
		var unit = instance_from_id(unit_id) as BaseUnit
		
		# Check if unit is still alive and controllable
		if is_instance_valid(unit) and unit in controllable_units:
			selected_units.append(unit)
			unit.set_selected(true)
			still_valid_ids.append(unit_id)
		
	# Prune any dead units from the control group
	control_groups[num] = still_valid_ids

	# --- Optional: Camera Pan ---
	# If we selected units, pan camera to them
	if not selected_units.is_empty():
		var center_pos = Vector2.ZERO
		for unit in selected_units:
			center_pos += unit.global_position
		center_pos /= selected_units.size()
		
		# Pan camera (assuming camera is RTSCamera)
		var camera = get_viewport().get_camera_2d()
		if camera and camera is RTSCamera:
			# Simple jump, as RTSCamera has no tween_pan_to method
			camera.global_position = center_pos
		elif camera:
			camera.global_position = center_pos

--- SCRIPT: res://scenes/components/AttackAI.gd ---
# res://scenes/components/AttackAI.gd
#
# A modular AI component that provides attack behavior for any unit or building.
# Simply instance this as a child of units or buildings that need to attack.
class_name AttackAI
extends Node2D

## Emitted when this AI starts attacking a target
signal attack_started(target: Node2D)
## Emitted when this AI stops attacking (no targets)
signal attack_stopped()
## Emitted just before firing a projectile or dealing damage
signal about_to_attack(target: Node2D, damage: int)

# --- NEW: AI Behavior Modes ---
enum AI_Mode {
	DEFAULT,         # Default behavior: Prioritize closest enemy units, then buildings.
	DEFENSIVE_SIEGE  # Enemy AI behavior: Prioritize Great Hall, then closest building.
}
@export var ai_mode: AI_Mode = AI_Mode.DEFAULT
@export var great_hall_los_range: float = 600.0 # Arbitrary LOS value
# --- END NEW ---

# Configuration - set these from the parent
@export var attack_damage: int = 10
@export var attack_range: float = 200.0
@export var attack_speed: float = 1.0  # attacks per second
@export var projectile_scene: PackedScene

var target_collision_mask: int = 0
var projectile_speed: float = 400.0

# Node references
@onready var detection_area: Area2D = $DetectionArea
@onready var attack_timer: Timer = $AttackTimer

# AI state
var parent_node: Node2D
var current_target: Node2D = null
var targets_in_range: Array[Node2D] = []
var is_attacking: bool = false

func _ready() -> void:
	parent_node = get_parent() as Node2D
	if not parent_node:
		push_error("AttackAI: Parent must be a Node2D")
		return
	
	_setup_ai()

func _setup_ai() -> void:
	"""Initialize the AI components"""
	if detection_area:
		detection_area.collision_layer = 0
		detection_area.collision_mask = target_collision_mask
		
		if detection_area.get_child(0) is CollisionShape2D:
			var detection_shape = detection_area.get_child(0) as CollisionShape2D
			if detection_shape.shape is CircleShape2D:
				(detection_shape.shape as CircleShape2D).radius = attack_range
		
		detection_area.body_entered.connect(_on_target_entered)
		detection_area.area_entered.connect(_on_target_entered)
		detection_area.body_exited.connect(_on_target_exited)
		detection_area.area_exited.connect(_on_target_exited)
	
	if attack_timer:
		if attack_speed > 0:
			attack_timer.wait_time = 1.0 / attack_speed
		else:
			attack_timer.wait_time = 999.0
	
		attack_timer.timeout.connect(_on_attack_timer_timeout)

func configure_from_data(data_resource) -> void:
	if not data_resource:
		return
	
	if "attack_damage" in data_resource:
		attack_damage = data_resource.attack_damage
	if "attack_range" in data_resource:
		attack_range = data_resource.attack_range
	if "attack_speed" in data_resource:
		attack_speed = data_resource.attack_speed
	if "projectile_scene" in data_resource:
		projectile_scene = data_resource.projectile_scene
	if "projectile_speed" in data_resource:
		projectile_speed = data_resource.projectile_speed
	
	if attack_timer:
		if attack_speed > 0:
			attack_timer.wait_time = 1.0 / attack_speed
		else:
			attack_timer.wait_time = 999.0
	
	if detection_area and detection_area.get_child(0) is CollisionShape2D:
		var detection_shape = detection_area.get_child(0) as CollisionShape2D
		if detection_shape.shape is CircleShape2D:
			(detection_shape.shape as CircleShape2D).radius = attack_range

func set_target_mask(mask: int) -> void:
	target_collision_mask = mask
	if detection_area:
		detection_area.collision_mask = mask

func force_target(target: Node2D) -> void:
	if not is_instance_valid(target):
		return
	
	if target is BaseBuilding and target.has_node("Hitbox"):
		current_target = target.get_node("Hitbox")
	else:
		current_target = target
	
	if current_target not in targets_in_range:
		targets_in_range.append(current_target)
	
	_start_attacking()

func stop_attacking() -> void:
	current_target = null
	_stop_attacking()

func _on_target_entered(body: Node2D) -> void:
	if body not in targets_in_range:
		targets_in_range.append(body)
	
	if not current_target and targets_in_range.size() > 0:
		_select_target()

func _on_target_exited(body: Node2D) -> void:
	targets_in_range.erase(body)
	
	if current_target == body:
		current_target = null
		_select_target()

func _select_target() -> void:
	"""Selects a target based on the current AI_Mode."""
	match ai_mode:
		AI_Mode.DEFAULT:
			_select_target_default()
		AI_Mode.DEFENSIVE_SIEGE:
			_select_target_defensive_siege()

func _select_target_default() -> void:
	"""Select the closest valid target, prioritizing units over buildings."""
	if targets_in_range.is_empty():
		current_target = null
		_stop_attacking()
		return
	
	var unit_targets: Array[Node2D] = []
	var building_targets: Array[Node2D] = []

	for target in targets_in_range:
		if not is_instance_valid(target):
			targets_in_range.erase(target)
			continue
		
		# --- FIX: Enforce Collision Mask ---
		# This prevents Friendly Fire. We check if the target matches our allowed mask.
		if not (target.collision_layer & target_collision_mask):
			continue
		# -----------------------------------

		# Determine type based on layer
		# Units: Layer 2 (Player) or Layer 3 (Enemy) -> Binary 0110 -> 6
		if target.collision_layer & 6: 
			unit_targets.append(target)
		# Buildings: Layer 1 (Player) or Layer 4 (Enemy) -> Binary 1001 -> 9
		elif target.collision_layer & 9: 
			building_targets.append(target)

	var closest_target: Node2D = null
	var closest_distance: float = INF
	
	# Prioritize Units over Buildings
	if not unit_targets.is_empty():
		for target in unit_targets:
			var distance = parent_node.global_position.distance_to(target.global_position)
			if distance < closest_distance:
				closest_distance = distance
				closest_target = target
	elif not building_targets.is_empty():
		for target in building_targets:
			var distance = parent_node.global_position.distance_to(target.global_position)
			if distance < closest_distance:
				closest_distance = distance
				closest_target = target
	
	current_target = closest_target
	
	if current_target:
		_start_attacking()
	else:
		_stop_attacking()

# --- NEW SIEGE AI LOGIC ---
func _select_target_defensive_siege() -> void:
	"""
	Enemy AI logic:
	1. Prioritize the Great Hall if it's in LOS.
	2. Otherwise, attack the closest building.
	"""
	# Only access FSM if parent is a BaseUnit
	var unit_parent = parent_node as BaseUnit
	if not is_instance_valid(unit_parent) or not unit_parent.fsm:
		_stop_attacking()
		return

	# 1. Check for Great Hall (Priority 1)
	var great_hall = unit_parent.fsm.objective_target
	if is_instance_valid(great_hall):
		var hall_pos = great_hall.global_position
		var distance_to_hall = parent_node.global_position.distance_to(hall_pos)
		
		if distance_to_hall <= great_hall_los_range:
			# If Hall is in LOS, override all other targets
			current_target = great_hall
			_start_attacking()
			return # Found our priority target

	# 2. Find Closest Building (Priority 2)
	var closest_building: Node2D = null
	var closest_distance: float = INF
	
	for target in targets_in_range:
		if not is_instance_valid(target):
			targets_in_range.erase(target)
			continue
			
		# --- FIX: Enforce Collision Mask ---
		if not (target.collision_layer & target_collision_mask):
			continue
		# -----------------------------------
		
		# Target Layer 1 (Player Buildings) or Layer 4 (Enemy Buildings)
		if target.collision_layer & 9: 
			var distance = parent_node.global_position.distance_to(target.global_position)
			if distance < closest_distance:
				closest_distance = distance
				closest_building = target
	
	current_target = closest_building
	
	if current_target:
		_start_attacking()
	else:
		# No buildings in range, stop attacking
		_stop_attacking()
# --- END NEW ---

func _start_attacking() -> void:
	if not is_attacking:
		is_attacking = true
		attack_started.emit(current_target)
	
	# Fire the first attack immediately instead of waiting for the timer.
	_on_attack_timer_timeout()
	
	if attack_timer and attack_timer.is_stopped():
		attack_timer.start()

func _stop_attacking() -> void:
	if is_attacking:
		is_attacking = false
		attack_stopped.emit()
	
	if attack_timer:
		attack_timer.stop()

func _on_attack_timer_timeout() -> void:
	"""Called when the attack timer fires"""
	if not current_target:
		# If our target is null, we should stop attacking
		_stop_attacking()
		return
	
	# Verify target is still valid and in range
	if not is_instance_valid(current_target):
		_select_target()
		return
	
	var distance_to_target = parent_node.global_position.distance_to(current_target.global_position)
	
	# Added a +10 buffer to prevent units from stopping if target is *just* at the edge
	if distance_to_target > attack_range + 10.0:
		_stop_attacking() 
		return
	
	# Emit signal before attacking
	about_to_attack.emit(current_target, attack_damage)
	
	# Attack the target
	if projectile_scene:
		# RANGED: Spawn projectile
		_spawn_projectile(current_target.global_position)
	else:
		# MELEE: Direct damage
		var target_to_damage = current_target
		
		if target_to_damage.name == "Hitbox":
			target_to_damage = target_to_damage.get_parent()
		
		if target_to_damage.has_method("take_damage"):
			# Pass parent_node as the attacker for retaliation logic
			target_to_damage.take_damage(attack_damage, parent_node)

func _spawn_projectile(target_position_world: Vector2) -> void:
	"""Spawn a projectile towards the target position"""
	if not projectile_scene:
		push_warning("AttackAI: No projectile scene assigned. Cannot fire.")
		return
	
	# 1. Get a projectile from the pool
	var projectile: Projectile = ProjectilePoolManager.get_projectile()
	if not projectile:
		push_error("AttackAI: ProjectilePoolManager failed to provide a projectile.")
		return
	
	# We set our new 'firer' variable instead of the 'owner' property
	projectile.firer = parent_node
	
	projectile.setup(
		parent_node.global_position,  # start position
		target_position_world,        # target position
		attack_damage,                # damage
		projectile_speed,             # Use configured speed
		target_collision_mask         # what to hit
	)

--- SCRIPT: res://scenes/effects/Projectile.gd ---
# res://scenes/effects/Projectile.gd
#
# A simple, straight-line projectile that applies damage on impact.
# Now integrated with ProjectilePoolManager.

class_name Projectile
extends Area2D

# Projectile properties
var damage: int = 0
var speed: float = 400.0
var direction: Vector2 = Vector2.RIGHT
var firer: Node2D = null

@onready var lifetime_timer: Timer = $LifetimeTimer

func _ready() -> void:
	area_entered.connect(_on_area_entered)
	body_entered.connect(_on_body_entered)
	
	# We must defer setting physics properties
	set_deferred("monitoring", true)
	
	self.monitorable = false
	lifetime_timer.timeout.connect(_on_lifetime_timeout)

func _physics_process(delta: float) -> void:
	global_position += direction * speed * delta

func setup(start_position: Vector2, target_position: Vector2, projectile_damage: int, projectile_speed: float = 400.0, collision_mask: int = 0) -> void:
	# This function now "wakes up" the projectile
	global_position = start_position
	direction = (target_position - start_position).normalized()
	damage = projectile_damage
	speed = projectile_speed
	self.collision_mask = collision_mask
	
	if direction != Vector2.ZERO:
		rotation = direction.angle()
	
	# Activate the projectile
	show()
	set_physics_process(true)
	set_deferred("monitoring", true)
	lifetime_timer.start()

func return_to_pool() -> void:
	"""
	Deactivates the projectile and hides it, returning it to the pool.
	"""
	hide()
	set_physics_process(false)
	set_deferred("monitoring", false)
	lifetime_timer.stop()
	global_position = Vector2(-1000, -1000) # Move it off-screen

func _on_area_entered(area: Area2D) -> void:
	"""Called when this Area2D detects a 'monitorable' Area2D (like our Hitbox)."""
	
	if area.collision_layer & self.collision_mask:
		var parent_body = area.get_parent()
		if parent_body and parent_body.has_method("take_damage"):
			
			if is_instance_valid(firer):
				parent_body.take_damage(damage, firer)
			else:
				parent_body.take_damage(damage, null)
			
			ProjectilePoolManager.return_projectile(self)
		else:
			push_warning("Projectile hit non-damagable Area: '%s'." % area.name)

func _on_body_entered(body: Node2D) -> void:
	"""Called when this Area2D detects a 'monitorable' PhysicsBody (like a unit)."""
	
	if not body is CollisionObject2D:
		return
	
	if body.collision_layer & self.collision_mask:
		if body.has_method("take_damage"):
			if is_instance_valid(firer):
				body.take_damage(damage, firer)
			else:
				body.take_damage(damage, null)
		
		ProjectilePoolManager.return_projectile(self)

func _on_lifetime_timeout() -> void:
	ProjectilePoolManager.return_projectile(self)

--- SCRIPT: res://scenes/missions/RaidMission.gd ---
# res://scenes/missions/RaidMission.gd
# Raid Mission Controller for Phase 3
#
# --- REFACTORED ---
# Fixed initialization order: 'data' is now assigned BEFORE add_child().
# This ensures BaseUnit._ready() has the data needed to create the FSM.
# ------------------
extends Node2D

# --- Exported Mission Configuration ---
@export var enemy_base_data: SettlementData
@export var default_enemy_base_path: String = "res://data/settlements/monastery_base.tres"
@export_group("Enemy Base Presets")
@export var available_enemy_bases: Array[String] = [
	"res://data/settlements/monastery_base.tres",
	"res://data/settlements/fortress_base.tres"
]
@export var player_spawn_formation: Dictionary = {"units_per_row": 5, "spacing": 40}
@export var mission_difficulty: float = 1.0
@export var allow_retreat: bool = true

# --- NEW: Defensive Mission ---
@export var is_defensive_mission: bool = false
@export var enemy_spawn_position: NodePath
# -----------------------------

# --- Node References ---
@onready var player_spawn_pos: Marker2D = $PlayerStartPosition
@onready var rts_controller: RTSController = $RTSController
@onready var grid_manager: Node = $GridManager
@onready var building_container: Node2D = $BuildingContainer
@onready var objective_manager: RaidObjectiveManager = $RaidObjectiveManager

# --- State Variables ---
var objective_building: BaseBuilding = null
var enemy_units: Array[BaseUnit] = []


func _ready() -> void:
	if DynastyManager.is_defensive_raid:
		self.is_defensive_mission = true
		objective_manager.is_defensive_mission = true
		DynastyManager.is_defensive_raid = false
	
	EventBus.settlement_loaded.connect(_on_settlement_ready_for_mission)
	
	if not SettlementManager.has_current_settlement():
		print("RaidMission: No current settlement - loading test settlement")
		_load_test_settlement()
		call_deferred("initialize_mission")
	else:
		print("RaidMission: Settlement already loaded - initializing mission")
		call_deferred("initialize_mission")

func _exit_tree() -> void:
	SettlementManager.unregister_active_scene_nodes()
	
	if EventBus.is_connected("settlement_loaded", _on_settlement_ready_for_mission):
		EventBus.settlement_loaded.disconnect(_on_settlement_ready_for_mission)


func _load_test_settlement() -> void:
	var test_settlement_path = "res://data/settlements/home_base_fixed.tres"
	var test_settlement = load(test_settlement_path) as SettlementData
	
	if test_settlement:
		print("RaidMission: Loading test settlement: %s" % test_settlement_path)
		SettlementManager.load_settlement(test_settlement)
	else:
		push_error("RaidMission: Failed to load test settlement from %s" % test_settlement_path)

func _on_settlement_ready_for_mission(_settlement_data: SettlementData) -> void:
	if not is_instance_valid(objective_manager.rts_controller): 
		print("RaidMission: Settlement loaded - initializing mission")
		initialize_mission()


func initialize_mission() -> void:
	print("RaidMission starting...")
	
	if rts_controller == null or objective_manager == null:
		push_error("RaidMission: Critical error! Nodes missing.")
		get_tree().quit()
		return
	
	if not is_instance_valid(grid_manager) or not "astar_grid" in grid_manager:
		push_error("RaidMission: GridManager node is missing or invalid!")
		return
	var local_astar_grid = grid_manager.astar_grid
	SettlementManager.register_active_scene_nodes(local_astar_grid, building_container)
	
	if is_defensive_mission:
		_load_player_base_for_defense()
		_spawn_player_garrison()
		_spawn_enemy_wave()
	else:
		if not enemy_base_data:
			enemy_base_data = load(default_enemy_base_path)
			if not enemy_base_data:
				push_error("Could not load enemy base data.")
				return
		_load_enemy_base()
		_spawn_player_garrison()
	
	if is_instance_valid(objective_building):
		objective_manager.initialize(rts_controller, objective_building, building_container, enemy_units)
	else:
		push_error("RaidMission: Could not find Objective Building (Great Hall)!")


func _load_player_base_for_defense() -> void:
	print("Loading PLAYER base for defense...")
	var settlement = SettlementManager.current_settlement
	if not settlement:
		push_error("Defensive Mission: Cannot load player base.")
		return
		
	for building_entry in settlement.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if not building_data or not building_data.scene_to_spawn:
			continue
		
		var building_instance: BaseBuilding = building_data.scene_to_spawn.instantiate()
		building_instance.name = building_data.display_name + "_Player"
		building_instance.data = building_data
		
		var world_pos_top_left: Vector2 = Vector2(grid_pos) * grid_manager.cell_size
		var building_footprint_size: Vector2 = Vector2(building_data.grid_size) * grid_manager.cell_size
		var building_center_offset: Vector2 = building_footprint_size / 2.0
		building_instance.global_position = world_pos_top_left + building_center_offset
		
		building_instance.set_collision_layer(1) # Player Buildings
		building_instance.set_collision_mask(0) 
		
		if building_data.display_name.to_lower().contains("hall"):
			objective_building = building_instance
			
		if building_instance.has_signal("building_destroyed"):
			building_instance.building_destroyed.connect(_on_enemy_building_destroyed_grid_clear)
		
		building_container.add_child(building_instance)
	
	_update_astar_grid_for_base(settlement.placed_buildings)


func _load_enemy_base() -> void:
	print("Loading ENEMY base for offense...")
	if not enemy_base_data:
		return
	
	for building_entry in enemy_base_data.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if not building_data or not building_data.scene_to_spawn:
			continue
		
		var building_instance: BaseBuilding = building_data.scene_to_spawn.instantiate()
		building_instance.name = building_data.display_name + "_Enemy"
		
		if "data" in building_instance:
			building_instance.data = building_data
		
		var world_pos_top_left: Vector2 = Vector2(grid_pos) * grid_manager.cell_size
		var building_footprint_size: Vector2 = Vector2(building_data.grid_size) * grid_manager.cell_size
		var building_center_offset: Vector2 = building_footprint_size / 2.0
		building_instance.global_position = world_pos_top_left + building_center_offset
		
		building_instance.add_to_group("enemy_buildings")
		building_instance.set_collision_layer(1 << 3) # Layer 4
		building_instance.set_collision_mask(0)
		
		if building_data.display_name.to_lower().contains("hall"):
			objective_building = building_instance
		
		if building_instance.has_signal("building_destroyed"):
			building_instance.building_destroyed.connect(_on_enemy_building_destroyed_grid_clear)
		
		building_container.add_child(building_instance)
	
	_update_astar_grid_for_base(enemy_base_data.placed_buildings)

func _update_astar_grid_for_base(placed_buildings: Array) -> void:
	for building_entry in placed_buildings:
		var building_data: BuildingData = load(building_entry["resource_path"])
		if not building_data: continue
		
		if building_data.blocks_pathfinding:
			var grid_size: Vector2i = building_data.grid_size
			var grid_pos: Vector2i = building_entry["grid_position"]
			
			for x in range(grid_size.x):
				for y in range(grid_size.y):
					var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
					SettlementManager.set_astar_point_solid(cell_pos, true)
	
	if is_instance_valid(grid_manager) and is_instance_valid(grid_manager.astar_grid):
		grid_manager.astar_grid.update()


func _spawn_player_garrison() -> void:
	if not SettlementManager.current_settlement:
		_spawn_test_units() 
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	if garrison.is_empty():
		if not is_defensive_mission:
			objective_manager.call_deferred("_check_loss_condition")
		return
	
	var units_per_row: int = player_spawn_formation.get("units_per_row", 5)
	var spacing: float = player_spawn_formation.get("spacing", 40.0)
	var current_row: int = 0
	var current_col: int = 0
	
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if not unit_data or not unit_data.scene_to_spawn:
			continue
		
		for i in range(unit_count):
			var unit_instance: Node2D = unit_data.scene_to_spawn.instantiate()
			
			if not unit_instance is BaseUnit:
				continue
				
			unit_instance.name = unit_data.display_name + "_" + str(i)
			if "data" in unit_instance:
				unit_instance.data = unit_data
			
			var spawn_pos: Vector2 = player_spawn_pos.global_position
			
			if is_defensive_mission and is_instance_valid(objective_building):
				spawn_pos = objective_building.global_position + Vector2(100, 100)
			
			spawn_pos.x += current_col * spacing
			spawn_pos.y += current_row * spacing
			unit_instance.global_position = spawn_pos
			
			unit_instance.add_to_group("player_units")
			rts_controller.add_unit_to_group(unit_instance)
			add_child(unit_instance)
			
			current_col += 1
			if current_col >= units_per_row:
				current_col = 0
				current_row += 1


func _spawn_enemy_wave() -> void:
	print("=== SPAWNING ENEMY WAVE ===")
	var enemy_spawner = get_node_or_null(enemy_spawn_position)
	if not is_instance_valid(enemy_spawner):
		push_error("Defensive Mission: Invalid or missing 'Enemy Spawn Position' node!")
		return
		
	var enemy_data_path = "res://data/units/EnemyVikingRaider_Data.tres"
	var enemy_data: UnitData = load(enemy_data_path)
	if not enemy_data or not enemy_data.scene_to_spawn:
		push_error("Failed to load enemy unit data: %s" % enemy_data_path)
		return

	var enemy_count = 5
	for i in range(enemy_count):
		
		# --- FIX: Logic Order ---
		
		# 1. Instantiate
		var enemy_node = enemy_data.scene_to_spawn.instantiate()
		
		# 2. Cast to BaseUnit and Set Data BEFORE add_child
		var enemy_unit = enemy_node as BaseUnit
		if not enemy_unit:
			push_error("Spawned enemy node is not a BaseUnit!")
			enemy_node.queue_free()
			continue
		
		# --- CRITICAL FIX: Assign data before adding to tree ---
		enemy_unit.data = enemy_data
		enemy_unit.name = enemy_data.display_name + "_Enemy_" + str(i)
		enemy_unit.collision_layer = 4  # Enemy Units = Layer 3
		# ------------------------------------------------------
		
		# 3. Add to Tree (Triggers _ready(), which now finds 'data')
		add_child(enemy_node) 
		
		# 4. Configure AI (Safe because FSM and AttackAI are created in _ready)
		if enemy_unit.attack_ai:
			enemy_unit.attack_ai.ai_mode = AttackAI.AI_Mode.DEFENSIVE_SIEGE
		else:
			push_warning("Enemy unit %s has no AttackAI node!" % enemy_unit.name)
		
		var spawn_pos = enemy_spawner.global_position + Vector2(i * 40, 0)
		enemy_unit.global_position = spawn_pos
		
		enemy_unit.add_to_group("enemy_units")
		enemy_units.append(enemy_unit)
		
		# 5. Command Attack
		if is_instance_valid(objective_building) and enemy_unit.fsm:
			enemy_unit.fsm.command_attack(objective_building)
		elif not enemy_unit.fsm:
			push_error("Enemy unit %s FSM is still null!" % enemy_unit.name)
		# --- END FIX ---
	
	print("Spawned %d enemy raiders." % enemy_count)


func _spawn_test_units() -> void:
	# (Test unit spawning code omitted for brevity - unchanged)
	pass

func _on_enemy_building_destroyed_grid_clear(building: BaseBuilding) -> void:
	_clear_building_from_pathfinding_grid(building)

func _clear_building_from_pathfinding_grid(building: BaseBuilding) -> void:
	if not building.data or not is_instance_valid(grid_manager):
		return
		
	var cell_size = grid_manager.cell_size
	var size_in_pixels = Vector2(building.data.grid_size) * cell_size
	var top_left_pos = building.global_position - (size_in_pixels / 2.0)
	var grid_pos = Vector2i(top_left_pos / cell_size)
	var grid_size = building.data.grid_size
	
	for x in range(grid_size.x):
		for y in range(grid_size.y):
			var cell_pos = Vector2i(grid_pos.x + x, grid_pos.y + y)
			SettlementManager.set_astar_point_solid(cell_pos, false)
	
	if is_instance_valid(grid_manager.astar_grid):
		grid_manager.astar_grid.update()

--- SCRIPT: res://scenes/missions/RaidObjectiveManager.gd ---
# res://scenes/missions/RaidObjectiveManager.gd
#
# Manages all mission-specific logic for a raid, including
# loot, win conditions, and loss conditions.
# Decoupled from RaidMission.gd (which is now just a level loader).
extends Node
class_name RaidObjectiveManager
# --- Mission Configuration ---
# These will be set in the Inspector on this node.
@export var victory_bonus_loot: Dictionary = {"gold": 200}
# MODIFIED: This is no longer used, but we leave it to avoid breaking the .tscn file
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
@export var is_defensive_mission: bool = false

# --- Internal State ---
var raid_loot: RaidLootData
var rts_controller: RTSController
var objective_building: BaseBuilding
var building_container: Node2D
var enemy_units: Array[BaseUnit] = [] # For defensive win condition
var is_initialized: bool = false
var mission_over: bool = false

# --- NEW: Preload the theme ---
const UI_THEME = preload("res://ui/themes/VikingDynastyTheme.tres")

func _ready() -> void:
	raid_loot = RaidLootData.new()

func initialize(
	p_rts_controller: RTSController, 
	p_objective_building: BaseBuilding, 
	p_building_container: Node2D,
	p_enemy_units: Array[BaseUnit] = []
) -> void:
	"""
	Called by RaidMission.gd after the level is loaded
	to pass in all necessary scene references.
	"""
	# Prevent multiple initialization
	if is_initialized:
		print("RaidObjectiveManager: Already initialized, skipping.")
		return
		
	self.rts_controller = p_rts_controller
	self.objective_building = p_objective_building
	self.building_container = p_building_container
	self.enemy_units = p_enemy_units
	
	if not is_instance_valid(rts_controller) or \
	   not is_instance_valid(objective_building) or \
	   not is_instance_valid(building_container):
		push_error("RaidObjectiveManager: Failed to initialize. Received invalid node references.")
		return
	
	print("RaidObjectiveManager: Initialized and tracking objectives.")
	
	# Connect to all necessary signals
	if not is_defensive_mission:
		_connect_to_building_signals()
		
	_setup_win_loss_conditions()
	
	# Mark as initialized
	is_initialized = true


func _connect_to_building_signals() -> void:
	# Connect to the Great Hall for the win condition
	if objective_building.has_signal("building_destroyed"):
		if not objective_building.building_destroyed.is_connected(_on_enemy_hall_destroyed):
			objective_building.building_destroyed.connect(_on_enemy_hall_destroyed)
	
	# Connect to *all* buildings for loot collection
	for building in building_container.get_children():
		if building is BaseBuilding and building.has_signal("building_destroyed"):
			if not building.building_destroyed.is_connected(_on_enemy_building_destroyed_for_loot):
				building.building_destroyed.connect(_on_enemy_building_destroyed_for_loot)

# --- Objective Logic ---

func _on_enemy_building_destroyed_for_loot(building: BaseBuilding) -> void:
	"""Called when any enemy building is destroyed - collect loot."""
	if mission_over: return
	
	var building_data = building.data as BuildingData
	
	if raid_loot and building_data:
		raid_loot.add_loot_from_building(building_data)
		print("RaidObjectiveManager: Building destroyed: %s | %s" % [building_data.display_name, raid_loot.get_loot_summary()])
	
	# Count remaining buildings for mission tracking
	var remaining_buildings = building_container.get_children().size() - 1 # -1 for the one just destroyed

func _setup_win_loss_conditions() -> void:
	"""Setup win/loss condition monitoring"""
	if is_defensive_mission:
		# --- DEFENSIVE MISSION ---
		# Lose if Hall is destroyed
		if objective_building.has_signal("building_destroyed"):
			objective_building.building_destroyed.connect(_on_player_hall_destroyed)
		# Win if all enemies are defeated
		_check_defensive_win_condition()
	else:
		# --- OFFENSIVE MISSION ---
		# Lose if all player units are destroyed
		_check_loss_condition()
		# Win if Enemy Hall is destroyed (handled by _connect_to_building_signals)


func _check_loss_condition() -> void:
	"""Check if all player units are destroyed (OFFENSIVE loss condition)"""
	if mission_over: return
	await get_tree().create_timer(1.0).timeout
	
	var remaining_units = 0
	if is_instance_valid(rts_controller):
		remaining_units = rts_controller.controllable_units.size()
	
	if remaining_units == 0:
		_on_mission_failed("All units destroyed")
		return # Stop the loop
	
	# Continue checking if mission is still active
	_check_loss_condition()

# --- NEW: Defensive Win/Loss ---
func _check_defensive_win_condition() -> void:
	"""Check if all enemy units are destroyed (DEFENSIVE win condition)"""
	if mission_over: return
	await get_tree().create_timer(1.0).timeout

	# Prune dead/invalid units
	enemy_units = enemy_units.filter(func(unit): return is_instance_valid(unit))
	var remaining_enemies = enemy_units.size()
	
	if remaining_enemies == 0:
		_on_defensive_mission_won()
		return # Stop the loop

	# Continue checking
	_check_defensive_win_condition()

func _on_player_hall_destroyed(_building: BaseBuilding) -> void:
	"""LOSE CONDITION for defensive mission"""
	if mission_over: return
	_on_mission_failed("Your Great Hall was destroyed!")

func _on_defensive_mission_won() -> void:
	"""WIN CONDITION for defensive mission"""
	if mission_over: return
	mission_over = true
	print("Mission Success! All attackers defeated.")
	
	# --- NEW: Show Victory Popup ---
	_show_victory_message("VICTORY!", "All attackers have been defeated.")
	
	# No loot for defense, just return home
	await get_tree().create_timer(3.0).timeout
	EventBus.scene_change_requested.emit("settlement")
# --- END NEW ---

func _on_mission_failed(reason: String) -> void:
	"""Called when player fails the mission"""
	if mission_over: return
	mission_over = true
	
	print("Mission Failed! %s" % reason)
	
	_show_failure_message(reason)
	
	await get_tree().create_timer(3.0).timeout
	
	EventBus.scene_change_requested.emit("settlement")


func _show_failure_message(reason: String) -> void:
	"""Display the mission failure message to the player"""
	var failure_popup = Control.new()
	failure_popup.name = "FailurePopup"
	failure_popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	# --- FIX: Apply theme ---
	failure_popup.theme = UI_THEME
	
	var bg_panel = Panel.new()
	bg_panel.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg_panel.modulate = Color(0, 0, 0, 0.7)
	failure_popup.add_child(bg_panel)
	
	var message_container = VBoxContainer.new()
	message_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	
	var failure_label = Label.new()
	failure_label.text = "DEFENSE FAILED!"
	failure_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	# --- FIX: Add theme overrides for visibility ---
	failure_label.add_theme_font_size_override("font_size", 32)
	failure_label.add_theme_color_override("font_color", Color.CRIMSON)
	message_container.add_child(failure_label)
	
	var subtitle_label = Label.new()
	subtitle_label.text = reason
	subtitle_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(subtitle_label)
	
	var return_label = Label.new()
	return_label.text = "Returning to settlement..."
	return_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(return_label)
	
	failure_popup.add_child(message_container)
	
	# --- FIX: Add to CanvasLayer, not scene root ---
	var canvas = get_parent().get_node_or_null("CanvasLayer")
	if canvas:
		canvas.add_child(failure_popup)
	else:
		push_error("RaidObjectiveManager: Could not find 'CanvasLayer' to show failure message!")
		get_tree().current_scene.add_child(failure_popup) # Fallback

# --- NEW: VICTORY POPUP FUNCTION ---
func _show_victory_message(title: String, subtitle: String) -> void:
	"""Displays a generic victory message popup."""
	var victory_popup = Control.new()
	victory_popup.name = "VictoryPopup"
	victory_popup.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	# --- FIX: Apply theme ---
	victory_popup.theme = UI_THEME
	
	var bg_panel = Panel.new()
	bg_panel.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)
	bg_panel.modulate = Color(0.1, 0.1, 0.1, 0.7) # Darker background
	victory_popup.add_child(bg_panel)
	
	var message_container = VBoxContainer.new()
	message_container.set_anchors_and_offsets_preset(Control.PRESET_CENTER)
	
	var title_label = Label.new()
	title_label.text = title
	# --- FIX: Add theme overrides for visibility ---
	title_label.add_theme_font_size_override("font_size", 32)
	title_label.add_theme_color_override("font_color", Color.GOLD)
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(title_label)
	
	var subtitle_label = Label.new()
	subtitle_label.text = subtitle
	subtitle_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(subtitle_label)
	
	var return_label = Label.new()
	return_label.text = "Returning to settlement..."
	return_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	message_container.add_child(return_label)
	
	victory_popup.add_child(message_container)
	
	# --- FIX: Add to CanvasLayer, not scene root ---
	var canvas = get_parent().get_node_or_null("CanvasLayer")
	if canvas:
		canvas.add_child(victory_popup)
	else:
		push_error("RaidObjectiveManager: Could not find 'CanvasLayer' to show victory message!")
		get_tree().current_scene.add_child(victory_popup) # Fallback
# --- END NEW ---

func _on_enemy_hall_destroyed(_building: BaseBuilding = null) -> void:
	"""Called when the enemy's Great Hall is destroyed (OFFENSIVE win condition)"""
	if mission_over: return
	mission_over = true
	
	print("Enemy Hall destroyed! Mission success!")
	
	# Add bonus loot
	raid_loot.add_loot("gold", victory_bonus_loot.get("gold", 200))
	var total_loot = raid_loot.get_total_loot()
	
	SettlementManager.deposit_resources(total_loot)
	print("Mission Complete! %s" % raid_loot.get_loot_summary())
	
	# --- NEW: Show Victory Popup ---
	var subtitle = "The enemy's Great Hall is in ruins.\nLoot: %s" % raid_loot.get_loot_summary()
	_show_victory_message("VICTORY!", subtitle)
	
	await get_tree().create_timer(3.0).timeout # Increased timer to 3s to read
	
	EventBus.scene_change_requested.emit("settlement")

--- SCRIPT: res://scenes/world_map/MacroCamera.gd ---
# res://scenes/world_map/MacroCamera.gd
#
# Camera controller for the Macro Map.
# Implements WASD and Middle-Mouse-Drag panning [cite: 471, 472]
# with boundaries.
extends Camera2D # [cite: 468]
class_name MacroCamera

@export var camera_speed: float = 500.0
@export var bounds_enabled: bool = true 
@export var bounds_rect: Rect2 = Rect2(0, 0, 1920, 1080)

var is_dragging: bool = false
var drag_start_pos: Vector2

func _ready() -> void:
	make_current()

func _process(delta: float) -> void:
	var movement_vector := Vector2.ZERO
	
	# WASD camera movement [cite: 471]
	if Input.is_action_pressed("ui_left") or Input.is_key_pressed(KEY_A):
		movement_vector.x -= 1
	if Input.is_action_pressed("ui_right") or Input.is_key_pressed(KEY_D):
		movement_vector.x += 1
	if Input.is_action_pressed("ui_up") or Input.is_key_pressed(KEY_W):
		movement_vector.y -= 1
	if Input.is_action_pressed("ui_down") or Input.is_key_pressed(KEY_S):
		movement_vector.y += 1
	
	if movement_vector != Vector2.ZERO:
		global_position += movement_vector.normalized() * camera_speed * delta
		
	# Apply clamping
	_clamp_camera_to_bounds()

func _unhandled_input(event: InputEvent) -> void:
	# Middle-Mouse-Drag Panning [cite: 472]
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_MIDDLE:
			if event.is_pressed():
				is_dragging = true
				drag_start_pos = get_global_mouse_position() - global_position
				get_viewport().set_input_as_handled()
			else:
				is_dragging = false
				get_viewport().set_input_as_handled()
				
	elif event is InputEventMouseMotion and is_dragging:
		global_position = get_global_mouse_position() - drag_start_pos
		_clamp_camera_to_bounds()
		get_viewport().set_input_as_handled()

func _clamp_camera_to_bounds() -> void:
	if bounds_enabled:
		global_position.x = clamp(global_position.x, bounds_rect.position.x, bounds_rect.end.x)
		global_position.y = clamp(global_position.y, bounds_rect.position.y, bounds_rect.end.y)

--- SCRIPT: res://scenes/world_map/MacroMap.gd ---
# res://scenes/world_map/MacroMap.gd
#
# Main controller for the MacroMap scene.
# Connects UI to the DynastyManager and handles region selection.
extends Node2D

# Scene paths for navigation
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
@export var end_year_popup_scene: PackedScene

# Raid Chance
@export var enemy_raid_chance: float = 0.25 # 25% chance

# UI Node References
@onready var authority_label: Label = $UI/JarlInfo/VBoxContainer/AuthorityLabel
@onready var renown_label: Label = $UI/JarlInfo/VBoxContainer/RenownLabel
@onready var end_year_button: Button = $UI/Actions/VBoxContainer/EndYearButton
@onready var region_info_panel: PanelContainer = $UI/RegionInfo
@onready var region_name_label: Label = $UI/RegionInfo/VBoxContainer/RegionNameLabel
@onready var launch_raid_button: Button = $UI/RegionInfo/VBoxContainer/LaunchRaidButton
@onready var settlement_button: Button = $UI/Actions/VBoxContainer/SettlementButton
@onready var tooltip: PanelContainer = $UI/Tooltip
@onready var tooltip_label: Label = $UI/Tooltip/Label

# --- Phase 2 UI ---
@onready var subjugate_button: Button = $UI/RegionInfo/VBoxContainer/SubjugateButton

# --- Phase 3a UI ---
@onready var dynasty_button: Button = $UI/Actions/VBoxContainer/DynastyButton
@onready var dynasty_ui: DynastyUI = $UI/Dynasty_UI
@onready var marry_button: Button = $UI/RegionInfo/VBoxContainer/MarryButton
# --- END ---

@onready var regions_container: Node2D = $Regions

var end_year_popup: PanelContainer
var selected_region_data: WorldRegionData
var selected_region_node: Region = null

# Stores the calculated cost after applying Jarl stats
var calculated_raid_cost: int = 1
var calculated_subjugate_cost: int = 5 # Base cost from proposal

func _ready() -> void:
	# Connect to the DynastyManager
	DynastyManager.jarl_stats_updated.connect(_update_jarl_ui)
	
	# Connect to all child regions
	for region in regions_container.get_children():
		if region is Region:
			region.region_hovered.connect(_on_region_hovered)
			region.region_exited.connect(_on_region_exited)
			region.region_selected.connect(_on_region_selected)
			
	# Connect local UI buttons
	launch_raid_button.pressed.connect(_on_launch_raid_pressed)
	settlement_button.pressed.connect(_on_settlement_pressed)
	subjugate_button.pressed.connect(_on_subjugate_pressed)
	end_year_button.pressed.connect(_on_end_year_pressed)
	
	# --- Phase 3a Connection ---
	dynasty_button.pressed.connect(_on_dynasty_pressed)
	marry_button.pressed.connect(_on_marry_pressed)
	# --- END ---
	
	# --- Setup Payout Popup ---
	if end_year_popup_scene:
		end_year_popup = end_year_popup_scene.instantiate()
		add_child(end_year_popup) 
		if end_year_popup.has_signal("collect_button_pressed"):
			end_year_popup.collect_button_pressed.connect(_on_end_year_payout_collected)
		else:
			push_error("EndOfYear_Popup scene is missing 'collect_button_pressed' signal.")
		end_year_popup.hide()
	else:
		push_warning("MacroMap: 'end_year_popup_scene' is not set in the Inspector!")
	
	# Connect to the EventManager's "all-clear" signal
	EventBus.event_system_finished.connect(_on_event_system_finished)
	
	# Initialize UI
	_update_jarl_ui(DynastyManager.get_current_jarl())
	region_info_panel.hide()
	tooltip.hide()

func _update_jarl_ui(jarl: JarlData) -> void:
	if not jarl:
		return
		
	authority_label.text = "Authority: %d / %d" % [jarl.current_authority, jarl.max_authority]
	renown_label.text = "Renown: %d" % jarl.renown
	
	if selected_region_data:
		_on_region_selected(selected_region_data)

# --- Region Signal Handlers ---

func _on_region_hovered(data: WorldRegionData, _screen_position: Vector2) -> void:
	tooltip_label.text = data.display_name
	var mouse_pos = get_viewport().get_mouse_position()
	tooltip.position = mouse_pos + Vector2(15, 15)
	tooltip.show()

func _on_region_exited() -> void:
	tooltip.hide()

func _on_region_selected(data: WorldRegionData) -> void:
	# De-select the previously selected region, if any
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
		
	# Find the new region node
	for region in regions_container.get_children():
		if region is Region and region.data == data:
			selected_region_node = region
			selected_region_node.is_selected = true
			selected_region_node.set_visual_state(false)
			break
			
	selected_region_data = data
	region_name_label.text = data.display_name
	
	var jarl = DynastyManager.get_current_jarl()
	if not jarl:
		push_error("MacroMap: Cannot get Jarl from DynastyManager!")
		return

	# --- CHECK IF CONQUERED OR ALLIED ---
	var is_conquered = DynastyManager.has_conquered_region(data.resource_path)
	var is_allied = DynastyManager.is_allied_region(data.resource_path)
	
	if is_conquered:
		launch_raid_button.disabled = true
		launch_raid_button.text = "Raid (Conquered)"
		subjugate_button.disabled = true
		subjugate_button.text = "Subjugate (Conquered)"
		marry_button.disabled = true
		marry_button.text = "Marry (Conquered)"
		region_info_panel.show()
		return
	
	# --- 1. CALCULATE RAID COST ---
	calculated_raid_cost = max(1, data.base_authority_cost) # Placeholder for now
	launch_raid_button.text = "Launch Raid (Cost: %d Auth)" % calculated_raid_cost
	var can_afford_raid = DynastyManager.can_spend_authority(calculated_raid_cost)
	launch_raid_button.disabled = (not can_afford_raid) or is_allied
	if is_allied:
		launch_raid_button.text = "Raid (Allied)"
	elif not can_afford_raid:
		launch_raid_button.text += "\nNot Enough Authority"
		
	# --- 2. CALCULATE SUBJUGATE COST ---
	var base_subjugate_cost = 5
	var trait_penalty = 0
	var alliance_discount = 0
	var penalty_text = ""
	var discount_text = ""
	
	# "Soft-Guide" Trait Penalty
	if jarl.has_trait("Pious") and data.region_type_tag == "Monastery":
		trait_penalty = 3
		penalty_text = " (+3 Pious)"
	
	# "Marry for Alliance" Bonus
	if is_allied:
		alliance_discount = 2 # Example discount
		discount_text = " (-2 Alliance)"
	
	calculated_subjugate_cost = max(1, base_subjugate_cost + trait_penalty - alliance_discount)
	
	subjugate_button.text = "Subjugate (Cost: %d Auth%s%s)" % [calculated_subjugate_cost, penalty_text, discount_text]
	var can_afford_subjugate = DynastyManager.can_spend_authority(calculated_subjugate_cost)
	subjugate_button.disabled = not can_afford_subjugate
	if not can_afford_subjugate:
		subjugate_button.text += "\nNot Enough Authority"

	# --- 3. CALCULATE MARRIAGE COST ---
	marry_button.text = "Marry for Alliance (Cost: 1 Heir)"
	var has_heir = DynastyManager.get_available_heir_count() > 0
	marry_button.disabled = is_allied or (not has_heir)
	
	if is_allied:
		marry_button.text = "Marry (Allied)"
	elif not has_heir:
		marry_button.text += "\n(No Available Heir)"
		
	region_info_panel.show()

# --- UI Button Handlers ---

func _on_launch_raid_pressed() -> void:
	if not selected_region_data:
		return
		
	DynastyManager.set_current_raid_target(selected_region_data.target_settlement_data)
	var success = DynastyManager.spend_authority(calculated_raid_cost)
	
	if success:
		EventBus.scene_change_requested.emit("raid_mission")
	else:
		push_error("MacroMap: LaunchRaid button was pressed but authority check failed.")
		DynastyManager.set_current_raid_target(null)

func _on_subjugate_pressed() -> void:
	if not selected_region_data:
		return
		
	var success = DynastyManager.spend_authority(calculated_subjugate_cost)
	
	if success:
		DynastyManager.add_conquered_region(selected_region_data.resource_path)
		
		# --- NEW: Add Legitimacy Boost ---
		var jarl = DynastyManager.get_current_jarl()
		jarl.legitimacy = min(100, jarl.legitimacy + 5) # +5 Legitimacy
		DynastyManager.jarl_stats_updated.emit(jarl) # Force UI/data refresh
		# --- END NEW ---
		
		print("Region %s successfully subjugated." % selected_region_data.display_name)
	else:
		push_error("MacroMap: Subjugate button was pressed but authority check failed.")

func _on_marry_pressed() -> void:
	"""Handles the 'Marry for Alliance' button press."""
	if not selected_region_data:
		return
		
	var success = DynastyManager.marry_heir_for_alliance(selected_region_data.resource_path)
	
	if success:
		print("MacroMap: Alliance with %s successful." % selected_region_data.display_name)
		# The UI will refresh automatically via the jarl_stats_updated signal.
	else:
		print("MacroMap: Alliance failed (no available heir).")

func _on_dynasty_pressed() -> void:
	"""Shows the Dynasty UI panel."""
	if is_instance_valid(dynasty_ui):
		dynasty_ui.show()

# --- End Year Payout Logic ---
func _on_end_year_pressed() -> void:
	if not is_instance_valid(end_year_popup):
		push_error("MacroMap: End year popup not instanced. Ending year without payout.")
		_process_end_year_logic({})
		return
	
	var payout = SettlementManager.calculate_payout()
	end_year_popup.display_payout(payout, "End of Year Payout")

func _on_end_year_payout_collected(payout: Dictionary) -> void:
	# This function's ONLY job is to process the end of year logic.
	# The scene change is now handled by _on_event_system_finished.
	_process_end_year_logic(payout)

func _on_event_system_finished() -> void:
	# This is the "all-clear" signal.
	# NOW we check for raids and change the scene.
	if randf() < enemy_raid_chance:
		print("--- ENEMY RAID TRIGGERED ---")
		DynastyManager.is_defensive_raid = true
		EventBus.scene_change_requested.emit("raid_mission")
	else:
		print("No enemy raid this year.")
		EventBus.scene_change_requested.emit("settlement")

func _process_end_year_logic(payout: Dictionary) -> void:
	if not payout.is_empty():
		SettlementManager.deposit_resources(payout)
	
	# This call is what triggers the EventManager's logic
	DynastyManager.end_year()
	
	if is_instance_valid(selected_region_node):
		selected_region_node.is_selected = false
		selected_region_node.set_visual_state(false)
	
	selected_region_data = null
	selected_region_node = null
	region_info_panel.hide()

func _on_settlement_pressed() -> void:
	EventBus.scene_change_requested.emit("settlement")

func _unhandled_input(event: InputEvent) -> void:
	pass

--- SCRIPT: res://scenes/world_map/Region.gd ---
# res://scenes/world_map/Region.gd
#
# Attached to an Area2D node to make a map province
# clickable and interactive.
class_name Region
extends Area2D

signal region_hovered(data: WorldRegionData, screen_position: Vector2)
signal region_exited()
signal region_selected(data: WorldRegionData)

@export var data: WorldRegionData

# Normally, we'd use a Sprite2d, but for now we'll just use a colorrect
@onready var sprite = $Sprite2D

var default_color: Color = Color(1.0, 1.0, 1.0, 0.2)
var hover_color: Color = Color(1.0, 1.0, 1.0, 0.6)
var selected_color: Color = Color(1.0, 0.9, 0.2, 0.8) # Yellow

var is_selected: bool = false

func _ready() -> void:
	if not data:
		push_error("Region node '%s' has no WorldRegionData assigned!" % name)
		queue_free()
		return
	
	# Essential error checking for collision shapes
	var collision_shape = get_node_or_null("CollisionShape2D")
	if not collision_shape:
		push_error("Region '%s' - CollisionShape2D NOT FOUND!" % name)
	elif not collision_shape.shape:
		push_error("Region '%s' - CollisionShape2D shape is NULL!" % name)
	
	# Connect to our own signals
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	input_event.connect(_on_input_event)
	
	if sprite:
		sprite.material = CanvasItemMaterial.new()
		sprite.material.blend_mode = CanvasItemMaterial.BLEND_MODE_MIX
		set_visual_state(false)
	else:
		push_warning("Region node '%s' is missing its $Sprite2D child." % name)

func set_visual_state(is_hovered: bool) -> void:
	if not sprite:
		return
		
	var target_color: Color
	if is_selected:
		target_color = selected_color
	elif is_hovered:
		target_color = hover_color
	else:
		target_color = default_color
		
	var tween = create_tween()
	tween.tween_property(sprite, "modulate", target_color, 0.1).set_trans(Tween.TRANS_SINE)

func _on_mouse_entered() -> void:
	set_visual_state(true)
	emit_signal("region_hovered", data, get_global_mouse_position())

func _on_mouse_exited() -> void:
	set_visual_state(false)
	emit_signal("region_exited")

func _on_input_event(_viewport: Node, event: InputEvent, _shape_idx: int) -> void:
	# Check for left mouse button click
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		is_selected = true
		set_visual_state(true)
		emit_signal("region_selected", data)
		get_viewport().set_input_as_handled()

--- SCRIPT: res://scenes/world_map/WorldMap_Stub.gd ---
# res://scenes/world_map/WorldMap_Stub.gd
# World map interface for selecting raid targets
# GDD Ref: Phase 3 Task 6

extends Control

# --- MODIFIED: Use String paths, not PackedScene ---
## The main raid mission scene to load (e.g., RaidMission.tscn)
@export var raid_mission_scene_path: String = "res://scenes/missions/RaidMission.tscn"

## The scene to return to (e.g., SettlementBridge.tscn)
@export var settlement_bridge_scene_path: String = "res://scenes/levels/SettlementBridge.tscn"
# --- END MODIFICATION ---

@onready var raid_monastery_button: Button = $ButtonContainer/RaidMonasteryButton
@onready var back_button: Button = $ButtonContainer/BackButton

func _ready() -> void:
	raid_monastery_button.pressed.connect(_on_raid_monastery_pressed)
	back_button.pressed.connect(_on_back_pressed)
	
	# Validate that we can actually raid (have settlement & units)
	_validate_raid_capability()

func _validate_raid_capability() -> void:
	"""Ensure the player can actually start a raid"""
	if not SettlementManager.current_settlement:
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Settlement Loaded"
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		raid_monastery_button.disabled = true
		raid_monastery_button.text = "No Units Available"
		return
	
	raid_monastery_button.disabled = false

func _on_raid_monastery_pressed() -> void:
	"""Launch the raid mission"""
	print("Starting raid on nearby monastery...")
	
	# Additional validation before starting raid
	if not SettlementManager.current_settlement:
		push_error("Cannot start raid: No settlement loaded")
		return
	
	# --- MODIFIED: Emit signal ---
	if not raid_mission_scene_path.is_empty():
		EventBus.scene_change_requested.emit(raid_mission_scene_path)
	else:
		push_error("WorldMap_Stub: raid_mission_scene_path is not set! Cannot start raid.")
	# --- END MODIFICATION ---

func _on_back_pressed() -> void:
	"""Return to the settlement"""
	print("Returning to settlement...")
	
	# --- MODIFIED: Emit signal ---
	if not settlement_bridge_scene_path.is_empty():
		EventBus.scene_change_requested.emit(settlement_bridge_scene_path)
	else:
		push_error("WorldMap_Stub: settlement_bridge_scene_path is not set! Cannot return.")
	# --- END MODIFICATION ---

--- SCRIPT: res://scripts/ai/SentryAI.gd ---
# res://scripts/ai/SentryAI.gd
# Simple Sentry AI for enemy defenders in Phase 3
# GDD Ref: Phase 3 - Enemy MVP (Simple Sentry AI)

extends Node2D
class_name SentryAI

@export var detection_radius: float = 80.0
@export var attack_damage: int = 25
@export var attack_cooldown: float = 1.5

var detection_area: Area2D
var attack_timer: float = 0.0
var current_target: Node2D = null

signal enemy_detected(target: Node2D)
signal attack_executed(target: Node2D, damage: int)

func _ready() -> void:
	_setup_detection_area()
	set_process(true)

func _setup_detection_area() -> void:
	"""Create detection area for sentry"""
	detection_area = Area2D.new()
	detection_area.name = "DetectionArea"
	
	var collision_shape = CollisionShape2D.new()
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = detection_radius
	collision_shape.shape = circle_shape
	
	detection_area.add_child(collision_shape)
	add_child(detection_area)
	
	# Connect signals
	detection_area.body_entered.connect(_on_body_entered)
	detection_area.body_exited.connect(_on_body_exited)
	
	# Set collision mask to detect player units (layer 1)
	detection_area.collision_mask = 1

func _process(delta: float) -> void:
	# Update attack timer
	if attack_timer > 0:
		attack_timer -= delta
	
	# Check for and attack valid targets
	if current_target and is_instance_valid(current_target):
		if attack_timer <= 0:
			_attack_target(current_target)
			attack_timer = attack_cooldown
	else:
		current_target = null

func _on_body_entered(body: Node2D) -> void:
	"""Handle detection of player units"""
	if body.is_in_group("player_units") and not current_target:
		current_target = body
		enemy_detected.emit(body)
		# Removed print: print("%s detected enemy: %s" % [get_parent().name, body.name])

func _on_body_exited(body: Node2D) -> void:
	"""Handle player units leaving detection range"""
	if body == current_target:
		current_target = null
		# Removed print: print("%s lost target: %s" % [get_parent().name, body.name])

func _attack_target(target: Node2D) -> void:
	"""Execute attack on target"""
	if not target or not is_instance_valid(target):
		return
	
	# Check if target is still in range
	var distance = global_position.distance_to(target.global_position)
	if distance > detection_radius:
		current_target = null
		return
	
	# Removed print: print("%s attacking %s for %d damage" % [get_parent().name, target.name, attack_damage])
	
	# Apply damage if target has take_damage method
	if target.has_method("take_damage"):
		target.take_damage(attack_damage)
	elif target.has_method("receive_damage"):
		target.receive_damage(attack_damage)
	else:
		# Fallback: just remove the target for demo purposes
		push_warning("SentryAI: Target %s has no damage method; removing for demo purposes." % target.name)
		target.queue_free()
	
	attack_executed.emit(target, attack_damage)

func get_detection_radius() -> float:
	"""Get current detection radius"""
	return detection_radius

func set_detection_radius(new_radius: float) -> void:
	"""Update detection radius"""
	detection_radius = new_radius
	if detection_area:
		var collision_shape = detection_area.get_child(0) as CollisionShape2D
		if collision_shape and collision_shape.shape is CircleShape2D:
			collision_shape.shape.radius = detection_radius

func is_actively_defending() -> bool:
	"""Check if sentry is currently engaged with a target"""
	return current_target != null and is_instance_valid(current_target)

--- SCRIPT: res://scripts/ai/UnitAIConstants.gd ---
# res://scripts/ai/UnitAIConstants.gd
#
# Holds shared enums for the Unit AI system to break
# circular dependencies between BaseUnit and UnitFSM.
class_name UnitAIConstants

enum State { IDLE, MOVING, FORMATION_MOVING, ATTACKING }
enum Stance { DEFENSIVE, HOLD_POSITION }

--- SCRIPT: res://scripts/ai/UnitFSM.gd ---
# res://scripts/ai/UnitFSM.gd
# Refactored UnitFSM for Phase 3 RTS commands
# Now uses modular AttackAI component for attacking behavior
#
# --- REFACTORED ---
# Fixed Friendly Fire bug in _find_closest_blocking_building.
# Units now respect their collision mask when looking for obstructions.
# ------------------

class_name UnitFSM

# Enums are now defined in UnitAIConstants.gd to break circular dependency

# Unit References
var unit # Type hint removed to break circular dependency
var attack_ai: AttackAI  # Reference to the AttackAI component

# State Data
var current_state: UnitAIConstants.State = UnitAIConstants.State.IDLE
var stance: UnitAIConstants.Stance = UnitAIConstants.Stance.DEFENSIVE
var path: Array = []
var stuck_timer: float = 0.0

var los_range: float = 450.0 # Player unit "Line of Sight"

# Target Data
var target_position: Vector2 = Vector2.ZERO
var move_command_position: Vector2 = Vector2.ZERO

var objective_target: Node2D = null # The long-term goal (e.g., Great Hall)
var current_target: Node2D = null # The immediate threat (e.g., nearby unit)

func _init(p_unit, p_attack_ai: AttackAI) -> void:
	unit = p_unit
	attack_ai = p_attack_ai
	
	if attack_ai:
		attack_ai.attack_started.connect(_on_ai_attack_started)
		attack_ai.attack_stopped.connect(_on_ai_attack_stopped)

func change_state(new_state: UnitAIConstants.State) -> void:
	if current_state == new_state:
		return
	
	_exit_state(current_state)
	current_state = new_state
	
	if is_instance_valid(unit):
		unit.call("on_state_changed", current_state)
	
	_enter_state(current_state)

func _enter_state(state: UnitAIConstants.State) -> void:
	match state:
		UnitAIConstants.State.IDLE:
			unit.velocity = Vector2.ZERO
			
		UnitAIConstants.State.MOVING:
			_recalculate_path() 
		
		UnitAIConstants.State.FORMATION_MOVING:
			pass
		
		UnitAIConstants.State.ATTACKING:
			unit.velocity = Vector2.ZERO
			if attack_ai and is_instance_valid(current_target):
				attack_ai.force_target(current_target)

func _exit_state(state: UnitAIConstants.State) -> void:
	match state:
		UnitAIConstants.State.MOVING:
			path.clear()
			stuck_timer = 0.0
		UnitAIConstants.State.FORMATION_MOVING:
			path.clear()
		
		UnitAIConstants.State.ATTACKING:
			if attack_ai:
				attack_ai.stop_attacking()
			# Clear the *current* target, but not the objective
			current_target = null

func _recalculate_path() -> void:
	var target_node = current_target if is_instance_valid(current_target) else objective_target
	
	if not is_instance_valid(target_node):
		change_state(UnitAIConstants.State.IDLE)
		return
		
	target_position = target_node.global_position
	var allow_partial = is_instance_valid(target_node)
	
	path = SettlementManager.get_astar_path(unit.global_position, target_position, allow_partial)
	
	if path.is_empty():
		push_warning("Unit at %s failed to find a path to %s." % [unit.global_position, target_position])
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()

# --- Find Obstruction (FIXED) ---
func _find_closest_blocking_building() -> Node2D:
	var mission_node = unit.get_parent()
	if not is_instance_valid(mission_node) or not mission_node.has_node("BuildingContainer"):
		return null

	var building_container = mission_node.get_node("BuildingContainer")
	var buildings = building_container.get_children()
	
	var closest_building: Node2D = null
	var min_dist_sq = INF
	
	# Use the mask from AttackAI to determine what we are allowed to attack
	var valid_mask = 0
	if attack_ai:
		valid_mask = attack_ai.target_collision_mask
	
	var unit_pos = unit.global_position

	for building in buildings:
		if not building is BaseBuilding:
			continue
		
		# --- FIX: Check if this is a valid target ---
		# If the building's layer is not in our target mask, ignore it.
		# This prevents Player Units (Target Mask L3+L4) from attacking Player Buildings (L1)
		if not (building.collision_layer & valid_mask):
			continue
		# -------------------------------------------
			
		var dist_sq = unit_pos.distance_squared_to(building.global_position)
		if dist_sq < min_dist_sq:
			min_dist_sq = dist_sq
			closest_building = building
				
	return closest_building
# --- END FIX ---


# --- RTS Command Functions ---

func command_defensive_attack(attacker: Node2D) -> void:
	if not is_instance_valid(attacker):
		return
	
	if current_state == UnitAIConstants.State.ATTACKING and current_target == attacker:
		return
	
	current_target = attacker 
	change_state(UnitAIConstants.State.ATTACKING)

func command_attack_obstruction(target: Node2D) -> void:
	if not is_instance_valid(target):
		return
		
	current_target = target
	target_position = target.global_position
	
	var distance: float = unit.global_position.distance_to(target.global_position)
	
	if distance <= unit.data.attack_range:
		change_state(UnitAIConstants.State.ATTACKING)
	else:
		change_state(UnitAIConstants.State.MOVING)

func command_move_to_formation_pos(target_pos: Vector2) -> void:
	target_position = target_pos
	move_command_position = target_pos
	
	current_target = null 
	objective_target = null
	
	if attack_ai:
		attack_ai.stop_attacking()
	
	path.clear()
	path.append(target_pos)
	
	change_state(UnitAIConstants.State.FORMATION_MOVING)

func command_move_to(target_pos: Vector2) -> void:
	target_position = target_pos
	move_command_position = target_pos

	current_target = null
	objective_target = null
	
	if attack_ai:
		attack_ai.stop_attacking()
	
	change_state(UnitAIConstants.State.MOVING)

func command_attack(target: Node2D) -> void:
	if not is_instance_valid(target):
		if unit and unit.has_method("flash_error_color"):
			unit.flash_error_color()
		return
	
	objective_target = target
	current_target = target
	target_position = target.global_position
	
	var distance: float = unit.global_position.distance_to(target.global_position)
	
	if distance <= unit.data.attack_range:
		change_state(UnitAIConstants.State.ATTACKING)
	else:
		change_state(UnitAIConstants.State.MOVING)

# --- State Machine Update ---

func update(delta: float) -> void:
	match current_state:
		UnitAIConstants.State.IDLE:
			_idle_state(delta)
		UnitAIConstants.State.MOVING:
			_move_state(delta)
		UnitAIConstants.State.FORMATION_MOVING:
			_formation_move_state(delta)
		UnitAIConstants.State.ATTACKING:
			_attack_state(delta)

# --- State Logic Functions ---

func _idle_state(_delta: float) -> void:
	unit.velocity = Vector2.ZERO

func _formation_move_state(delta: float) -> void:
	if path.is_empty():
		change_state(UnitAIConstants.State.IDLE)
		return

	var next_waypoint: Vector2 = path[0]
	var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
	var velocity: Vector2 = direction * unit.data.move_speed
	
	unit.velocity = velocity
	unit.move_and_slide()
	
	var arrival_radius: float = 8.0 
	if unit.global_position.distance_to(next_waypoint) < arrival_radius:
		path.pop_front()
		
		if path.is_empty():
			change_state(UnitAIConstants.State.IDLE)

func _move_state(delta: float) -> void:
	var target_node = current_target if is_instance_valid(current_target) else objective_target

	if not is_instance_valid(target_node):
		change_state(UnitAIConstants.State.IDLE)
		return
	
	var distance_to_target: float = unit.global_position.distance_to(target_node.global_position)
	if distance_to_target <= unit.data.attack_range:
		change_state(UnitAIConstants.State.ATTACKING)
		return
	
	if not path.is_empty():
		var next_waypoint: Vector2 = path[0]
		var direction: Vector2 = (next_waypoint - unit.global_position).normalized()
		var velocity: Vector2 = direction * unit.data.move_speed
		
		unit.velocity = velocity
		unit.move_and_slide()
		
		var arrival_radius: float = 8.0 
		if unit.global_position.distance_to(next_waypoint) < arrival_radius:
			path.pop_front()
		
		# Stuck Timer Logic
		if unit.velocity.length_squared() < 1.0:
			stuck_timer += delta
			if stuck_timer > 1.5: # Stuck for 1.5 seconds
				var blocking_building = _find_closest_blocking_building()
				if is_instance_valid(blocking_building):
					# Found a VALID obstruction (Enemy)
					# push_warning("Unit is stuck. Attacking obstruction: %s" % blocking_building.name)
					command_attack_obstruction(blocking_building)
				else:
					# No valid obstruction (or it's friendly), so just give up
					change_state(UnitAIConstants.State.IDLE) 
				stuck_timer = 0.0 
		else:
			stuck_timer = 0.0 
			
		return
	
	# Path is empty logic
	if target_node == objective_target and is_instance_valid(objective_target):
		var blocking_building = _find_closest_blocking_building()
		if is_instance_valid(blocking_building):
			command_attack_obstruction(blocking_building)
		else:
			change_state(UnitAIConstants.State.IDLE)
	else:
		var direction: Vector2 = (target_node.global_position - unit.global_position).normalized()
		var velocity: Vector2 = direction * unit.data.move_speed
		unit.velocity = velocity
		unit.move_and_slide()
		
		if unit.velocity.length_squared() < 1.0:
			stuck_timer += delta
			if stuck_timer > 0.5:
				change_state(UnitAIConstants.State.IDLE)
				stuck_timer = 0.0
		else:
			stuck_timer = 0.0

func _attack_state(_delta: float) -> void:
	if not is_instance_valid(current_target):
		_resume_objective()
		return
	
	var distance_to_target: float = unit.global_position.distance_to(current_target.global_position)
	if distance_to_target > unit.data.attack_range + 10:
		_resume_objective()
		return
	
	unit.velocity = Vector2.ZERO

func _resume_objective() -> void:
	current_target = null
		
	if is_instance_valid(objective_target):
		current_target = objective_target
		change_state(UnitAIConstants.State.MOVING)
	else:
		if attack_ai and attack_ai.ai_mode == AttackAI.AI_Mode.DEFAULT:
			var new_target = _find_closest_enemy_in_los()
			if is_instance_valid(new_target):
				command_attack(new_target)
			else:
				change_state(UnitAIConstants.State.IDLE)
		else:
			change_state(UnitAIConstants.State.IDLE)

func _find_closest_enemy_in_los() -> Node2D:
	var mission_node = unit.get_parent()
	if not is_instance_valid(mission_node):
		return null

	var closest_target: Node2D = null
	var min_dist_sq = los_range * los_range
	var unit_pos = unit.global_position

	# 1. Check Enemy Buildings
	var building_container = mission_node.get_node_or_null("BuildingContainer")
	if is_instance_valid(building_container):
		for building in building_container.get_children():
			if not building is BaseBuilding or not (building.collision_layer & (1 << 3)):
				continue
				
			var dist_sq = unit_pos.distance_squared_to(building.global_position)
			if dist_sq < min_dist_sq:
				min_dist_sq = dist_sq
				closest_target = building

	# 2. Check Enemy Units
	var enemy_units = unit.get_tree().get_nodes_in_group("enemy_units")
	for enemy_unit in enemy_units:
		if not is_instance_valid(enemy_unit) or not enemy_unit is Node2D:
			continue

		var dist_sq = unit_pos.distance_squared_to(enemy_unit.global_position)
		if dist_sq < min_dist_sq:
			min_dist_sq = dist_sq
			closest_target = enemy_unit
			
	return closest_target

func _on_ai_attack_started(target: Node2D) -> void:
	if current_state != UnitAIConstants.State.IDLE:
		return
		
	if current_state == UnitAIConstants.State.ATTACKING and target == current_target:
		return
		
	if attack_ai.ai_mode == AttackAI.AI_Mode.DEFENSIVE_SIEGE:
		return
		
	current_target = target
	change_state(UnitAIConstants.State.ATTACKING)

func _on_ai_attack_stopped() -> void:
	if current_state == UnitAIConstants.State.ATTACKING:
		_resume_objective()

--- SCRIPT: res://scripts/buildings/SettlementBridge.gd ---
# res://scripts/buildings/SettlementBridge.gd
#
# --- REFACTORED (The "Proper Fix" + GridManager) ---
# This scene now instances a GridManager node for all grid logic.
# It gets the grid from that child and registers it with the SettlementManager.
extends Node

# --- Exported Resources ---
@export var home_base_data: SettlementData
@export var test_building_data: BuildingData
@export var raider_scene: PackedScene
# --- MODIFICATION: Renamed export ---
@export var end_of_year_popup_scene: PackedScene
# --- END MODIFICATION ---
@export var world_map_scene_path: String = "res://scenes/world_map/WorldMap_Stub.tscn"

# --- DEPRECATED: Grid config is now on the GridManager node ---
# @export var cell_size: int = 32
# @export var grid_width: int = 60
# @export var grid_height: int = 40

# --- Default Assets (fallback) ---
var default_test_building: BuildingData = preload("res://data/buildings/Bldg_Wall.tres")
var default_raider_scene: PackedScene 

# --- MODIFICATION: Renamed preload path and variable ---
var default_end_of_year_popup: PackedScene = preload("res://ui/EndOfYear_Popup.tscn")
# --- END MODIFICATION ---

# --- Scene Node References ---
@onready var unit_container: Node2D = $UnitContainer
@onready var ui_layer: CanvasLayer = $UI
@onready var restart_button: Button = $UI/RestartButton
@onready var start_raid_button: Button = $UI/StartRaidButton
@onready var storefront_ui: Control = $UI/Storefront_UI
@onready var building_cursor: Node2D = $BuildingCursor
# --- MODIFICATION: Renamed variable ---
var end_of_year_popup: PanelContainer
# --- END MODIFICATION ---

# --- NEW: Debug Button ---
@onready var debug_raid_button: Button = $UI/Storefront_UI/DebugRaidButton
# -----------------------

# --- Local Node References ---
@onready var building_container: Node2D = $BuildingContainer
@onready var grid_manager: Node = $GridManager # Reference to our new scene

# --- State Variables ---
var great_hall_instance: BaseBuilding = null
var game_is_over: bool = false
var awaiting_placement: BuildingData = null


func _ready() -> void:
	_setup_default_resources()
	_initialize_settlement() 
	_setup_ui()
	_connect_signals()
	
	# --- MODIFICATION ---
	# We no longer handle the payout here.
	# _handle_welcome_payout()
	# Instead, we just show the storefront immediately.
	storefront_ui.show()
	if end_of_year_popup:
		end_of_year_popup.hide()
	# --- END MODIFICATION ---

func _exit_tree() -> void:
	SettlementManager.unregister_active_scene_nodes()

func _setup_default_resources() -> void:
	if not test_building_data:
		test_building_data = default_test_building
	if not raider_scene:
		raider_scene = load("res://scenes/units/EnemyVikingRaider.tscn")
	# --- MODIFICATION: Renamed variables ---
	if not end_of_year_popup_scene: 
		end_of_year_popup_scene = default_end_of_year_popup
	# --- END MODIFICATION ---

func _initialize_settlement() -> void:
	"""Initialize data, then grid, then spawn buildings."""
	if not home_base_data:
		home_base_data = _create_default_settlement()
		print("SettlementBridge: Created default settlement data")
	else:
		if not home_base_data is SettlementData:
			push_warning("SettlementBridge: Inspector data is not SettlementData, creating default")
			home_base_data = _create_default_settlement()
		else:
			print("SettlementBridge: Using inspector settlement data")
	
	if home_base_data and (not home_base_data.resource_path or home_base_data.resource_path.is_empty()):
		home_base_data.resource_path = "res://data/settlements/home_base_fixed.tres"
		print("SettlementBridge: Set resource_path to: %s" % home_base_data.resource_path)
	
	# 1. Load data into the manager
	SettlementManager.load_settlement(home_base_data)
	
	# 2. Get the grid from our new GridManager child
	if not is_instance_valid(grid_manager) or not "astar_grid" in grid_manager:
		push_error("SettlementBridge: GridManager node is missing or invalid!")
		return
	var local_astar_grid = grid_manager.astar_grid
	
	# 3. Register our local nodes with the manager
	SettlementManager.register_active_scene_nodes(local_astar_grid, building_container)
	
	# 4. Spawn buildings into our local container
	_spawn_placed_buildings()
	
	# 5. Emit signal for other nodes (like StorefrontUI)
	EventBus.settlement_loaded.emit(home_base_data)

# --- REMOVED _initialize_local_grid() ---
# This logic is now inside GridManager.gd

func _spawn_placed_buildings() -> void:
	"""
	Instantiates buildings from the loaded settlement data
	using the (now delegated) SettlementManager.place_building function.
	"""
	if not SettlementManager.current_settlement:
		push_error("SettlementBridge: Cannot spawn buildings, no settlement data loaded.")
		return
	
	for child in building_container.get_children():
		child.queue_free()

	for building_entry in SettlementManager.current_settlement.placed_buildings:
		var building_res_path: String = building_entry["resource_path"]
		var grid_pos: Vector2i = building_entry["grid_position"]
		
		var building_data: BuildingData = load(building_res_path)
		if building_data:
			var new_building = SettlementManager.place_building(building_data, grid_pos)
			if new_building and new_building.data.display_name == "Great Hall":
				_setup_great_hall(new_building)
		else:
			push_error("Failed to load building resource from path: %s" % building_res_path)
	
	# Update grid once after all buildings are placed
	if is_instance_valid(SettlementManager.active_astar_grid):
		SettlementManager.active_astar_grid.update()
	
	print("SettlementBridge: Spawned %d buildings." % building_container.get_child_count())


func _create_default_settlement() -> SettlementData:
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 100, "stone": 200}
	var empty_buildings: Array[Dictionary] = []
	settlement.placed_buildings = empty_buildings
	settlement.garrisoned_units = {}
	settlement.resource_path = "res://data/settlements/home_base_fixed.tres"
	return settlement

func _setup_ui() -> void:
	# --- MODIFICATION: Renamed variables ---
	end_of_year_popup = end_of_year_popup_scene.instantiate()
	ui_layer.add_child(end_of_year_popup)
	end_of_year_popup.collect_button_pressed.connect(_on_payout_collected)
	# --- END MODIFICATION ---
	
	# We hide the storefront here initially
	storefront_ui.hide()

func _connect_signals() -> void:
	restart_button.pressed.connect(_on_restart_pressed)
	start_raid_button.pressed.connect(_on_start_raid_pressed)
	
	EventBus.settlement_loaded.connect(_on_settlement_loaded)
	EventBus.building_ready_for_placement.connect(_on_building_ready_for_placement)
	EventBus.building_placement_cancelled.connect(_on_building_placement_cancelled)
	
	if building_cursor:
		building_cursor.placement_completed.connect(_on_building_placement_completed)
		building_cursor.placement_cancelled.connect(_on_building_placement_cancelled_by_cursor)

	# --- NEW: Connect Debug Button ---
	if is_instance_valid(debug_raid_button):
		debug_raid_button.pressed.connect(_on_debug_raid_pressed)
	# --- END NEW ---

func _handle_welcome_payout() -> void:
	var payout = SettlementManager.calculate_payout()
	# --- MODIFICATION: Renamed variable ---
	if not payout.is_empty():
		end_of_year_popup.display_payout(payout)
		storefront_ui.hide()
	else:
		# If no payout, just show the store
		storefront_ui.show()
		end_of_year_popup.hide()
	# --- END MODIFICATION ---

func _on_settlement_loaded(_settlement_data: SettlementData) -> void:
	pass

# --- MODIFICATION: Removed _unhandled_input ---
# func _unhandled_input(event: InputEvent) -> void: ...
# --- END MODIFICATION ---

# --- NEW: Debug Button Function ---
func _on_debug_raid_pressed() -> void:
	print("DEBUG: Forcing defensive raid mission!")
	DynastyManager.is_defensive_raid = true
	EventBus.scene_change_requested.emit("raid_mission")
# --- END NEW ---

func _on_payout_collected(payout: Dictionary) -> void:
	SettlementManager.deposit_resources(payout)
	storefront_ui.show()

func _setup_great_hall(hall_instance: BaseBuilding) -> void:
	if not is_instance_valid(hall_instance):
		push_error("SettlementBridge: Invalid Great Hall instance provided.")
		return
	
	great_hall_instance = hall_instance
	great_hall_instance.building_destroyed.connect(_on_great_hall_destroyed)
	print("Great Hall found and connected.")

func _on_great_hall_destroyed(_building: BaseBuilding) -> void:
	print("GAME OVER: The Great Hall has been destroyed!")
	game_is_over = true
	var label : Label = $UI/Label
	label.text = "YOU HAVE BEEN SACKED."
	restart_button.show()
	_destroy_all_enemies()

func _destroy_all_enemies() -> void:
	for enemy in unit_container.get_children():
		enemy.queue_free()
	print("All surviving enemies have been removed.")

func _on_restart_pressed() -> void:
	get_tree().reload_current_scene()

func _on_start_raid_pressed() -> void:
	print("Opening world map...")
	
	if not SettlementManager.current_settlement:
		push_error("Cannot open world map: No settlement loaded")
		return
	
	if SettlementManager.current_settlement.garrisoned_units.is_empty():
		print("Warning: No units in garrison. Adding test unit.")
		var test_unit_path = "res://data/units/EnemyVikingRaider_Data.tres"
		SettlementManager.current_settlement.garrisoned_units[test_unit_path] = 2
		SettlementManager.save_settlement()
	
	print("Settlement loaded with garrison: %s" % SettlementManager.current_settlement.garrisoned_units)
	
	if not world_map_scene_path.is_empty():
		EventBus.scene_change_requested.emit("world_map")
	else:
		push_error("world_map_scene_path is not set! Cannot change scene.")

# --- Building Cursor System Functions ---

func _on_building_ready_for_placement(building_data: BuildingData) -> void:
	awaiting_placement = building_data
	# Pass the cell_size from our GridManager to the cursor
	building_cursor.cell_size = grid_manager.cell_size
	building_cursor.set_building_preview(building_data)
	print("Building ready for placement: %s" % building_data.display_name)

func _on_building_placement_cancelled(building_data: BuildingData) -> void:
	print("Building placement cancelled: %s" % building_data.display_name)

func _on_building_placement_completed() -> void:
	print("Building placement completed successfully. Saving settlement.")
	
	if awaiting_placement and SettlementManager.current_settlement:
		var snapped_grid_pos = Vector2i(building_cursor.global_position / grid_manager.cell_size)
		
		var building_entry = {
			"resource_path": awaiting_placement.resource_path,
			"grid_position": snapped_grid_pos
		}
		SettlementManager.current_settlement.placed_buildings.append(building_entry)
		SettlementManager.save_settlement()
		print("Added %s to settlement data at %s" % [awaiting_placement.display_name, snapped_grid_pos])
	
	awaiting_placement = null

func _on_building_placement_cancelled_by_cursor() -> void:
	if awaiting_placement:
		SettlementManager.deposit_resources(awaiting_placement.build_cost)
		print("Building placement cancelled by cursor, refunded: %s" % awaiting_placement.build_cost)
		
		awaiting_placement = null

--- SCRIPT: res://scripts/formations/SquadFormation.gd ---
# res://scripts/formations/SquadFormation.gd
# Squad Formation Manager - Company of Heroes style formations
# Handles formation positioning and movement for multiple units

class_name SquadFormation

enum FormationType {
	LINE,      # Horizontal line formation  
	COLUMN,    # Vertical column formation
	WEDGE,     # V-shaped formation
	BOX,       # Rectangular formation
	CIRCLE     # Circular formation
}

# Formation settings
var formation_type: FormationType = FormationType.LINE
var unit_spacing: float = 40.0
var max_units_per_row: int = 4

# Squad data
var units: Array[Node2D] = []
var leader_position: Vector2 = Vector2.ZERO
var target_position: Vector2 = Vector2.ZERO
var formation_center: Vector2 = Vector2.ZERO

# Movement state
var is_moving: bool = false
var move_speed: float = 100.0

func _init(squad_units: Array[Node2D] = []) -> void:
	units = squad_units
	if not units.is_empty():
		formation_center = _calculate_center_position()

func add_unit(unit: Node2D) -> void:
	"""Add a unit to the squad"""
	if unit not in units:
		units.append(unit)
		_update_formation_positions()

func remove_unit(unit: Node2D) -> void:
	"""Remove a unit from the squad"""
	units.erase(unit)
	_update_formation_positions()

func set_formation_type(new_type: FormationType) -> void:
	"""Change the formation type"""
	formation_type = new_type
	_update_formation_positions()

# --- MODIFIED: Added direction vector parameter ---
func move_to_position(target_pos: Vector2, direction: Vector2 = Vector2.DOWN) -> void:
	"""Command the entire squad to move to a target position"""
	target_position = target_pos
	is_moving = true
	
	# Calculate formation positions around the target, using the direction
	var formation_positions = _calculate_formation_positions(target_pos, direction)
	
	# Assign each unit a position in the formation
	for i in range(min(units.size(), formation_positions.size())):
		var unit = units[i]
		if not is_instance_valid(unit):
			continue
		var target_formation_pos = formation_positions[i]
		
		# Move the unit to its formation position
		_move_unit_to_position(unit, target_formation_pos)
	
	print("Squad moving to %s in %s formation with %d units" % [target_pos, FormationType.keys()[formation_type], units.size()])

# --- MODIFIED: Added direction and rotation logic ---
func _calculate_formation_positions(center_pos: Vector2, direction: Vector2) -> Array[Vector2]:
	"""Calculate formation positions based on formation type"""
	var positions: Array[Vector2] = []
	var unit_count = units.size()
	
	# --- AI FIX: Invert the direction vector ---
	# The user is dragging *from* the center *to* the facing direction.
	# Our previous logic was calculating the opposite rotation.
	# Inverting the vector here corrects the rotation 180 degrees.
	var rotation_angle = Vector2.DOWN.angle_to(direction * -1.0)
	# ------------------------------------------
	
	match formation_type:
		FormationType.LINE:
			positions = _calculate_line_formation(center_pos, unit_count)
		FormationType.COLUMN:
			positions = _calculate_column_formation(center_pos, unit_count)
		FormationType.WEDGE:
			positions = _calculate_wedge_formation(center_pos, unit_count)
		FormationType.BOX:
			positions = _calculate_box_formation(center_pos, unit_count)
		FormationType.CIRCLE:
			positions = _calculate_circle_formation(center_pos, unit_count)
	
	# --- NEW: Rotate all points ---
	var rotated_positions: Array[Vector2] = []
	for pos in positions:
		# 1. Translate position to be relative to center_pos
		var relative_pos = pos - center_pos
		# 2. Rotate it
		var rotated_relative_pos = relative_pos.rotated(rotation_angle)
		# 3. Translate it back to world space
		rotated_positions.append(center_pos + rotated_relative_pos)
	
	return rotated_positions
	# ---------------------------------
	
func _calculate_line_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate horizontal line formation positions"""
	var positions: Array[Vector2] = []
	var start_x = center_pos.x - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(start_x + i * unit_spacing, center_pos.y)
		positions.append(pos)
	
	return positions

func _calculate_column_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate vertical column formation positions"""
	var positions: Array[Vector2] = []
	var start_y = center_pos.y - (unit_count - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var pos = Vector2(center_pos.x, start_y + i * unit_spacing)
		positions.append(pos)
	
	return positions

func _calculate_wedge_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate V-shaped wedge formation positions"""
	var positions: Array[Vector2] = []
	
	# Leader at the front (relative to center_pos.y)
	positions.append(center_pos)
	
	# Place remaining units in V formation behind the leader
	var side_offset = unit_spacing * 0.7  # 70% spacing for tighter formation
	var rear_offset = unit_spacing
	
	for i in range(1, unit_count):
		var row = (i + 1) / 2  # Which row behind the leader
		var side = 1 if i % 2 == 1 else -1  # Left or right side
		
		# --- AI FIX: Changed from - to + to face DOWN by default ---
		var pos = Vector2(
			center_pos.x + side * side_offset * row,
			center_pos.y + rear_offset * row
		)
		# -----------------------------------------------------------
		positions.append(pos)
	
	return positions

func _calculate_box_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate rectangular box formation positions"""
	var positions: Array[Vector2] = []
	
	var rows = int(ceil(float(unit_count) / max_units_per_row))
	var cols = min(unit_count, max_units_per_row)
	
	var start_x = center_pos.x - (cols - 1) * unit_spacing * 0.5
	var start_y = center_pos.y - (rows - 1) * unit_spacing * 0.5
	
	for i in range(unit_count):
		var row = i / max_units_per_row
		var col = i % max_units_per_row
		
		# Center the last row if it has fewer units
		var row_unit_count = min(max_units_per_row, unit_count - row * max_units_per_row)
		var row_start_x = center_pos.x - (row_unit_count - 1) * unit_spacing * 0.5
		
		var pos = Vector2(
			row_start_x + col * unit_spacing,
			start_y + row * unit_spacing
		)
		positions.append(pos)
	
	return positions

func _calculate_circle_formation(center_pos: Vector2, unit_count: int) -> Array[Vector2]:
	"""Calculate circular formation positions"""
	var positions: Array[Vector2] = []
	var radius = max(unit_spacing, unit_count * unit_spacing / (2 * PI))
	
	for i in range(unit_count):
		var angle = (2 * PI * i) / unit_count
		var pos = Vector2(
			center_pos.x + cos(angle) * radius,
			center_pos.y + sin(angle) * radius
		)
		positions.append(pos)
	
	return positions

# --- MODIFIED: To call the new FSM function ---
func _move_unit_to_position(unit: Node2D, target_pos: Vector2) -> void:
	"""Move a specific unit to a target position"""
	if not is_instance_valid(unit):
		return
	
	# Check if unit has FSM (proper unit system)
	if "fsm" in unit and unit.fsm != null:
		# Call the new formation-specific move function
		unit.fsm.command_move_to_formation_pos(target_pos)
	# Check if unit has direct movement method
	elif unit.has_method("command_move_to"):
		# Fallback for non-FSM units (like old test units)
		unit.command_move_to(target_pos)
	# Fallback: simple movement for test units
	else:
		_simple_unit_movement(unit, target_pos)
# --- END MODIFICATION ---

func _simple_unit_movement(unit: Node2D, target_pos: Vector2) -> void:
	"""Simple movement system for test units without FSM"""
	if not unit.has_method("set_target_position"):
		# Add simple movement script to unit if it doesn't have one
		var movement_script = """
var target_position: Vector2 = Vector2.ZERO
var move_speed: float = 100.0
var is_moving: bool = false

func set_target_position(pos: Vector2) -> void:
	target_position = pos
	is_moving = true

func _physics_process(delta: float) -> void:
	if is_moving and target_position != Vector2.ZERO:
		var direction = (target_position - global_position).normalized()
		var distance = global_position.distance_to(target_position)
		
		if distance < 5.0:
			is_moving = false
			velocity = Vector2.ZERO
		else:
			velocity = direction * move_speed
		
		move_and_slide()
"""
		# Create and attach movement behavior
		var script = GDScript.new()
		var existing_script = unit.get_script()
		if existing_script:
			script.source_code = existing_script.source_code + "\n" + movement_script
		else:
			push_error("Unit has no script, cannot add simple movement.")
			return
		script.reload()
		unit.set_script(script)
	
	# Set the target position
	unit.set_target_position(target_pos)

func _update_formation_positions() -> void:
	"""Update formation positions for current units"""
	if not units.is_empty():
		formation_center = _calculate_center_position()

func _calculate_center_position() -> Vector2:
	"""Calculate the center position of all units"""
	if units.is_empty():
		return Vector2.ZERO
	
	var total_pos = Vector2.ZERO
	for unit in units:
		if is_instance_valid(unit):
			total_pos += unit.global_position
	
	return total_pos / units.size()

func get_unit_count() -> int:
	"""Get the number of units in the squad"""
	return units.size()

func is_squad_moving() -> bool:
	"""Check if the squad is currently moving"""
	return is_moving

func get_formation_info() -> Dictionary:
	"""Get information about the current formation"""
	return {
		"type": FormationType.keys()[formation_type],
		"unit_count": units.size(),
		"spacing": unit_spacing,
		"center": formation_center,
		"is_moving": is_moving
	}

--- SCRIPT: res://scripts/ui/BuildingPreviewCursor.gd ---
# BuildingPreviewCursor.gd - RTS-style building placement system
extends Node2D
class_name BuildingPreviewCursor

# Building preview components
var current_building_data: BuildingData
var preview_sprite: Sprite2D
var is_active: bool = false

# Grid and placement
var cell_size: int = 32 # This is now SET by the scene (e.g., SettlementBridge)
var grid_overlay: Node2D
var can_place: bool = false

# Visual feedback
var valid_color: Color = Color(0.0, 1.0, 0.0, 0.7)    # Green for valid placement
var invalid_color: Color = Color(1.0, 0.0, 0.0, 0.7)  # Red for invalid placement

signal placement_completed
signal placement_cancelled

func _ready() -> void:
	# Ensure we're always on top for visibility
	z_index = 100
	
	# Create grid overlay for visual feedback
	grid_overlay = Node2D.new()
	grid_overlay.name = "GridOverlay"
	add_child(grid_overlay)
	
	# --- THIS IS THE FIX ---
	# Removed dependency on SettlementManager.tile_size
	# The 'cell_size' var will be set externally by SettlementBridge.gd
	# -----------------------
	print("BuildingPreviewCursor ready. Waiting for cell_size to be set.")

func set_building_preview(building_data: BuildingData) -> void:
	"""Start building placement mode with the specified building"""
	if not building_data:
		print("ERROR: No building data provided to set_building_preview")
		return
	
	if cell_size <= 0:
		push_error("BuildingPreviewCursor: cell_size is not set! Cannot create preview.")
		return
	
	print("Setting building preview for: %s" % building_data.display_name)
	current_building_data = building_data
	
	# Clean up any existing preview
	_cleanup_preview()
	
	# Create new preview sprite
	preview_sprite = Sprite2D.new()
	preview_sprite.name = "PreviewSprite"
	
	# Set up the building texture
	if building_data.building_texture:
		preview_sprite.texture = building_data.building_texture
	else:
		# Create a simple colored rectangle if no texture
		var texture = _create_building_texture(building_data)
		preview_sprite.texture = texture
		print("Created fallback texture for preview")
	
	
	# --- Automatic Scaling Logic ---
	
	# 1. Get the target size based on grid
	var target_size: Vector2 = Vector2(building_data.grid_size) * cell_size
	
	# 2. Scale the Sprite (if texture exists)
	if preview_sprite.texture:
		var texture_size: Vector2 = preview_sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			var new_scale: Vector2 = target_size / texture_size
			preview_sprite.scale = new_scale
		else:
			push_warning("BuildingPreviewCursor: Texture for '%s' has invalid size %s. Cannot scale preview." % [building_data.display_name, texture_size])
	else:
		push_warning("BuildingPreviewCursor: No texture for '%s' preview." % building_data.display_name)
			
	# --- END SCALING LOGIC ---

	
	# Set semi-transparent
	preview_sprite.modulate = valid_color
	add_child(preview_sprite)
	
	# Create grid outline to show building footprint
	_create_grid_outline(building_data.grid_size)
	
	# Activate placement mode
	is_active = true
	visible = true

func _create_building_texture(building_data: BuildingData) -> ImageTexture:
	"""Create a simple colored texture for buildings without textures"""
	var size = Vector2i(
		building_data.grid_size.x * cell_size,
		building_data.grid_size.y * cell_size
	)
	
	var image = Image.create(size.x, size.y, false, Image.FORMAT_RGBA8)
	var color = _get_building_color(building_data)
	image.fill(color)
	
	var texture = ImageTexture.new()
	texture.set_image(image)
	return texture

func _create_grid_outline(grid_size: Vector2i) -> void:
	"""Create a visual outline showing the building's grid footprint"""
	_clear_grid_overlay()
	
	var outline_color = Color.WHITE
	var line_width = 2.0
	
	# This var 'rect_size' now correctly uses the synced 'cell_size'
	var rect_size = Vector2(grid_size.x * cell_size, grid_size.y * cell_size)
	
	# Create outline using Line2D nodes for each edge
	var lines = []
	
	# Top line
	var top_line = Line2D.new()
	top_line.add_point(Vector2(0, 0))
	top_line.add_point(Vector2(rect_size.x, 0))
	top_line.width = line_width
	top_line.default_color = outline_color
	lines.append(top_line)
	
	# Right line
	var right_line = Line2D.new()
	right_line.add_point(Vector2(rect_size.x, 0))
	right_line.add_point(Vector2(rect_size.x, rect_size.y))
	right_line.width = line_width
	right_line.default_color = outline_color
	lines.append(right_line)
	
	# Bottom line
	var bottom_line = Line2D.new()
	bottom_line.add_point(Vector2(rect_size.x, rect_size.y))
	bottom_line.add_point(Vector2(0, rect_size.y))
	bottom_line.width = line_width
	bottom_line.default_color = outline_color
	lines.append(bottom_line)
	
	# Left line
	var left_line = Line2D.new()
	left_line.add_point(Vector2(0, rect_size.y))
	left_line.add_point(Vector2(0, 0))
	left_line.width = line_width
	left_line.default_color = outline_color
	lines.append(left_line)
	
	# Add lines to grid overlay
	for line in lines:
		grid_overlay.add_child(line)

func _clear_grid_overlay() -> void:
	"""Clear the grid overlay visual elements"""
	for child in grid_overlay.get_children():
		child.queue_free()

func _get_building_color(building_data: BuildingData) -> Color:
	"""Get a representative color for the building type"""
	var name = building_data.display_name.to_lower()
	if "wall" in name:
		return Color(0.7, 0.5, 0.3, 1.0) # Brown
	elif "hall" in name:
		return Color(0.8, 0.8, 0.2, 1.0) # Yellow
	elif "tower" in name or "watchtower" in name:
		return Color(0.5, 0.5, 0.8, 1.0) # Blue
	elif "lumber" in name:
		return Color(0.3, 0.8, 0.3, 1.0) # Green
	elif "granary" in name:
		return Color(0.9, 0.6, 0.2, 1.0) # Orange
	elif "chapel" in name or "library" in name or "scriptorium" in name:
		return Color(0.8, 0.4, 0.8, 1.0) # Purple
	else:
		return Color(0.6, 0.6, 0.6, 1.0) # Gray

func _process(_delta: float) -> void:
	"""Update cursor position and placement validity"""
	if not is_active or not current_building_data:
		return
	
	# Get mouse position and snap to grid
	var mouse_pos = get_global_mouse_position()
	var grid_pos = _world_to_grid(mouse_pos)
	var snapped_world_pos = _grid_to_world(grid_pos)
	
	# Update cursor position
	global_position = snapped_world_pos
	
	# Check placement validity
	can_place = _can_place_at_position(grid_pos)
	
	# Update visual feedback
	_update_visual_feedback()

func _world_to_grid(world_pos: Vector2) -> Vector2i:
	"""Convert world position to grid coordinates"""
	if cell_size <= 0: return Vector2i.ZERO # Safety check
	return Vector2i(int(world_pos.x / cell_size), int(world_pos.y / cell_size))

func _grid_to_world(grid_pos: Vector2i) -> Vector2:
	"""Convert grid coordinates to world position (centered on cell)"""
	return Vector2(grid_pos.x * cell_size, grid_pos.y * cell_size)

func _can_place_at_position(grid_pos: Vector2i) -> bool:
	"""Check if building can be placed by asking the SettlementManager."""
	if not SettlementManager or not current_building_data:
		return false
	
	# This call still works because SettlementManager delegates
	# to the registered AStarGrid object.
	return SettlementManager.is_placement_valid(grid_pos, current_building_data.grid_size)

func _update_visual_feedback() -> void:
	"""Update the visual appearance based on placement validity"""
	if not preview_sprite:
		return
	
	# Change color based on placement validity
	if can_place:
		preview_sprite.modulate = valid_color
		_set_grid_overlay_color(Color.GREEN)
	else:
		preview_sprite.modulate = invalid_color
		_set_grid_overlay_color(Color.RED)

func _set_grid_overlay_color(color: Color) -> void:
	"""Set the color of the grid overlay lines"""
	for child in grid_overlay.get_children():
		if child is Line2D:
			child.default_color = color

func place_building() -> bool:
	"""Attempt to place the building at current position"""
	if not is_active or not current_building_data or not can_place:
		print("Cannot place building: not active (%s), no data (%s), or invalid position (%s)" % [is_active, current_building_data != null, can_place])
		return false
	
	var grid_pos = _world_to_grid(global_position)
	
	print("Attempting to place %s at grid position %s" % [current_building_data.display_name, grid_pos])
	
	# This call still works!
	var new_building = SettlementManager.place_building(current_building_data, grid_pos)
	
	if new_building:
		print("Successfully placed building: %s" % current_building_data.display_name)
		placement_completed.emit()
		cancel_preview()
		return true
	else:
		print("Failed to place building through SettlementManager")
		return false

func cancel_preview() -> void:
	"""Cancel building placement and clean up"""
	print("Cancelling building preview")
	
	is_active = false
	visible = false
	current_building_data = null
	can_place = false
	
	_cleanup_preview()
	placement_cancelled.emit()

func _cleanup_preview() -> void:
	"""Clean up preview visual elements"""
	if preview_sprite:
		preview_sprite.queue_free()
		preview_sprite = null
	
	_clear_grid_overlay()

func _input(event: InputEvent) -> void:
	"""Handle input for building placement"""
	if not is_active:
		return
	
	if event is InputEventMouseButton and event.is_pressed():
		if event.button_index == MOUSE_BUTTON_LEFT:
			# Attempt to place building
			if place_building():
				print("Building placed successfully")
			else:
				print("Failed to place building")
			get_viewport().set_input_as_handled()
		
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			# Cancel placement
			print("Building placement cancelled by right click")
			cancel_preview()
			get_viewport().set_input_as_handled()

--- SCRIPT: res://scripts/ui/PauseMenu.gd ---
# res://ui/PauseMenu.gd
#
# This script controls the pause menu itself.
# It runs while the game is paused (Process Mode = "When Paused").
# It is responsible for unpausing the game.

extends CanvasLayer

@onready var resume_button: Button = $PanelContainer/VBoxContainer/ResumeButton
@onready var save_button: Button = $PanelContainer/VBoxContainer/SaveButton
@onready var quit_button: Button = $PanelContainer/VBoxContainer/QuitButton


func _ready() -> void:
	# Connect signals in code
	resume_button.pressed.connect(_on_resume_pressed)
	save_button.pressed.connect(_on_save_pressed)
	quit_button.pressed.connect(_on_quit_pressed)


func _unhandled_input(event: InputEvent) -> void:
	# Also allow 'Escape' to close the pause menu
	if event.is_action_pressed("ui_pause"):
		get_viewport().set_input_as_handled() # Consume the event
		_on_resume_pressed()


func _on_resume_pressed() -> void:
	"""Unpauses the game and removes the menu."""
	get_tree().paused = false
	queue_free() # Destroy the menu


func _on_save_pressed() -> void:
	"""Saves the game state via the SettlementManager."""
	if SettlementManager.has_current_settlement():
		SettlementManager.save_settlement()
		print("Game saved from pause menu.")
	else:
		print("Pause Menu: No settlement loaded, cannot save.")


func _on_quit_pressed() -> void:
	"""Quits the game."""
	get_tree().quit()

--- SCRIPT: res://scripts/units/Base_Unit.gd ---
# res://scripts/units/Base_Unit.gd
# Base unit class for all units in the Viking Dynasty RTS

class_name BaseUnit
extends CharacterBody2D

signal destroyed

@export var data: UnitData
# Removed the : UnitFSM type hint to break the circular dependency.
var fsm
var current_health: int = 50
var attack_ai: AttackAI = null

# Node refs
@onready var attack_timer: Timer = $AttackTimer
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
@onready var separation_area: Area2D = $SeparationArea

@export_group("AI")
@export var separation_enabled: bool = true
@export var separation_force: float = 30.0
@export var separation_radius: float = 40.0

# Visual state system
var _color_tween: Tween
# --- THIS IS THE FIX ---
# Changed all references from UnitFSM.State to UnitAIConstants.State
const STATE_COLORS := {
	UnitAIConstants.State.IDLE: Color(0.3, 0.6, 1.0),     # Blue
	UnitAIConstants.State.MOVING: Color(0.4, 1.0, 0.4),   # Green
	UnitAIConstants.State.FORMATION_MOVING: Color(0.4, 1.0, 0.4), # Green
	UnitAIConstants.State.ATTACKING: Color(1.0, 0.3, 0.3) # Red
}
# --- END FIX ---
const ERROR_COLOR := Color(0.7, 0.3, 1.0)

func _ready() -> void:
	if not data:
		push_warning("BaseUnit: Node '%s' is missing its 'UnitData' resource. Cannot initialize." % name)
		return
	
	current_health = data.max_health
	_apply_texture_and_scale()
	
	if data.ai_component_scene:
		attack_ai = data.ai_component_scene.instantiate() as AttackAI
		if attack_ai:
			add_child(attack_ai)
			attack_ai.configure_from_data(data)
			
			var target_mask = 0
			if self.collision_layer & 2: # Player unit (Layer 2)
				target_mask = (1 << 2) | (1 << 3) # Target Enemy Units (L3) & Enemy Buildings (L4)
			elif self.collision_layer & 4: # Enemy unit (Layer 3)
				target_mask = (1 << 0) | (1 << 1) # Target Player Buildings (L1) & Player Units (L2)
			
			if target_mask == 0:
				push_warning("BaseUnit: '%s' is on an unhandled collision layer (%s). AI will not target anything." % [name, self.collision_layer])
			
			attack_ai.set_target_mask(target_mask)
		else:
			push_error("BaseUnit: Failed to instantiate ai_component_scene for %s" % data.display_name)
	
	fsm = UnitFSM.new(self, attack_ai)
	
	# --- THIS IS THE FIX ---
	sprite.modulate = STATE_COLORS.get(UnitAIConstants.State.IDLE, Color.WHITE)
	# --- END FIX ---
	
	EventBus.pathfinding_grid_updated.connect(_on_grid_updated)
	
	separation_area.collision_mask = 2
	
	var area_shape = separation_area.get_node_or_null("CollisionShape2D")
	if area_shape and area_shape.shape is CircleShape2D:
		area_shape.shape.radius = separation_radius
	else:
		push_warning("'%s' has no 'SeparationArea/CollisionShape2D' with a CircleShape!" % name)

func _apply_texture_and_scale() -> void:
	if data.target_pixel_size.x <= 0 or data.target_pixel_size.y <= 0:
		push_warning("BaseUnit: '%s' has a target_pixel_size of %s, which is invalid." % [data.display_name, data.target_pixel_size])
		return
		
	var target_size: Vector2 = data.target_pixel_size

	if data.visual_texture:
		sprite.texture = data.visual_texture
		var texture_size: Vector2 = sprite.texture.get_size()
		
		if texture_size.x > 0 and texture_size.y > 0:
			var new_scale: Vector2 = target_size / texture_size
			sprite.scale = new_scale
		else:
			push_warning("BaseUnit: Texture for '%s' has an invalid size of %s. Cannot scale sprite." % [data.display_name, texture_size])
	else:
		push_warning("BaseUnit: '%s' is missing its 'visual_texture'. Sprite will be blank or use placeholder." % data.display_name)
		
	if collision_shape and collision_shape.shape is RectangleShape2D:
		collision_shape.shape.size = target_size
	else:
		push_warning("BaseUnit: '%s' is missing its CollisionShape2D node or its shape is not a RectangleShape2D. Collision will not match visuals." % data.display_name)

func _exit_tree() -> void:
	if EventBus.is_connected("pathfinding_grid_updated", _on_grid_updated):
		EventBus.pathfinding_grid_updated.disconnect(_on_grid_updated)

func _on_grid_updated(_grid_pos: Vector2i) -> void:
	# --- THIS IS THE FIX ---
	if fsm and fsm.current_state == UnitAIConstants.State.MOVING:
	# --- END FIX ---
		fsm._recalculate_path()

func _physics_process(delta: float) -> void:
	if not data:
		return

	var fsm_velocity = Vector2.ZERO
	if fsm:
		fsm.update(delta)
		fsm_velocity = velocity
		velocity = Vector2.ZERO 
	
	var target_fsm_velocity = Vector2.ZERO
	
	# --- THIS IS THE FIX ---
	if fsm and (fsm.current_state == UnitAIConstants.State.MOVING or fsm.current_state == UnitAIConstants.State.FORMATION_MOVING):
	# --- END FIX ---
		target_fsm_velocity = fsm_velocity
	
	if target_fsm_velocity.length() > 0.1:
		velocity = velocity.lerp(target_fsm_velocity, data.acceleration * delta)
	else:
		velocity = velocity.lerp(Vector2.ZERO, data.linear_damping * delta)
	
	if separation_enabled:
		var separation_push = _calculate_separation_push(delta)
		velocity += separation_push

	move_and_slide()

func _calculate_separation_push(delta: float) -> Vector2:
	var push_vector = Vector2.ZERO
	var neighbors = separation_area.get_overlapping_bodies()
	if neighbors.is_empty():
		return Vector2.ZERO
		
	for neighbor in neighbors:
		if neighbor == self or not neighbor is CharacterBody2D:
			continue
			
		var away_vector = global_position - neighbor.global_position
		var distance_sq = away_vector.length_squared()
		
		if distance_sq > 0.01 and distance_sq < separation_radius * separation_radius:
			var push_strength = 1.0 - (sqrt(distance_sq) / separation_radius)
			push_vector += away_vector.normalized() * push_strength
			
	return push_vector * separation_force * delta

# --- THIS IS THE FIX ---
func on_state_changed(state: UnitAIConstants.State) -> void:
# --- END FIX ---
	var to_color: Color = STATE_COLORS.get(state, Color.WHITE)
	_tween_color(to_color, 0.2)

func flash_error_color() -> void:
	var back_color: Color = STATE_COLORS.get(fsm.current_state, Color.WHITE)
	var t := create_tween()
	t.tween_property(sprite, "modulate", ERROR_COLOR, 0.08).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
	t.tween_property(sprite, "modulate", back_color, 0.18).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

func _tween_color(to_color: Color, duration: float = 0.2) -> void:
	if _color_tween and _color_tween.is_running():
		_color_tween.kill()
	_color_tween = create_tween()
	_color_tween.tween_property(sprite, "modulate", to_color, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

# --- MODIFIED: Added attacker parameter ---
func take_damage(amount: int, attacker: Node2D = null) -> void:
	current_health = max(0, current_health - amount)
	
	# --- NEW: Retaliation Logic ---
	if fsm and is_instance_valid(attacker):
		# Tell the FSM we are being attacked
		fsm.command_defensive_attack(attacker)
	# --- END NEW ---
	
	if current_health == 0:
		die()

func die() -> void:
	destroyed.emit()
	queue_free()

func command_move_to(target_pos: Vector2) -> void:
	if fsm:
		fsm.command_move_to(target_pos)

func command_attack(target: Node2D) -> void:
	if fsm:
		fsm.command_attack(target)

var is_selected: bool = false

func set_selected(selected: bool) -> void:
	is_selected = selected
	
	if is_selected:
		_show_selection_indicator()
	else:
		_hide_selection_indicator()

func _show_selection_indicator() -> void:
	queue_redraw()

func _hide_selection_indicator() -> void:
	queue_redraw()

func _draw() -> void:
	if is_selected:
		var radius = 25.0
		var color = Color.YELLOW
		color.a = 0.8
		draw_circle(Vector2.ZERO, radius, color, false, 3.0)

--- SCRIPT: res://scripts/units/EnemyVikingRaider.gd ---
# res://scripts/units/EnemyVikingRaider.gd
#
# Concrete implementation of the Viking Raider enemy unit.
#
# --- MODIFIED: Target position is now set correctly ---

extends BaseUnit

# This function is called by the 'SettlementBridge' spawner
func set_attack_target(target: BaseBuilding) -> void:
	"""
	Gives the Raider its one and only goal.
	"""
	if not fsm or not is_instance_valid(target):
		push_warning("Raider FSM or target is not valid.")
		return

	# Set the node (for attacking)
	fsm.target_unit = target
	
	# --- THIS IS THE FIX ---
	# Target the building's actual center.
	# The FSM will find the closest walkable spot.
	fsm.target_position = target.global_position
	# --- END FIX ---
	
	# Start the FSM
	# --- THIS IS THE FINAL FIX ---
	# Updated to use the new constants script
	fsm.change_state(UnitAIConstants.State.MOVING)
	# --- END FIX ---
	print("Viking Raider initialized and moving to target: %s" % target.data.display_name)

--- SCRIPT: res://scripts/units/PlayerVikingRaider.gd ---
# res://scripts/units/PlayerVikingRaider.gd
#
# Player-controlled Viking Raider unit.
# This script is now much simpler. It just inherits all the
# complex logic from BaseUnit and the FSM.

extends BaseUnit
class_name PlayerVikingRaider

func _ready() -> void:
	# Call parent _ready first to initialize base unit systems
	super._ready()
	
	# Add to player units group for RTS selection and control
	add_to_group("player_units")
	
	print("PlayerVikingRaider '%s' initialized and ready for RTS control" % name)

# --- THIS IS THE FIX ---
# We override the command_attack function just to add a print statement,
# then we call super.command_attack(target) to let the Base_Unit and FSM
# handle the *actual* logic correctly.
func command_attack(target: Node2D) -> void:
	if not fsm or not is_instance_valid(target):
		push_warning("Player Raider FSM or target is not valid.")
		return

	print("Player Viking Raider '%s' attacking %s" % [name, target.name])

	# Pass the command to the base class, which will pass it to the FSM
	super.command_attack(target)
# --- END FIX ---

# Override die method to handle player unit death
func die() -> void:
	"""Handle player unit death with proper cleanup"""
	# Remove from player units group
	remove_from_group("player_units")
	
	# Notify other systems about unit death
	EventBus.emit_signal("player_unit_died", self)
	
	print("Player Viking Raider '%s' has fallen in battle!" % name)
	
	# Call parent die method
	super.die()

--- SCRIPT: res://scripts/utility/GridManager.gd ---
# res://scripts/utility/GridManager.gd
#
# A reusable scene that creates and manages an AStarGrid2D object.
# This encapsulates grid logic so scenes like SettlementBridge
# and RaidMission don't have to duplicate code.

extends Node

@export_group("Grid Configuration")
@export var grid_width: int = 60
@export var grid_height: int = 40
@export var cell_size: int = 32

## The AStarGrid2D object this manager creates and configures.
var astar_grid: AStarGrid2D

func _ready() -> void:
	# Create and configure the grid object
	astar_grid = AStarGrid2D.new()
		
	var playable_rect := Rect2i(0, 0, grid_width, grid_height)
	astar_grid.region = playable_rect
	astar_grid.cell_size = Vector2(cell_size, cell_size)
	astar_grid.diagonal_mode = AStarGrid2D.DIAGONAL_MODE_NEVER
	astar_grid.update()
	
	print("GridManager: Local grid initialized: %dx%d cells" % [grid_width, grid_height])

--- SCRIPT: res://tools/EnemyBaseEditor.gd ---
@tool
extends EditorScript

# Simple Enemy Base Layout Editor
# Usage: Tools -> Execute Script to run this

func _run():
	print("=== ENEMY BASE LAYOUT EDITOR ===")
	
	var settlement_path = "res://data/settlements/monastery_base.tres"
	var settlement_data: SettlementData = load(settlement_path)
	
	if not settlement_data:
		print("ERROR: Could not load settlement data!")
		return
	
	print("Current layout for: " + settlement_path)
	print("Grid positions (format: Building @ X,Y):")
	print("-".repeat(40))
	
	for i in range(settlement_data.placed_buildings.size()):
		var building = settlement_data.placed_buildings[i]
		var pos = building["grid_position"]
		var building_data: BuildingData = load(building["resource_path"])
		var name = building_data.display_name if building_data else "Unknown"
		
		print("%d. %s @ %d,%d" % [i+1, name, pos.x, pos.y])
	
	print("-".repeat(40))
	print("To modify layout:")
	print("1. Edit grid_position values in the .tres file")
	print("2. Or use this script to create new layouts")
	print("3. Grid range: 0-%d (width), 0-%d (height)" % [
		SettlementManager.grid_width-1, 
		SettlementManager.grid_height-1
	])

# Helper function to create new enemy base layouts
static func create_enemy_base_layout(buildings: Array[Dictionary], save_path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 500, "wood": 200, "food": 150, "stone": 100}
	settlement.placed_buildings = buildings
	
	ResourceSaver.save(settlement, save_path)
	print("Created new enemy base: " + save_path)

# Example usage:
# EnemyBaseEditor.create_fortress_layout()
static func create_fortress_layout():
	var buildings = [
		{"grid_position": Vector2i(30, 20), "resource_path": "res://data/buildings/Bldg_GreatHall.tres"},
		{"grid_position": Vector2i(29, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 19), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(29, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(30, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(31, 21), "resource_path": "res://data/buildings/Bldg_Wall.tres"},
		{"grid_position": Vector2i(28, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
		{"grid_position": Vector2i(32, 20), "resource_path": "res://data/buildings/LumberYard.tres"},
	]
	
	create_enemy_base_layout(buildings, "res://data/settlements/fortress_base.tres")

--- SCRIPT: res://tools/SettlementLayoutEditor.gd ---
# SettlementLayoutEditor.gd
# Tool to help create custom settlement layouts
@tool
extends EditorScript

# Define available buildings with their paths
const BUILDINGS = {
	"Great Hall": "res://data/buildings/GreatHall.tres",
	"Wall": "res://data/buildings/Bldg_Wall.tres", 
	"Lumber Yard": "res://data/buildings/LumberYard.tres",
	"Chapel": "res://data/buildings/Monastery_Chapel.tres",
	"Granary": "res://data/buildings/Monastery_Granary.tres",
	"Library": "res://data/buildings/Monastery_Library.tres",
	"Scriptorium": "res://data/buildings/Monastery_Scriptorium.tres",
	"Watchtower": "res://data/buildings/Monastery_Watchtower.tres"
}

func _run():
	print("=== SETTLEMENT LAYOUT EDITOR ===")
	print("Available buildings:")
	for name in BUILDINGS.keys():
		print("  - %s: %s" % [name, BUILDINGS[name]])
	
	print("\n=== EXAMPLE LAYOUTS ===")
	
	# Example 1: Small Defensive Settlement
	var small_defensive = create_small_defensive_layout()
	print("\n1. SMALL DEFENSIVE LAYOUT:")
	print_layout(small_defensive)
	save_layout(small_defensive, "res://data/settlements/small_defensive.tres")
	
	# Example 2: Economic Settlement
	var economic = create_economic_layout()
	print("\n2. ECONOMIC LAYOUT:")
	print_layout(economic)
	save_layout(economic, "res://data/settlements/economic_base.tres")
	
	# Example 3: Monastery Layout
	var monastery = create_monastery_layout()
	print("\n3. MONASTERY LAYOUT:")
	print_layout(monastery)
	save_layout(monastery, "res://data/settlements/monastery_base.tres")
	
	print("\n=== LAYOUT FILES CREATED ===")
	print("You can now use these layouts by:")
	print("1. Loading them in the Inspector on SettlementBridge")
	print("2. Or copying the placement arrays manually")

func create_small_defensive_layout() -> Array[Dictionary]:
	return [
		# Great Hall in center
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(8, 6)},
		
		# Defensive walls around perimeter
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(7, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(11, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(13, 4)},
		
		# Watchtowers at corners
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(4, 3)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(14, 3)},
		
		# Basic resource building
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 8)}
	]

func create_economic_layout() -> Array[Dictionary]:
	return [
		# Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 8)},
		
		# Economic buildings clustered together
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(6, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(8, 6)},
		{"resource_path": BUILDINGS["Lumber Yard"], "grid_position": Vector2i(12, 6)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(14, 6)},
		
		# Minimal defenses
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(10, 4)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(10, 3)}
	]

func create_monastery_layout() -> Array[Dictionary]:
	return [
		# Central Great Hall
		{"resource_path": BUILDINGS["Great Hall"], "grid_position": Vector2i(10, 10)},
		
		# Monastery buildings in organized pattern
		{"resource_path": BUILDINGS["Chapel"], "grid_position": Vector2i(8, 7)},
		{"resource_path": BUILDINGS["Library"], "grid_position": Vector2i(12, 7)},
		{"resource_path": BUILDINGS["Scriptorium"], "grid_position": Vector2i(8, 13)},
		{"resource_path": BUILDINGS["Granary"], "grid_position": Vector2i(12, 13)},
		
		# Outer walls for protection
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(6, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(8, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(12, 5)},
		{"resource_path": BUILDINGS["Wall"], "grid_position": Vector2i(14, 5)},
		
		# Watchtowers
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 4)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(5, 15)},
		{"resource_path": BUILDINGS["Watchtower"], "grid_position": Vector2i(15, 15)}
	]

func print_layout(layout: Array[Dictionary]):
	for i in range(layout.size()):
		var building = layout[i]
		var name = get_building_name(building["resource_path"])
		var pos = building["grid_position"]
		print("  [%d] %s at (%d, %d)" % [i, name, pos.x, pos.y])

func get_building_name(path: String) -> String:
	for name in BUILDINGS.keys():
		if BUILDINGS[name] == path:
			return name
	return "Unknown"

func save_layout(layout: Array[Dictionary], path: String):
	var settlement = SettlementData.new()
	settlement.treasury = {"gold": 1000, "wood": 500, "food": 200, "stone": 300}
	settlement.placed_buildings = layout
	settlement.garrisoned_units = {"res://data/units/Unit_PlayerRaider.tres": 3}
	
	var error = ResourceSaver.save(settlement, path)
	if error == OK:
		print(" Saved layout to: %s" % path)
	else:
		print(" Failed to save layout to: %s" % path)

--- SCRIPT: res://ui/DynastyUI.gd ---
# res://ui/DynastyUI.gd
#
# Manages the "Dynasty" UI panel, which allows the player
# to spend heirs as a resource for the "Progenitor" pillar.
class_name DynastyUI
extends PanelContainer

@onready var title_label: Label = $Margin/VBox/TitleLabel
@onready var heirs_container: VBoxContainer = $Margin/VBox/HeirsContainer
@onready var close_button: Button = $Margin/VBox/CloseButton

# Expedition cost from proposal 
const EXPEDITION_GOLD_COST = 500

func _ready() -> void:
	close_button.pressed.connect(hide)
	
	# Connect to the DynastyManager to refresh when Jarl data changes
	DynastyManager.jarl_stats_updated.connect(_on_jarl_stats_updated)
	
	# Initial population
	if DynastyManager.current_jarl:
		_on_jarl_stats_updated(DynastyManager.get_current_jarl())
	
	hide() # Start hidden by default

func _on_jarl_stats_updated(jarl: JarlData) -> void:
	"""Refreshes all UI elements with the latest Jarl data."""
	if not jarl:
		return
		
	title_label.text = "%s's Dynasty" % jarl.display_name
	
	# Clear existing heirs
	for child in heirs_container.get_children():
		child.queue_free()
		
	# Populate heirs list
	if jarl.heirs.is_empty():
		var label = Label.new()
		label.text = "No valid heirs."
		heirs_container.add_child(label)
		return

	# Check current gold for button disabling
	var current_gold = 0
	if SettlementManager.current_settlement:
		current_gold = SettlementManager.current_settlement.treasury.get("gold", 0)

	for heir in jarl.heirs:
		if not heir: continue
		
		var heir_row = HBoxContainer.new()
		heir_row.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		
		var name_label = Label.new()
		name_label.text = " %s (%d)" % [heir.display_name, heir.age]
		name_label.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		heir_row.add_child(name_label)

		match heir.status:
			JarlHeirData.HeirStatus.Available:
				var expedition_button = Button.new()
				expedition_button.text = "Send on Expedition"
				expedition_button.tooltip_text = "Cost: 1 Heir, %d Gold" % EXPEDITION_GOLD_COST
				
				if current_gold < EXPEDITION_GOLD_COST:
					expedition_button.disabled = true
					expedition_button.tooltip_text += "\n(Not enough Gold)"
				
				expedition_button.pressed.connect(_on_expedition_pressed.bind(heir))
				heir_row.add_child(expedition_button)
				
				# TODO: Add "Marry for Alliance" button here
			
			JarlHeirData.HeirStatus.OnExpedition:
				var status_label = Label.new()
				status_label.text = "On Expedition (%d years)" % heir.expedition_years_remaining
				status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
				heir_row.add_child(status_label)
				
			JarlHeirData.HeirStatus.MarriedOff:
				var status_label = Label.new()
				status_label.text = "Married Away"
				status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
				heir_row.add_child(status_label)
			
			_:
				var status_label = Label.new()
				status_label.text = "Unavailable"
				status_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
				heir_row.add_child(status_label)

		heirs_container.add_child(heir_row)


func _on_expedition_pressed(heir: JarlHeirData) -> void:
	"""Called when an 'Send on Expedition' button is pressed."""
	
	var cost = {"gold": EXPEDITION_GOLD_COST}
	
	# 1. Attempt to spend the gold
	if SettlementManager.attempt_purchase(cost):
		# 2. If gold spend is successful, spend the heir
		print("DynastyUI: Spent %d gold. Sending heir %s on expedition." % [EXPEDITION_GOLD_COST, heir.display_name])
		DynastyManager.start_heir_expedition(heir)
		
		# UI will refresh automatically via the jarl_stats_updated signal
	else:
		# This shouldn't happen if the button is disabled, but as a fallback.
		print("DynastyUI: Expedition failed. Not enough gold.")
		EventBus.purchase_failed.emit("Not enough Gold")

--- SCRIPT: res://ui/EndOfYear_Popup.gd ---
# res://ui/EndOfYear_Popup.gd
extends PanelContainer

signal collect_button_pressed(payout: Dictionary)

@onready var payout_label: Label = $MarginContainer/VBoxContainer/PayoutLabel
@onready var collect_button: Button = $MarginContainer/VBoxContainer/CollectButton

var _current_payout: Dictionary = {}

func _ready() -> void:
	collect_button.pressed.connect(_on_collect_pressed)
	
	# --- MODIFICATION ---
	# Update the button text as requested
	collect_button.text = "Collect and return to settlement"
	# --- END MODIFICATION ---
	
	hide()

func display_payout(payout: Dictionary, title: String = "Welcome home!") -> void:
	if payout.is_empty():
		# If there's no payout, just emit the signal and don't show
		collect_button_pressed.emit({})
		return

	_current_payout = payout
	
	# Use the new title parameter
	var payout_text: String = "%s\n\nResources gathered:\n" % title
	for resource_type in payout:
		payout_text += "- %s: %d\n" % [resource_type.capitalize(), payout[resource_type]]
	
	payout_label.text = payout_text
	show()

func _on_collect_pressed() -> void:
	collect_button_pressed.emit(_current_payout)
	hide()

--- SCRIPT: res://ui/Event_UI.gd ---
# res://ui/Event_UI.gd
#
# Controller script for the modal event window (Event_UI.tscn).
# This scene is responsible for displaying an EventData resource
# and returning the player's choice.
class_name EventUI
extends CanvasLayer

## Emitted when the player clicks a choice button.
## Passes the EventData and the chosen EventChoice.
signal choice_made(event: EventData, choice: EventChoice)

# Node References
@onready var title_label: Label = $PanelContainer/Margin/VBox/TitleLabel
@onready var description_label: Label = $PanelContainer/Margin/VBox/HBox/DescriptionLabel
@onready var portrait: TextureRect = %Portrait
@onready var choice_buttons_container: VBoxContainer = $PanelContainer/Margin/VBox/ChoiceButtonsContainer

var current_event: EventData

func _ready() -> void:
	# Start hidden. The EventManager will show this UI.
	hide()
	
	# Set process mode to "When Paused" so it works even if
	# the EventManager pauses the game to show the event.
	process_mode = Node.PROCESS_MODE_WHEN_PAUSED

func display_event(event_data: EventData) -> void:
	"""
	Configures and displays the event window based on an EventData resource.
	"""
	if not event_data:
		push_error("EventUI: Cannot display a null EventData resource.")
		return
		
	current_event = event_data
	
	# 1. Populate Text
	title_label.text = event_data.title
	description_label.text = event_data.description
	
	# 2. Populate Portrait
	if event_data.portrait:
		portrait.texture = event_data.portrait
		portrait.show()
	else:
		portrait.texture = null
		portrait.hide()
		
	# 3. Clear and Create Choice Buttons
	for child in choice_buttons_container.get_children():
		child.queue_free()
		
	if event_data.choices.is_empty():
		# Create a default "OK" button if no choices are provided
		var ok_button = Button.new()
		ok_button.text = "OK"
		ok_button.pressed.connect(_on_choice_button_pressed.bind(null))
		choice_buttons_container.add_child(ok_button)
	else:
		# Create a button for each choice
		for choice in event_data.choices:
			var choice_button = Button.new()
			choice_button.text = choice.choice_text
			choice_button.tooltip_text = choice.tooltip_text
			choice_button.pressed.connect(_on_choice_button_pressed.bind(choice))
			choice_buttons_container.add_child(choice_button)
			
	# 4. Show the UI
	show()
	
	# Grab focus so gamepad/keyboard input works
	# A CanvasLayer can't grab focus, so we focus the first button
	var first_button = choice_buttons_container.get_child(0) as Button
	if first_button:
		first_button.grab_focus()

func _on_choice_button_pressed(choice: EventChoice) -> void:
	"""
	Called when any choice button is pressed.
	Emits the signal and hides the window.
	"""
	hide()
	choice_made.emit(current_event, choice)
	current_event = null

--- SCRIPT: res://ui/SelectionBox.gd ---
# res://ui/SelectionBox.gd
# This Control node covers the entire screen.
# It listens for
# raw input, draws the selection box, and emits clean,
# intent-based signals to the EventBus.
# It also uses
# accept_event() to stop input from passing through the UI.
extends Control

var is_dragging := false
var start_pos := Vector2.ZERO

# --- NEW: Formation Drag ---
var is_command_dragging := false
var command_start_pos := Vector2.ZERO
# ---------------------------

func _ready() -> void:
	# This node handles its own input via _gui_input,
	# so it doesn't need to connect to the EventRouter.
	pass

func _gui_input(event: InputEvent) -> void:
	# We use _gui_input, which is only called if the mouse
	# is over this Control. Since it's fullscreen,
	# this will always be the case.
	
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.is_pressed():
				is_dragging = true
				start_pos = get_local_mouse_position()
				# This is the UI-bug-fix. We consume the
				# event so nothing else can process it.
				accept_event()
			elif is_dragging: # On Left-Click Release
				is_dragging = false
				var end_pos := get_local_mouse_position()
				var rect := Rect2(start_pos, end_pos - start_pos).abs()
				
				# Check if it was a "drag" or just a "click"
				# A 'click' is a box with a very small area.
				var is_box_select = rect.size.length_squared() > 100 # 10x10 px
				
				# Emit the clean command for the RTSController
				EventBus.emit_signal("select_command", rect, is_box_select)
				
				queue_redraw() # Clear the box
				accept_event()
		
		# --- MODIFIED: Handle Right Click Drag ---
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			if event.is_pressed():
				is_command_dragging = true
				command_start_pos = get_local_mouse_position()
				accept_event()
			else: # On Right-Click Release
				if not is_command_dragging:
					# This can happen if the click started outside the window
					# and was released inside. Ignore it.
					return
					
				is_command_dragging = false
				var end_pos = get_local_mouse_position()
				var drag_vector = end_pos - command_start_pos
				
				var main_camera: Camera2D = get_viewport().get_camera_2d()
				if not main_camera: 
					push_error("SelectionBox: No Camera2D found.")
					return

				# Convert screen positions to world
				# We use get_global_mouse_position() for the *end*
				# and calculate the start based on the drag vector
				var world_end_pos = main_camera.get_global_mouse_position()
				var world_start_pos = world_end_pos - (drag_vector / main_camera.zoom)
				
				# Check if it was a drag or just a click
				if drag_vector.length_squared() > 225: # 15px drag threshold
					# It was a drag. Emit formation move.
					# The direction is from start to end
					var world_drag_vector = (world_end_pos - world_start_pos).normalized()
					EventBus.formation_move_command.emit(world_start_pos, world_drag_vector)
				else:
					# It was a click. Do smart command.
					_handle_smart_command(end_pos)
					
				queue_redraw() # Clear drag line
				accept_event()
		# -----------------------------------------
	
	elif event is InputEventMouseMotion:
		if is_dragging or is_command_dragging:
			# Update the draw loop as the mouse moves
			queue_redraw()
			accept_event()

func _handle_smart_command(screen_pos: Vector2) -> void:
	# This function determines if a right-click
	# is a "move" or "attack" command.
	var world_space: PhysicsDirectSpaceState2D = get_world_2d().direct_space_state
	var main_camera: Camera2D = get_viewport().get_camera_2d()
	
	if not main_camera:
		push_error("SelectionBox: No Camera2D found in viewport.")
		return
		
	# Convert screen position to world position
	var world_pos: Vector2 = main_camera.get_global_mouse_position()
	
	var query := PhysicsPointQueryParameters2D.new()
	query.position = world_pos
	query.collide_with_areas = true
	query.collide_with_bodies = true
	
	# --- MODIFIED: Collision Mask ---
	# We now attack Layer 3 (Enemy Units) and Layer 4 (Enemy Buildings)
	# Binary 1100 = 12
	query.collision_mask = 12 
	# --------------------------------
	
	var results: Array = world_space.intersect_point(query)
	
	if not results.is_empty():
		# We hit an enemy! Emit an attack command.
		var target = results[0].collider
		EventBus.emit_signal("attack_command", target)
	else:
		# We hit the ground. Emit a move command.
		EventBus.emit_signal("move_command", world_pos)

func _draw() -> void:
	# This function draws the selection box
	if is_dragging:
		var current_pos := get_local_mouse_position()
		var rect := Rect2(start_pos, current_pos - start_pos).abs()
		
		# Draw a semi-transparent fill
		draw_rect(rect, Color(0.8, 0.8, 1.0, 0.2), true)
		# Draw a solid outline
		draw_rect(rect, Color(0.8, 0.8, 1.0, 1.0), false, 1.0)
	
	# --- NEW: Draw command drag line ---
	if is_command_dragging:
		var current_pos := get_local_mouse_position()
		draw_line(command_start_pos, current_pos, Color.GREEN, 2.0)
		draw_circle(command_start_pos, 5.0, Color.GREEN)
		draw_circle(current_pos, 3.0, Color.GREEN)
	# ----------------------------------

--- SCRIPT: res://ui/StorefrontUI.gd ---
# res://ui/StorefrontUI.gd (Fully Refactored)
extends Control

const LegacyUpgradeData = preload("res://data/legacy/LegacyUpgradeData.gd")
# --- Node References ---
@onready var gold_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/GoldLabel
@onready var wood_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/WoodLabel
@onready var food_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/FoodLabel
@onready var stone_label: Label = $PanelContainer/MarginContainer/TabContainer/BuildTab/TreasuryDisplay/StoneLabel

@onready var build_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/BuildTab/BuildButtonsContainer

@onready var recruit_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/RecruitButtons
@onready var garrison_list_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/RecruitTab/GarrisonList

# --- Legacy Tab References ---
@onready var renown_label: Label = $PanelContainer/MarginContainer/TabContainer/LegacyTab/JarlStatsDisplay/RenownLabel
@onready var authority_label: Label = $PanelContainer/MarginContainer/TabContainer/LegacyTab/JarlStatsDisplay/AuthorityLabel
@onready var legacy_buttons_container: VBoxContainer = $PanelContainer/MarginContainer/TabContainer/LegacyTab/LegacyButtonsContainer

# --- Exported Data ---
@export var available_buildings: Array[BuildingData] = []
@export var available_units: Array[UnitData] = []
@export var default_treasury_display: Dictionary = {"gold": 0, "wood": 0, "food": 0, "stone": 0}
@export var auto_load_units_from_directory: bool = true

# --- Internal state for legacy upgrades ---
# --- THIS IS THE FIX: This variable is no longer needed here ---
# var loaded_legacy_upgrades: Array[LegacyUpgradeData] = []
# --- END FIX ---
var minimum_inherited_legitimacy: int = 0 # This will be set by the upgrade


# --- MOVED FUNCTIONS UP TO FIX PARSING ERROR ---

# --- Utility Functions ---
func _format_cost(cost: Dictionary) -> String:
	"""Format cost dictionary as readable string"""
	var cost_parts: Array[String] = []
	for resource in cost:
		cost_parts.append("%d %s" % [cost[resource], resource])
	return ", ".join(cost_parts)

func _update_treasury_display(new_treasury: Dictionary) -> void:
	gold_label.text = "Gold: %d" % new_treasury.get("gold", 0)
	wood_label.text = "Wood: %d" % new_treasury.get("wood", 0)
	food_label.text = "Food: %d" % new_treasury.get("food", 0)
	stone_label.text = "Stone: %d" % new_treasury.get("stone", 0)

func _on_purchase_successful(item_name: String) -> void:
	"""Handle purchase success event - refresh garrison display"""
	# Check if the item was a unit to avoid unnecessary UI churn
	# A bit of a hack, but good for performance.
	if item_name.contains("Raider") or item_name.contains("Unit"):
		_update_garrison_display()
	
	# If a legacy upgrade was purchased, the jarl_stats_updated signal
	# will handle refreshing the legacy button list.
	# We don't need to refresh the build list, as it's static for now.
	pass

func _update_garrison_display() -> void:
	"""Update the garrison list display with current garrisoned units"""
	if not garrison_list_container:
		return
	
	for child in garrison_list_container.get_children():
		child.queue_free()
	
	if not SettlementManager.current_settlement:
		var no_settlement_label = Label.new()
		no_settlement_label.text = "No settlement loaded"
		garrison_list_container.add_child(no_settlement_label)
		return
	
	var garrison = SettlementManager.current_settlement.garrisoned_units
	
	if garrison.is_empty():
		var empty_garrison_label = Label.new()
		empty_garrison_label.text = "No units in garrison"
		garrison_list_container.add_child(empty_garrison_label)
		return
	
	var header_label = Label.new()
	header_label.text = "Current Garrison:"
	header_label.add_theme_font_size_override("font_size", 16)
	garrison_list_container.add_child(header_label)
	
	for unit_path in garrison:
		var unit_count: int = garrison[unit_path]
		var unit_data: UnitData = load(unit_path)
		
		if unit_data:
			var unit_label = Label.new()
			unit_label.text = " %s x%d" % [unit_data.display_name, unit_count]
			garrison_list_container.add_child(unit_label)
		else:
			var error_label = Label.new()
			error_label.text = " Unknown unit x%d" % unit_count
			garrison_list_container.add_child(error_label)
	
	var total_units = 0
	for unit_path in garrison:
		total_units += garrison[unit_path]
	
	var total_label = Label.new()
	total_label.text = "Total units: %d" % total_units
	total_label.add_theme_font_size_override("font_size", 12)
	garrison_list_container.add_child(total_label)

# --- END MOVED FUNCTIONS ---


func _ready() -> void:
	# Connect to SettlementManager for treasury
	EventBus.treasury_updated.connect(_update_treasury_display)
	EventBus.purchase_successful.connect(_on_purchase_successful)
	
	if SettlementManager.current_settlement:
		_update_treasury_display(SettlementManager.current_settlement.treasury)
	else:
		_update_treasury_display(default_treasury_display)

	# Connect to DynastyManager for Jarl stats
	DynastyManager.jarl_stats_updated.connect(_update_jarl_stats_display)
	
	# Initial load
	_load_building_data()
	_load_unit_data()
	
	# --- THIS IS THE FIX: Removed local call ---
	# _load_legacy_upgrades() # Load the data first
	# --- END FIX ---
	
	# Setup UI
	if DynastyManager.current_jarl:
		_update_jarl_stats_display(DynastyManager.get_current_jarl())
	
	_setup_recruit_buttons()
	_update_garrison_display()
	_populate_legacy_buttons() # Populate buttons after data is loaded

# --- Jarl Stats UI ---
func _update_jarl_stats_display(jarl_data: JarlData) -> void:
	"""Updates the Renown and Authority labels in the Legacy tab."""
	if not jarl_data:
		return
	renown_label.text = "Renown: %d" % jarl_data.renown
	authority_label.text = "Authority: %d / %d" % [jarl_data.current_authority, jarl_data.max_authority]
	
	# This ensures buttons are enabled/disabled when stats change (e.g., End Year)
	_populate_legacy_buttons()

# --- Legacy Upgrade Functions ---
# --- THIS IS THE FIX: Removed _load_legacy_upgrades() function ---
# --- END FIX ---

func _populate_legacy_buttons() -> void:
	"""
	Populate the Legacy tab with available upgrades.
	This function now creates real buttons from loaded data.
	"""
	for child in legacy_buttons_container.get_children():
		child.queue_free()
	
	# --- THIS IS THE FIX ---
	# Read the list from the manager, not our internal variable
	if DynastyManager.loaded_legacy_upgrades.is_empty():
	# --- END FIX ---
		var placeholder_label = Label.new()
		placeholder_label.text = "No legacy upgrades found."
		legacy_buttons_container.add_child(placeholder_label)
		return
	
	var jarl = DynastyManager.get_current_jarl()
	if not jarl:
		push_error("StorefrontUI: Cannot get Jarl from DynastyManager!")
		return

	# --- "SOFT-GUIDE" LITMUS TEST ---
	# Check for traits that modify costs
	var is_pious = jarl.has_trait("Pious")
	# ---------------------------------

	# --- THIS IS THE FIX ---
	# Create a button for each loaded upgrade
	for upgrade_data in DynastyManager.loaded_legacy_upgrades:
	# --- END FIX ---
		
		# --- "SOFT-GUIDE" LOGIC ---
		# This is the core mechanic of the proposal in action.
		var current_renown_cost = upgrade_data.renown_cost
		var trait_modifier_text = ""
		
		if is_pious and upgrade_data.effect_key == "UPG_BUILD_CHAPEL":
			# Example: "Pious" trait gives a 25 Renown discount
			current_renown_cost = max(0, upgrade_data.renown_cost - 25)
			trait_modifier_text = " (-25 Pious)"
		# --------------------------

		var button = Button.new()
		var cost_text = "Cost: %d Renown%s, %d Auth" % [current_renown_cost, trait_modifier_text, upgrade_data.authority_cost]
		
		# Set the text (without the name, as the icon is present)
		# --- MODIFIED: Show Progress ---
		var title_text = upgrade_data.display_name
		if upgrade_data.required_progress > 1:
			title_text += " (%d/%d)" % [upgrade_data.current_progress, upgrade_data.required_progress]
		
		button.text = "%s\\n%s" % [title_text, cost_text]
		# --- END MODIFIED ---
		button.tooltip_text = upgrade_data.description
		
		# --- NEW: Set Icon ---
		if upgrade_data.icon:
			button.icon = upgrade_data.icon
			# Optional: Align text to the left if an icon is present
			button.alignment = HORIZONTAL_ALIGNMENT_LEFT
			button.icon_alignment = HORIZONTAL_ALIGNMENT_LEFT
		# --- END NEW ---
		
		# --- MODIFIED: Check affordability and purchase status ---
		var can_buy_renown = jarl.renown >= current_renown_cost # Use modified cost
		var can_buy_auth = jarl.current_authority >= upgrade_data.authority_cost
		
		# --- THIS IS THE FIX ---
		# We must check the Jarl's *data*, not the local copy
		var is_purchased = DynastyManager.has_purchased_upgrade(upgrade_data.effect_key)
		# We should also check the progress on the *manager's* copy
		if upgrade_data.is_purchased:
		# --- END FIX ---
			button.disabled = true
			button.text = "%s (Completed)" % upgrade_data.display_name
		elif not can_buy_renown:
			button.disabled = true
			button.text += "\n(Not enough Renown)"
		elif not can_buy_auth:
			button.disabled = true
			button.text += "\n(Not enough Authority)"
		
		# We must bind the *original* upgrade_data (which holds the modified cost)
		# to the pressed signal.
		button.pressed.connect(_on_legacy_upgrade_pressed.bind(upgrade_data, current_renown_cost))
		legacy_buttons_container.add_child(button)

func _on_legacy_upgrade_pressed(upgrade_data: LegacyUpgradeData, final_renown_cost: int) -> void:
	"""
	Handles the purchase logic for a Legacy Upgrade.
	Uses the dynamically calculated final_renown_cost.
	"""
	print("Attempting to purchase legacy upgrade: %s" % upgrade_data.display_name)
	
	# 1. Double-check costs using the calculated cost
	if not DynastyManager.can_spend_renown(final_renown_cost):
		print("Purchase failed: Not enough Renown.")
		EventBus.purchase_failed.emit("Not enough Renown")
		return
		
	if not DynastyManager.can_spend_authority(upgrade_data.authority_cost):
		print("Purchase failed: Not enough Authority.")
		EventBus.purchase_failed.emit("Not enough Authority")
		return
	
	# 2. Spend resources
	var spent_renown = DynastyManager.spend_renown(final_renown_cost)
	var spent_auth = DynastyManager.spend_authority(upgrade_data.authority_cost)
	
	if not (spent_renown and spent_auth):
		push_error("Legacy purchase failed mid-transaction! This should not happen.")
		if spent_renown: DynastyManager.award_renown(final_renown_cost) # Refund
		return
	
	# 3. Mark as purchased (This is now progress)
	upgrade_data.current_progress += 1
	
	# 4. Apply the effect ONLY if progress is complete
	if upgrade_data.is_purchased: # This check now works
		DynastyManager.purchase_legacy_upgrade(upgrade_data.effect_key)
		_apply_legacy_upgrade_effect(upgrade_data.effect_key)
	
	# 5. Refresh the UI
	_populate_legacy_buttons() # This will now show the button as "Purchased"
	EventBus.purchase_successful.emit(upgrade_data.display_name)

func _apply_legacy_upgrade_effect(effect_key: String) -> void:
	"""
	Applies the permanent game-state change for a purchased upgrade.
	"""
	match effect_key:
		"UPG_TRELLEBORG":
			if SettlementManager.current_settlement:
				SettlementManager.current_settlement.max_garrison_bonus += 10 # Example value
				SettlementManager.save_settlement()
				print("Applied UPG_TRELLEBORG: Max garrison bonus +10")
			else:
				push_error("Cannot apply Trelleborg upgrade: No current settlement!")
				
		"UPG_JELLING_STONE":
			var jarl = DynastyManager.get_current_jarl()
			if jarl:
				jarl.heir_starting_renown_bonus += 50
				# --- NEW: Set Minimum Legitimacy ---
				# --- THIS IS THE FIX ---
				# We set this on the *manager*, not a local var
				DynastyManager.minimum_inherited_legitimacy = 25 # Example: 25
				# --- END FIX ---
				print("Applied UPG_JELLING_STONE: Heir renown +50, Min Legitimacy set to 25")
			else:
				push_error("Cannot apply Jelling Stone upgrade: No current Jarl!")
		
		"UPG_BUILD_CHAPEL":
			# For this test, we just log the success.
			# A real implementation might add a modifier to SettlementManager.
			print("Applied UPG_BUILD_CHAPEL: Dynasty's piety increased.")
		
		_:
			push_warning("Unknown legacy upgrade effect key: %s" % effect_key)

# --- Building Tab Functions ---
func _load_building_data() -> void:
	"""Scan res://data/buildings/ for buildable .tres files and create buttons."""
	var dir = DirAccess.open("res://data/buildings/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var building_path = "res://data/buildings/" + file_name
				var building_data = load(building_path) as BuildingData
				
				if building_data and building_data.is_player_buildable:
					_create_building_button(building_data)
					
			file_name = dir.get_next()

func _create_building_button(building_data: BuildingData) -> void:
	"""Creates and connects a single button for the build tab."""
	var button = Button.new()
	button.text = "%s (Cost: %s)" % [building_data.display_name, _format_cost(building_data.build_cost)]
	
	# --- Set Icon for Build Tab ---
	if building_data.icon:
		button.icon = building_data.icon
		button.alignment = HORIZONTAL_ALIGNMENT_LEFT
		button.icon_alignment = HORIZONTAL_ALIGNMENT_LEFT
	
	button.pressed.connect(_on_buy_button_pressed.bind(building_data))
	build_buttons_container.add_child(button)

func _on_buy_button_pressed(item_data: BuildingData) -> void:
	if not item_data:
		return
	
	print("UI attempting to purchase '%s'." % item_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(item_data.build_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % item_data.display_name)
		EventBus.building_ready_for_placement.emit(item_data)
	else:
		print("UI received purchase failure for '%s'." % item_data.display_name)

# --- Recruit Tab Functions ---
func _load_unit_data() -> void:
	"""Scan res://data/units/ directory for .tres files and load them as UnitData"""
	var dir = DirAccess.open("res://data/units/")
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name.ends_with(".tres"):
				var unit_path = "res://data/units/" + file_name
				var unit_data = load(unit_path) as UnitData
				if unit_data:
					if _is_player_unit(unit_data):
						available_units.append(unit_data)
			file_name = dir.get_next()

func _setup_recruit_buttons() -> void:
	"""Create recruit buttons for each available unit"""
	for unit_data in available_units:
		var button = Button.new()
		button.text = "%s (Cost: %s)" % [unit_data.display_name, _format_cost(unit_data.spawn_cost)]
		
		# --- Set Icon for Recruit Tab ---
		if unit_data.icon:
			button.icon = unit_data.icon
			button.alignment = HORIZONTAL_ALIGNMENT_LEFT
			button.icon_alignment = HORIZONTAL_ALIGNMENT_LEFT

		button.pressed.connect(_on_recruit_button_pressed.bind(unit_data))
		recruit_buttons_container.add_child(button)

func _is_player_unit(unit_data: UnitData) -> bool:
	if not unit_data: return false
	if "Player" in unit_data.display_name: return true
	if "Player" in unit_data.resource_path: return true
	if unit_data.scene_to_spawn and "Player" in unit_data.scene_to_spawn.resource_path: return true
	if unit_data.display_name in ["Viking Raider"]: return false
	return true

func _on_recruit_button_pressed(unit_data: UnitData) -> void:
	"""Handle recruit button press"""
	if not unit_data:
		return
	
	print("UI attempting to recruit '%s'." % unit_data.display_name)
	var purchase_successful: bool = SettlementManager.attempt_purchase(unit_data.spawn_cost)
	
	if purchase_successful:
		print("UI received purchase confirmation for '%s'." % unit_data.display_name)
		SettlementManager.recruit_unit(unit_data)
	else:
		print("UI received purchase failure for '%s'." % unit_data.display_name)

--- SCRIPT: res://ui/Succession_Crisis_UI.gd ---
# res://ui/Succession_Crisis_UI.gd
extends CanvasLayer

# --- Node Refs ---
@onready var desc_label = $PanelContainer/MarginContainer/VBoxContainer/DescriptionLabel
@onready var legit_label = $PanelContainer/MarginContainer/VBoxContainer/LegitimacyLabel
@onready var renown_desc = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxDescription
@onready var gold_desc = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxDescription
@onready var pay_renown_btn = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons/PayRenownButton
@onready var refuse_renown_btn = $PanelContainer/MarginContainer/VBoxContainer/RenownTaxButtons/RefuseRenownButton
@onready var pay_gold_btn = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons/PayGoldButton
@onready var refuse_gold_btn = $PanelContainer/MarginContainer/VBoxContainer/GoldTaxButtons/RefuseGoldButton
@onready var confirm_btn = $PanelContainer/MarginContainer/VBoxContainer/ConfirmButton

# --- State ---
var renown_tax: int = 0
var gold_tax: int = 0
var renown_choice: String = "pay"
var gold_choice: String = "pay"

func _ready() -> void:
	# Create ButtonGroups
	var renown_group = ButtonGroup.new()
	pay_renown_btn.button_group = renown_group
	refuse_renown_btn.button_group = renown_group
	
	var gold_group = ButtonGroup.new()
	pay_gold_btn.button_group = gold_group
	refuse_gold_btn.button_group = gold_group
	
	pay_renown_btn.pressed.connect(_on_renown_choice.bind("pay"))
	refuse_renown_btn.pressed.connect(_on_renown_choice.bind("refuse"))
	pay_gold_btn.pressed.connect(_on_gold_choice.bind("pay"))
	refuse_gold_btn.pressed.connect(_on_gold_choice.bind("refuse"))
	confirm_btn.pressed.connect(_on_confirm)

func display_crisis(jarl: JarlData, settlement: SettlementData) -> void:
	var legitimacy = jarl.legitimacy
	legit_label.text = "New Legitimacy: %d/100" % legitimacy
	
	# --- Calculate Taxes (Higher legitimacy = lower taxes) ---
	var tax_multiplier = 1.0 - (legitimacy / 100.0) # 100 legit = 0x, 20 legit = 0.8x
	
	# Renown Tax
	renown_tax = int(max(50, DynastyManager.get_current_jarl().renown * 0.2) * tax_multiplier)
	pay_renown_btn.text = "Pay %d Renown" % renown_tax
	refuse_renown_btn.text = "Refuse (Risk Project Setbacks)"
	
	# --- FIX: Update Description Text Dynamically ---
	renown_desc.text = "Pay %d Renown to protect your legacy, or refuse and risk setbacks." % renown_tax
	# -----------------------------------------------
	
	# Gold Tax
	gold_tax = int(max(200, settlement.treasury.get("gold", 0) * 0.3) * tax_multiplier)
	pay_gold_btn.text = "Pay %d Gold" % gold_tax
	refuse_gold_btn.text = "Refuse (Risk Instability)"
	
	# --- FIX: Update Description Text Dynamically ---
	gold_desc.text = "Pay %d Gold to ensure loyalty, or refuse and risk instability." % gold_tax
	# -----------------------------------------------
	
	# Check affordability
	if jarl.renown < renown_tax:
		pay_renown_btn.disabled = true
		refuse_renown_btn.button_pressed = true
		renown_choice = "refuse"
	else:
		pay_renown_btn.button_pressed = true
		renown_choice = "pay"
	
	if settlement.treasury.get("gold", 0) < gold_tax:
		pay_gold_btn.disabled = true
		refuse_gold_btn.button_pressed = true
		gold_choice = "refuse"
	else:
		pay_gold_btn.button_pressed = true
		gold_choice = "pay"
	
	show()

func _on_renown_choice(choice: String) -> void:
	renown_choice = choice

func _on_gold_choice(choice: String) -> void:
	gold_choice = choice

func _on_confirm() -> void:
	# 1. Apply costs
	if renown_choice == "pay":
		DynastyManager.spend_renown(renown_tax)
	if gold_choice == "pay":
		SettlementManager.attempt_purchase({"gold": gold_tax})
	
	# 2. Emit choices to EventManager/DynastyManager for consequences
	EventBus.succession_choices_made.emit(renown_choice, gold_choice)
	
	# 3. Close the window
	queue_free()
--- END OF CODEBASE ---

---
