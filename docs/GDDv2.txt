Viking Dynasty GDD (v2.0.0)

1. High-Level Concept & Vision

Concept: A strategy hybrid blending the dynastic, grand strategy of Crusader Kings with the tactical, real-time battles of Age of Empires II1.


Layers: Players manage a dynasty on a strategic Macro layer 2, build a persistent, grid-based Bridge (Settlement) 3, and fight in real-time Micro missions4.


Core Tension: Balancing long-term dynasty needs with immediate-term combat and settlement defense5.



2. Core Gameplay Loop: The Three Layers


2.A. The Macro (Dynasty Layer)

Status: Partially Implemented (Data Only)
Description: The "Crusader Kings" layer for managing family, diplomacy, and traits6.


Implementation: The core data structures (JarlData.gd, TraitData.gd) are fully implemented, including properties for renown, authority, skills, and traits. The gameplay systems (UI, event engine, "End Year" button) are not yet built.

2.B. The Micro (RTS Layer)

Status: Implemented
Description: The "Age of Empires" layer for real-time combat7. Player commands units to achieve objectives8.


Implementation: This is fully functional via RaidMission.tscn9. It uses an RTSController 10and SelectionBox 11for unit command and RaidObjectiveManager 12 to track win/loss conditions.



2.C. The Bridge (Settlement Layer)

Status: Implemented
Description: The persistent, grid-based home base13. The layout of this settlement becomes the map for all defensive Micro missions14.


Implementation: This is fully functional via SettlementBridge.tscn15. It uses GridManager 16for placement, and StorefrontUI 17 handles building. The "Sacked" defensive loop is functional18.



3. Key Implemented Systems (Current State)

This section details the functional, implemented state of the game as of v1.81.

3.A. Technical Architecture

Data-Driven: All stats are custom Resources (.tres) 19, confirmed by the use of BuildingData.gd 20, UnitData.gd 21, and SettlementData.gd22.


Autoloads (Singletons):
EventBus.gd: A clean "switchboard" for all signals, including new RTS commands23.


SettlementManager.gd: A pure data manager that holds the current_settlement 24, delegating pathfinding/placement to the active scene's GridManager25.


SceneManager.gd: Handles all EventBus-driven scene transitions26.



3.B. "Reinvestment" Economy (Bridge Layer)

Pillar 1: Treasury & Storefront: [Implemented]
The treasury in SettlementData.gd tracks resources27.


StorefrontUI.gd 28auto-scans res://data/buildings/ and res://data/units/ to dynamically create "Buy" and "Recruit" buttons for items marked is_player_buildable 29or as player units30.


SettlementManager.attempt_purchase() 31correctly deducts costs32.


Pillar 2: "Reinvestment" Payout: [Implemented]
The "one attack = one payout" loop is functional33.


SettlementManager.calculate_payout() 34sums the fixed_payout_amount 35from all owned EconomicBuildingData structures36.


WelcomeHome_Popup.tscn 37displays this payout, and the player must click "Collect" to deposit it38.



3.C. "Offensive Raid" (Micro Layer)

Pillar 1: The Garrison: [Implemented]
Buying a unit from the StorefrontUI 39correctly calls SettlementManager.recruit_unit()40.


This increments the count in the garrisoned_units dictionary in the SettlementData.gd resource41.


Pillar 2: The RTS Controller: [Implemented]
The full SelectionBox -> EventBus -> RTSController architecture is functional42.


SelectionBox.gd 43captures input, draws the selection box, and emits clean signals (select_command, move_command, attack_command)44.


RTSController.gd 45listens for these signals and commands units46.


The UnitFSM.gd 47correctly handles MOVING and ATTACKING states based on these commands48.


Pillar 3: The Raid Mission: [Implemented]
WorldMap_Stub.tscn 49correctly uses the EventBus to launch RaidMission.tscn50.


RaidMission.gd 51functions as the "Raid Loader"52. It correctly:


Loads an enemy SettlementData resource (e.g., monastery_base.tres)53.


Reads the player's garrisoned_units and spawns them at the PlayerStartPosition54.


Registers all spawned units with the RTSController55.


RaidObjectiveManager.gd 56tracks the building_destroyed signal from the enemy's Great Hall to trigger victory57.


The Loot system uses RaidLootData.gd 58to sum loot from all destroyed buildings and deposits the total (plus victory_bonus_loot) to the SettlementManager on victory59.



4. Future Implementation (Roadmap)

This section details the remaining systems to be built, based on the original GDD and Appendix.

4.A. Core Pacing Engine

Mechanic: Implement the "1 Turn = 1 Year" pacing60.


To-Do:
Create the main Macro Layer UI.
Add an "End Year" button61.


Hook the "End Year" button to advance time, generate Authority, and trigger Renown Decay6262.



4.B. Macro Layer Gameplay

Mechanic: Build the "Dynasty" game on top of your existing JarlData and TraitData.
To-Do:
Authority: Hook JarlData.current_authority 63 into the UI. All major actions (launching raids, diplomacy) must spend it. Implement the Escalating Cost for political actions646464.


Renown: Award Renown (using JarlData.award_renown() 65) after successful raids66. Implement Renown Tiers 676767to set the max_authority cap68. Implement the annual Renown Decay696969.


Succession: Implement the "Dynasty Failure" check (Jarl dies with no heir)70707070. Build the UI and logic for the Succession Crisis 717171and "Foolish Death" Penalty72727272.


Trait Consequences: Connect the RTS layer to the Macro layer. When a Jarl's army is badly beaten, use the EventBus to signal the JarlData to add the "Maimed" trait73737373.



4.C. Advanced Raiding (Micro Layer)

Mechanic: Evolve the current raid into the two distinct types from the GDD74.


To-Do:
Raiding Expedition (The "Big One"): 75 Expand the current RaidMission with:


Thralls: Create the Thrall unit and the "Dual-Carrier Hauling" system76767676.


Extraction Phase: Implement the "Invisible Threat" timer and escalating enemy waves777777777777777777.


Coastal Raid (The "Quick Grab"): 78Create a separate, smaller 5-10 minute mission that costs a fixed 1 Authority 79and is used to stop Renown Decay80808080.



4.D. Mid-Game Loop

Mechanic: Implement the "Conquest" loop81818181.


To-Do:
Subjugation: Create the three-mission RTS campaign logic82828282.


Jarl's Judgment: Create the text-event UI that presents the player with the three-way choice (Execute, Vassalize, Install Heir) and its consequences 83838383.



4.E. Economy Balancing

Mechanic: Implement the Resource Market 84848484 to make Gold the premier resource.


To-Do:
Create the market building and UI85.


Implement the logic for fluctuating exchange rates to prevent exploits86868686.



5. Design Philosophy & Vision

This section defines the "North Star" for the game's feel, look, and sound.

5.A.
Controls & UI/UX Philosophy 87

Bridge Layer (Settlement): 88


Feel: Relaxed, strategic, "god-game" city builder89.


Controls: 100% mouse-driven. Left-click to select/place, right-click to cancel90. WASD/middle-mouse drag to pan91.


UI: Non-intrusive. The "Storefront" is a modal window, reinforcing deliberate, strategic choice92.


Micro Layer (RTS Combat): 93


Feel: Fast, responsive, tactical, and familiar94.


Controls: Classic RTS scheme. Left-click select, drag for box selection95. Right-click is the "smart" command (move or attack)96.


UI: A minimal, persistent HUD is required, showing selected unit(s) and HP, readable at a glance97.


Macro Layer (Dynasty Map): 98


Feel: Deliberate, thoughtful, "board game" or grand strategy99.


Controls: Turn-based or pausable real-time. Entirely mouse-driven, interacting with menus, map provinces, and portraits100.


UI: Information-dense. The UI is the game. Heavy use of nested tooltips and clear iconography101.



5.B.
UI Style Guide 102

Central Theme: All UI components must use the central theme resource: res://ui/themes/VikingDynastyTheme.tres103.


Spacing Standards (in pixels): 104


Primary Containers: 20px horizontal, 15px vertical margins105.


Major Section Separation: 12-15px spacing106.


Element Groups (Buttons): 8-10px spacing107.


List Items: 6px spacing108.


Typography: 109


Storefront: 14px base font size110.


Popups: 16px base font size, centered111.


Interactive Target Sizing (Minimums): 112


Storefront Build Buttons: 100x36px113.


Storefront Recruit Buttons: 200x36px (dynamic)114.


Popup Buttons ('Collect'): 120x40px115.


Anchoring: All UI must use proper anchoring and container layouts (e.g., VBoxContainer, MarginContainer) to ensure responsiveness116.



5.C. Art Style & Mood

(Placeholder section for future development) 117



5.D. Audio & Sound Design

(Placeholder section for future development)

6. Technical Stack & Core Architecture

Engine: Godot 4.4 118


Scripting: GDScript 119


Architecture Principles:
Data-Driven: All game stats (unit HP, building cost, etc.) must be custom Resource files (.tres) to empower design without code changes120.


Singleton (Autoload) Managers: Global systems (EventBus, SettlementManager) are implemented as Autoloads for easy access and clear separation of concerns121.


Event Bus: All communication between major, decoupled systems (e.g., UI, AI, Game Loop) must go through the EventBus singleton. No direct references122.


Finite State Machines (FSMs): All entities with 3+ states (like AI units) must use an FSM123.



7. Core Data Structures (Reference)

All game entities are defined by a Resource script (.gd) and implemented as .tres files124.

BuildingData.gd: 125Defines stats for all static structures126.


Key Properties: display_name, scene_to_spawn, icon, building_texture 127, build_cost 128, max_health 129, blocks_pathfinding 130, grid_size 131, (Defensive Stats) is_defensive_structure 132, attack_damage 133, attack_range 134, attack_speed135.


EconomicBuildingData.gd: 136 (Extends BuildingData)


Key Properties: resource_type 137, fixed_payout_amount 138, storage_cap139.


UnitData.gd: 140


Key Properties: display_name 141, scene_to_spawn 142, icon 143, spawn_cost 144, (Combat Stats) max_health 145, move_speed 146, attack_damage 147, attack_range 148, attack_speed149.


SettlementData.gd: 150


Key Properties: treasury 151, placed_buildings 152, garrisoned_units153.


RaidLootData.gd: 154Tracks loot collected during a raid155.


Key Properties: collected_loot156.


Key Methods: add_loot_from_building()157
